(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([[888], {
  39016: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.CoinbaseWalletSDK = void 0;
    let el = eo(52719)
      , ec = eo(96415)
      , ed = eo(32072)
      , eh = eo(49682)
      , ep = eo(83143)
      , ef = eo(26840)
      , em = eo(18411)
      , eg = eo(81107)
      , ey = eo(20462)
      , eb = eo(23129)
      , ew = eo(43604);
    let CoinbaseWalletSDK = class CoinbaseWalletSDK {
      constructor(J) {
        var et, eo, el;
        this._appName = "",
          this._appLogoUrl = null,
          this._relay = null,
          this._relayEventManager = null;
        let ep = J.linkAPIUrl || ec.LINK_API_URL;
        void 0 === J.overrideIsMetaMask ? this._overrideIsMetaMask = !1 : this._overrideIsMetaMask = J.overrideIsMetaMask,
          this._overrideIsCoinbaseWallet = null === (et = J.overrideIsCoinbaseWallet) || void 0 === et || et,
          this._overrideIsCoinbaseBrowser = null !== (eo = J.overrideIsCoinbaseBrowser) && void 0 !== eo && eo,
          this._diagnosticLogger = J.diagnosticLogger,
          this._reloadOnDisconnect = null === (el = J.reloadOnDisconnect) || void 0 === el || el;
        let e_ = new URL(ep)
          , ex = `${e_.protocol}//${e_.host}`;
        if (this._storage = new eh.ScopedLocalStorage(`-walletlink:${ex}`),
          this._storage.setItem("version", CoinbaseWalletSDK.VERSION),
          this.walletExtension || this.coinbaseBrowser)
          return;
        this._relayEventManager = new eg.RelayEventManager;
        let eE = (0,
          ed.isMobileWeb)()
          , eC = J.uiConstructor || (J => eE ? new em.MobileRelayUI(J) : new ey.WalletLinkRelayUI(J))
          , eS = {
            linkAPIUrl: ep,
            version: ew.LIB_VERSION,
            darkMode: !!J.darkMode,
            uiConstructor: eC,
            storage: this._storage,
            relayEventManager: this._relayEventManager,
            diagnosticLogger: this._diagnosticLogger,
            reloadOnDisconnect: this._reloadOnDisconnect,
            enableMobileWalletLink: J.enableMobileWalletLink
          };
        if (this._relay = eE ? new ef.MobileRelay(eS) : new eb.WalletLinkRelay(eS),
          this.setAppInfo(J.appName, J.appLogoUrl),
          J.headlessMode)
          return;
        this._relay.attachUI()
      }
      makeWeb3Provider(J = "", et = 1) {
        let eo = this.walletExtension;
        if (eo)
          return this.isCipherProvider(eo) || eo.setProviderInfo(J, et),
            !1 === this._reloadOnDisconnect && "function" == typeof eo.disableReloadOnDisconnect && eo.disableReloadOnDisconnect(),
            eo;
        let el = this.coinbaseBrowser;
        if (el)
          return el;
        let ec = this._relay;
        if (!ec || !this._relayEventManager || !this._storage)
          throw Error("Relay not initialized, should never happen");
        return J || ec.setConnectDisabled(!0),
          new ep.CoinbaseWalletProvider({
            relayProvider: () => Promise.resolve(ec),
            relayEventManager: this._relayEventManager,
            storage: this._storage,
            jsonRpcUrl: J,
            chainId: et,
            qrUrl: this.getQrUrl(),
            diagnosticLogger: this._diagnosticLogger,
            overrideIsMetaMask: this._overrideIsMetaMask,
            overrideIsCoinbaseWallet: this._overrideIsCoinbaseWallet,
            overrideIsCoinbaseBrowser: this._overrideIsCoinbaseBrowser
          })
      }
      setAppInfo(J, et) {
        var eo;
        this._appName = J || "DApp",
          this._appLogoUrl = et || (0,
            ed.getFavicon)();
        let el = this.walletExtension;
        el ? this.isCipherProvider(el) || el.setAppInfo(this._appName, this._appLogoUrl) : null === (eo = this._relay) || void 0 === eo || eo.setAppInfo(this._appName, this._appLogoUrl)
      }
      disconnect() {
        var J;
        let et = this === null || void 0 === this ? void 0 : this.walletExtension;
        et ? et.close() : null === (J = this._relay) || void 0 === J || J.resetAndReload()
      }
      getQrUrl() {
        var J, et;
        return null !== (et = null === (J = this._relay) || void 0 === J ? void 0 : J.getQRCodeUrl()) && void 0 !== et ? et : null
      }
      getCoinbaseWalletLogo(J, et = 240) {
        return (0,
          el.walletLogo)(J, et)
      }
      get walletExtension() {
        var J;
        return null !== (J = window.coinbaseWalletExtension) && void 0 !== J ? J : window.walletLinkExtension
      }
      get coinbaseBrowser() {
        var J, et;
        try {
          let eo = null !== (J = window.ethereum) && void 0 !== J ? J : null === (et = window.top) || void 0 === et ? void 0 : et.ethereum;
          if (!eo)
            return;
          if ("isCoinbaseBrowser" in eo && eo.isCoinbaseBrowser)
            return eo;
          return
        } catch (J) {
          return
        }
      }
      isCipherProvider(J) {
        return "boolean" == typeof J.isCipher && J.isCipher
      }
    }
      ;
    et.CoinbaseWalletSDK = CoinbaseWalletSDK,
      CoinbaseWalletSDK.VERSION = ew.LIB_VERSION
  },
  52719: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.walletLogo = void 0,
      et.walletLogo = (J, et) => {
        let eo;
        switch (J) {
          case "standard":
          default:
            return eo = et,
              `data:image/svg+xml,%3Csvg width='${et}' height='${eo}' viewBox='0 0 1024 1024' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Crect width='1024' height='1024' fill='%230052FF'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z' fill='white'/%3E %3C/svg%3E `;
          case "circle":
            return eo = et,
              `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='${et}' height='${eo}' viewBox='0 0 999.81 999.81'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052fe;%7D.cls-2%7Bfill:%23fefefe;%7D.cls-3%7Bfill:%230152fe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M655-115.9h56c.83,1.59,2.36.88,3.56,1a478,478,0,0,1,75.06,10.42C891.4-81.76,978.33-32.58,1049.19,44q116.7,126,131.94,297.61c.38,4.14-.34,8.53,1.78,12.45v59c-1.58.84-.91,2.35-1,3.56a482.05,482.05,0,0,1-10.38,74.05c-24,106.72-76.64,196.76-158.83,268.93s-178.18,112.82-287.2,122.6c-4.83.43-9.86-.25-14.51,1.77H654c-1-1.68-2.69-.91-4.06-1a496.89,496.89,0,0,1-105.9-18.59c-93.54-27.42-172.78-77.59-236.91-150.94Q199.34,590.1,184.87,426.58c-.47-5.19.25-10.56-1.77-15.59V355c1.68-1,.91-2.7,1-4.06a498.12,498.12,0,0,1,18.58-105.9c26-88.75,72.64-164.9,140.6-227.57q126-116.27,297.21-131.61C645.32-114.57,650.35-113.88,655-115.9Zm377.92,500c0-192.44-156.31-349.49-347.56-350.15-194.13-.68-350.94,155.13-352.29,347.42-1.37,194.55,155.51,352.1,348.56,352.47C876.15,734.23,1032.93,577.84,1032.93,384.11Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-2' d='M1032.93,384.11c0,193.73-156.78,350.12-351.29,349.74-193-.37-349.93-157.92-348.56-352.47C334.43,189.09,491.24,33.28,685.37,34,876.62,34.62,1032.94,191.67,1032.93,384.11ZM683,496.81q43.74,0,87.48,0c15.55,0,25.32-9.72,25.33-25.21q0-87.48,0-175c0-15.83-9.68-25.46-25.59-25.46H595.77c-15.88,0-25.57,9.64-25.58,25.46q0,87.23,0,174.45c0,16.18,9.59,25.7,25.84,25.71Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-3' d='M683,496.81H596c-16.25,0-25.84-9.53-25.84-25.71q0-87.23,0-174.45c0-15.82,9.7-25.46,25.58-25.46H770.22c15.91,0,25.59,9.63,25.59,25.46q0,87.47,0,175c0,15.49-9.78,25.2-25.33,25.21Q726.74,496.84,683,496.81Z' transform='translate(-183.1 115.9)'/%3E%3C/svg%3E`;
          case "text":
            return eo = (.1 * et).toFixed(2),
              `data:image/svg+xml,%3Csvg width='${et}' height='${eo}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`;
          case "textWithLogo":
            return eo = (.25 * et).toFixed(2),
              `data:image/svg+xml,%3Csvg width='${et}' height='${eo}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`;
          case "textLight":
            return eo = (.1 * et).toFixed(2),
              `data:image/svg+xml,%3Csvg width='${et}' height='${eo}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`;
          case "textWithLogoLight":
            return eo = (.25 * et).toFixed(2),
              `data:image/svg+xml,%3Csvg width='${et}' height='${eo}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`
        }
      }
  },
  96415: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.LINK_API_URL = void 0,
      et.LINK_API_URL = "https://www.walletlink.org"
  },
  76079: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.errorValues = et.standardErrorCodes = void 0,
      et.standardErrorCodes = {
        rpc: {
          invalidInput: -32e3,
          resourceNotFound: -32001,
          resourceUnavailable: -32002,
          transactionRejected: -32003,
          methodNotSupported: -32004,
          limitExceeded: -32005,
          parse: -32700,
          invalidRequest: -32600,
          methodNotFound: -32601,
          invalidParams: -32602,
          internal: -32603
        },
        provider: {
          userRejectedRequest: 4001,
          unauthorized: 4100,
          unsupportedMethod: 4200,
          disconnected: 4900,
          chainDisconnected: 4901,
          unsupportedChain: 4902
        }
      },
      et.errorValues = {
        "-32700": {
          standard: "JSON RPC 2.0",
          message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
        },
        "-32600": {
          standard: "JSON RPC 2.0",
          message: "The JSON sent is not a valid Request object."
        },
        "-32601": {
          standard: "JSON RPC 2.0",
          message: "The method does not exist / is not available."
        },
        "-32602": {
          standard: "JSON RPC 2.0",
          message: "Invalid method parameter(s)."
        },
        "-32603": {
          standard: "JSON RPC 2.0",
          message: "Internal JSON-RPC error."
        },
        "-32000": {
          standard: "EIP-1474",
          message: "Invalid input."
        },
        "-32001": {
          standard: "EIP-1474",
          message: "Resource not found."
        },
        "-32002": {
          standard: "EIP-1474",
          message: "Resource unavailable."
        },
        "-32003": {
          standard: "EIP-1474",
          message: "Transaction rejected."
        },
        "-32004": {
          standard: "EIP-1474",
          message: "Method not supported."
        },
        "-32005": {
          standard: "EIP-1474",
          message: "Request limit exceeded."
        },
        4001: {
          standard: "EIP-1193",
          message: "User rejected the request."
        },
        4100: {
          standard: "EIP-1193",
          message: "The requested account and/or method has not been authorized by the user."
        },
        4200: {
          standard: "EIP-1193",
          message: "The requested method is not supported by this Ethereum provider."
        },
        4900: {
          standard: "EIP-1193",
          message: "The provider is disconnected from all chains."
        },
        4901: {
          standard: "EIP-1193",
          message: "The provider is disconnected from the specified chain."
        },
        4902: {
          standard: "EIP-3085",
          message: "Unrecognized chain ID."
        }
      }
  },
  99322: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.standardErrors = void 0;
    let el = eo(76079)
      , ec = eo(10761);
    function getEthJsonRpcError(J, et) {
      let [eo, el] = parseOpts(et);
      return new EthereumRpcError(J, eo || (0,
        ec.getMessageFromCode)(J), el)
    }
    function getEthProviderError(J, et) {
      let [eo, el] = parseOpts(et);
      return new EthereumProviderError(J, eo || (0,
        ec.getMessageFromCode)(J), el)
    }
    function parseOpts(J) {
      if (J) {
        if ("string" == typeof J)
          return [J];
        if ("object" == typeof J && !Array.isArray(J)) {
          let { message: et, data: eo } = J;
          if (et && "string" != typeof et)
            throw Error("Must specify string message.");
          return [et || void 0, eo]
        }
      }
      return []
    }
    et.standardErrors = {
      rpc: {
        parse: J => getEthJsonRpcError(el.standardErrorCodes.rpc.parse, J),
        invalidRequest: J => getEthJsonRpcError(el.standardErrorCodes.rpc.invalidRequest, J),
        invalidParams: J => getEthJsonRpcError(el.standardErrorCodes.rpc.invalidParams, J),
        methodNotFound: J => getEthJsonRpcError(el.standardErrorCodes.rpc.methodNotFound, J),
        internal: J => getEthJsonRpcError(el.standardErrorCodes.rpc.internal, J),
        server: J => {
          if (!J || "object" != typeof J || Array.isArray(J))
            throw Error("Ethereum RPC Server errors must provide single object argument.");
          let { code: et } = J;
          if (!Number.isInteger(et) || et > -32005 || et < -32099)
            throw Error('"code" must be an integer such that: -32099 <= code <= -32005');
          return getEthJsonRpcError(et, J)
        }
        ,
        invalidInput: J => getEthJsonRpcError(el.standardErrorCodes.rpc.invalidInput, J),
        resourceNotFound: J => getEthJsonRpcError(el.standardErrorCodes.rpc.resourceNotFound, J),
        resourceUnavailable: J => getEthJsonRpcError(el.standardErrorCodes.rpc.resourceUnavailable, J),
        transactionRejected: J => getEthJsonRpcError(el.standardErrorCodes.rpc.transactionRejected, J),
        methodNotSupported: J => getEthJsonRpcError(el.standardErrorCodes.rpc.methodNotSupported, J),
        limitExceeded: J => getEthJsonRpcError(el.standardErrorCodes.rpc.limitExceeded, J)
      },
      provider: {
        userRejectedRequest: J => getEthProviderError(el.standardErrorCodes.provider.userRejectedRequest, J),
        unauthorized: J => getEthProviderError(el.standardErrorCodes.provider.unauthorized, J),
        unsupportedMethod: J => getEthProviderError(el.standardErrorCodes.provider.unsupportedMethod, J),
        disconnected: J => getEthProviderError(el.standardErrorCodes.provider.disconnected, J),
        chainDisconnected: J => getEthProviderError(el.standardErrorCodes.provider.chainDisconnected, J),
        unsupportedChain: J => getEthProviderError(el.standardErrorCodes.provider.unsupportedChain, J),
        custom: J => {
          if (!J || "object" != typeof J || Array.isArray(J))
            throw Error("Ethereum Provider custom errors must provide single object argument.");
          let { code: et, message: eo, data: el } = J;
          if (!eo || "string" != typeof eo)
            throw Error('"message" must be a nonempty string');
          return new EthereumProviderError(et, eo, el)
        }
      }
    };
    let EthereumRpcError = class EthereumRpcError extends Error {
      constructor(J, et, eo) {
        if (!Number.isInteger(J))
          throw Error('"code" must be an integer.');
        if (!et || "string" != typeof et)
          throw Error('"message" must be a nonempty string.');
        super(et),
          this.code = J,
          void 0 !== eo && (this.data = eo)
      }
    }
      ;
    let EthereumProviderError = class EthereumProviderError extends EthereumRpcError {
      constructor(J, et, eo) {
        if (!(Number.isInteger(J) && J >= 1e3 && J <= 4999))
          throw Error('"code" must be an integer such that: 1000 <= code <= 4999');
        super(J, et, eo)
      }
    }
  },
  37185: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.standardErrors = et.standardErrorCodes = et.serializeError = et.getMessageFromCode = et.getErrorCode = void 0;
    let el = eo(76079);
    Object.defineProperty(et, "standardErrorCodes", {
      enumerable: !0,
      get: function () {
        return el.standardErrorCodes
      }
    });
    let ec = eo(99322);
    Object.defineProperty(et, "standardErrors", {
      enumerable: !0,
      get: function () {
        return ec.standardErrors
      }
    });
    let ed = eo(70011);
    Object.defineProperty(et, "serializeError", {
      enumerable: !0,
      get: function () {
        return ed.serializeError
      }
    });
    let eh = eo(10761);
    Object.defineProperty(et, "getErrorCode", {
      enumerable: !0,
      get: function () {
        return eh.getErrorCode
      }
    }),
      Object.defineProperty(et, "getMessageFromCode", {
        enumerable: !0,
        get: function () {
          return eh.getMessageFromCode
        }
      })
  },
  70011: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.serializeError = void 0;
    let el = eo(7588)
      , ec = eo(43604)
      , ed = eo(76079)
      , eh = eo(10761);
    et.serializeError = function (J, et) {
      let eo = (0,
        eh.serialize)("string" == typeof J ? {
          message: J,
          code: ed.standardErrorCodes.rpc.internal
        } : (0,
          el.isErrorResponse)(J) ? Object.assign(Object.assign({}, J), {
            message: J.errorMessage,
            code: J.errorCode,
            data: {
              method: J.method
            }
          }) : J, {
          shouldIncludeStack: !0
        })
        , ep = new URL("https://docs.cloud.coinbase.com/wallet-sdk/docs/errors");
      ep.searchParams.set("version", ec.LIB_VERSION),
        ep.searchParams.set("code", eo.code.toString());
      let ef = function (J, et) {
        let eo = null == J ? void 0 : J.method;
        if (eo)
          return eo;
        if (void 0 === et)
          ;
        else if ("string" == typeof et)
          return et;
        else if (!Array.isArray(et))
          return et.method;
        else if (et.length > 0)
          return et[0].method
      }(eo.data, et);
      return ef && ep.searchParams.set("method", ef),
        ep.searchParams.set("message", eo.message),
        Object.assign(Object.assign({}, eo), {
          docUrl: ep.href
        })
    }
  },
  10761: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.serialize = et.getErrorCode = et.isValidCode = et.getMessageFromCode = et.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
    let el = eo(76079)
      , ec = "Unspecified error message.";
    function getMessageFromCode(J, eo = ec) {
      if (J && Number.isInteger(J)) {
        let eo = J.toString();
        if (hasKey(el.errorValues, eo))
          return el.errorValues[eo].message;
        if (J >= -32099 && J <= -32e3)
          return et.JSON_RPC_SERVER_ERROR_MESSAGE
      }
      return eo
    }
    function isValidCode(J) {
      if (!Number.isInteger(J))
        return !1;
      let et = J.toString();
      return !!(el.errorValues[et] || J >= -32099 && J <= -32e3)
    }
    function assignOriginalError(J) {
      return J && "object" == typeof J && !Array.isArray(J) ? Object.assign({}, J) : J
    }
    function hasKey(J, et) {
      return Object.prototype.hasOwnProperty.call(J, et)
    }
    function hasStringProperty(J, et) {
      return "object" == typeof J && null !== J && et in J && "string" == typeof J[et]
    }
    et.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.",
      et.getMessageFromCode = getMessageFromCode,
      et.isValidCode = isValidCode,
      et.getErrorCode = function (J) {
        var et;
        return "number" == typeof J ? J : "object" == typeof J && null !== J && ("number" == typeof J.code || "number" == typeof J.errorCode) ? null !== (et = J.code) && void 0 !== et ? et : J.errorCode : void 0
      }
      ,
      et.serialize = function (J, { shouldIncludeStack: et = !1 } = {}) {
        let eo = {};
        return J && "object" == typeof J && !Array.isArray(J) && hasKey(J, "code") && isValidCode(J.code) ? (eo.code = J.code,
          J.message && "string" == typeof J.message ? (eo.message = J.message,
            hasKey(J, "data") && (eo.data = J.data)) : (eo.message = getMessageFromCode(eo.code),
              eo.data = {
                originalError: assignOriginalError(J)
              })) : (eo.code = el.standardErrorCodes.rpc.internal,
                eo.message = hasStringProperty(J, "message") ? J.message : ec,
                eo.data = {
                  originalError: assignOriginalError(J)
                }),
          et && (eo.stack = hasStringProperty(J, "stack") ? J.stack : void 0),
          eo
      }
  },
  34083: function (J, et) {
    "use strict";
    var eo, el;
    function OpaqueType() {
      return J => J
    }
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.ProviderType = et.RegExpString = et.IntNumber = et.BigIntString = et.AddressString = et.HexString = et.OpaqueType = void 0,
      et.OpaqueType = OpaqueType,
      et.HexString = OpaqueType(),
      et.AddressString = OpaqueType(),
      et.BigIntString = OpaqueType(),
      et.IntNumber = function (J) {
        return Math.floor(J)
      }
      ,
      et.RegExpString = OpaqueType(),
      (el = eo || (et.ProviderType = eo = {})).CoinbaseWallet = "CoinbaseWallet",
      el.MetaMask = "MetaMask",
      el.Unselected = ""
  },
  32072: function (J, et, eo) {
    "use strict";
    var el = eo(48764).Buffer
      , ec = this && this.__importDefault || function (J) {
        return J && J.__esModule ? J : {
          default: J
        }
      }
      ;
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.isMobileWeb = et.getLocation = et.isInIFrame = et.createQrUrl = et.getFavicon = et.range = et.isBigNumber = et.ensureParsedJSONObject = et.ensureBN = et.ensureRegExpString = et.ensureIntNumber = et.ensureBuffer = et.ensureAddressString = et.ensureEvenLengthHexString = et.ensureHexString = et.isHexString = et.prepend0x = et.strip0x = et.has0xPrefix = et.hexStringFromIntNumber = et.intNumberFromHexString = et.bigIntStringFromBN = et.hexStringFromBuffer = et.hexStringToUint8Array = et.uint8ArrayToHex = et.randomBytesHex = void 0;
    let ed = ec(eo(13550))
      , eh = eo(37185)
      , ep = eo(34083)
      , ef = /^[0-9]*$/
      , em = /^[a-f0-9]*$/;
    function uint8ArrayToHex(J) {
      return [...J].map(J => J.toString(16).padStart(2, "0")).join("")
    }
    function has0xPrefix(J) {
      return J.startsWith("0x") || J.startsWith("0X")
    }
    function strip0x(J) {
      return has0xPrefix(J) ? J.slice(2) : J
    }
    function prepend0x(J) {
      return has0xPrefix(J) ? `0x${J.slice(2)}` : `0x${J}`
    }
    function isHexString(J) {
      if ("string" != typeof J)
        return !1;
      let et = strip0x(J).toLowerCase();
      return em.test(et)
    }
    function ensureHexString(J, et = !1) {
      if ("string" == typeof J) {
        let eo = strip0x(J).toLowerCase();
        if (em.test(eo))
          return (0,
            ep.HexString)(et ? `0x${eo}` : eo)
      }
      throw eh.standardErrors.rpc.invalidParams(`"${String(J)}" is not a hexadecimal string`)
    }
    function ensureEvenLengthHexString(J, et = !1) {
      let eo = ensureHexString(J, !1);
      return eo.length % 2 == 1 && (eo = (0,
        ep.HexString)(`0${eo}`)),
        et ? (0,
          ep.HexString)(`0x${eo}`) : eo
    }
    function ensureIntNumber(J) {
      if ("number" == typeof J && Number.isInteger(J))
        return (0,
          ep.IntNumber)(J);
      if ("string" == typeof J) {
        if (ef.test(J))
          return (0,
            ep.IntNumber)(Number(J));
        if (isHexString(J))
          return (0,
            ep.IntNumber)(new ed.default(ensureEvenLengthHexString(J, !1), 16).toNumber())
      }
      throw eh.standardErrors.rpc.invalidParams(`Not an integer: ${String(J)}`)
    }
    function isBigNumber(J) {
      if (null == J || "function" != typeof J.constructor)
        return !1;
      let { constructor: et } = J;
      return "function" == typeof et.config && "number" == typeof et.EUCLID
    }
    function isInIFrame() {
      try {
        return null !== window.frameElement
      } catch (J) {
        return !1
      }
    }
    et.randomBytesHex = function (J) {
      return uint8ArrayToHex(crypto.getRandomValues(new Uint8Array(J)))
    }
      ,
      et.uint8ArrayToHex = uint8ArrayToHex,
      et.hexStringToUint8Array = function (J) {
        return new Uint8Array(J.match(/.{1,2}/g).map(J => parseInt(J, 16)))
      }
      ,
      et.hexStringFromBuffer = function (J, et = !1) {
        let eo = J.toString("hex");
        return (0,
          ep.HexString)(et ? `0x${eo}` : eo)
      }
      ,
      et.bigIntStringFromBN = function (J) {
        return (0,
          ep.BigIntString)(J.toString(10))
      }
      ,
      et.intNumberFromHexString = function (J) {
        return (0,
          ep.IntNumber)(new ed.default(ensureEvenLengthHexString(J, !1), 16).toNumber())
      }
      ,
      et.hexStringFromIntNumber = function (J) {
        return (0,
          ep.HexString)(`0x${new ed.default(J).toString(16)}`)
      }
      ,
      et.has0xPrefix = has0xPrefix,
      et.strip0x = strip0x,
      et.prepend0x = prepend0x,
      et.isHexString = isHexString,
      et.ensureHexString = ensureHexString,
      et.ensureEvenLengthHexString = ensureEvenLengthHexString,
      et.ensureAddressString = function (J) {
        if ("string" == typeof J) {
          let et = strip0x(J).toLowerCase();
          if (isHexString(et) && 40 === et.length)
            return (0,
              ep.AddressString)(prepend0x(et))
        }
        throw eh.standardErrors.rpc.invalidParams(`Invalid Ethereum address: ${String(J)}`)
      }
      ,
      et.ensureBuffer = function (J) {
        if (el.isBuffer(J))
          return J;
        if ("string" == typeof J) {
          if (isHexString(J)) {
            let et = ensureEvenLengthHexString(J, !1);
            return el.from(et, "hex")
          }
          return el.from(J, "utf8")
        }
        throw eh.standardErrors.rpc.invalidParams(`Not binary data: ${String(J)}`)
      }
      ,
      et.ensureIntNumber = ensureIntNumber,
      et.ensureRegExpString = function (J) {
        if (J instanceof RegExp)
          return (0,
            ep.RegExpString)(J.toString());
        throw eh.standardErrors.rpc.invalidParams(`Not a RegExp: ${String(J)}`)
      }
      ,
      et.ensureBN = function (J) {
        if (null !== J && (ed.default.isBN(J) || isBigNumber(J)))
          return new ed.default(J.toString(10), 10);
        if ("number" == typeof J)
          return new ed.default(ensureIntNumber(J));
        if ("string" == typeof J) {
          if (ef.test(J))
            return new ed.default(J, 10);
          if (isHexString(J))
            return new ed.default(ensureEvenLengthHexString(J, !1), 16)
        }
        throw eh.standardErrors.rpc.invalidParams(`Not an integer: ${String(J)}`)
      }
      ,
      et.ensureParsedJSONObject = function (J) {
        if ("string" == typeof J)
          return JSON.parse(J);
        if ("object" == typeof J)
          return J;
        throw eh.standardErrors.rpc.invalidParams(`Not a JSON string or an object: ${String(J)}`)
      }
      ,
      et.isBigNumber = isBigNumber,
      et.range = function (J, et) {
        return Array.from({
          length: et - J
        }, (et, eo) => J + eo)
      }
      ,
      et.getFavicon = function () {
        let J = document.querySelector('link[sizes="192x192"]') || document.querySelector('link[sizes="180x180"]') || document.querySelector('link[rel="icon"]') || document.querySelector('link[rel="shortcut icon"]')
          , { protocol: et, host: eo } = document.location
          , el = J ? J.getAttribute("href") : null;
        return !el || el.startsWith("javascript:") || el.startsWith("vbscript:") ? null : el.startsWith("http://") || el.startsWith("https://") || el.startsWith("data:") ? el : el.startsWith("//") ? et + el : `${et}//${eo}${el}`
      }
      ,
      et.createQrUrl = function (J, et, eo, el, ec, ed) {
        let eh = new URLSearchParams({
          [el ? "parent-id" : "id"]: J,
          secret: et,
          server: eo,
          v: ec,
          chainId: ed.toString()
        }).toString()
          , ep = `${eo}/#/link?${eh}`;
        return ep
      }
      ,
      et.isInIFrame = isInIFrame,
      et.getLocation = function () {
        try {
          if (isInIFrame() && window.top)
            return window.top.location;
          return window.location
        } catch (J) {
          return window.location
        }
      }
      ,
      et.isMobileWeb = function () {
        var J;
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(null === (J = null == window ? void 0 : window.navigator) || void 0 === J ? void 0 : J.userAgent)
      }
  },
  45811: function (J, et, eo) {
    "use strict";
    et.jp = void 0;
    let el = eo(39016)
      , ec = eo(83143);
    var ed = eo(39016);
    Object.defineProperty(et, "jp", {
      enumerable: !0,
      get: function () {
        return ed.CoinbaseWalletSDK
      }
    }),
      eo(83143),
      el.CoinbaseWalletSDK,
      "undefined" != typeof window && (window.CoinbaseWalletSDK = el.CoinbaseWalletSDK,
        window.CoinbaseWalletProvider = ec.CoinbaseWalletProvider,
        window.WalletLink = el.CoinbaseWalletSDK,
        window.WalletLinkProvider = ec.CoinbaseWalletProvider)
  },
  50769: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.Cipher = void 0;
    let el = eo(32072);
    et.Cipher = class {
      constructor(J) {
        this.secret = J
      }
      async encrypt(J) {
        let et = this.secret;
        if (64 !== et.length)
          throw Error("secret must be 256 bits");
        let eo = crypto.getRandomValues(new Uint8Array(12))
          , ec = await crypto.subtle.importKey("raw", (0,
            el.hexStringToUint8Array)(et), {
            name: "aes-gcm"
          }, !1, ["encrypt", "decrypt"])
          , ed = new TextEncoder
          , eh = await window.crypto.subtle.encrypt({
            name: "AES-GCM",
            iv: eo
          }, ec, ed.encode(J))
          , ep = eh.slice(eh.byteLength - 16)
          , ef = eh.slice(0, eh.byteLength - 16)
          , em = new Uint8Array(ep)
          , eg = new Uint8Array(ef)
          , ey = new Uint8Array([...eo, ...em, ...eg]);
        return (0,
          el.uint8ArrayToHex)(ey)
      }
      async decrypt(J) {
        let et = this.secret;
        if (64 !== et.length)
          throw Error("secret must be 256 bits");
        return new Promise((eo, ec) => {
          !async function () {
            let ed = await crypto.subtle.importKey("raw", (0,
              el.hexStringToUint8Array)(et), {
              name: "aes-gcm"
            }, !1, ["encrypt", "decrypt"])
              , eh = (0,
                el.hexStringToUint8Array)(J)
              , ep = eh.slice(0, 12)
              , ef = eh.slice(12, 28)
              , em = eh.slice(28)
              , eg = new Uint8Array([...em, ...ef])
              , ey = {
                name: "AES-GCM",
                iv: new Uint8Array(ep)
              };
            try {
              let J = await window.crypto.subtle.decrypt(ey, ed, eg)
                , et = new TextDecoder;
              eo(et.decode(J))
            } catch (J) {
              ec(J)
            }
          }()
        }
        )
      }
    }
  },
  49682: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.ScopedLocalStorage = void 0,
      et.ScopedLocalStorage = class {
        constructor(J) {
          this.scope = J
        }
        setItem(J, et) {
          localStorage.setItem(this.scopedKey(J), et)
        }
        getItem(J) {
          return localStorage.getItem(this.scopedKey(J))
        }
        removeItem(J) {
          localStorage.removeItem(this.scopedKey(J))
        }
        clear() {
          let J = this.scopedKey("")
            , et = [];
          for (let eo = 0; eo < localStorage.length; eo++) {
            let el = localStorage.key(eo);
            "string" == typeof el && el.startsWith(J) && et.push(el)
          }
          et.forEach(J => localStorage.removeItem(J))
        }
        scopedKey(J) {
          return `${this.scope}:${J}`
        }
      }
  },
  1119: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.default = '@namespace svg "http://www.w3.org/2000/svg";.-cbwsdk-css-reset,.-cbwsdk-css-reset *{animation:none;animation-delay:0;animation-direction:normal;animation-duration:0;animation-fill-mode:none;animation-iteration-count:1;animation-name:none;animation-play-state:running;animation-timing-function:ease;backface-visibility:visible;background:0;background-attachment:scroll;background-clip:border-box;background-color:rgba(0,0,0,0);background-image:none;background-origin:padding-box;background-position:0 0;background-position-x:0;background-position-y:0;background-repeat:repeat;background-size:auto auto;border:0;border-style:none;border-width:medium;border-color:inherit;border-bottom:0;border-bottom-color:inherit;border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-style:none;border-bottom-width:medium;border-collapse:separate;border-image:none;border-left:0;border-left-color:inherit;border-left-style:none;border-left-width:medium;border-radius:0;border-right:0;border-right-color:inherit;border-right-style:none;border-right-width:medium;border-spacing:0;border-top:0;border-top-color:inherit;border-top-left-radius:0;border-top-right-radius:0;border-top-style:none;border-top-width:medium;box-shadow:none;box-sizing:border-box;caption-side:top;clear:none;clip:auto;color:inherit;columns:auto;column-count:auto;column-fill:balance;column-gap:normal;column-rule:medium none currentColor;column-rule-color:currentColor;column-rule-style:none;column-rule-width:none;column-span:1;column-width:auto;counter-increment:none;counter-reset:none;direction:ltr;empty-cells:show;float:none;font:normal;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;height:auto;hyphens:none;letter-spacing:normal;line-height:normal;list-style:none;list-style-image:none;list-style-position:outside;list-style-type:disc;margin:0;margin-bottom:0;margin-left:0;margin-right:0;margin-top:0;opacity:1;orphans:0;outline:0;outline-color:invert;outline-style:none;outline-width:medium;overflow:visible;overflow-x:visible;overflow-y:visible;padding:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;page-break-after:auto;page-break-before:auto;page-break-inside:auto;perspective:none;perspective-origin:50% 50%;pointer-events:auto;position:static;quotes:"\\201C" "\\201D" "\\2018" "\\2019";tab-size:8;table-layout:auto;text-align:inherit;text-align-last:auto;text-decoration:none;text-decoration-color:inherit;text-decoration-line:none;text-decoration-style:solid;text-indent:0;text-shadow:none;text-transform:none;transform:none;transform-style:flat;transition:none;transition-delay:0s;transition-duration:0s;transition-property:none;transition-timing-function:ease;unicode-bidi:normal;vertical-align:baseline;visibility:visible;white-space:normal;widows:0;word-spacing:normal;z-index:auto}.-cbwsdk-css-reset strong{font-weight:bold}.-cbwsdk-css-reset *{box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;line-height:1}.-cbwsdk-css-reset [class*=container]{margin:0;padding:0}.-cbwsdk-css-reset style{display:none}'
  },
  27162: function (J, et, eo) {
    "use strict";
    var el = this && this.__importDefault || function (J) {
      return J && J.__esModule ? J : {
        default: J
      }
    }
      ;
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.injectCssReset = void 0;
    let ec = el(eo(1119));
    et.injectCssReset = function () {
      let J = document.createElement("style");
      J.type = "text/css",
        J.appendChild(document.createTextNode(ec.default)),
        document.documentElement.appendChild(J)
    }
  },
  83143: function (J, et, eo) {
    "use strict";
    var el = eo(48764).Buffer
      , ec = this && this.__importDefault || function (J) {
        return J && J.__esModule ? J : {
          default: J
        }
      }
      ;
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.CoinbaseWalletProvider = void 0;
    let ed = ec(eo(13550))
      , eh = eo(26729)
      , ep = eo(37185)
      , ef = eo(32072)
      , em = eo(26840)
      , eg = eo(92036)
      , ey = eo(73526)
      , eb = eo(7588)
      , ew = ec(eo(14497))
      , e_ = eo(38431)
      , ex = eo(33648)
      , eE = eo(5313)
      , eC = "DefaultChainId"
      , eS = "DefaultJsonRpcUrl";
    let CoinbaseWalletProvider = class CoinbaseWalletProvider extends eh.EventEmitter {
      constructor(J) {
        var et, eo;
        super(),
          this._filterPolyfill = new ex.FilterPolyfill(this),
          this._subscriptionManager = new eE.SubscriptionManager(this),
          this._relay = null,
          this._addresses = [],
          this.hasMadeFirstChainChangedEmission = !1,
          this.setProviderInfo = this.setProviderInfo.bind(this),
          this.updateProviderInfo = this.updateProviderInfo.bind(this),
          this.getChainId = this.getChainId.bind(this),
          this.setAppInfo = this.setAppInfo.bind(this),
          this.enable = this.enable.bind(this),
          this.close = this.close.bind(this),
          this.send = this.send.bind(this),
          this.sendAsync = this.sendAsync.bind(this),
          this.request = this.request.bind(this),
          this._setAddresses = this._setAddresses.bind(this),
          this.scanQRCode = this.scanQRCode.bind(this),
          this.genericRequest = this.genericRequest.bind(this),
          this._chainIdFromOpts = J.chainId,
          this._jsonRpcUrlFromOpts = J.jsonRpcUrl,
          this._overrideIsMetaMask = J.overrideIsMetaMask,
          this._relayProvider = J.relayProvider,
          this._storage = J.storage,
          this._relayEventManager = J.relayEventManager,
          this.diagnostic = J.diagnosticLogger,
          this.reloadOnDisconnect = !0,
          this.isCoinbaseWallet = null === (et = J.overrideIsCoinbaseWallet) || void 0 === et || et,
          this.isCoinbaseBrowser = null !== (eo = J.overrideIsCoinbaseBrowser) && void 0 !== eo && eo,
          this.qrUrl = J.qrUrl;
        let el = this.getChainId()
          , ec = (0,
            ef.prepend0x)(el.toString(16));
        this.emit("connect", {
          chainIdStr: ec
        });
        let ed = this._storage.getItem(eg.LOCAL_STORAGE_ADDRESSES_KEY);
        if (ed) {
          let J = ed.split(" ");
          "" !== J[0] && (this._addresses = J.map(J => (0,
            ef.ensureAddressString)(J)),
            this.emit("accountsChanged", J))
        }
        this._subscriptionManager.events.on("notification", J => {
          this.emit("message", {
            type: J.method,
            data: J.params
          })
        }
        ),
          this._isAuthorized() && this.initializeRelay(),
          window.addEventListener("message", J => {
            var et;
            if (J.origin === location.origin && J.source === window && "walletLinkMessage" === J.data.type && "dappChainSwitched" === J.data.data.action) {
              let eo = J.data.data.chainId
                , el = null !== (et = J.data.data.jsonRpcUrl) && void 0 !== et ? et : this.jsonRpcUrl;
              this.updateProviderInfo(el, Number(eo))
            }
          }
          )
      }
      get selectedAddress() {
        return this._addresses[0] || void 0
      }
      get networkVersion() {
        return this.getChainId().toString(10)
      }
      get chainId() {
        return (0,
          ef.prepend0x)(this.getChainId().toString(16))
      }
      get isWalletLink() {
        return !0
      }
      get isMetaMask() {
        return this._overrideIsMetaMask
      }
      get host() {
        return this.jsonRpcUrl
      }
      get connected() {
        return !0
      }
      isConnected() {
        return !0
      }
      get jsonRpcUrl() {
        var J;
        return null !== (J = this._storage.getItem(eS)) && void 0 !== J ? J : this._jsonRpcUrlFromOpts
      }
      set jsonRpcUrl(J) {
        this._storage.setItem(eS, J)
      }
      disableReloadOnDisconnect() {
        this.reloadOnDisconnect = !1
      }
      setProviderInfo(J, et) {
        this.isCoinbaseBrowser || (this._chainIdFromOpts = et,
          this._jsonRpcUrlFromOpts = J),
          this.updateProviderInfo(this.jsonRpcUrl, this.getChainId())
      }
      updateProviderInfo(J, et) {
        this.jsonRpcUrl = J;
        let eo = this.getChainId();
        this._storage.setItem(eC, et.toString(10));
        let el = (0,
          ef.ensureIntNumber)(et) !== eo;
        (el || !this.hasMadeFirstChainChangedEmission) && (this.emit("chainChanged", this.getChainId()),
          this.hasMadeFirstChainChangedEmission = !0)
      }
      async watchAsset(J, et, eo, el, ec, ed) {
        let eh = await this.initializeRelay()
          , ep = await eh.watchAsset(J, et, eo, el, ec, null == ed ? void 0 : ed.toString()).promise;
        return !(0,
          eb.isErrorResponse)(ep) && !!ep.result
      }
      async addEthereumChain(J, et, eo, el, ec, ed) {
        var eh, ep;
        if ((0,
          ef.ensureIntNumber)(J) === this.getChainId())
          return !1;
        let em = await this.initializeRelay()
          , eg = em.inlineAddEthereumChain(J.toString());
        this._isAuthorized() || eg || await em.requestEthereumAccounts().promise;
        let ey = await em.addEthereumChain(J.toString(), et, ec, eo, el, ed).promise;
        return !(0,
          eb.isErrorResponse)(ey) && ((null === (eh = ey.result) || void 0 === eh ? void 0 : eh.isApproved) === !0 && this.updateProviderInfo(et[0], J),
            (null === (ep = ey.result) || void 0 === ep ? void 0 : ep.isApproved) === !0)
      }
      async switchEthereumChain(J) {
        let et = await this.initializeRelay()
          , eo = await et.switchEthereumChain(J.toString(10), this.selectedAddress || void 0).promise;
        if ((0,
          eb.isErrorResponse)(eo)) {
          if (!eo.errorCode)
            return;
          if (eo.errorCode === ep.standardErrorCodes.provider.unsupportedChain)
            throw ep.standardErrors.provider.unsupportedChain();
          throw ep.standardErrors.provider.custom({
            message: eo.errorMessage,
            code: eo.errorCode
          })
        }
        let el = eo.result;
        el.isApproved && el.rpcUrl.length > 0 && this.updateProviderInfo(el.rpcUrl, J)
      }
      setAppInfo(J, et) {
        this.initializeRelay().then(eo => eo.setAppInfo(J, et))
      }
      async enable() {
        var J;
        return (null === (J = this.diagnostic) || void 0 === J || J.log(e_.EVENTS.ETH_ACCOUNTS_STATE, {
          method: "provider::enable",
          addresses_length: this._addresses.length,
          sessionIdHash: this._relay ? ey.Session.hash(this._relay.session.id) : void 0
        }),
          this._isAuthorized()) ? [...this._addresses] : await this.send("eth_requestAccounts")
      }
      async close() {
        let J = await this.initializeRelay();
        J.resetAndReload()
      }
      send(J, et) {
        try {
          let eo = this._send(J, et);
          if (eo instanceof Promise)
            return eo.catch(et => {
              throw (0,
                ep.serializeError)(et, J)
            }
            )
        } catch (et) {
          throw (0,
            ep.serializeError)(et, J)
        }
      }
      _send(J, et) {
        if ("string" == typeof J) {
          let eo = Array.isArray(et) ? et : void 0 !== et ? [et] : [];
          return this._sendRequestAsync({
            jsonrpc: "2.0",
            id: 0,
            method: J,
            params: eo
          }).then(J => J.result)
        }
        return "function" == typeof et ? this._sendAsync(J, et) : Array.isArray(J) ? J.map(J => this._sendRequest(J)) : this._sendRequest(J)
      }
      async sendAsync(J, et) {
        try {
          return this._sendAsync(J, et).catch(et => {
            throw (0,
              ep.serializeError)(et, J)
          }
          )
        } catch (et) {
          return Promise.reject((0,
            ep.serializeError)(et, J))
        }
      }
      async _sendAsync(J, et) {
        if ("function" != typeof et)
          throw Error("callback is required");
        if (Array.isArray(J)) {
          this._sendMultipleRequestsAsync(J).then(J => et(null, J)).catch(J => et(J, null));
          return
        }
        return this._sendRequestAsync(J).then(J => et(null, J)).catch(J => et(J, null))
      }
      async request(J) {
        try {
          return this._request(J).catch(et => {
            throw (0,
              ep.serializeError)(et, J.method)
          }
          )
        } catch (et) {
          return Promise.reject((0,
            ep.serializeError)(et, J.method))
        }
      }
      async _request(J) {
        if (!J || "object" != typeof J || Array.isArray(J))
          throw ep.standardErrors.rpc.invalidRequest({
            message: "Expected a single, non-array, object argument.",
            data: J
          });
        let { method: et, params: eo } = J;
        if ("string" != typeof et || 0 === et.length)
          throw ep.standardErrors.rpc.invalidRequest({
            message: "'args.method' must be a non-empty string.",
            data: J
          });
        if (void 0 !== eo && !Array.isArray(eo) && ("object" != typeof eo || null === eo))
          throw ep.standardErrors.rpc.invalidRequest({
            message: "'args.params' must be an object or array if provided.",
            data: J
          });
        let el = void 0 === eo ? [] : eo
          , ec = this._relayEventManager.makeRequestId()
          , ed = await this._sendRequestAsync({
            method: et,
            params: el,
            jsonrpc: "2.0",
            id: ec
          });
        return ed.result
      }
      async scanQRCode(J) {
        let et = await this.initializeRelay()
          , eo = await et.scanQRCode((0,
            ef.ensureRegExpString)(J)).promise;
        if ((0,
          eb.isErrorResponse)(eo))
          throw (0,
            ep.serializeError)(eo.errorMessage, "scanQRCode");
        if ("string" != typeof eo.result)
          throw (0,
            ep.serializeError)("result was not a string", "scanQRCode");
        return eo.result
      }
      async genericRequest(J, et) {
        let eo = await this.initializeRelay()
          , el = await eo.genericRequest(J, et).promise;
        if ((0,
          eb.isErrorResponse)(el))
          throw (0,
            ep.serializeError)(el.errorMessage, "generic");
        if ("string" != typeof el.result)
          throw (0,
            ep.serializeError)("result was not a string", "generic");
        return el.result
      }
      async connectAndSignIn(J) {
        var et;
        let eo;
        null === (et = this.diagnostic) || void 0 === et || et.log(e_.EVENTS.ETH_ACCOUNTS_STATE, {
          method: "provider::connectAndSignIn",
          sessionIdHash: this._relay ? ey.Session.hash(this._relay.session.id) : void 0
        });
        try {
          let et = await this.initializeRelay();
          if (!(et instanceof em.MobileRelay))
            throw Error("connectAndSignIn is only supported on mobile");
          if (eo = await et.connectAndSignIn(J).promise,
            (0,
              eb.isErrorResponse)(eo))
            throw Error(eo.errorMessage)
        } catch (J) {
          if ("string" == typeof J.message && J.message.match(/(denied|rejected)/i))
            throw ep.standardErrors.provider.userRejectedRequest("User denied account authorization");
          throw J
        }
        if (!eo.result)
          throw Error("accounts received is empty");
        let { accounts: el } = eo.result;
        return this._setAddresses(el),
          this.isCoinbaseBrowser || await this.switchEthereumChain(this.getChainId()),
          eo.result
      }
      async selectProvider(J) {
        let et = await this.initializeRelay()
          , eo = await et.selectProvider(J).promise;
        if ((0,
          eb.isErrorResponse)(eo))
          throw (0,
            ep.serializeError)(eo.errorMessage, "selectProvider");
        if ("string" != typeof eo.result)
          throw (0,
            ep.serializeError)("result was not a string", "selectProvider");
        return eo.result
      }
      supportsSubscriptions() {
        return !1
      }
      subscribe() {
        throw Error("Subscriptions are not supported")
      }
      unsubscribe() {
        throw Error("Subscriptions are not supported")
      }
      disconnect() {
        return !0
      }
      _sendRequest(J) {
        let et = {
          jsonrpc: "2.0",
          id: J.id
        }
          , { method: eo } = J;
        if (et.result = this._handleSynchronousMethods(J),
          void 0 === et.result)
          throw Error(`Coinbase Wallet does not support calling ${eo} synchronously without a callback. Please provide a callback parameter to call ${eo} asynchronously.`);
        return et
      }
      _setAddresses(J, et) {
        if (!Array.isArray(J))
          throw Error("addresses is not an array");
        let eo = J.map(J => (0,
          ef.ensureAddressString)(J));
        JSON.stringify(eo) !== JSON.stringify(this._addresses) && (this._addresses = eo,
          this.emit("accountsChanged", this._addresses),
          this._storage.setItem(eg.LOCAL_STORAGE_ADDRESSES_KEY, eo.join(" ")))
      }
      _sendRequestAsync(J) {
        return new Promise((et, eo) => {
          try {
            let el = this._handleSynchronousMethods(J);
            if (void 0 !== el)
              return et({
                jsonrpc: "2.0",
                id: J.id,
                result: el
              });
            let ec = this._handleAsynchronousFilterMethods(J);
            if (void 0 !== ec) {
              ec.then(eo => et(Object.assign(Object.assign({}, eo), {
                id: J.id
              }))).catch(J => eo(J));
              return
            }
            let ed = this._handleSubscriptionMethods(J);
            if (void 0 !== ed) {
              ed.then(eo => et({
                jsonrpc: "2.0",
                id: J.id,
                result: eo.result
              })).catch(J => eo(J));
              return
            }
          } catch (J) {
            return eo(J)
          }
          this._handleAsynchronousMethods(J).then(eo => eo && et(Object.assign(Object.assign({}, eo), {
            id: J.id
          }))).catch(J => eo(J))
        }
        )
      }
      _sendMultipleRequestsAsync(J) {
        return Promise.all(J.map(J => this._sendRequestAsync(J)))
      }
      _handleSynchronousMethods(J) {
        let { method: et } = J
          , eo = J.params || [];
        switch (et) {
          case "eth_accounts":
            return this._eth_accounts();
          case "eth_coinbase":
            return this._eth_coinbase();
          case "eth_uninstallFilter":
            return this._eth_uninstallFilter(eo);
          case "net_version":
            return this._net_version();
          case "eth_chainId":
            return this._eth_chainId();
          default:
            return
        }
      }
      async _handleAsynchronousMethods(J) {
        let { method: et } = J
          , eo = J.params || [];
        switch (et) {
          case "eth_requestAccounts":
            return this._eth_requestAccounts();
          case "eth_sign":
            return this._eth_sign(eo);
          case "eth_ecRecover":
            return this._eth_ecRecover(eo);
          case "personal_sign":
            return this._personal_sign(eo);
          case "personal_ecRecover":
            return this._personal_ecRecover(eo);
          case "eth_signTransaction":
            return this._eth_signTransaction(eo);
          case "eth_sendRawTransaction":
            return this._eth_sendRawTransaction(eo);
          case "eth_sendTransaction":
            return this._eth_sendTransaction(eo);
          case "eth_signTypedData_v1":
            return this._eth_signTypedData_v1(eo);
          case "eth_signTypedData_v2":
            return this._throwUnsupportedMethodError();
          case "eth_signTypedData_v3":
            return this._eth_signTypedData_v3(eo);
          case "eth_signTypedData_v4":
          case "eth_signTypedData":
            return this._eth_signTypedData_v4(eo);
          case "cbWallet_arbitrary":
            return this._cbwallet_arbitrary(eo);
          case "wallet_addEthereumChain":
            return this._wallet_addEthereumChain(eo);
          case "wallet_switchEthereumChain":
            return this._wallet_switchEthereumChain(eo);
          case "wallet_watchAsset":
            return this._wallet_watchAsset(eo)
        }
        let el = await this.initializeRelay();
        return el.makeEthereumJSONRPCRequest(J, this.jsonRpcUrl).catch(et => {
          var eo;
          throw (et.code === ep.standardErrorCodes.rpc.methodNotFound || et.code === ep.standardErrorCodes.rpc.methodNotSupported) && (null === (eo = this.diagnostic) || void 0 === eo || eo.log(e_.EVENTS.METHOD_NOT_IMPLEMENTED, {
            method: J.method,
            sessionIdHash: this._relay ? ey.Session.hash(this._relay.session.id) : void 0
          })),
          et
        }
        )
      }
      _handleAsynchronousFilterMethods(J) {
        let { method: et } = J
          , eo = J.params || [];
        switch (et) {
          case "eth_newFilter":
            return this._eth_newFilter(eo);
          case "eth_newBlockFilter":
            return this._eth_newBlockFilter();
          case "eth_newPendingTransactionFilter":
            return this._eth_newPendingTransactionFilter();
          case "eth_getFilterChanges":
            return this._eth_getFilterChanges(eo);
          case "eth_getFilterLogs":
            return this._eth_getFilterLogs(eo)
        }
      }
      _handleSubscriptionMethods(J) {
        switch (J.method) {
          case "eth_subscribe":
          case "eth_unsubscribe":
            return this._subscriptionManager.handleRequest(J)
        }
      }
      _isKnownAddress(J) {
        try {
          let et = (0,
            ef.ensureAddressString)(J)
            , eo = this._addresses.map(J => (0,
              ef.ensureAddressString)(J));
          return eo.includes(et)
        } catch (J) { }
        return !1
      }
      _ensureKnownAddress(J) {
        var et;
        if (!this._isKnownAddress(J))
          throw null === (et = this.diagnostic) || void 0 === et || et.log(e_.EVENTS.UNKNOWN_ADDRESS_ENCOUNTERED),
          Error("Unknown Ethereum address")
      }
      _prepareTransactionParams(J) {
        let et = J.from ? (0,
          ef.ensureAddressString)(J.from) : this.selectedAddress;
        if (!et)
          throw Error("Ethereum address is unavailable");
        this._ensureKnownAddress(et);
        let eo = J.to ? (0,
          ef.ensureAddressString)(J.to) : null
          , ec = null != J.value ? (0,
            ef.ensureBN)(J.value) : new ed.default(0)
          , eh = J.data ? (0,
            ef.ensureBuffer)(J.data) : el.alloc(0)
          , ep = null != J.nonce ? (0,
            ef.ensureIntNumber)(J.nonce) : null
          , em = null != J.gasPrice ? (0,
            ef.ensureBN)(J.gasPrice) : null
          , eg = null != J.maxFeePerGas ? (0,
            ef.ensureBN)(J.maxFeePerGas) : null
          , ey = null != J.maxPriorityFeePerGas ? (0,
            ef.ensureBN)(J.maxPriorityFeePerGas) : null
          , eb = null != J.gas ? (0,
            ef.ensureBN)(J.gas) : null
          , ew = J.chainId ? (0,
            ef.ensureIntNumber)(J.chainId) : this.getChainId();
        return {
          fromAddress: et,
          toAddress: eo,
          weiValue: ec,
          data: eh,
          nonce: ep,
          gasPriceInWei: em,
          maxFeePerGas: eg,
          maxPriorityFeePerGas: ey,
          gasLimit: eb,
          chainId: ew
        }
      }
      _isAuthorized() {
        return this._addresses.length > 0
      }
      _requireAuthorization() {
        if (!this._isAuthorized())
          throw ep.standardErrors.provider.unauthorized({})
      }
      _throwUnsupportedMethodError() {
        throw ep.standardErrors.provider.unsupportedMethod({})
      }
      async _signEthereumMessage(J, et, eo, el) {
        this._ensureKnownAddress(et);
        try {
          let ec = await this.initializeRelay()
            , ed = await ec.signEthereumMessage(J, et, eo, el).promise;
          if ((0,
            eb.isErrorResponse)(ed))
            throw Error(ed.errorMessage);
          return {
            jsonrpc: "2.0",
            id: 0,
            result: ed.result
          }
        } catch (J) {
          if ("string" == typeof J.message && J.message.match(/(denied|rejected)/i))
            throw ep.standardErrors.provider.userRejectedRequest("User denied message signature");
          throw J
        }
      }
      async _ethereumAddressFromSignedMessage(J, et, eo) {
        let el = await this.initializeRelay()
          , ec = await el.ethereumAddressFromSignedMessage(J, et, eo).promise;
        if ((0,
          eb.isErrorResponse)(ec))
          throw Error(ec.errorMessage);
        return {
          jsonrpc: "2.0",
          id: 0,
          result: ec.result
        }
      }
      _eth_accounts() {
        return [...this._addresses]
      }
      _eth_coinbase() {
        return this.selectedAddress || null
      }
      _net_version() {
        return this.getChainId().toString(10)
      }
      _eth_chainId() {
        return (0,
          ef.hexStringFromIntNumber)(this.getChainId())
      }
      getChainId() {
        let J = this._storage.getItem(eC);
        if (!J)
          return (0,
            ef.ensureIntNumber)(this._chainIdFromOpts);
        let et = parseInt(J, 10);
        return (0,
          ef.ensureIntNumber)(et)
      }
      async _eth_requestAccounts() {
        var J;
        let et;
        if (null === (J = this.diagnostic) || void 0 === J || J.log(e_.EVENTS.ETH_ACCOUNTS_STATE, {
          method: "provider::_eth_requestAccounts",
          addresses_length: this._addresses.length,
          sessionIdHash: this._relay ? ey.Session.hash(this._relay.session.id) : void 0
        }),
          this._isAuthorized())
          return Promise.resolve({
            jsonrpc: "2.0",
            id: 0,
            result: this._addresses
          });
        try {
          let J = await this.initializeRelay();
          if (et = await J.requestEthereumAccounts().promise,
            (0,
              eb.isErrorResponse)(et))
            throw Error(et.errorMessage)
        } catch (J) {
          if ("string" == typeof J.message && J.message.match(/(denied|rejected)/i))
            throw ep.standardErrors.provider.userRejectedRequest("User denied account authorization");
          throw J
        }
        if (!et.result)
          throw Error("accounts received is empty");
        return this._setAddresses(et.result),
          this.isCoinbaseBrowser || await this.switchEthereumChain(this.getChainId()),
        {
          jsonrpc: "2.0",
          id: 0,
          result: this._addresses
        }
      }
      _eth_sign(J) {
        this._requireAuthorization();
        let et = (0,
          ef.ensureAddressString)(J[0])
          , eo = (0,
            ef.ensureBuffer)(J[1]);
        return this._signEthereumMessage(eo, et, !1)
      }
      _eth_ecRecover(J) {
        let et = (0,
          ef.ensureBuffer)(J[0])
          , eo = (0,
            ef.ensureBuffer)(J[1]);
        return this._ethereumAddressFromSignedMessage(et, eo, !1)
      }
      _personal_sign(J) {
        this._requireAuthorization();
        let et = (0,
          ef.ensureBuffer)(J[0])
          , eo = (0,
            ef.ensureAddressString)(J[1]);
        return this._signEthereumMessage(et, eo, !0)
      }
      _personal_ecRecover(J) {
        let et = (0,
          ef.ensureBuffer)(J[0])
          , eo = (0,
            ef.ensureBuffer)(J[1]);
        return this._ethereumAddressFromSignedMessage(et, eo, !0)
      }
      async _eth_signTransaction(J) {
        this._requireAuthorization();
        let et = this._prepareTransactionParams(J[0] || {});
        try {
          let J = await this.initializeRelay()
            , eo = await J.signEthereumTransaction(et).promise;
          if ((0,
            eb.isErrorResponse)(eo))
            throw Error(eo.errorMessage);
          return {
            jsonrpc: "2.0",
            id: 0,
            result: eo.result
          }
        } catch (J) {
          if ("string" == typeof J.message && J.message.match(/(denied|rejected)/i))
            throw ep.standardErrors.provider.userRejectedRequest("User denied transaction signature");
          throw J
        }
      }
      async _eth_sendRawTransaction(J) {
        let et = (0,
          ef.ensureBuffer)(J[0])
          , eo = await this.initializeRelay()
          , el = await eo.submitEthereumTransaction(et, this.getChainId()).promise;
        if ((0,
          eb.isErrorResponse)(el))
          throw Error(el.errorMessage);
        return {
          jsonrpc: "2.0",
          id: 0,
          result: el.result
        }
      }
      async _eth_sendTransaction(J) {
        this._requireAuthorization();
        let et = this._prepareTransactionParams(J[0] || {});
        try {
          let J = await this.initializeRelay()
            , eo = await J.signAndSubmitEthereumTransaction(et).promise;
          if ((0,
            eb.isErrorResponse)(eo))
            throw Error(eo.errorMessage);
          return {
            jsonrpc: "2.0",
            id: 0,
            result: eo.result
          }
        } catch (J) {
          if ("string" == typeof J.message && J.message.match(/(denied|rejected)/i))
            throw ep.standardErrors.provider.userRejectedRequest("User denied transaction signature");
          throw J
        }
      }
      async _eth_signTypedData_v1(J) {
        this._requireAuthorization();
        let et = (0,
          ef.ensureParsedJSONObject)(J[0])
          , eo = (0,
            ef.ensureAddressString)(J[1]);
        this._ensureKnownAddress(eo);
        let el = ew.default.hashForSignTypedDataLegacy({
          data: et
        })
          , ec = JSON.stringify(et, null, 2);
        return this._signEthereumMessage(el, eo, !1, ec)
      }
      async _eth_signTypedData_v3(J) {
        this._requireAuthorization();
        let et = (0,
          ef.ensureAddressString)(J[0])
          , eo = (0,
            ef.ensureParsedJSONObject)(J[1]);
        this._ensureKnownAddress(et);
        let el = ew.default.hashForSignTypedData_v3({
          data: eo
        })
          , ec = JSON.stringify(eo, null, 2);
        return this._signEthereumMessage(el, et, !1, ec)
      }
      async _eth_signTypedData_v4(J) {
        this._requireAuthorization();
        let et = (0,
          ef.ensureAddressString)(J[0])
          , eo = (0,
            ef.ensureParsedJSONObject)(J[1]);
        this._ensureKnownAddress(et);
        let el = ew.default.hashForSignTypedData_v4({
          data: eo
        })
          , ec = JSON.stringify(eo, null, 2);
        return this._signEthereumMessage(el, et, !1, ec)
      }
      async _cbwallet_arbitrary(J) {
        let et = J[0]
          , eo = J[1];
        if ("string" != typeof eo)
          throw Error("parameter must be a string");
        if ("object" != typeof et || null === et)
          throw Error("parameter must be an object");
        let el = await this.genericRequest(et, eo);
        return {
          jsonrpc: "2.0",
          id: 0,
          result: el
        }
      }
      async _wallet_addEthereumChain(J) {
        var et, eo, el, ec;
        let ed = J[0];
        if ((null === (et = ed.rpcUrls) || void 0 === et ? void 0 : et.length) === 0)
          return {
            jsonrpc: "2.0",
            id: 0,
            error: {
              code: 2,
              message: "please pass in at least 1 rpcUrl"
            }
          };
        if (!ed.chainName || "" === ed.chainName.trim())
          throw ep.standardErrors.rpc.invalidParams("chainName is a required field");
        if (!ed.nativeCurrency)
          throw ep.standardErrors.rpc.invalidParams("nativeCurrency is a required field");
        let eh = parseInt(ed.chainId, 16)
          , ef = await this.addEthereumChain(eh, null !== (eo = ed.rpcUrls) && void 0 !== eo ? eo : [], null !== (el = ed.blockExplorerUrls) && void 0 !== el ? el : [], ed.chainName, null !== (ec = ed.iconUrls) && void 0 !== ec ? ec : [], ed.nativeCurrency);
        return ef ? {
          jsonrpc: "2.0",
          id: 0,
          result: null
        } : {
          jsonrpc: "2.0",
          id: 0,
          error: {
            code: 2,
            message: "unable to add ethereum chain"
          }
        }
      }
      async _wallet_switchEthereumChain(J) {
        let et = J[0];
        return await this.switchEthereumChain(parseInt(et.chainId, 16)),
        {
          jsonrpc: "2.0",
          id: 0,
          result: null
        }
      }
      async _wallet_watchAsset(J) {
        let et = Array.isArray(J) ? J[0] : J;
        if (!et.type)
          throw ep.standardErrors.rpc.invalidParams("Type is required");
        if ((null == et ? void 0 : et.type) !== "ERC20")
          throw ep.standardErrors.rpc.invalidParams(`Asset of type '${et.type}' is not supported`);
        if (!(null == et ? void 0 : et.options))
          throw ep.standardErrors.rpc.invalidParams("Options are required");
        if (!(null == et ? void 0 : et.options.address))
          throw ep.standardErrors.rpc.invalidParams("Address is required");
        let eo = this.getChainId()
          , { address: el, symbol: ec, image: ed, decimals: eh } = et.options
          , ef = await this.watchAsset(et.type, el, ec, eh, ed, eo);
        return {
          jsonrpc: "2.0",
          id: 0,
          result: ef
        }
      }
      _eth_uninstallFilter(J) {
        let et = (0,
          ef.ensureHexString)(J[0]);
        return this._filterPolyfill.uninstallFilter(et)
      }
      async _eth_newFilter(J) {
        let et = J[0]
          , eo = await this._filterPolyfill.newFilter(et);
        return {
          jsonrpc: "2.0",
          id: 0,
          result: eo
        }
      }
      async _eth_newBlockFilter() {
        let J = await this._filterPolyfill.newBlockFilter();
        return {
          jsonrpc: "2.0",
          id: 0,
          result: J
        }
      }
      async _eth_newPendingTransactionFilter() {
        let J = await this._filterPolyfill.newPendingTransactionFilter();
        return {
          jsonrpc: "2.0",
          id: 0,
          result: J
        }
      }
      _eth_getFilterChanges(J) {
        let et = (0,
          ef.ensureHexString)(J[0]);
        return this._filterPolyfill.getFilterChanges(et)
      }
      _eth_getFilterLogs(J) {
        let et = (0,
          ef.ensureHexString)(J[0]);
        return this._filterPolyfill.getFilterLogs(et)
      }
      initializeRelay() {
        return this._relay ? Promise.resolve(this._relay) : this._relayProvider().then(J => (J.setAccountsCallback((J, et) => this._setAddresses(J, et)),
          J.setChainCallback((J, et) => {
            this.updateProviderInfo(et, parseInt(J, 10))
          }
          ),
          J.setDappDefaultChainCallback(this._chainIdFromOpts),
          this._relay = J,
          J))
      }
    }
      ;
    et.CoinbaseWalletProvider = CoinbaseWalletProvider
  },
  38431: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.EVENTS = void 0,
      et.EVENTS = {
        STARTED_CONNECTING: "walletlink_sdk.started.connecting",
        CONNECTED_STATE_CHANGE: "walletlink_sdk.connected",
        DISCONNECTED: "walletlink_sdk.disconnected",
        METADATA_DESTROYED: "walletlink_sdk_metadata_destroyed",
        LINKED: "walletlink_sdk.linked",
        FAILURE: "walletlink_sdk.generic_failure",
        SESSION_CONFIG_RECEIVED: "walletlink_sdk.session_config_event_received",
        ETH_ACCOUNTS_STATE: "walletlink_sdk.eth_accounts_state",
        SESSION_STATE_CHANGE: "walletlink_sdk.session_state_change",
        UNLINKED_ERROR_STATE: "walletlink_sdk.unlinked_error_state",
        SKIPPED_CLEARING_SESSION: "walletlink_sdk.skipped_clearing_session",
        GENERAL_ERROR: "walletlink_sdk.general_error",
        WEB3_REQUEST: "walletlink_sdk.web3.request",
        WEB3_REQUEST_PUBLISHED: "walletlink_sdk.web3.request_published",
        WEB3_RESPONSE: "walletlink_sdk.web3.response",
        METHOD_NOT_IMPLEMENTED: "walletlink_sdk.method_not_implemented",
        UNKNOWN_ADDRESS_ENCOUNTERED: "walletlink_sdk.unknown_address_encountered"
      }
  },
  33648: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.filterFromParam = et.FilterPolyfill = void 0;
    let el = eo(34083)
      , ec = eo(32072)
      , ed = {
        jsonrpc: "2.0",
        id: 0
      };
    function filterFromParam(J) {
      return {
        fromBlock: intBlockHeightFromHexBlockHeight(J.fromBlock),
        toBlock: intBlockHeightFromHexBlockHeight(J.toBlock),
        addresses: void 0 === J.address ? null : Array.isArray(J.address) ? J.address : [J.address],
        topics: J.topics || []
      }
    }
    function paramFromFilter(J) {
      let et = {
        fromBlock: hexBlockHeightFromIntBlockHeight(J.fromBlock),
        toBlock: hexBlockHeightFromIntBlockHeight(J.toBlock),
        topics: J.topics
      };
      return null !== J.addresses && (et.address = J.addresses),
        et
    }
    function intBlockHeightFromHexBlockHeight(J) {
      if (void 0 === J || "latest" === J || "pending" === J)
        return "latest";
      if ("earliest" === J)
        return (0,
          el.IntNumber)(0);
      if ((0,
        ec.isHexString)(J))
        return (0,
          ec.intNumberFromHexString)(J);
      throw Error(`Invalid block option: ${String(J)}`)
    }
    function hexBlockHeightFromIntBlockHeight(J) {
      return "latest" === J ? J : (0,
        ec.hexStringFromIntNumber)(J)
    }
    function filterNotFoundError() {
      return Object.assign(Object.assign({}, ed), {
        error: {
          code: -32e3,
          message: "filter not found"
        }
      })
    }
    function emptyResult() {
      return Object.assign(Object.assign({}, ed), {
        result: []
      })
    }
    et.FilterPolyfill = class {
      constructor(J) {
        this.logFilters = new Map,
          this.blockFilters = new Set,
          this.pendingTransactionFilters = new Set,
          this.cursors = new Map,
          this.timeouts = new Map,
          this.nextFilterId = (0,
            el.IntNumber)(1),
          this.REQUEST_THROTTLE_INTERVAL = 1e3,
          this.lastFetchTimestamp = new Date(0),
          this.resolvers = [],
          this.provider = J
      }
      async newFilter(J) {
        let et = filterFromParam(J)
          , eo = this.makeFilterId()
          , el = await this.setInitialCursorPosition(eo, et.fromBlock);
        return console.info(`Installing new log filter(${eo}):`, et, "initial cursor position:", el),
          this.logFilters.set(eo, et),
          this.setFilterTimeout(eo),
          (0,
            ec.hexStringFromIntNumber)(eo)
      }
      async newBlockFilter() {
        let J = this.makeFilterId()
          , et = await this.setInitialCursorPosition(J, "latest");
        return console.info(`Installing new block filter (${J}) with initial cursor position:`, et),
          this.blockFilters.add(J),
          this.setFilterTimeout(J),
          (0,
            ec.hexStringFromIntNumber)(J)
      }
      async newPendingTransactionFilter() {
        let J = this.makeFilterId()
          , et = await this.setInitialCursorPosition(J, "latest");
        return console.info(`Installing new block filter (${J}) with initial cursor position:`, et),
          this.pendingTransactionFilters.add(J),
          this.setFilterTimeout(J),
          (0,
            ec.hexStringFromIntNumber)(J)
      }
      uninstallFilter(J) {
        let et = (0,
          ec.intNumberFromHexString)(J);
        return console.info(`Uninstalling filter (${et})`),
          this.deleteFilter(et),
          !0
      }
      getFilterChanges(J) {
        let et = (0,
          ec.intNumberFromHexString)(J);
        return (this.timeouts.has(et) && this.setFilterTimeout(et),
          this.logFilters.has(et)) ? this.getLogFilterChanges(et) : this.blockFilters.has(et) ? this.getBlockFilterChanges(et) : this.pendingTransactionFilters.has(et) ? this.getPendingTransactionFilterChanges(et) : Promise.resolve(filterNotFoundError())
      }
      async getFilterLogs(J) {
        let et = (0,
          ec.intNumberFromHexString)(J)
          , eo = this.logFilters.get(et);
        return eo ? this.sendAsyncPromise(Object.assign(Object.assign({}, ed), {
          method: "eth_getLogs",
          params: [paramFromFilter(eo)]
        })) : filterNotFoundError()
      }
      makeFilterId() {
        return (0,
          el.IntNumber)(++this.nextFilterId)
      }
      sendAsyncPromise(J) {
        return new Promise((et, eo) => {
          this.provider.sendAsync(J, (J, el) => J ? eo(J) : Array.isArray(el) || null == el ? eo(Error(`unexpected response received: ${JSON.stringify(el)}`)) : void et(el))
        }
        )
      }
      deleteFilter(J) {
        console.info(`Deleting filter (${J})`),
          this.logFilters.delete(J),
          this.blockFilters.delete(J),
          this.pendingTransactionFilters.delete(J),
          this.cursors.delete(J),
          this.timeouts.delete(J)
      }
      async getLogFilterChanges(J) {
        let et = this.logFilters.get(J)
          , eo = this.cursors.get(J);
        if (!eo || !et)
          return filterNotFoundError();
        let eh = await this.getCurrentBlockHeight()
          , ep = "latest" === et.toBlock ? eh : et.toBlock;
        if (eo > eh || eo > Number(et.toBlock))
          return emptyResult();
        console.info(`Fetching logs from ${eo} to ${ep} for filter ${J}`);
        let ef = await this.sendAsyncPromise(Object.assign(Object.assign({}, ed), {
          method: "eth_getLogs",
          params: [paramFromFilter(Object.assign(Object.assign({}, et), {
            fromBlock: eo,
            toBlock: ep
          }))]
        }));
        if (Array.isArray(ef.result)) {
          let et = ef.result.map(J => (0,
            ec.intNumberFromHexString)(J.blockNumber || "0x0"))
            , ed = Math.max(...et);
          if (ed && ed > eo) {
            let et = (0,
              el.IntNumber)(ed + 1);
            console.info(`Moving cursor position for filter (${J}) from ${eo} to ${et}`),
              this.cursors.set(J, et)
          }
        }
        return ef
      }
      async getBlockFilterChanges(J) {
        let et = this.cursors.get(J);
        if (!et)
          return filterNotFoundError();
        let eo = await this.getCurrentBlockHeight();
        if (et > eo)
          return emptyResult();
        console.info(`Fetching blocks from ${et} to ${eo} for filter (${J})`);
        let eh = (await Promise.all((0,
          ec.range)(et, eo + 1).map(J => this.getBlockHashByNumber((0,
            el.IntNumber)(J))))).filter(J => !!J)
          , ep = (0,
            el.IntNumber)(et + eh.length);
        return console.info(`Moving cursor position for filter (${J}) from ${et} to ${ep}`),
          this.cursors.set(J, ep),
          Object.assign(Object.assign({}, ed), {
            result: eh
          })
      }
      async getPendingTransactionFilterChanges(J) {
        return Promise.resolve(emptyResult())
      }
      async setInitialCursorPosition(J, et) {
        let eo = await this.getCurrentBlockHeight()
          , el = "number" == typeof et && et > eo ? et : eo;
        return this.cursors.set(J, el),
          el
      }
      setFilterTimeout(J) {
        let et = this.timeouts.get(J);
        et && window.clearTimeout(et);
        let eo = window.setTimeout(() => {
          console.info(`Filter (${J}) timed out`),
            this.deleteFilter(J)
        }
          , 3e5);
        this.timeouts.set(J, eo)
      }
      async getCurrentBlockHeight() {
        let J = new Date;
        if (J.getTime() - this.lastFetchTimestamp.getTime() > this.REQUEST_THROTTLE_INTERVAL) {
          this.lastFetchTimestamp = J;
          let et = await this._getCurrentBlockHeight();
          this.currentBlockHeight = et,
            this.resolvers.forEach(J => J(et)),
            this.resolvers = []
        }
        return this.currentBlockHeight ? this.currentBlockHeight : new Promise(J => this.resolvers.push(J))
      }
      async _getCurrentBlockHeight() {
        let { result: J } = await this.sendAsyncPromise(Object.assign(Object.assign({}, ed), {
          method: "eth_blockNumber",
          params: []
        }));
        return (0,
          ec.intNumberFromHexString)((0,
            ec.ensureHexString)(J))
      }
      async getBlockHashByNumber(J) {
        let et = await this.sendAsyncPromise(Object.assign(Object.assign({}, ed), {
          method: "eth_getBlockByNumber",
          params: [(0,
            ec.hexStringFromIntNumber)(J), !1]
        }));
        return et.result && "string" == typeof et.result.hash ? (0,
          ec.ensureHexString)(et.result.hash) : null
      }
    }
      ,
      et.filterFromParam = filterFromParam
  },
  5313: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.SubscriptionManager = void 0;
    let el = eo(6842)
      , ec = eo(62876)
      , noop = () => { }
      ;
    et.SubscriptionManager = class {
      constructor(J) {
        let et = new el.PollingBlockTracker({
          provider: J,
          pollingInterval: 15e3,
          setSkipCacheFlag: !0
        })
          , { events: eo, middleware: ed } = ec({
            blockTracker: et,
            provider: J
          });
        this.events = eo,
          this.subscriptionMiddleware = ed
      }
      async handleRequest(J) {
        let et = {};
        return await this.subscriptionMiddleware(J, et, noop, noop),
          et
      }
      destroy() {
        this.subscriptionMiddleware.destroy()
      }
    }
  },
  92036: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.RelayAbstract = et.APP_VERSION_KEY = et.LOCAL_STORAGE_ADDRESSES_KEY = et.WALLET_USER_NAME_KEY = void 0;
    let el = eo(37185);
    et.WALLET_USER_NAME_KEY = "walletUsername",
      et.LOCAL_STORAGE_ADDRESSES_KEY = "Addresses",
      et.APP_VERSION_KEY = "AppVersion",
      et.RelayAbstract = class {
        async makeEthereumJSONRPCRequest(J, et) {
          if (!et)
            throw Error("Error: No jsonRpcUrl provided");
          return window.fetch(et, {
            method: "POST",
            body: JSON.stringify(J),
            mode: "cors",
            headers: {
              "Content-Type": "application/json"
            }
          }).then(J => J.json()).then(et => {
            if (!et)
              throw el.standardErrors.rpc.parse({});
            let { error: eo } = et;
            if (eo)
              throw (0,
                el.serializeError)(eo, J.method);
            return et
          }
          )
        }
      }
  },
  81107: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.RelayEventManager = void 0;
    let el = eo(32072);
    et.RelayEventManager = class {
      constructor() {
        this._nextRequestId = 0,
          this.callbacks = new Map
      }
      makeRequestId() {
        this._nextRequestId = (this._nextRequestId + 1) % 2147483647;
        let J = this._nextRequestId
          , et = (0,
            el.prepend0x)(J.toString(16))
          , eo = this.callbacks.get(et);
        return eo && this.callbacks.delete(et),
          J
      }
    }
  },
  73526: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.Session = void 0;
    let el = eo(89072)
      , ec = eo(32072)
      , ed = "session:id"
      , eh = "session:secret"
      , ep = "session:linked";
    let Session = class Session {
      constructor(J, et, eo, ed) {
        this._storage = J,
          this._id = et || (0,
            ec.randomBytesHex)(16),
          this._secret = eo || (0,
            ec.randomBytesHex)(32),
          this._key = new el.sha256().update(`${this._id}, ${this._secret} WalletLink`).digest("hex"),
          this._linked = !!ed
      }
      static load(J) {
        let et = J.getItem(ed)
          , eo = J.getItem(ep)
          , el = J.getItem(eh);
        return et && el ? new Session(J, et, el, "1" === eo) : null
      }
      static hash(J) {
        return new el.sha256().update(J).digest("hex")
      }
      get id() {
        return this._id
      }
      get secret() {
        return this._secret
      }
      get key() {
        return this._key
      }
      get linked() {
        return this._linked
      }
      set linked(J) {
        this._linked = J,
          this.persistLinked()
      }
      save() {
        return this._storage.setItem(ed, this._id),
          this._storage.setItem(eh, this._secret),
          this.persistLinked(),
          this
      }
      persistLinked() {
        this._storage.setItem(ep, this._linked ? "1" : "0")
      }
    }
      ;
    et.Session = Session
  },
  26840: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.MobileRelay = void 0;
    let el = eo(32072)
      , ec = eo(23129)
      , ed = eo(18411);
    let MobileRelay = class MobileRelay extends ec.WalletLinkRelay {
      constructor(J) {
        var et;
        super(J),
          this._enableMobileWalletLink = null !== (et = J.enableMobileWalletLink) && void 0 !== et && et
      }
      requestEthereumAccounts() {
        return this._enableMobileWalletLink ? super.requestEthereumAccounts() : {
          promise: new Promise(() => {
            let J = (0,
              el.getLocation)();
            J.href = `https://go.cb-w.com/dapp?cb_url=${encodeURIComponent(J.href)}`
          }
          ),
          cancel: () => { }
        }
      }
      publishWeb3RequestEvent(J, et) {
        if (super.publishWeb3RequestEvent(J, et),
          !(this._enableMobileWalletLink && this.ui instanceof ed.MobileRelayUI))
          return;
        let eo = !1;
        switch (et.method) {
          case "requestEthereumAccounts":
          case "connectAndSignIn":
            eo = !0,
              this.ui.openCoinbaseWalletDeeplink(this.getQRCodeUrl());
            break;
          case "switchEthereumChain":
            return;
          default:
            eo = !0,
              this.ui.openCoinbaseWalletDeeplink()
        }
        eo && window.addEventListener("blur", () => {
          window.addEventListener("focus", () => {
            this.connection.checkUnseenEvents()
          }
            , {
              once: !0
            })
        }
          , {
            once: !0
          })
      }
      handleWeb3ResponseMessage(J) {
        super.handleWeb3ResponseMessage(J),
          this._enableMobileWalletLink && this.ui instanceof ed.MobileRelayUI && this.ui.closeOpenedWindow()
      }
      connectAndSignIn(J) {
        if (!this._enableMobileWalletLink)
          throw Error("connectAndSignIn is supported only when enableMobileWalletLink is on");
        return this.sendRequest({
          method: "connectAndSignIn",
          params: {
            appName: this.appName,
            appLogoUrl: this.appLogoUrl,
            domain: window.location.hostname,
            aud: window.location.href,
            version: "1",
            type: "eip4361",
            nonce: J.nonce,
            iat: new Date().toISOString(),
            chainId: `eip155:${this.dappDefaultChain}`,
            statement: J.statement,
            resources: J.resources
          }
        })
      }
    }
      ;
    et.MobileRelay = MobileRelay
  },
  18411: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.MobileRelayUI = void 0;
    let el = eo(8592);
    et.MobileRelayUI = class {
      constructor(J) {
        this.attached = !1,
          this.darkMode = !1,
          this.openedWindow = null,
          this.redirectDialog = new el.RedirectDialog,
          this.darkMode = J.darkMode
      }
      attach() {
        if (this.attached)
          throw Error("Coinbase Wallet SDK UI is already attached");
        this.redirectDialog.attach(),
          this.attached = !0
      }
      setConnected(J) { }
      closeOpenedWindow() {
        var J;
        null === (J = this.openedWindow) || void 0 === J || J.close(),
          this.openedWindow = null
      }
      redirectToCoinbaseWallet(J) {
        let et = new URL("https://go.cb-w.com/walletlink");
        et.searchParams.append("redirect_url", window.location.href),
          J && et.searchParams.append("wl_url", J),
          this.openedWindow = window.open(et.href, "cbw-opener"),
          this.openedWindow && setTimeout(() => this.closeOpenedWindow(), 5e3)
      }
      openCoinbaseWalletDeeplink(J) {
        this.redirectDialog.present({
          title: "Redirecting to Coinbase Wallet...",
          buttonText: "Open",
          darkMode: this.darkMode,
          onButtonClick: () => {
            this.redirectToCoinbaseWallet(J)
          }
        }),
          setTimeout(() => {
            this.redirectToCoinbaseWallet(J)
          }
            , 99)
      }
      showConnecting(J) {
        return () => {
          this.closeOpenedWindow(),
            this.redirectDialog.clear()
        }
      }
      hideRequestEthereumAccounts() {
        this.closeOpenedWindow(),
          this.redirectDialog.clear()
      }
      requestEthereumAccounts() { }
      addEthereumChain() { }
      watchAsset() { }
      selectProvider() { }
      switchEthereumChain() { }
      signEthereumMessage() { }
      signEthereumTransaction() { }
      submitEthereumTransaction() { }
      ethereumAddressFromSignedMessage() { }
      reloadUI() { }
      setStandalone() { }
      setConnectDisabled() { }
      inlineAccountsResponse() {
        return !1
      }
      inlineAddEthereumChain() {
        return !1
      }
      inlineWatchAsset() {
        return !1
      }
      inlineSwitchEthereumChain() {
        return !1
      }
      isStandalone() {
        return !1
      }
    }
  },
  23129: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.WalletLinkRelay = void 0;
    let el = eo(37185)
      , ec = eo(34083)
      , ed = eo(32072)
      , eh = eo(38431)
      , ep = eo(92036)
      , ef = eo(73526)
      , em = eo(33689)
      , eg = eo(7588)
      , ey = eo(20462);
    let WalletLinkRelay = class WalletLinkRelay extends ep.RelayAbstract {
      constructor(J) {
        var et;
        super(),
          this.accountsCallback = null,
          this.chainCallbackParams = {
            chainId: "",
            jsonRpcUrl: ""
          },
          this.chainCallback = null,
          this.dappDefaultChain = 1,
          this.appName = "",
          this.appLogoUrl = null,
          this.linkedUpdated = J => {
            var et;
            this.isLinked = J;
            let eo = this.storage.getItem(ep.LOCAL_STORAGE_ADDRESSES_KEY);
            if (J && (this.session.linked = J),
              this.isUnlinkedErrorState = !1,
              eo) {
              let el = eo.split(" ")
                , ec = "true" === this.storage.getItem("IsStandaloneSigning");
              if ("" !== el[0] && !J && this.session.linked && !ec) {
                this.isUnlinkedErrorState = !0;
                let J = this.getSessionIdHash();
                null === (et = this.diagnostic) || void 0 === et || et.log(eh.EVENTS.UNLINKED_ERROR_STATE, {
                  sessionIdHash: J
                })
              }
            }
          }
          ,
          this.metadataUpdated = (J, et) => {
            this.storage.setItem(J, et)
          }
          ,
          this.chainUpdated = (J, et) => {
            (this.chainCallbackParams.chainId !== J || this.chainCallbackParams.jsonRpcUrl !== et) && (this.chainCallbackParams = {
              chainId: J,
              jsonRpcUrl: et
            },
              this.chainCallback && this.chainCallback(J, et))
          }
          ,
          this.accountUpdated = J => {
            this.accountsCallback && this.accountsCallback([J]),
              WalletLinkRelay.accountRequestCallbackIds.size > 0 && (Array.from(WalletLinkRelay.accountRequestCallbackIds.values()).forEach(et => {
                this.invokeCallback(Object.assign(Object.assign({}, {
                  type: "WEB3_RESPONSE",
                  id: et,
                  response: {
                    method: "requestEthereumAccounts",
                    result: [J]
                  }
                }), {
                  id: et
                }))
              }
              ),
                WalletLinkRelay.accountRequestCallbackIds.clear())
          }
          ,
          this.connectedUpdated = J => {
            this.ui.setConnected(J)
          }
          ,
          this.resetAndReload = this.resetAndReload.bind(this),
          this.linkAPIUrl = J.linkAPIUrl,
          this.storage = J.storage,
          this.options = J;
        let { session: eo, ui: el, connection: ec } = this.subscribe();
        this._session = eo,
          this.connection = ec,
          this.relayEventManager = J.relayEventManager,
          this.diagnostic = J.diagnosticLogger,
          this._reloadOnDisconnect = null === (et = J.reloadOnDisconnect) || void 0 === et || et,
          this.ui = el
      }
      subscribe() {
        let J = ef.Session.load(this.storage) || new ef.Session(this.storage).save()
          , { linkAPIUrl: et, diagnostic: eo } = this
          , el = new em.WalletLinkConnection({
            session: J,
            linkAPIUrl: et,
            diagnostic: eo,
            listener: this
          })
          , { version: ec, darkMode: ed } = this.options
          , eh = this.options.uiConstructor({
            linkAPIUrl: et,
            version: ec,
            darkMode: ed,
            session: J
          });
        return el.connect(),
        {
          session: J,
          ui: eh,
          connection: el
        }
      }
      attachUI() {
        this.ui.attach()
      }
      resetAndReload() {
        Promise.race([this.connection.setSessionMetadata("__destroyed", "1"), new Promise(J => setTimeout(() => J(null), 1e3))]).then(() => {
          var J, et;
          let eo = this.ui.isStandalone();
          null === (J = this.diagnostic) || void 0 === J || J.log(eh.EVENTS.SESSION_STATE_CHANGE, {
            method: "relay::resetAndReload",
            sessionMetadataChange: "__destroyed, 1",
            sessionIdHash: this.getSessionIdHash()
          }),
            this.connection.destroy();
          let el = ef.Session.load(this.storage);
          if ((null == el ? void 0 : el.id) === this._session.id ? this.storage.clear() : el && (null === (et = this.diagnostic) || void 0 === et || et.log(eh.EVENTS.SKIPPED_CLEARING_SESSION, {
            sessionIdHash: this.getSessionIdHash(),
            storedSessionIdHash: ef.Session.hash(el.id)
          })),
            this._reloadOnDisconnect) {
            this.ui.reloadUI();
            return
          }
          this.accountsCallback && this.accountsCallback([], !0);
          let { session: ec, ui: ed, connection: ep } = this.subscribe();
          this._session = ec,
            this.connection = ep,
            this.ui = ed,
            eo && this.ui.setStandalone && this.ui.setStandalone(!0),
            this.attachUI()
        }
        ).catch(J => {
          var et;
          null === (et = this.diagnostic) || void 0 === et || et.log(eh.EVENTS.FAILURE, {
            method: "relay::resetAndReload",
            message: `failed to reset and reload with ${J}`,
            sessionIdHash: this.getSessionIdHash()
          })
        }
        )
      }
      setAppInfo(J, et) {
        this.appName = J,
          this.appLogoUrl = et
      }
      getStorageItem(J) {
        return this.storage.getItem(J)
      }
      get session() {
        return this._session
      }
      setStorageItem(J, et) {
        this.storage.setItem(J, et)
      }
      signEthereumMessage(J, et, eo, el) {
        return this.sendRequest({
          method: "signEthereumMessage",
          params: {
            message: (0,
              ed.hexStringFromBuffer)(J, !0),
            address: et,
            addPrefix: eo,
            typedDataJson: el || null
          }
        })
      }
      ethereumAddressFromSignedMessage(J, et, eo) {
        return this.sendRequest({
          method: "ethereumAddressFromSignedMessage",
          params: {
            message: (0,
              ed.hexStringFromBuffer)(J, !0),
            signature: (0,
              ed.hexStringFromBuffer)(et, !0),
            addPrefix: eo
          }
        })
      }
      signEthereumTransaction(J) {
        return this.sendRequest({
          method: "signEthereumTransaction",
          params: {
            fromAddress: J.fromAddress,
            toAddress: J.toAddress,
            weiValue: (0,
              ed.bigIntStringFromBN)(J.weiValue),
            data: (0,
              ed.hexStringFromBuffer)(J.data, !0),
            nonce: J.nonce,
            gasPriceInWei: J.gasPriceInWei ? (0,
              ed.bigIntStringFromBN)(J.gasPriceInWei) : null,
            maxFeePerGas: J.gasPriceInWei ? (0,
              ed.bigIntStringFromBN)(J.gasPriceInWei) : null,
            maxPriorityFeePerGas: J.gasPriceInWei ? (0,
              ed.bigIntStringFromBN)(J.gasPriceInWei) : null,
            gasLimit: J.gasLimit ? (0,
              ed.bigIntStringFromBN)(J.gasLimit) : null,
            chainId: J.chainId,
            shouldSubmit: !1
          }
        })
      }
      signAndSubmitEthereumTransaction(J) {
        return this.sendRequest({
          method: "signEthereumTransaction",
          params: {
            fromAddress: J.fromAddress,
            toAddress: J.toAddress,
            weiValue: (0,
              ed.bigIntStringFromBN)(J.weiValue),
            data: (0,
              ed.hexStringFromBuffer)(J.data, !0),
            nonce: J.nonce,
            gasPriceInWei: J.gasPriceInWei ? (0,
              ed.bigIntStringFromBN)(J.gasPriceInWei) : null,
            maxFeePerGas: J.maxFeePerGas ? (0,
              ed.bigIntStringFromBN)(J.maxFeePerGas) : null,
            maxPriorityFeePerGas: J.maxPriorityFeePerGas ? (0,
              ed.bigIntStringFromBN)(J.maxPriorityFeePerGas) : null,
            gasLimit: J.gasLimit ? (0,
              ed.bigIntStringFromBN)(J.gasLimit) : null,
            chainId: J.chainId,
            shouldSubmit: !0
          }
        })
      }
      submitEthereumTransaction(J, et) {
        return this.sendRequest({
          method: "submitEthereumTransaction",
          params: {
            signedTransaction: (0,
              ed.hexStringFromBuffer)(J, !0),
            chainId: et
          }
        })
      }
      scanQRCode(J) {
        return this.sendRequest({
          method: "scanQRCode",
          params: {
            regExp: J
          }
        })
      }
      getQRCodeUrl() {
        return (0,
          ed.createQrUrl)(this._session.id, this._session.secret, this.linkAPIUrl, !1, this.options.version, this.dappDefaultChain)
      }
      genericRequest(J, et) {
        return this.sendRequest({
          method: "generic",
          params: {
            action: et,
            data: J
          }
        })
      }
      sendGenericMessage(J) {
        return this.sendRequest(J)
      }
      sendRequest(J) {
        let et = null
          , eo = (0,
            ed.randomBytesHex)(8)
          , cancel = el => {
            this.publishWeb3RequestCanceledEvent(eo),
              this.handleErrorResponse(eo, J.method, el),
              null == et || et()
          }
          , el = new Promise((el, ec) => {
            this.ui.isStandalone() || (et = this.ui.showConnecting({
              isUnlinkedErrorState: this.isUnlinkedErrorState,
              onCancel: cancel,
              onResetConnection: this.resetAndReload
            })),
              this.relayEventManager.callbacks.set(eo, J => {
                if (null == et || et(),
                  (0,
                    eg.isErrorResponse)(J))
                  return ec(Error(J.errorMessage));
                el(J)
              }
              ),
              this.ui.isStandalone() ? this.sendRequestStandalone(eo, J) : this.publishWeb3RequestEvent(eo, J)
          }
          );
        return {
          promise: el,
          cancel
        }
      }
      setConnectDisabled(J) {
        this.ui.setConnectDisabled(J)
      }
      setAccountsCallback(J) {
        this.accountsCallback = J
      }
      setChainCallback(J) {
        this.chainCallback = J
      }
      setDappDefaultChainCallback(J) {
        this.dappDefaultChain = J,
          this.ui instanceof ey.WalletLinkRelayUI && this.ui.setChainId(J)
      }
      publishWeb3RequestEvent(J, et) {
        var eo;
        let el = {
          type: "WEB3_REQUEST",
          id: J,
          request: et
        }
          , ec = ef.Session.load(this.storage);
        null === (eo = this.diagnostic) || void 0 === eo || eo.log(eh.EVENTS.WEB3_REQUEST, {
          eventId: el.id,
          method: `relay::${et.method}`,
          sessionIdHash: this.getSessionIdHash(),
          storedSessionIdHash: ec ? ef.Session.hash(ec.id) : "",
          isSessionMismatched: ((null == ec ? void 0 : ec.id) !== this._session.id).toString()
        }),
          this.publishEvent("Web3Request", el, !0).then(J => {
            var eo;
            null === (eo = this.diagnostic) || void 0 === eo || eo.log(eh.EVENTS.WEB3_REQUEST_PUBLISHED, {
              eventId: el.id,
              method: `relay::${et.method}`,
              sessionIdHash: this.getSessionIdHash(),
              storedSessionIdHash: ec ? ef.Session.hash(ec.id) : "",
              isSessionMismatched: ((null == ec ? void 0 : ec.id) !== this._session.id).toString()
            })
          }
          ).catch(J => {
            this.handleWeb3ResponseMessage({
              type: "WEB3_RESPONSE",
              id: el.id,
              response: {
                method: et.method,
                errorMessage: J.message
              }
            })
          }
          )
      }
      publishWeb3RequestCanceledEvent(J) {
        this.publishEvent("Web3RequestCanceled", {
          type: "WEB3_REQUEST_CANCELED",
          id: J
        }, !1).then()
      }
      publishEvent(J, et, eo) {
        return this.connection.publishEvent(J, et, eo)
      }
      handleWeb3ResponseMessage(J) {
        var et;
        let { response: eo } = J;
        if (null === (et = this.diagnostic) || void 0 === et || et.log(eh.EVENTS.WEB3_RESPONSE, {
          eventId: J.id,
          method: `relay::${eo.method}`,
          sessionIdHash: this.getSessionIdHash()
        }),
          "requestEthereumAccounts" === eo.method) {
          WalletLinkRelay.accountRequestCallbackIds.forEach(et => this.invokeCallback(Object.assign(Object.assign({}, J), {
            id: et
          }))),
            WalletLinkRelay.accountRequestCallbackIds.clear();
          return
        }
        this.invokeCallback(J)
      }
      handleErrorResponse(J, et, eo, ec) {
        var ed;
        let eh = null !== (ed = null == eo ? void 0 : eo.message) && void 0 !== ed ? ed : (0,
          el.getMessageFromCode)(ec);
        this.handleWeb3ResponseMessage({
          type: "WEB3_RESPONSE",
          id: J,
          response: {
            method: et,
            errorMessage: eh,
            errorCode: ec
          }
        })
      }
      invokeCallback(J) {
        let et = this.relayEventManager.callbacks.get(J.id);
        et && (et(J.response),
          this.relayEventManager.callbacks.delete(J.id))
      }
      requestEthereumAccounts() {
        let J = {
          method: "requestEthereumAccounts",
          params: {
            appName: this.appName,
            appLogoUrl: this.appLogoUrl || null
          }
        }
          , et = (0,
            ed.randomBytesHex)(8)
          , cancel = eo => {
            this.publishWeb3RequestCanceledEvent(et),
              this.handleErrorResponse(et, J.method, eo)
          }
          , eo = new Promise((eo, ec) => {
            if (this.relayEventManager.callbacks.set(et, J => {
              if (this.ui.hideRequestEthereumAccounts(),
                (0,
                  eg.isErrorResponse)(J))
                return ec(Error(J.errorMessage));
              eo(J)
            }
            ),
              this.ui.inlineAccountsResponse())
              this.ui.requestEthereumAccounts({
                onCancel: cancel,
                onAccounts: J => {
                  this.handleWeb3ResponseMessage({
                    type: "WEB3_RESPONSE",
                    id: et,
                    response: {
                      method: "requestEthereumAccounts",
                      result: J
                    }
                  })
                }
              });
            else {
              let J = el.standardErrors.provider.userRejectedRequest("User denied account authorization");
              this.ui.requestEthereumAccounts({
                onCancel: () => cancel(J)
              })
            }
            WalletLinkRelay.accountRequestCallbackIds.add(et),
              this.ui.inlineAccountsResponse() || this.ui.isStandalone() || this.publishWeb3RequestEvent(et, J)
          }
          );
        return {
          promise: eo,
          cancel
        }
      }
      selectProvider(J) {
        let et = (0,
          ed.randomBytesHex)(8)
          , eo = new Promise((eo, el) => {
            this.relayEventManager.callbacks.set(et, J => {
              if ((0,
                eg.isErrorResponse)(J))
                return el(Error(J.errorMessage));
              eo(J)
            }
            ),
              this.ui.selectProvider && this.ui.selectProvider({
                onApprove: J => {
                  this.handleWeb3ResponseMessage({
                    type: "WEB3_RESPONSE",
                    id: et,
                    response: {
                      method: "selectProvider",
                      result: J
                    }
                  })
                }
                ,
                onCancel: J => {
                  this.handleWeb3ResponseMessage({
                    type: "WEB3_RESPONSE",
                    id: et,
                    response: {
                      method: "selectProvider",
                      result: ec.ProviderType.Unselected
                    }
                  })
                }
                ,
                providerOptions: J
              })
          }
          );
        return {
          cancel: J => {
            this.publishWeb3RequestCanceledEvent(et),
              this.handleErrorResponse(et, "selectProvider", J)
          }
          ,
          promise: eo
        }
      }
      watchAsset(J, et, eo, el, ec, eh) {
        let ep = {
          method: "watchAsset",
          params: {
            type: J,
            options: {
              address: et,
              symbol: eo,
              decimals: el,
              image: ec
            },
            chainId: eh
          }
        }
          , ef = null
          , em = (0,
            ed.randomBytesHex)(8)
          , cancel = J => {
            this.publishWeb3RequestCanceledEvent(em),
              this.handleErrorResponse(em, ep.method, J),
              null == ef || ef()
          }
          ;
        this.ui.inlineWatchAsset() || (ef = this.ui.showConnecting({
          isUnlinkedErrorState: this.isUnlinkedErrorState,
          onCancel: cancel,
          onResetConnection: this.resetAndReload
        }));
        let ey = new Promise((ed, ey) => {
          this.relayEventManager.callbacks.set(em, J => {
            if (null == ef || ef(),
              (0,
                eg.isErrorResponse)(J))
              return ey(Error(J.errorMessage));
            ed(J)
          }
          ),
            this.ui.inlineWatchAsset() && this.ui.watchAsset({
              onApprove: () => {
                this.handleWeb3ResponseMessage({
                  type: "WEB3_RESPONSE",
                  id: em,
                  response: {
                    method: "watchAsset",
                    result: !0
                  }
                })
              }
              ,
              onCancel: J => {
                this.handleWeb3ResponseMessage({
                  type: "WEB3_RESPONSE",
                  id: em,
                  response: {
                    method: "watchAsset",
                    result: !1
                  }
                })
              }
              ,
              type: J,
              address: et,
              symbol: eo,
              decimals: el,
              image: ec,
              chainId: eh
            }),
            this.ui.inlineWatchAsset() || this.ui.isStandalone() || this.publishWeb3RequestEvent(em, ep)
        }
        );
        return {
          cancel,
          promise: ey
        }
      }
      addEthereumChain(J, et, eo, el, ec, eh) {
        let ep = {
          method: "addEthereumChain",
          params: {
            chainId: J,
            rpcUrls: et,
            blockExplorerUrls: el,
            chainName: ec,
            iconUrls: eo,
            nativeCurrency: eh
          }
        }
          , ef = null
          , em = (0,
            ed.randomBytesHex)(8)
          , cancel = J => {
            this.publishWeb3RequestCanceledEvent(em),
              this.handleErrorResponse(em, ep.method, J),
              null == ef || ef()
          }
          ;
        this.ui.inlineAddEthereumChain(J) || (ef = this.ui.showConnecting({
          isUnlinkedErrorState: this.isUnlinkedErrorState,
          onCancel: cancel,
          onResetConnection: this.resetAndReload
        }));
        let ey = new Promise((et, eo) => {
          this.relayEventManager.callbacks.set(em, J => {
            if (null == ef || ef(),
              (0,
                eg.isErrorResponse)(J))
              return eo(Error(J.errorMessage));
            et(J)
          }
          ),
            this.ui.inlineAddEthereumChain(J) && this.ui.addEthereumChain({
              onCancel: J => {
                this.handleWeb3ResponseMessage({
                  type: "WEB3_RESPONSE",
                  id: em,
                  response: {
                    method: "addEthereumChain",
                    result: {
                      isApproved: !1,
                      rpcUrl: ""
                    }
                  }
                })
              }
              ,
              onApprove: J => {
                this.handleWeb3ResponseMessage({
                  type: "WEB3_RESPONSE",
                  id: em,
                  response: {
                    method: "addEthereumChain",
                    result: {
                      isApproved: !0,
                      rpcUrl: J
                    }
                  }
                })
              }
              ,
              chainId: ep.params.chainId,
              rpcUrls: ep.params.rpcUrls,
              blockExplorerUrls: ep.params.blockExplorerUrls,
              chainName: ep.params.chainName,
              iconUrls: ep.params.iconUrls,
              nativeCurrency: ep.params.nativeCurrency
            }),
            this.ui.inlineAddEthereumChain(J) || this.ui.isStandalone() || this.publishWeb3RequestEvent(em, ep)
        }
        );
        return {
          promise: ey,
          cancel
        }
      }
      switchEthereumChain(J, et) {
        let eo = {
          method: "switchEthereumChain",
          params: Object.assign({
            chainId: J
          }, {
            address: et
          })
        }
          , ec = (0,
            ed.randomBytesHex)(8)
          , eh = new Promise((et, ed) => {
            this.relayEventManager.callbacks.set(ec, J => (0,
              eg.isErrorResponse)(J) && J.errorCode ? ed(el.standardErrors.provider.custom({
                code: J.errorCode,
                message: "Unrecognized chain ID. Try adding the chain using addEthereumChain first."
              })) : (0,
                eg.isErrorResponse)(J) ? ed(Error(J.errorMessage)) : void et(J)),
              this.ui.switchEthereumChain({
                onCancel: et => {
                  var eo;
                  if (et) {
                    let ed = null !== (eo = (0,
                      el.getErrorCode)(et)) && void 0 !== eo ? eo : el.standardErrorCodes.provider.unsupportedChain;
                    this.handleErrorResponse(ec, "switchEthereumChain", et instanceof Error ? et : el.standardErrors.provider.unsupportedChain(J), ed)
                  } else
                    this.handleWeb3ResponseMessage({
                      type: "WEB3_RESPONSE",
                      id: ec,
                      response: {
                        method: "switchEthereumChain",
                        result: {
                          isApproved: !1,
                          rpcUrl: ""
                        }
                      }
                    })
                }
                ,
                onApprove: J => {
                  this.handleWeb3ResponseMessage({
                    type: "WEB3_RESPONSE",
                    id: ec,
                    response: {
                      method: "switchEthereumChain",
                      result: {
                        isApproved: !0,
                        rpcUrl: J
                      }
                    }
                  })
                }
                ,
                chainId: eo.params.chainId,
                address: eo.params.address
              }),
              this.ui.inlineSwitchEthereumChain() || this.ui.isStandalone() || this.publishWeb3RequestEvent(ec, eo)
          }
          );
        return {
          promise: eh,
          cancel: J => {
            this.publishWeb3RequestCanceledEvent(ec),
              this.handleErrorResponse(ec, eo.method, J)
          }
        }
      }
      inlineAddEthereumChain(J) {
        return this.ui.inlineAddEthereumChain(J)
      }
      getSessionIdHash() {
        return ef.Session.hash(this._session.id)
      }
      sendRequestStandalone(J, et) {
        let _cancel = eo => {
          this.handleErrorResponse(J, et.method, eo)
        }
          , onSuccess = et => {
            this.handleWeb3ResponseMessage({
              type: "WEB3_RESPONSE",
              id: J,
              response: et
            })
          }
          ;
        switch (et.method) {
          case "signEthereumMessage":
            this.ui.signEthereumMessage({
              request: et,
              onSuccess,
              onCancel: _cancel
            });
            break;
          case "signEthereumTransaction":
            this.ui.signEthereumTransaction({
              request: et,
              onSuccess,
              onCancel: _cancel
            });
            break;
          case "submitEthereumTransaction":
            this.ui.submitEthereumTransaction({
              request: et,
              onSuccess,
              onCancel: _cancel
            });
            break;
          case "ethereumAddressFromSignedMessage":
            this.ui.ethereumAddressFromSignedMessage({
              request: et,
              onSuccess
            });
            break;
          default:
            _cancel()
        }
      }
    }
      ;
    et.WalletLinkRelay = WalletLinkRelay,
      WalletLinkRelay.accountRequestCallbackIds = new Set
  },
  33689: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.WalletLinkConnection = void 0;
    let el = eo(34083)
      , ec = eo(50769)
      , ed = eo(38431)
      , eh = eo(92036)
      , ep = eo(73526)
      , ef = eo(12389)
      , em = eo(57326);
    et.WalletLinkConnection = class {
      constructor({ session: J, linkAPIUrl: et, listener: eo, diagnostic: eg, WebSocketClass: ey = WebSocket }) {
        this.destroyed = !1,
          this.lastHeartbeatResponse = 0,
          this.nextReqId = (0,
            el.IntNumber)(1),
          this._connected = !1,
          this._linked = !1,
          this.shouldFetchUnseenEventsOnConnect = !1,
          this.requestResolutions = new Map,
          this.handleSessionMetadataUpdated = J => {
            if (!J)
              return;
            let et = new Map([["__destroyed", this.handleDestroyed], ["EthereumAddress", this.handleAccountUpdated], ["WalletUsername", this.handleWalletUsernameUpdated], ["AppVersion", this.handleAppVersionUpdated], ["ChainId", et => J.JsonRpcUrl && this.handleChainUpdated(et, J.JsonRpcUrl)]]);
            et.forEach((et, eo) => {
              let el = J[eo];
              void 0 !== el && et(el)
            }
            )
          }
          ,
          this.handleDestroyed = J => {
            var et, eo;
            "1" === J && (null === (et = this.listener) || void 0 === et || et.resetAndReload(),
              null === (eo = this.diagnostic) || void 0 === eo || eo.log(ed.EVENTS.METADATA_DESTROYED, {
                alreadyDestroyed: this.isDestroyed,
                sessionIdHash: ep.Session.hash(this.session.id)
              }))
          }
          ,
          this.handleAccountUpdated = async J => {
            var et, eo;
            try {
              let eo = await this.cipher.decrypt(J);
              null === (et = this.listener) || void 0 === et || et.accountUpdated(eo)
            } catch (J) {
              null === (eo = this.diagnostic) || void 0 === eo || eo.log(ed.EVENTS.GENERAL_ERROR, {
                message: "Had error decrypting",
                value: "selectedAddress"
              })
            }
          }
          ,
          this.handleMetadataUpdated = async (J, et) => {
            var eo, el;
            try {
              let el = await this.cipher.decrypt(et);
              null === (eo = this.listener) || void 0 === eo || eo.metadataUpdated(J, el)
            } catch (et) {
              null === (el = this.diagnostic) || void 0 === el || el.log(ed.EVENTS.GENERAL_ERROR, {
                message: "Had error decrypting",
                value: J
              })
            }
          }
          ,
          this.handleWalletUsernameUpdated = async J => {
            this.handleMetadataUpdated(eh.WALLET_USER_NAME_KEY, J)
          }
          ,
          this.handleAppVersionUpdated = async J => {
            this.handleMetadataUpdated(eh.APP_VERSION_KEY, J)
          }
          ,
          this.handleChainUpdated = async (J, et) => {
            var eo, el;
            try {
              let el = await this.cipher.decrypt(J)
                , ec = await this.cipher.decrypt(et);
              null === (eo = this.listener) || void 0 === eo || eo.chainUpdated(el, ec)
            } catch (J) {
              null === (el = this.diagnostic) || void 0 === el || el.log(ed.EVENTS.GENERAL_ERROR, {
                message: "Had error decrypting",
                value: "chainId|jsonRpcUrl"
              })
            }
          }
          ,
          this.session = J,
          this.cipher = new ec.Cipher(J.secret),
          this.diagnostic = eg,
          this.listener = eo;
        let eb = new em.WalletLinkWebSocket(`${et}/rpc`, ey);
        eb.setConnectionStateListener(async et => {
          var eo;
          null === (eo = this.diagnostic) || void 0 === eo || eo.log(ed.EVENTS.CONNECTED_STATE_CHANGE, {
            state: et,
            sessionIdHash: ep.Session.hash(J.id)
          });
          let el = !1;
          switch (et) {
            case em.ConnectionState.DISCONNECTED:
              if (!this.destroyed) {
                let connect = async () => {
                  await new Promise(J => setTimeout(J, 5e3)),
                    this.destroyed || eb.connect().catch(() => {
                      connect()
                    }
                    )
                }
                  ;
                connect()
              }
              break;
            case em.ConnectionState.CONNECTED:
              try {
                await this.authenticate(),
                  this.sendIsLinked(),
                  this.sendGetSessionConfig(),
                  el = !0
              } catch (J) { }
              this.updateLastHeartbeat(),
                setInterval(() => {
                  this.heartbeat()
                }
                  , 1e4),
                this.shouldFetchUnseenEventsOnConnect && this.fetchUnseenEventsAPI();
            case em.ConnectionState.CONNECTING:
          }
          this.connected !== el && (this.connected = el)
        }
        ),
          eb.setIncomingDataListener(et => {
            var eo, el, ec;
            switch (et.type) {
              case "Heartbeat":
                this.updateLastHeartbeat();
                return;
              case "IsLinkedOK":
              case "Linked":
                {
                  let el = "IsLinkedOK" === et.type ? et.linked : void 0;
                  null === (eo = this.diagnostic) || void 0 === eo || eo.log(ed.EVENTS.LINKED, {
                    sessionIdHash: ep.Session.hash(J.id),
                    linked: el,
                    type: et.type,
                    onlineGuests: et.onlineGuests
                  }),
                    this.linked = el || et.onlineGuests > 0;
                  break
                }
              case "GetSessionConfigOK":
              case "SessionConfigUpdated":
                null === (el = this.diagnostic) || void 0 === el || el.log(ed.EVENTS.SESSION_CONFIG_RECEIVED, {
                  sessionIdHash: ep.Session.hash(J.id),
                  metadata_keys: et && et.metadata ? Object.keys(et.metadata) : void 0
                }),
                  this.handleSessionMetadataUpdated(et.metadata);
                break;
              case "Event":
                this.handleIncomingEvent(et)
            }
            void 0 !== et.id && (null === (ec = this.requestResolutions.get(et.id)) || void 0 === ec || ec(et))
          }
          ),
          this.ws = eb,
          this.http = new ef.WalletLinkHTTP(et, J.id, J.key)
      }
      connect() {
        var J;
        if (this.destroyed)
          throw Error("instance is destroyed");
        null === (J = this.diagnostic) || void 0 === J || J.log(ed.EVENTS.STARTED_CONNECTING, {
          sessionIdHash: ep.Session.hash(this.session.id)
        }),
          this.ws.connect()
      }
      destroy() {
        var J;
        this.destroyed = !0,
          this.ws.disconnect(),
          null === (J = this.diagnostic) || void 0 === J || J.log(ed.EVENTS.DISCONNECTED, {
            sessionIdHash: ep.Session.hash(this.session.id)
          }),
          this.listener = void 0
      }
      get isDestroyed() {
        return this.destroyed
      }
      get connected() {
        return this._connected
      }
      set connected(J) {
        var et, eo;
        this._connected = J,
          J && (null === (et = this.onceConnected) || void 0 === et || et.call(this)),
          null === (eo = this.listener) || void 0 === eo || eo.connectedUpdated(J)
      }
      setOnceConnected(J) {
        return new Promise(et => {
          this.connected ? J().then(et) : this.onceConnected = () => {
            J().then(et),
              this.onceConnected = void 0
          }
        }
        )
      }
      get linked() {
        return this._linked
      }
      set linked(J) {
        var et, eo;
        this._linked = J,
          J && (null === (et = this.onceLinked) || void 0 === et || et.call(this)),
          null === (eo = this.listener) || void 0 === eo || eo.linkedUpdated(J)
      }
      setOnceLinked(J) {
        return new Promise(et => {
          this.linked ? J().then(et) : this.onceLinked = () => {
            J().then(et),
              this.onceLinked = void 0
          }
        }
        )
      }
      async handleIncomingEvent(J) {
        var et, eo;
        if ("Event" === J.type && "Web3Response" === J.event)
          try {
            let eo = await this.cipher.decrypt(J.data)
              , el = JSON.parse(eo);
            if ("WEB3_RESPONSE" !== el.type)
              return;
            null === (et = this.listener) || void 0 === et || et.handleWeb3ResponseMessage(el)
          } catch (J) {
            null === (eo = this.diagnostic) || void 0 === eo || eo.log(ed.EVENTS.GENERAL_ERROR, {
              message: "Had error decrypting",
              value: "incomingEvent"
            })
          }
      }
      async checkUnseenEvents() {
        if (!this.connected) {
          this.shouldFetchUnseenEventsOnConnect = !0;
          return
        }
        await new Promise(J => setTimeout(J, 250));
        try {
          await this.fetchUnseenEventsAPI()
        } catch (J) {
          console.error("Unable to check for unseen events", J)
        }
      }
      async fetchUnseenEventsAPI() {
        this.shouldFetchUnseenEventsOnConnect = !1;
        let J = await this.http.fetchUnseenEvents();
        J.forEach(J => this.handleIncomingEvent(J))
      }
      async setSessionMetadata(J, et) {
        let eo = {
          type: "SetSessionConfig",
          id: (0,
            el.IntNumber)(this.nextReqId++),
          sessionId: this.session.id,
          metadata: {
            [J]: et
          }
        };
        return this.setOnceConnected(async () => {
          let J = await this.makeRequest(eo);
          if ("Fail" === J.type)
            throw Error(J.error || "failed to set session metadata")
        }
        )
      }
      async publishEvent(J, et, eo = !1) {
        let ec = await this.cipher.encrypt(JSON.stringify(Object.assign(Object.assign({}, et), {
          origin: location.origin,
          relaySource: window.coinbaseWalletExtension ? "injected_sdk" : "sdk"
        })))
          , ed = {
            type: "PublishEvent",
            id: (0,
              el.IntNumber)(this.nextReqId++),
            sessionId: this.session.id,
            event: J,
            data: ec,
            callWebhook: eo
          };
        return this.setOnceLinked(async () => {
          let J = await this.makeRequest(ed);
          if ("Fail" === J.type)
            throw Error(J.error || "failed to publish event");
          return J.eventId
        }
        )
      }
      sendData(J) {
        this.ws.sendData(JSON.stringify(J))
      }
      updateLastHeartbeat() {
        this.lastHeartbeatResponse = Date.now()
      }
      heartbeat() {
        if (Date.now() - this.lastHeartbeatResponse > 2e4) {
          this.ws.disconnect();
          return
        }
        try {
          this.ws.sendData("h")
        } catch (J) { }
      }
      async makeRequest(J, et = 6e4) {
        let eo;
        let el = J.id;
        return this.sendData(J),
          Promise.race([new Promise((J, ec) => {
            eo = window.setTimeout(() => {
              ec(Error(`request ${el} timed out`))
            }
              , et)
          }
          ), new Promise(J => {
            this.requestResolutions.set(el, et => {
              clearTimeout(eo),
                J(et),
                this.requestResolutions.delete(el)
            }
            )
          }
          )])
      }
      async authenticate() {
        let J = {
          type: "HostSession",
          id: (0,
            el.IntNumber)(this.nextReqId++),
          sessionId: this.session.id,
          sessionKey: this.session.key
        }
          , et = await this.makeRequest(J);
        if ("Fail" === et.type)
          throw Error(et.error || "failed to authentcate")
      }
      sendIsLinked() {
        let J = {
          type: "IsLinked",
          id: (0,
            el.IntNumber)(this.nextReqId++),
          sessionId: this.session.id
        };
        this.sendData(J)
      }
      sendGetSessionConfig() {
        let J = {
          type: "GetSessionConfig",
          id: (0,
            el.IntNumber)(this.nextReqId++),
          sessionId: this.session.id
        };
        this.sendData(J)
      }
    }
  },
  12389: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.WalletLinkHTTP = void 0,
      et.WalletLinkHTTP = class {
        constructor(J, et, eo) {
          this.linkAPIUrl = J,
            this.sessionId = et;
          let el = `${et}:${eo}`;
          this.auth = `Basic ${btoa(el)}`
        }
        async markUnseenEventsAsSeen(J) {
          return Promise.all(J.map(J => fetch(`${this.linkAPIUrl}/events/${J.eventId}/seen`, {
            method: "POST",
            headers: {
              Authorization: this.auth
            }
          }))).catch(J => console.error("Unabled to mark event as failed:", J))
        }
        async fetchUnseenEvents() {
          var J;
          let et = await fetch(`${this.linkAPIUrl}/events?unseen=true`, {
            headers: {
              Authorization: this.auth
            }
          });
          if (et.ok) {
            let { events: eo, error: el } = await et.json();
            if (el)
              throw Error(`Check unseen events failed: ${el}`);
            let ec = null !== (J = null == eo ? void 0 : eo.filter(J => "Web3Response" === J.event).map(J => ({
              type: "Event",
              sessionId: this.sessionId,
              eventId: J.id,
              event: J.event,
              data: J.data
            }))) && void 0 !== J ? J : [];
            return this.markUnseenEventsAsSeen(ec),
              ec
          }
          throw Error(`Check unseen events failed: ${et.status}`)
        }
      }
  },
  57326: function (J, et) {
    "use strict";
    var eo, el;
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.WalletLinkWebSocket = et.ConnectionState = void 0,
      (el = eo || (et.ConnectionState = eo = {}))[el.DISCONNECTED = 0] = "DISCONNECTED",
      el[el.CONNECTING = 1] = "CONNECTING",
      el[el.CONNECTED = 2] = "CONNECTED",
      et.WalletLinkWebSocket = class {
        setConnectionStateListener(J) {
          this.connectionStateListener = J
        }
        setIncomingDataListener(J) {
          this.incomingDataListener = J
        }
        constructor(J, et = WebSocket) {
          this.WebSocketClass = et,
            this.webSocket = null,
            this.pendingData = [],
            this.url = J.replace(/^http/, "ws")
        }
        async connect() {
          if (this.webSocket)
            throw Error("webSocket object is not null");
          return new Promise((J, et) => {
            var el;
            let ec;
            try {
              this.webSocket = ec = new this.WebSocketClass(this.url)
            } catch (J) {
              et(J);
              return
            }
            null === (el = this.connectionStateListener) || void 0 === el || el.call(this, eo.CONNECTING),
              ec.onclose = J => {
                var el;
                this.clearWebSocket(),
                  et(Error(`websocket error ${J.code}: ${J.reason}`)),
                  null === (el = this.connectionStateListener) || void 0 === el || el.call(this, eo.DISCONNECTED)
              }
              ,
              ec.onopen = et => {
                var el;
                if (J(),
                  null === (el = this.connectionStateListener) || void 0 === el || el.call(this, eo.CONNECTED),
                  this.pendingData.length > 0) {
                  let J = [...this.pendingData];
                  J.forEach(J => this.sendData(J)),
                    this.pendingData = []
                }
              }
              ,
              ec.onmessage = J => {
                var et, eo;
                if ("h" === J.data)
                  null === (et = this.incomingDataListener) || void 0 === et || et.call(this, {
                    type: "Heartbeat"
                  });
                else
                  try {
                    let et = JSON.parse(J.data);
                    null === (eo = this.incomingDataListener) || void 0 === eo || eo.call(this, et)
                  } catch (J) { }
              }
          }
          )
        }
        disconnect() {
          var J;
          let { webSocket: et } = this;
          if (et) {
            this.clearWebSocket(),
              null === (J = this.connectionStateListener) || void 0 === J || J.call(this, eo.DISCONNECTED),
              this.connectionStateListener = void 0,
              this.incomingDataListener = void 0;
            try {
              et.close()
            } catch (J) { }
          }
        }
        sendData(J) {
          let { webSocket: et } = this;
          if (!et) {
            this.pendingData.push(J),
              this.connect();
            return
          }
          et.send(J)
        }
        clearWebSocket() {
          let { webSocket: J } = this;
          J && (this.webSocket = null,
            J.onclose = null,
            J.onerror = null,
            J.onmessage = null,
            J.onopen = null)
        }
      }
  },
  7588: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.isErrorResponse = void 0,
      et.isErrorResponse = function (J) {
        return void 0 !== J.errorMessage
      }
  },
  20462: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.WalletLinkRelayUI = void 0;
    let el = eo(27162)
      , ec = eo(27834)
      , ed = eo(52049);
    et.WalletLinkRelayUI = class {
      constructor(J) {
        this.standalone = null,
          this.attached = !1,
          this.snackbar = new ed.Snackbar({
            darkMode: J.darkMode
          }),
          this.linkFlow = new ec.LinkFlow({
            darkMode: J.darkMode,
            version: J.version,
            sessionId: J.session.id,
            sessionSecret: J.session.secret,
            linkAPIUrl: J.linkAPIUrl,
            isParentConnection: !1
          })
      }
      attach() {
        if (this.attached)
          throw Error("Coinbase Wallet SDK UI is already attached");
        let J = document.documentElement
          , et = document.createElement("div");
        et.className = "-cbwsdk-css-reset",
          J.appendChild(et),
          this.linkFlow.attach(et),
          this.snackbar.attach(et),
          this.attached = !0,
          (0,
            el.injectCssReset)()
      }
      setConnected(J) {
        this.linkFlow.setConnected(J)
      }
      setChainId(J) {
        this.linkFlow.setChainId(J)
      }
      setConnectDisabled(J) {
        this.linkFlow.setConnectDisabled(J)
      }
      addEthereumChain() { }
      watchAsset() { }
      switchEthereumChain() { }
      requestEthereumAccounts(J) {
        this.linkFlow.open({
          onCancel: J.onCancel
        })
      }
      hideRequestEthereumAccounts() {
        this.linkFlow.close()
      }
      signEthereumMessage() { }
      signEthereumTransaction() { }
      submitEthereumTransaction() { }
      ethereumAddressFromSignedMessage() { }
      showConnecting(J) {
        let et;
        return et = J.isUnlinkedErrorState ? {
          autoExpand: !0,
          message: "Connection lost",
          menuItems: [{
            isRed: !1,
            info: "Reset connection",
            svgWidth: "10",
            svgHeight: "11",
            path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
            defaultFillRule: "evenodd",
            defaultClipRule: "evenodd",
            onClick: J.onResetConnection
          }]
        } : {
          message: "Confirm on phone",
          menuItems: [{
            isRed: !0,
            info: "Cancel transaction",
            svgWidth: "11",
            svgHeight: "11",
            path: "M10.3711 1.52346L9.21775 0.370117L5.37109 4.21022L1.52444 0.370117L0.371094 1.52346L4.2112 5.37012L0.371094 9.21677L1.52444 10.3701L5.37109 6.53001L9.21775 10.3701L10.3711 9.21677L6.53099 5.37012L10.3711 1.52346Z",
            defaultFillRule: "inherit",
            defaultClipRule: "inherit",
            onClick: J.onCancel
          }, {
            isRed: !1,
            info: "Reset connection",
            svgWidth: "10",
            svgHeight: "11",
            path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
            defaultFillRule: "evenodd",
            defaultClipRule: "evenodd",
            onClick: J.onResetConnection
          }]
        },
          this.snackbar.presentItem(et)
      }
      reloadUI() {
        document.location.reload()
      }
      inlineAccountsResponse() {
        return !1
      }
      inlineAddEthereumChain() {
        return !1
      }
      inlineWatchAsset() {
        return !1
      }
      inlineSwitchEthereumChain() {
        return !1
      }
      setStandalone(J) {
        this.standalone = J
      }
      isStandalone() {
        var J;
        return null !== (J = this.standalone) && void 0 !== J && J
      }
    }
  },
  55490: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.default = ".-cbwsdk-css-reset .-cbwsdk-connect-content{height:430px;width:700px;border-radius:12px;padding:30px}.-cbwsdk-css-reset .-cbwsdk-connect-content.light{background:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content.dark{background:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-header{display:flex;align-items:center;justify-content:space-between;margin:0 0 30px}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading{font-style:normal;font-weight:500;font-size:28px;line-height:36px;margin:0}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-layout{display:flex;flex-direction:row}.-cbwsdk-css-reset .-cbwsdk-connect-content-column-left{margin-right:30px;display:flex;flex-direction:column;justify-content:space-between}.-cbwsdk-css-reset .-cbwsdk-connect-content-column-right{flex:25%;margin-right:34px}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-wrapper{width:220px;height:220px;border-radius:12px;display:flex;justify-content:center;align-items:center;background:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting{position:absolute;top:0;bottom:0;left:0;right:0;display:flex;flex-direction:column;align-items:center;justify-content:center}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.light{background-color:rgba(255,255,255,.95)}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.light>p{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.dark{background-color:rgba(10,11,13,.9)}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.dark>p{color:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting>p{font-size:12px;font-weight:bold;margin-top:16px}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app{border-radius:8px;font-size:14px;line-height:20px;padding:12px;width:339px}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app.light{background:#eef0f3;color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app.dark{background:#1e2025;color:#8a919e}.-cbwsdk-css-reset .-cbwsdk-cancel-button{-webkit-appearance:none;border:none;background:none;cursor:pointer;padding:0;margin:0}.-cbwsdk-css-reset .-cbwsdk-cancel-button-x{position:relative;display:block;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-wallet-steps{padding:0 0 0 16px;margin:0;width:100%;list-style:decimal}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item{list-style-type:decimal;display:list-item;font-style:normal;font-weight:400;font-size:16px;line-height:24px;margin-top:20px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item-wrapper{display:flex;align-items:center}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-pad-left{margin-left:6px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon{display:flex;border-radius:50%;height:24px;width:24px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon svg{margin:auto;display:block}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon.light{background:#0052ff}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon.dark{background:#588af5}.-cbwsdk-css-reset .-cbwsdk-connect-item{align-items:center;display:flex;flex-direction:row;padding:16px 24px;gap:12px;cursor:pointer;border-radius:100px;font-weight:600}.-cbwsdk-css-reset .-cbwsdk-connect-item.light{background:#f5f8ff;color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-connect-item.dark{background:#001033;color:#588af5}.-cbwsdk-css-reset .-cbwsdk-connect-item-copy-wrapper{margin:0 4px 0 8px}.-cbwsdk-css-reset .-cbwsdk-connect-item-title{margin:0 0 0;font-size:16px;line-height:24px;font-weight:500}.-cbwsdk-css-reset .-cbwsdk-connect-item-description{font-weight:400;font-size:14px;line-height:20px;margin:0}"
  },
  15898: function (J, et, eo) {
    "use strict";
    var el = this && this.__importDefault || function (J) {
      return J && J.__esModule ? J : {
        default: J
      }
    }
      ;
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.CoinbaseWalletSteps = et.ConnectContent = void 0;
    let ec = el(eo(86010))
      , ed = eo(74052)
      , eh = eo(32072)
      , ep = eo(43604)
      , ef = eo(50408)
      , em = eo(70578)
      , eg = eo(59309)
      , ey = eo(81508)
      , eb = eo(2620)
      , ew = el(eo(55490))
      , e_ = {
        title: "Coinbase Wallet app",
        description: "Connect with your self-custody wallet",
        steps: CoinbaseWalletSteps
      }
      , makeIconColor = J => "light" === J ? "#FFFFFF" : "#0A0B0D";
    function ConnectItem({ title: J, description: et, theme: eo }) {
      return (0,
        ed.h)("div", {
          className: (0,
            ec.default)("-cbwsdk-connect-item", eo)
        }, (0,
          ed.h)("div", null, (0,
            ed.h)(em.CoinbaseWalletRound, null)), (0,
              ed.h)("div", {
                className: "-cbwsdk-connect-item-copy-wrapper"
              }, (0,
                ed.h)("h3", {
                  className: "-cbwsdk-connect-item-title"
                }, J), (0,
                  ed.h)("p", {
                    className: "-cbwsdk-connect-item-description"
                  }, et)))
    }
    function CoinbaseWalletSteps({ theme: J }) {
      return (0,
        ed.h)("ol", {
          className: "-cbwsdk-wallet-steps"
        }, (0,
          ed.h)("li", {
            className: (0,
              ec.default)("-cbwsdk-wallet-steps-item", J)
          }, (0,
            ed.h)("div", {
              className: "-cbwsdk-wallet-steps-item-wrapper"
            }, "Open Coinbase Wallet app")), (0,
              ed.h)("li", {
                className: (0,
                  ec.default)("-cbwsdk-wallet-steps-item", J)
              }, (0,
                ed.h)("div", {
                  className: "-cbwsdk-wallet-steps-item-wrapper"
                }, (0,
                  ed.h)("span", null, "Tap ", (0,
                    ed.h)("strong", null, "Scan"), " "), (0,
                      ed.h)("span", {
                        className: (0,
                          ec.default)("-cbwsdk-wallet-steps-pad-left", "-cbwsdk-wallet-steps-icon", J)
                      }, (0,
                        ed.h)(eg.QRCodeIcon, {
                          fill: makeIconColor(J)
                        })))))
    }
    et.ConnectContent = function (J) {
      let { theme: et } = J
        , eo = (0,
          eh.createQrUrl)(J.sessionId, J.sessionSecret, J.linkAPIUrl, J.isParentConnection, J.version, J.chainId)
        , el = e_.steps;
      return (0,
        ed.h)("div", {
          "data-testid": "connect-content",
          className: (0,
            ec.default)("-cbwsdk-connect-content", et)
        }, (0,
          ed.h)("style", null, ew.default), (0,
            ed.h)("div", {
              className: "-cbwsdk-connect-content-header"
            }, (0,
              ed.h)("h2", {
                className: (0,
                  ec.default)("-cbwsdk-connect-content-heading", et)
              }, "Scan to connect with our mobile app"), J.onCancel && (0,
                ed.h)("button", {
                  type: "button",
                  className: "-cbwsdk-cancel-button",
                  onClick: J.onCancel
                }, (0,
                  ed.h)(ef.CloseIcon, {
                    fill: "light" === et ? "#0A0B0D" : "#FFFFFF"
                  }))), (0,
                    ed.h)("div", {
                      className: "-cbwsdk-connect-content-layout"
                    }, (0,
                      ed.h)("div", {
                        className: "-cbwsdk-connect-content-column-left"
                      }, (0,
                        ed.h)(ConnectItem, {
                          title: e_.title,
                          description: e_.description,
                          theme: et
                        })), (0,
                          ed.h)("div", {
                            className: "-cbwsdk-connect-content-column-right"
                          }, (0,
                            ed.h)("div", {
                              className: "-cbwsdk-connect-content-qr-wrapper"
                            }, (0,
                              ed.h)(ey.QRCode, {
                                content: eo,
                                width: 200,
                                height: 200,
                                fgColor: "#000",
                                bgColor: "transparent"
                              }), (0,
                                ed.h)("input", {
                                  type: "hidden",
                                  name: "cbw-cbwsdk-version",
                                  value: ep.LIB_VERSION
                                }), (0,
                                  ed.h)("input", {
                                    type: "hidden",
                                    value: eo
                                  })), (0,
                                    ed.h)(el, {
                                      theme: et
                                    }), !J.isConnected && (0,
                                      ed.h)("div", {
                                        "data-testid": "connecting-spinner",
                                        className: (0,
                                          ec.default)("-cbwsdk-connect-content-qr-connecting", et)
                                      }, (0,
                                        ed.h)(eb.Spinner, {
                                          size: 36,
                                          color: "dark" === et ? "#FFF" : "#000"
                                        }), (0,
                                          ed.h)("p", null, "Connecting...")))))
    }
      ,
      et.CoinbaseWalletSteps = CoinbaseWalletSteps
  },
  28171: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.default = ".-cbwsdk-css-reset .-cbwsdk-connect-dialog{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;transition:opacity .25s}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop.light{background-color:rgba(0,0,0,.5)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop.dark{background-color:rgba(50,53,61,.4)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop-hidden{opacity:0}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-box{display:flex;position:relative;flex-direction:column;transform:scale(1);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-box-hidden{opacity:0;transform:scale(0.85)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-container{display:block}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-container-hidden{display:none}"
  },
  5670: function (J, et, eo) {
    "use strict";
    var el = this && this.__importDefault || function (J) {
      return J && J.__esModule ? J : {
        default: J
      }
    }
      ;
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.ConnectDialog = void 0;
    let ec = el(eo(86010))
      , ed = eo(74052)
      , eh = eo(54971)
      , ep = eo(15898)
      , ef = eo(19719)
      , em = el(eo(28171));
    et.ConnectDialog = J => {
      let { isOpen: et, darkMode: eo } = J
        , [el, eg] = (0,
          eh.useState)(!et)
        , [ey, eb] = (0,
          eh.useState)(!et);
      (0,
        eh.useEffect)(() => {
          let J = [window.setTimeout(() => {
            eb(!et)
          }
            , 10)];
          return et ? eg(!1) : J.push(window.setTimeout(() => {
            eg(!0)
          }
            , 360)),
            () => {
              J.forEach(window.clearTimeout)
            }
        }
          , [et]);
      let ew = eo ? "dark" : "light";
      return (0,
        ed.h)("div", {
          class: (0,
            ec.default)("-cbwsdk-connect-dialog-container", el && "-cbwsdk-connect-dialog-container-hidden")
        }, (0,
          ed.h)("style", null, em.default), (0,
            ed.h)("div", {
              class: (0,
                ec.default)("-cbwsdk-connect-dialog-backdrop", ew, ey && "-cbwsdk-connect-dialog-backdrop-hidden")
            }), (0,
              ed.h)("div", {
                class: "-cbwsdk-connect-dialog"
              }, (0,
                ed.h)("div", {
                  class: (0,
                    ec.default)("-cbwsdk-connect-dialog-box", ey && "-cbwsdk-connect-dialog-box-hidden")
                }, J.connectDisabled ? null : (0,
                  ed.h)(ep.ConnectContent, {
                    theme: ew,
                    version: J.version,
                    sessionId: J.sessionId,
                    sessionSecret: J.sessionSecret,
                    linkAPIUrl: J.linkAPIUrl,
                    isConnected: J.isConnected,
                    isParentConnection: J.isParentConnection,
                    chainId: J.chainId,
                    onCancel: J.onCancel
                  }), (0,
                    ed.h)(ef.TryExtensionContent, {
                      theme: ew
                    }))))
    }
  },
  27834: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.LinkFlow = void 0;
    let el = eo(74052)
      , ec = eo(5670);
    et.LinkFlow = class {
      constructor(J) {
        this.connected = !1,
          this.chainId = 1,
          this.isOpen = !1,
          this.onCancel = null,
          this.root = null,
          this.connectDisabled = !1,
          this.darkMode = J.darkMode,
          this.version = J.version,
          this.sessionId = J.sessionId,
          this.sessionSecret = J.sessionSecret,
          this.linkAPIUrl = J.linkAPIUrl,
          this.isParentConnection = J.isParentConnection
      }
      attach(J) {
        this.root = document.createElement("div"),
          this.root.className = "-cbwsdk-link-flow-root",
          J.appendChild(this.root),
          this.render()
      }
      setConnected(J) {
        this.connected !== J && (this.connected = J,
          this.render())
      }
      setChainId(J) {
        this.chainId !== J && (this.chainId = J,
          this.render())
      }
      detach() {
        var J;
        this.root && ((0,
          el.render)(null, this.root),
          null === (J = this.root.parentElement) || void 0 === J || J.removeChild(this.root))
      }
      setConnectDisabled(J) {
        this.connectDisabled = J
      }
      open(J) {
        this.isOpen = !0,
          this.onCancel = J.onCancel,
          this.render()
      }
      close() {
        this.isOpen = !1,
          this.onCancel = null,
          this.render()
      }
      render() {
        this.root && (0,
          el.render)((0,
            el.h)(ec.ConnectDialog, {
              darkMode: this.darkMode,
              version: this.version,
              sessionId: this.sessionId,
              sessionSecret: this.sessionSecret,
              linkAPIUrl: this.linkAPIUrl,
              isOpen: this.isOpen,
              isConnected: this.connected,
              isParentConnection: this.isParentConnection,
              chainId: this.chainId,
              onCancel: this.onCancel,
              connectDisabled: this.connectDisabled
            }), this.root)
      }
    }
  },
  81508: function (J, et, eo) {
    "use strict";
    var el = eo(48764).Buffer
      , ec = this && this.__importDefault || function (J) {
        return J && J.__esModule ? J : {
          default: J
        }
      }
      ;
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.QRCode = void 0;
    let ed = eo(74052)
      , eh = eo(54971)
      , ep = ec(eo(7713));
    et.QRCode = J => {
      let [et, eo] = (0,
        eh.useState)("");
      return (0,
        eh.useEffect)(() => {
          var et, ec;
          let ed = new ep.default({
            content: J.content,
            background: J.bgColor || "#ffffff",
            color: J.fgColor || "#000000",
            container: "svg",
            ecl: "M",
            width: null !== (et = J.width) && void 0 !== et ? et : 256,
            height: null !== (ec = J.height) && void 0 !== ec ? ec : 256,
            padding: 0,
            image: J.image
          })
            , eh = el.from(ed.svg(), "utf8").toString("base64");
          eo(`data:image/svg+xml;base64,${eh}`)
        }
          , [J.bgColor, J.content, J.fgColor, J.height, J.image, J.width]),
        et ? (0,
          ed.h)("img", {
            src: et,
            alt: "QR Code"
          }) : null
    }
  },
  73714: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.default = ".-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop{position:fixed;top:0;left:0;right:0;bottom:0;transition:opacity .25s;background-color:rgba(10,11,13,.5)}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop-hidden{opacity:0}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box{display:block;position:fixed;top:50%;left:50%;transform:translate(-50%, -50%);padding:20px;border-radius:8px;background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box p{display:block;font-weight:400;font-size:14px;line-height:20px;padding-bottom:12px;color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box button{appearance:none;border:none;background:none;color:#0052ff;padding:0;text-decoration:none;display:block;font-weight:600;font-size:16px;line-height:24px}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark{background-color:#0a0b0d;color:#fff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark button{color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light{background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light button{color:#0052ff}"
  },
  8592: function (J, et, eo) {
    "use strict";
    var el = this && this.__importDefault || function (J) {
      return J && J.__esModule ? J : {
        default: J
      }
    }
      ;
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.RedirectDialog = void 0;
    let ec = el(eo(86010))
      , ed = eo(74052)
      , eh = eo(27162)
      , ep = eo(25767)
      , ef = el(eo(73714));
    et.RedirectDialog = class {
      constructor() {
        this.root = null
      }
      attach() {
        let J = document.documentElement;
        this.root = document.createElement("div"),
          this.root.className = "-cbwsdk-css-reset",
          J.appendChild(this.root),
          (0,
            eh.injectCssReset)()
      }
      present(J) {
        this.render(J)
      }
      clear() {
        this.render(null)
      }
      render(J) {
        this.root && ((0,
          ed.render)(null, this.root),
          J && (0,
            ed.render)((0,
              ed.h)(RedirectDialogContent, Object.assign({}, J, {
                onDismiss: () => {
                  this.clear()
                }
              })), this.root))
      }
    }
      ;
    let RedirectDialogContent = ({ title: J, buttonText: et, darkMode: eo, onButtonClick: el, onDismiss: eh }) => (0,
      ed.h)(ep.SnackbarContainer, {
        darkMode: eo
      }, (0,
        ed.h)("div", {
          class: "-cbwsdk-redirect-dialog"
        }, (0,
          ed.h)("style", null, ef.default), (0,
            ed.h)("div", {
              class: "-cbwsdk-redirect-dialog-backdrop",
              onClick: eh
            }), (0,
              ed.h)("div", {
                class: (0,
                  ec.default)("-cbwsdk-redirect-dialog-box", eo ? "dark" : "light")
              }, (0,
                ed.h)("p", null, J), (0,
                  ed.h)("button", {
                    onClick: el
                  }, et))))
  },
  43879: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.default = ".-cbwsdk-css-reset .-gear-container{margin-left:16px !important;margin-right:9px !important;display:flex;align-items:center;justify-content:center;width:24px;height:24px;transition:opacity .25s}.-cbwsdk-css-reset .-gear-container *{user-select:none}.-cbwsdk-css-reset .-gear-container svg{opacity:0;position:absolute}.-cbwsdk-css-reset .-gear-icon{height:12px;width:12px;z-index:10000}.-cbwsdk-css-reset .-cbwsdk-snackbar{align-items:flex-end;display:flex;flex-direction:column;position:fixed;right:0;top:0;z-index:2147483647}.-cbwsdk-css-reset .-cbwsdk-snackbar *{user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance{display:flex;flex-direction:column;margin:8px 16px 0 16px;overflow:visible;text-align:left;transform:translateX(0);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header:hover .-gear-container svg{opacity:1}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header{display:flex;align-items:center;background:#fff;overflow:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-cblogo{margin:8px 8px 8px 8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-message{color:#000;font-size:13px;line-height:1.5;user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu{background:#fff;transition:opacity .25s ease-in-out,transform .25s linear,visibility 0s;visibility:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;opacity:0;flex-direction:column;padding-left:8px;padding-right:8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:last-child{margin-bottom:8px !important}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover{background:#f5f7f8;border-radius:6px;transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover span{color:#050f19;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover svg path{fill:#000;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item{visibility:inherit;height:35px;margin-top:8px;margin-bottom:0;display:flex;flex-direction:row;align-items:center;padding:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item *{visibility:inherit;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover{background:rgba(223,95,103,.2);transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover svg path{fill:#df5f67;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover span{color:#df5f67;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-info{color:#aaa;font-size:13px;margin:0 8px 0 32px;position:absolute}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-hidden{opacity:0;text-align:left;transform:translateX(25%);transition:opacity .5s linear}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-expanded .-cbwsdk-snackbar-instance-menu{opacity:1;display:flex;transform:translateY(8px);visibility:visible}"
  },
  52049: function (J, et, eo) {
    "use strict";
    var el = this && this.__importDefault || function (J) {
      return J && J.__esModule ? J : {
        default: J
      }
    }
      ;
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.SnackbarInstance = et.SnackbarContainer = et.Snackbar = void 0;
    let ec = el(eo(86010))
      , ed = eo(74052)
      , eh = eo(54971)
      , ep = el(eo(43879));
    et.Snackbar = class {
      constructor(J) {
        this.items = new Map,
          this.nextItemKey = 0,
          this.root = null,
          this.darkMode = J.darkMode
      }
      attach(J) {
        this.root = document.createElement("div"),
          this.root.className = "-cbwsdk-snackbar-root",
          J.appendChild(this.root),
          this.render()
      }
      presentItem(J) {
        let et = this.nextItemKey++;
        return this.items.set(et, J),
          this.render(),
          () => {
            this.items.delete(et),
              this.render()
          }
      }
      clear() {
        this.items.clear(),
          this.render()
      }
      render() {
        this.root && (0,
          ed.render)((0,
            ed.h)("div", null, (0,
              ed.h)(et.SnackbarContainer, {
                darkMode: this.darkMode
              }, Array.from(this.items.entries()).map(([J, eo]) => (0,
                ed.h)(et.SnackbarInstance, Object.assign({}, eo, {
                  key: J
                }))))), this.root)
      }
    }
      ,
      et.SnackbarContainer = J => (0,
        ed.h)("div", {
          class: (0,
            ec.default)("-cbwsdk-snackbar-container")
        }, (0,
          ed.h)("style", null, ep.default), (0,
            ed.h)("div", {
              class: "-cbwsdk-snackbar"
            }, J.children)),
      et.SnackbarInstance = ({ autoExpand: J, message: et, menuItems: eo }) => {
        let [el, ep] = (0,
          eh.useState)(!0)
          , [ef, em] = (0,
            eh.useState)(null != J && J);
        return (0,
          eh.useEffect)(() => {
            let J = [window.setTimeout(() => {
              ep(!1)
            }
              , 1), window.setTimeout(() => {
                em(!0)
              }
                , 1e4)];
            return () => {
              J.forEach(window.clearTimeout)
            }
          }
          ),
          (0,
            ed.h)("div", {
              class: (0,
                ec.default)("-cbwsdk-snackbar-instance", el && "-cbwsdk-snackbar-instance-hidden", ef && "-cbwsdk-snackbar-instance-expanded")
            }, (0,
              ed.h)("div", {
                class: "-cbwsdk-snackbar-instance-header",
                onClick: () => {
                  em(!ef)
                }
              }, (0,
                ed.h)("img", {
                  src: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEuNDkyIDEwLjQxOWE4LjkzIDguOTMgMCAwMTguOTMtOC45M2gxMS4xNjNhOC45MyA4LjkzIDAgMDE4LjkzIDguOTN2MTEuMTYzYTguOTMgOC45MyAwIDAxLTguOTMgOC45M0gxMC40MjJhOC45MyA4LjkzIDAgMDEtOC45My04LjkzVjEwLjQxOXoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEwLjQxOSAwSDIxLjU4QzI3LjMzNSAwIDMyIDQuNjY1IDMyIDEwLjQxOVYyMS41OEMzMiAyNy4zMzUgMjcuMzM1IDMyIDIxLjU4MSAzMkgxMC40MkM0LjY2NSAzMiAwIDI3LjMzNSAwIDIxLjU4MVYxMC40MkMwIDQuNjY1IDQuNjY1IDAgMTAuNDE5IDB6bTAgMS40ODhhOC45MyA4LjkzIDAgMDAtOC45MyA4LjkzdjExLjE2M2E4LjkzIDguOTMgMCAwMDguOTMgOC45M0gyMS41OGE4LjkzIDguOTMgMCAwMDguOTMtOC45M1YxMC40MmE4LjkzIDguOTMgMCAwMC04LjkzLTguOTNIMTAuNDJ6IiBmaWxsPSIjZmZmIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNS45OTggMjYuMDQ5Yy01LjU0OSAwLTEwLjA0Ny00LjQ5OC0xMC4wNDctMTAuMDQ3IDAtNS41NDggNC40OTgtMTAuMDQ2IDEwLjA0Ny0xMC4wNDYgNS41NDggMCAxMC4wNDYgNC40OTggMTAuMDQ2IDEwLjA0NiAwIDUuNTQ5LTQuNDk4IDEwLjA0Ny0xMC4wNDYgMTAuMDQ3eiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xMi43NjIgMTQuMjU0YzAtLjgyMi42NjctMS40ODkgMS40ODktMS40ODloMy40OTdjLjgyMiAwIDEuNDg4LjY2NiAxLjQ4OCAxLjQ4OXYzLjQ5N2MwIC44MjItLjY2NiAxLjQ4OC0xLjQ4OCAxLjQ4OGgtMy40OTdhMS40ODggMS40ODggMCAwMS0xLjQ4OS0xLjQ4OHYtMy40OTh6IiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+",
                  class: "-cbwsdk-snackbar-instance-header-cblogo"
                }), " ", (0,
                  ed.h)("div", {
                    class: "-cbwsdk-snackbar-instance-header-message"
                  }, et), (0,
                    ed.h)("div", {
                      class: "-gear-container"
                    }, !ef && (0,
                      ed.h)("svg", {
                        width: "24",
                        height: "24",
                        viewBox: "0 0 24 24",
                        fill: "none",
                        xmlns: "http://www.w3.org/2000/svg"
                      }, (0,
                        ed.h)("circle", {
                          cx: "12",
                          cy: "12",
                          r: "12",
                          fill: "#F5F7F8"
                        })), (0,
                          ed.h)("img", {
                            src: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDYuNzV2LTEuNWwtMS43Mi0uNTdjLS4wOC0uMjctLjE5LS41Mi0uMzItLjc3bC44MS0xLjYyLTEuMDYtMS4wNi0xLjYyLjgxYy0uMjQtLjEzLS41LS4yNC0uNzctLjMyTDYuNzUgMGgtMS41bC0uNTcgMS43MmMtLjI3LjA4LS41My4xOS0uNzcuMzJsLTEuNjItLjgxLTEuMDYgMS4wNi44MSAxLjYyYy0uMTMuMjQtLjI0LjUtLjMyLjc3TDAgNS4yNXYxLjVsMS43Mi41N2MuMDguMjcuMTkuNTMuMzIuNzdsLS44MSAxLjYyIDEuMDYgMS4wNiAxLjYyLS44MWMuMjQuMTMuNS4yMy43Ny4zMkw1LjI1IDEyaDEuNWwuNTctMS43MmMuMjctLjA4LjUyLS4xOS43Ny0uMzJsMS42Mi44MSAxLjA2LTEuMDYtLjgxLTEuNjJjLjEzLS4yNC4yMy0uNS4zMi0uNzdMMTIgNi43NXpNNiA4LjVhMi41IDIuNSAwIDAxMC01IDIuNSAyLjUgMCAwMTAgNXoiIGZpbGw9IiMwNTBGMTkiLz48L3N2Zz4=",
                            class: "-gear-icon",
                            title: "Expand"
                          }))), eo && eo.length > 0 && (0,
                            ed.h)("div", {
                              class: "-cbwsdk-snackbar-instance-menu"
                            }, eo.map((J, et) => (0,
                              ed.h)("div", {
                                class: (0,
                                  ec.default)("-cbwsdk-snackbar-instance-menu-item", J.isRed && "-cbwsdk-snackbar-instance-menu-item-is-red"),
                                onClick: J.onClick,
                                key: et
                              }, (0,
                                ed.h)("svg", {
                                  width: J.svgWidth,
                                  height: J.svgHeight,
                                  viewBox: "0 0 10 11",
                                  fill: "none",
                                  xmlns: "http://www.w3.org/2000/svg"
                                }, (0,
                                  ed.h)("path", {
                                    "fill-rule": J.defaultFillRule,
                                    "clip-rule": J.defaultClipRule,
                                    d: J.path,
                                    fill: "#AAAAAA"
                                  })), (0,
                                    ed.h)("span", {
                                      class: (0,
                                        ec.default)("-cbwsdk-snackbar-instance-menu-item-info", J.isRed && "-cbwsdk-snackbar-instance-menu-item-info-is-red")
                                    }, J.info)))))
      }
  },
  25767: function (J, et, eo) {
    "use strict";
    var el = this && this.__createBinding || (Object.create ? function (J, et, eo, el) {
      void 0 === el && (el = eo);
      var ec = Object.getOwnPropertyDescriptor(et, eo);
      (!ec || ("get" in ec ? !et.__esModule : ec.writable || ec.configurable)) && (ec = {
        enumerable: !0,
        get: function () {
          return et[eo]
        }
      }),
        Object.defineProperty(J, el, ec)
    }
      : function (J, et, eo, el) {
        void 0 === el && (el = eo),
          J[el] = et[eo]
      }
    )
      , ec = this && this.__exportStar || function (J, et) {
        for (var eo in J)
          "default" === eo || Object.prototype.hasOwnProperty.call(et, eo) || el(et, J, eo)
      }
      ;
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      ec(eo(52049), et)
  },
  53156: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.default = ".-cbwsdk-css-reset .-cbwsdk-spinner{display:inline-block}.-cbwsdk-css-reset .-cbwsdk-spinner svg{display:inline-block;animation:2s linear infinite -cbwsdk-spinner-svg}.-cbwsdk-css-reset .-cbwsdk-spinner svg circle{animation:1.9s ease-in-out infinite both -cbwsdk-spinner-circle;display:block;fill:rgba(0,0,0,0);stroke-dasharray:283;stroke-dashoffset:280;stroke-linecap:round;stroke-width:10px;transform-origin:50% 50%}@keyframes -cbwsdk-spinner-svg{0%{transform:rotateZ(0deg)}100%{transform:rotateZ(360deg)}}@keyframes -cbwsdk-spinner-circle{0%,25%{stroke-dashoffset:280;transform:rotate(0)}50%,75%{stroke-dashoffset:75;transform:rotate(45deg)}100%{stroke-dashoffset:280;transform:rotate(360deg)}}"
  },
  2620: function (J, et, eo) {
    "use strict";
    var el = this && this.__importDefault || function (J) {
      return J && J.__esModule ? J : {
        default: J
      }
    }
      ;
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.Spinner = void 0;
    let ec = eo(74052)
      , ed = el(eo(53156));
    et.Spinner = J => {
      var et;
      let eo = null !== (et = J.size) && void 0 !== et ? et : 64
        , el = J.color || "#000";
      return (0,
        ec.h)("div", {
          class: "-cbwsdk-spinner"
        }, (0,
          ec.h)("style", null, ed.default), (0,
            ec.h)("svg", {
              viewBox: "0 0 100 100",
              xmlns: "http://www.w3.org/2000/svg",
              style: {
                width: eo,
                height: eo
              }
            }, (0,
              ec.h)("circle", {
                style: {
                  cx: 50,
                  cy: 50,
                  r: 45,
                  stroke: el
                }
              })))
    }
  },
  20096: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.default = ".-cbwsdk-css-reset .-cbwsdk-try-extension{display:flex;margin-top:12px;height:202px;width:700px;border-radius:12px;padding:30px}.-cbwsdk-css-reset .-cbwsdk-try-extension.light{background:#fff}.-cbwsdk-css-reset .-cbwsdk-try-extension.dark{background:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-try-extension-column-half{flex:50%}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading{font-style:normal;font-weight:500;font-size:25px;line-height:32px;margin:0;max-width:204px}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta{appearance:none;border:none;background:none;color:#0052ff;cursor:pointer;padding:0;text-decoration:none;display:block;font-weight:600;font-size:16px;line-height:24px}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta.light{color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta.dark{color:#588af5}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta-wrapper{display:flex;align-items:center;margin-top:12px}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta-icon{display:block;margin-left:4px;height:14px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list{display:flex;flex-direction:column;justify-content:center;align-items:center;margin:0;padding:0;list-style:none;height:100%}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item{display:flex;align-items:center;flex-flow:nowrap;margin-top:24px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item:first-of-type{margin-top:0}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon-wrapper{display:block}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon{display:flex;height:32px;width:32px;border-radius:50%}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon svg{margin:auto;display:block}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon.light{background:#eef0f3}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon.dark{background:#1e2025}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy{display:block;font-weight:400;font-size:14px;line-height:20px;padding-left:12px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy.light{color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy.dark{color:#8a919e}"
  },
  19719: function (J, et, eo) {
    "use strict";
    var el = this && this.__importDefault || function (J) {
      return J && J.__esModule ? J : {
        default: J
      }
    }
      ;
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.TryExtensionContent = void 0;
    let ec = el(eo(86010))
      , ed = eo(74052)
      , eh = eo(54971)
      , ep = eo(70865)
      , ef = eo(539)
      , em = eo(4841)
      , eg = el(eo(20096));
    et.TryExtensionContent = function ({ theme: J }) {
      let [et, eo] = (0,
        eh.useState)(!1)
        , el = (0,
          eh.useCallback)(() => {
            window.open("https://api.wallet.coinbase.com/rpc/v2/desktop/chrome", "_blank")
          }
            , [])
        , ey = (0,
          eh.useCallback)(() => {
            et ? window.location.reload() : (el(),
              eo(!0))
          }
            , [el, et]);
      return (0,
        ed.h)("div", {
          class: (0,
            ec.default)("-cbwsdk-try-extension", J)
        }, (0,
          ed.h)("style", null, eg.default), (0,
            ed.h)("div", {
              class: "-cbwsdk-try-extension-column-half"
            }, (0,
              ed.h)("h3", {
                class: (0,
                  ec.default)("-cbwsdk-try-extension-heading", J)
              }, "Or try the Coinbase Wallet browser extension"), (0,
                ed.h)("div", {
                  class: "-cbwsdk-try-extension-cta-wrapper"
                }, (0,
                  ed.h)("button", {
                    class: (0,
                      ec.default)("-cbwsdk-try-extension-cta", J),
                    onClick: ey
                  }, et ? "Refresh" : "Install"), (0,
                    ed.h)("div", null, !et && (0,
                      ed.h)(ep.ArrowLeftIcon, {
                        class: "-cbwsdk-try-extension-cta-icon",
                        fill: "light" === J ? "#0052FF" : "#588AF5"
                      })))), (0,
                        ed.h)("div", {
                          class: "-cbwsdk-try-extension-column-half"
                        }, (0,
                          ed.h)("ul", {
                            class: "-cbwsdk-try-extension-list"
                          }, (0,
                            ed.h)("li", {
                              class: "-cbwsdk-try-extension-list-item"
                            }, (0,
                              ed.h)("div", {
                                class: "-cbwsdk-try-extension-list-item-icon-wrapper"
                              }, (0,
                                ed.h)("span", {
                                  class: (0,
                                    ec.default)("-cbwsdk-try-extension-list-item-icon", J)
                                }, (0,
                                  ed.h)(ef.LaptopIcon, {
                                    fill: "light" === J ? "#0A0B0D" : "#FFFFFF"
                                  }))), (0,
                                    ed.h)("div", {
                                      class: (0,
                                        ec.default)("-cbwsdk-try-extension-list-item-copy", J)
                                    }, "Connect with dapps with just one click on your desktop browser")), (0,
                                      ed.h)("li", {
                                        class: "-cbwsdk-try-extension-list-item"
                                      }, (0,
                                        ed.h)("div", {
                                          class: "-cbwsdk-try-extension-list-item-icon-wrapper"
                                        }, (0,
                                          ed.h)("span", {
                                            class: (0,
                                              ec.default)("-cbwsdk-try-extension-list-item-icon", J)
                                          }, (0,
                                            ed.h)(em.SafeIcon, {
                                              fill: "light" === J ? "#0A0B0D" : "#FFFFFF"
                                            }))), (0,
                                              ed.h)("div", {
                                                class: (0,
                                                  ec.default)("-cbwsdk-try-extension-list-item-copy", J)
                                              }, "Add an additional layer of security by using a supported Ledger hardware wallet")))))
    }
  },
  70865: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.ArrowLeftIcon = void 0;
    let el = eo(74052);
    et.ArrowLeftIcon = function (J) {
      return (0,
        el.h)("svg", Object.assign({
          width: "16",
          height: "16",
          viewBox: "0 0 16 16",
          xmlns: "http://www.w3.org/2000/svg"
        }, J), (0,
          el.h)("path", {
            d: "M8.60675 0.155884L7.37816 1.28209L12.7723 7.16662H0V8.83328H12.6548L6.82149 14.6666L8 15.8451L15.8201 8.02501L8.60675 0.155884Z"
          }))
    }
  },
  50408: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.CloseIcon = void 0;
    let el = eo(74052);
    et.CloseIcon = function (J) {
      return (0,
        el.h)("svg", Object.assign({
          width: "40",
          height: "40",
          viewBox: "0 0 40 40",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg"
        }, J), (0,
          el.h)("path", {
            d: "M13.7677 13L12.3535 14.4142L18.3535 20.4142L12.3535 26.4142L13.7677 27.8284L19.7677 21.8284L25.7677 27.8284L27.1819 26.4142L21.1819 20.4142L27.1819 14.4142L25.7677 13L19.7677 19L13.7677 13Z"
          }))
    }
  },
  70578: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.CoinbaseWalletRound = void 0;
    let el = eo(74052);
    et.CoinbaseWalletRound = function (J) {
      return (0,
        el.h)("svg", Object.assign({
          width: "28",
          height: "28",
          viewBox: "0 0 28 28",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg"
        }, J), (0,
          el.h)("circle", {
            cx: "14",
            cy: "14",
            r: "14",
            fill: "#0052FF"
          }), (0,
            el.h)("path", {
              d: "M23.8521 14.0003C23.8521 19.455 19.455 23.8521 14.0003 23.8521C8.54559 23.8521 4.14844 19.455 4.14844 14.0003C4.14844 8.54559 8.54559 4.14844 14.0003 4.14844C19.455 4.14844 23.8521 8.54559 23.8521 14.0003Z",
              fill: "white"
            }), (0,
              el.h)("path", {
                d: "M11.1855 12.5042C11.1855 12.0477 11.1855 11.7942 11.2835 11.642C11.3814 11.4899 11.4793 11.3377 11.6261 11.287C11.8219 11.1855 12.0178 11.1855 12.5073 11.1855H15.4934C15.983 11.1855 16.1788 11.1855 16.3746 11.287C16.5215 11.3884 16.6683 11.4899 16.7173 11.642C16.8152 11.8449 16.8152 12.0477 16.8152 12.5042V15.4965C16.8152 15.953 16.8152 16.2066 16.7173 16.3587C16.6194 16.5109 16.5215 16.663 16.3746 16.7137C16.1788 16.8152 15.983 16.8152 15.4934 16.8152H12.5073C12.0178 16.8152 11.8219 16.8152 11.6261 16.7137C11.4793 16.6123 11.3324 16.5109 11.2835 16.3587C11.1855 16.1558 11.1855 15.953 11.1855 15.4965V12.5042Z",
                fill: "#0052FF"
              }))
    }
  },
  539: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.LaptopIcon = void 0;
    let el = eo(74052);
    et.LaptopIcon = function (J) {
      return (0,
        el.h)("svg", Object.assign({
          width: "14",
          height: "14",
          viewBox: "0 0 14 14",
          xmlns: "http://www.w3.org/2000/svg"
        }, J), (0,
          el.h)("path", {
            d: "M1.8001 2.2002H12.2001V9.40019H1.8001V2.2002ZM3.4001 3.8002V7.80019H10.6001V3.8002H3.4001Z"
          }), (0,
            el.h)("path", {
              d: "M13.4001 10.2002H0.600098C0.600098 11.0838 1.31644 11.8002 2.2001 11.8002H11.8001C12.6838 11.8002 13.4001 11.0838 13.4001 10.2002Z"
            }))
    }
  },
  59309: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.QRCodeIcon = void 0;
    let el = eo(74052);
    et.QRCodeIcon = function (J) {
      return (0,
        el.h)("svg", Object.assign({
          width: "18",
          height: "18",
          viewBox: "0 0 24 24",
          xmlns: "http://www.w3.org/2000/svg"
        }, J), (0,
          el.h)("path", {
            d: "M3 3V8.99939L5 8.99996V5H9V3H3Z"
          }), (0,
            el.h)("path", {
              d: "M15 21L21 21V15.0006L19 15V19L15 19V21Z"
            }), (0,
              el.h)("path", {
                d: "M21 9H19V5H15.0006L15 3H21V9Z"
              }), (0,
                el.h)("path", {
                  d: "M3 15V21H8.99939L8.99996 19H5L5 15H3Z"
                }))
    }
  },
  4841: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.SafeIcon = void 0;
    let el = eo(74052);
    et.SafeIcon = function (J) {
      return (0,
        el.h)("svg", Object.assign({
          width: "14",
          height: "14",
          viewBox: "0 0 14 14",
          xmlns: "http://www.w3.org/2000/svg"
        }, J), (0,
          el.h)("path", {
            "fill-rule": "evenodd",
            "clip-rule": "evenodd",
            d: "M0.600098 0.600098V11.8001H13.4001V0.600098H0.600098ZM7.0001 9.2001C5.3441 9.2001 4.0001 7.8561 4.0001 6.2001C4.0001 4.5441 5.3441 3.2001 7.0001 3.2001C8.6561 3.2001 10.0001 4.5441 10.0001 6.2001C10.0001 7.8561 8.6561 9.2001 7.0001 9.2001ZM0.600098 12.6001H3.8001V13.4001H0.600098V12.6001ZM10.2001 12.6001H13.4001V13.4001H10.2001V12.6001ZM8.8001 6.2001C8.8001 7.19421 7.99421 8.0001 7.0001 8.0001C6.00598 8.0001 5.2001 7.19421 5.2001 6.2001C5.2001 5.20598 6.00598 4.4001 7.0001 4.4001C7.99421 4.4001 8.8001 5.20598 8.8001 6.2001Z"
          }))
    }
  },
  36089: function (J, et, eo) {
    var el = eo(48764).Buffer;
    let ec = eo(32518)
      , ed = eo(13550);
    function elementaryName(J) {
      if (J.startsWith("int["))
        return "int256" + J.slice(3);
      if ("int" === J)
        return "int256";
      if (J.startsWith("uint["))
        return "uint256" + J.slice(4);
      if ("uint" === J)
        return "uint256";
      if (J.startsWith("fixed["))
        return "fixed128x128" + J.slice(5);
      if ("fixed" === J)
        return "fixed128x128";
      if (J.startsWith("ufixed["))
        return "ufixed128x128" + J.slice(6);
      else if ("ufixed" === J)
        return "ufixed128x128";
      return J
    }
    function parseTypeN(J) {
      return parseInt(/^\D+(\d+)$/.exec(J)[1], 10)
    }
    function parseTypeNxM(J) {
      var et = /^\D+(\d+)x(\d+)$/.exec(J);
      return [parseInt(et[1], 10), parseInt(et[2], 10)]
    }
    function parseTypeArray(J) {
      var et = J.match(/(.*)\[(.*?)\]$/);
      return et ? "" === et[2] ? "dynamic" : parseInt(et[2], 10) : null
    }
    function parseNumber(J) {
      var et = typeof J;
      if ("string" === et)
        return ec.isHexString(J) ? new ed(ec.stripHexPrefix(J), 16) : new ed(J, 10);
      if ("number" === et)
        return new ed(J);
      if (J.toArray)
        return J;
      throw Error("Argument is not a number")
    }
    function encodeSingle(J, et) {
      if ("address" === J)
        return encodeSingle("uint160", parseNumber(et));
      if ("bool" === J)
        return encodeSingle("uint8", et ? 1 : 0);
      if ("string" === J)
        return encodeSingle("bytes", new el(et, "utf8"));
      if ((em = J).lastIndexOf("]") === em.length - 1) {
        if (void 0 === et.length)
          throw Error("Not an array?");
        if ("dynamic" !== (eo = parseTypeArray(J)) && 0 !== eo && et.length > eo)
          throw Error("Elements exceed array size: " + eo);
        for (ef in ep = [],
          J = J.slice(0, J.lastIndexOf("[")),
          "string" == typeof et && (et = JSON.parse(et)),
          et)
          ep.push(encodeSingle(J, et[ef]));
        if ("dynamic" === eo) {
          var eo, eh, ep, ef, em, eg = encodeSingle("uint256", et.length);
          ep.unshift(eg)
        }
        return el.concat(ep)
      }
      if ("bytes" === J)
        return et = new el(et),
          ep = el.concat([encodeSingle("uint256", et.length), et]),
          et.length % 32 != 0 && (ep = el.concat([ep, ec.zeros(32 - et.length % 32)])),
          ep;
      if (J.startsWith("bytes")) {
        if ((eo = parseTypeN(J)) < 1 || eo > 32)
          throw Error("Invalid bytes<N> width: " + eo);
        return ec.setLengthRight(et, 32)
      } else if (J.startsWith("uint")) {
        if ((eo = parseTypeN(J)) % 8 || eo < 8 || eo > 256)
          throw Error("Invalid uint<N> width: " + eo);
        if ((eh = parseNumber(et)).bitLength() > eo)
          throw Error("Supplied uint exceeds width: " + eo + " vs " + eh.bitLength());
        if (eh < 0)
          throw Error("Supplied uint is negative");
        return eh.toArrayLike(el, "be", 32)
      } else if (J.startsWith("int")) {
        if ((eo = parseTypeN(J)) % 8 || eo < 8 || eo > 256)
          throw Error("Invalid int<N> width: " + eo);
        if ((eh = parseNumber(et)).bitLength() > eo)
          throw Error("Supplied int exceeds width: " + eo + " vs " + eh.bitLength());
        return eh.toTwos(256).toArrayLike(el, "be", 32)
      } else if (J.startsWith("ufixed")) {
        if (eo = parseTypeNxM(J),
          (eh = parseNumber(et)) < 0)
          throw Error("Supplied ufixed is negative");
        return encodeSingle("uint256", eh.mul(new ed(2).pow(new ed(eo[1]))))
      } else if (J.startsWith("fixed"))
        return eo = parseTypeNxM(J),
          encodeSingle("int256", parseNumber(et).mul(new ed(2).pow(new ed(eo[1]))));
      throw Error("Unsupported or invalid type: " + J)
    }
    function solidityPack(J, et) {
      if (J.length !== et.length)
        throw Error("Number of types are not matching the values");
      for (var eo, ed, eh = [], ep = 0; ep < J.length; ep++) {
        var ef = elementaryName(J[ep])
          , em = et[ep];
        if ("bytes" === ef)
          eh.push(em);
        else if ("string" === ef)
          eh.push(new el(em, "utf8"));
        else if ("bool" === ef)
          eh.push(new el(em ? "01" : "00", "hex"));
        else if ("address" === ef)
          eh.push(ec.setLength(em, 20));
        else if (ef.startsWith("bytes")) {
          if ((eo = parseTypeN(ef)) < 1 || eo > 32)
            throw Error("Invalid bytes<N> width: " + eo);
          eh.push(ec.setLengthRight(em, eo))
        } else if (ef.startsWith("uint")) {
          if ((eo = parseTypeN(ef)) % 8 || eo < 8 || eo > 256)
            throw Error("Invalid uint<N> width: " + eo);
          if ((ed = parseNumber(em)).bitLength() > eo)
            throw Error("Supplied uint exceeds width: " + eo + " vs " + ed.bitLength());
          eh.push(ed.toArrayLike(el, "be", eo / 8))
        } else if (ef.startsWith("int")) {
          if ((eo = parseTypeN(ef)) % 8 || eo < 8 || eo > 256)
            throw Error("Invalid int<N> width: " + eo);
          if ((ed = parseNumber(em)).bitLength() > eo)
            throw Error("Supplied int exceeds width: " + eo + " vs " + ed.bitLength());
          eh.push(ed.toTwos(eo).toArrayLike(el, "be", eo / 8))
        } else
          throw Error("Unsupported or invalid type: " + ef)
      }
      return el.concat(eh)
    }
    J.exports = {
      rawEncode: function (J, et) {
        var eo = []
          , ec = []
          , ed = 32 * J.length;
        for (var eh in J) {
          var ep = elementaryName(J[eh])
            , ef = encodeSingle(ep, et[eh]);
          "string" === ep || "bytes" === ep || "dynamic" === parseTypeArray(ep) ? (eo.push(encodeSingle("uint256", ed)),
            ec.push(ef),
            ed += ef.length) : eo.push(ef)
        }
        return el.concat(eo.concat(ec))
      },
      solidityPack,
      soliditySHA3: function (J, et) {
        return ec.keccak(solidityPack(J, et))
      }
    }
  },
  14497: function (J, et, eo) {
    var el = eo(48764).Buffer;
    let ec = eo(32518)
      , ed = eo(36089)
      , eh = {
        type: "object",
        properties: {
          types: {
            type: "object",
            additionalProperties: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  name: {
                    type: "string"
                  },
                  type: {
                    type: "string"
                  }
                },
                required: ["name", "type"]
              }
            }
          },
          primaryType: {
            type: "string"
          },
          domain: {
            type: "object"
          },
          message: {
            type: "object"
          }
        },
        required: ["types", "primaryType", "domain", "message"]
      }
      , ep = {
        encodeData(J, et, eo, eh = !0) {
          let ep = ["bytes32"]
            , ef = [this.hashType(J, eo)];
          if (eh) {
            let encodeField = (J, et, ep) => {
              if (void 0 !== eo[et])
                return ["bytes32", null == ep ? "0x0000000000000000000000000000000000000000000000000000000000000000" : ec.keccak(this.encodeData(et, ep, eo, eh))];
              if (void 0 === ep)
                throw Error(`missing value for field ${J} of type ${et}`);
              if ("bytes" === et)
                return ["bytes32", ec.keccak(ep)];
              if ("string" === et)
                return "string" == typeof ep && (ep = el.from(ep, "utf8")),
                  ["bytes32", ec.keccak(ep)];
              if (et.lastIndexOf("]") === et.length - 1) {
                let eo = et.slice(0, et.lastIndexOf("["))
                  , el = ep.map(et => encodeField(J, eo, et));
                return ["bytes32", ec.keccak(ed.rawEncode(el.map(([J]) => J), el.map(([, J]) => J)))]
              }
              return [et, ep]
            }
              ;
            for (let el of eo[J]) {
              let [J, eo] = encodeField(el.name, el.type, et[el.name]);
              ep.push(J),
                ef.push(eo)
            }
          } else
            for (let ed of eo[J]) {
              let J = et[ed.name];
              if (void 0 !== J) {
                if ("bytes" === ed.type)
                  ep.push("bytes32"),
                    J = ec.keccak(J),
                    ef.push(J);
                else if ("string" === ed.type)
                  ep.push("bytes32"),
                    "string" == typeof J && (J = el.from(J, "utf8")),
                    J = ec.keccak(J),
                    ef.push(J);
                else if (void 0 !== eo[ed.type])
                  ep.push("bytes32"),
                    J = ec.keccak(this.encodeData(ed.type, J, eo, eh)),
                    ef.push(J);
                else if (ed.type.lastIndexOf("]") === ed.type.length - 1)
                  throw Error("Arrays currently unimplemented in encodeData");
                else
                  ep.push(ed.type),
                    ef.push(J)
              }
            }
          return ed.rawEncode(ep, ef)
        },
        encodeType(J, et) {
          let eo = ""
            , el = this.findTypeDependencies(J, et).filter(et => et !== J);
          for (let ec of el = [J].concat(el.sort())) {
            let J = et[ec];
            if (!J)
              throw Error("No type definition specified: " + ec);
            eo += ec + "(" + et[ec].map(({ name: J, type: et }) => et + " " + J).join(",") + ")"
          }
          return eo
        },
        findTypeDependencies(J, et, eo = []) {
          if (J = J.match(/^\w*/)[0],
            eo.includes(J) || void 0 === et[J])
            return eo;
          for (let el of (eo.push(J),
            et[J]))
            for (let J of this.findTypeDependencies(el.type, et, eo))
              eo.includes(J) || eo.push(J);
          return eo
        },
        hashStruct(J, et, eo, el = !0) {
          return ec.keccak(this.encodeData(J, et, eo, el))
        },
        hashType(J, et) {
          return ec.keccak(this.encodeType(J, et))
        },
        sanitizeData(J) {
          let et = {};
          for (let eo in eh.properties)
            J[eo] && (et[eo] = J[eo]);
          return et.types && (et.types = Object.assign({
            EIP712Domain: []
          }, et.types)),
            et
        },
        hash(J, et = !0) {
          let eo = this.sanitizeData(J)
            , ed = [el.from("1901", "hex")];
          return ed.push(this.hashStruct("EIP712Domain", eo.domain, eo.types, et)),
            "EIP712Domain" !== eo.primaryType && ed.push(this.hashStruct(eo.primaryType, eo.message, eo.types, et)),
            ec.keccak(el.concat(ed))
        }
      };
    J.exports = {
      TYPED_MESSAGE_SCHEMA: eh,
      TypedDataUtils: ep,
      hashForSignTypedDataLegacy: function (J) {
        return function (J) {
          let et = Error("Expect argument to be non-empty array");
          if ("object" != typeof J || !J.length)
            throw et;
          let eo = J.map(function (J) {
            return "bytes" === J.type ? ec.toBuffer(J.value) : J.value
          })
            , el = J.map(function (J) {
              return J.type
            })
            , eh = J.map(function (J) {
              if (!J.name)
                throw et;
              return J.type + " " + J.name
            });
          return ed.soliditySHA3(["bytes32", "bytes32"], [ed.soliditySHA3(Array(J.length).fill("string"), eh), ed.soliditySHA3(el, eo)])
        }(J.data)
      },
      hashForSignTypedData_v3: function (J) {
        return ep.hash(J.data, !1)
      },
      hashForSignTypedData_v4: function (J) {
        return ep.hash(J.data)
      }
    }
  },
  32518: function (J, et, eo) {
    var el = eo(48764).Buffer;
    let ec = eo(95811)
      , ed = eo(13550);
    function zeros(J) {
      return el.allocUnsafe(J).fill(0)
    }
    function setLength(J, et, eo) {
      let el = zeros(et);
      return (J = toBuffer(J),
        eo) ? J.length < et ? (J.copy(el),
          el) : J.slice(0, et) : J.length < et ? (J.copy(el, et - J.length),
            el) : J.slice(-et)
    }
    function toBuffer(J) {
      if (!el.isBuffer(J)) {
        if (Array.isArray(J))
          J = el.from(J);
        else if ("string" == typeof J) {
          var et;
          J = isHexString(J) ? el.from((et = stripHexPrefix(J)).length % 2 ? "0" + et : et, "hex") : el.from(J)
        } else if ("number" == typeof J)
          J = intToBuffer(J);
        else if (null == J)
          J = el.allocUnsafe(0);
        else if (ed.isBN(J))
          J = J.toArrayLike(el);
        else if (J.toArray)
          J = el.from(J.toArray());
        else
          throw Error("invalid type")
      }
      return J
    }
    function isHexString(J) {
      return "string" == typeof J && J.match(/^0x[0-9A-Fa-f]*$/)
    }
    function stripHexPrefix(J) {
      return "string" == typeof J && J.startsWith("0x") ? J.slice(2) : J
    }
    J.exports = {
      zeros,
      setLength,
      setLengthRight: function (J, et) {
        return setLength(J, et, !0)
      },
      isHexString,
      stripHexPrefix,
      toBuffer,
      bufferToHex: function (J) {
        return "0x" + (J = toBuffer(J)).toString("hex")
      },
      keccak: function (J, et) {
        return J = toBuffer(J),
          et || (et = 256),
          ec("keccak" + et).update(J).digest()
      }
    }
  },
  7713: function (J) {
    function QR8bitByte(J) {
      this.mode = et.MODE_8BIT_BYTE,
        this.data = J,
        this.parsedData = [];
      for (var eo = 0, el = this.data.length; eo < el; eo++) {
        var ec = []
          , ed = this.data.charCodeAt(eo);
        ed > 65536 ? (ec[0] = 240 | (1835008 & ed) >>> 18,
          ec[1] = 128 | (258048 & ed) >>> 12,
          ec[2] = 128 | (4032 & ed) >>> 6,
          ec[3] = 128 | 63 & ed) : ed > 2048 ? (ec[0] = 224 | (61440 & ed) >>> 12,
            ec[1] = 128 | (4032 & ed) >>> 6,
            ec[2] = 128 | 63 & ed) : ed > 128 ? (ec[0] = 192 | (1984 & ed) >>> 6,
              ec[1] = 128 | 63 & ed) : ec[0] = ed,
          this.parsedData.push(ec)
      }
      this.parsedData = Array.prototype.concat.apply([], this.parsedData),
        this.parsedData.length != this.data.length && (this.parsedData.unshift(191),
          this.parsedData.unshift(187),
          this.parsedData.unshift(239))
    }
    function QRCodeModel(J, et) {
      this.typeNumber = J,
        this.errorCorrectLevel = et,
        this.modules = null,
        this.moduleCount = 0,
        this.dataCache = null,
        this.dataList = []
    }
    QR8bitByte.prototype = {
      getLength: function (J) {
        return this.parsedData.length
      },
      write: function (J) {
        for (var et = 0, eo = this.parsedData.length; et < eo; et++)
          J.put(this.parsedData[et], 8)
      }
    },
      QRCodeModel.prototype = {
        addData: function (J) {
          var et = new QR8bitByte(J);
          this.dataList.push(et),
            this.dataCache = null
        },
        isDark: function (J, et) {
          if (J < 0 || this.moduleCount <= J || et < 0 || this.moduleCount <= et)
            throw Error(J + "," + et);
          return this.modules[J][et]
        },
        getModuleCount: function () {
          return this.moduleCount
        },
        make: function () {
          this.makeImpl(!1, this.getBestMaskPattern())
        },
        makeImpl: function (J, et) {
          this.moduleCount = 4 * this.typeNumber + 17,
            this.modules = Array(this.moduleCount);
          for (var eo = 0; eo < this.moduleCount; eo++) {
            this.modules[eo] = Array(this.moduleCount);
            for (var el = 0; el < this.moduleCount; el++)
              this.modules[eo][el] = null
          }
          this.setupPositionProbePattern(0, 0),
            this.setupPositionProbePattern(this.moduleCount - 7, 0),
            this.setupPositionProbePattern(0, this.moduleCount - 7),
            this.setupPositionAdjustPattern(),
            this.setupTimingPattern(),
            this.setupTypeInfo(J, et),
            this.typeNumber >= 7 && this.setupTypeNumber(J),
            null == this.dataCache && (this.dataCache = QRCodeModel.createData(this.typeNumber, this.errorCorrectLevel, this.dataList)),
            this.mapData(this.dataCache, et)
        },
        setupPositionProbePattern: function (J, et) {
          for (var eo = -1; eo <= 7; eo++)
            if (!(J + eo <= -1) && !(this.moduleCount <= J + eo))
              for (var el = -1; el <= 7; el++)
                et + el <= -1 || this.moduleCount <= et + el || (0 <= eo && eo <= 6 && (0 == el || 6 == el) || 0 <= el && el <= 6 && (0 == eo || 6 == eo) || 2 <= eo && eo <= 4 && 2 <= el && el <= 4 ? this.modules[J + eo][et + el] = !0 : this.modules[J + eo][et + el] = !1)
        },
        getBestMaskPattern: function () {
          for (var J = 0, et = 0, eo = 0; eo < 8; eo++) {
            this.makeImpl(!0, eo);
            var el = ec.getLostPoint(this);
            (0 == eo || J > el) && (J = el,
              et = eo)
          }
          return et
        },
        createMovieClip: function (J, et, eo) {
          var el = J.createEmptyMovieClip(et, eo);
          this.make();
          for (var ec = 0; ec < this.modules.length; ec++)
            for (var ed = 1 * ec, eh = 0; eh < this.modules[ec].length; eh++) {
              var ep = 1 * eh;
              this.modules[ec][eh] && (el.beginFill(0, 100),
                el.moveTo(ep, ed),
                el.lineTo(ep + 1, ed),
                el.lineTo(ep + 1, ed + 1),
                el.lineTo(ep, ed + 1),
                el.endFill())
            }
          return el
        },
        setupTimingPattern: function () {
          for (var J = 8; J < this.moduleCount - 8; J++)
            null == this.modules[J][6] && (this.modules[J][6] = J % 2 == 0);
          for (var et = 8; et < this.moduleCount - 8; et++)
            null == this.modules[6][et] && (this.modules[6][et] = et % 2 == 0)
        },
        setupPositionAdjustPattern: function () {
          for (var J = ec.getPatternPosition(this.typeNumber), et = 0; et < J.length; et++)
            for (var eo = 0; eo < J.length; eo++) {
              var el = J[et]
                , ed = J[eo];
              if (null == this.modules[el][ed])
                for (var eh = -2; eh <= 2; eh++)
                  for (var ep = -2; ep <= 2; ep++)
                    -2 == eh || 2 == eh || -2 == ep || 2 == ep || 0 == eh && 0 == ep ? this.modules[el + eh][ed + ep] = !0 : this.modules[el + eh][ed + ep] = !1
            }
        },
        setupTypeNumber: function (J) {
          for (var et = ec.getBCHTypeNumber(this.typeNumber), eo = 0; eo < 18; eo++) {
            var el = !J && (et >> eo & 1) == 1;
            this.modules[Math.floor(eo / 3)][eo % 3 + this.moduleCount - 8 - 3] = el
          }
          for (var eo = 0; eo < 18; eo++) {
            var el = !J && (et >> eo & 1) == 1;
            this.modules[eo % 3 + this.moduleCount - 8 - 3][Math.floor(eo / 3)] = el
          }
        },
        setupTypeInfo: function (J, et) {
          for (var eo = this.errorCorrectLevel << 3 | et, el = ec.getBCHTypeInfo(eo), ed = 0; ed < 15; ed++) {
            var eh = !J && (el >> ed & 1) == 1;
            ed < 6 ? this.modules[ed][8] = eh : ed < 8 ? this.modules[ed + 1][8] = eh : this.modules[this.moduleCount - 15 + ed][8] = eh
          }
          for (var ed = 0; ed < 15; ed++) {
            var eh = !J && (el >> ed & 1) == 1;
            ed < 8 ? this.modules[8][this.moduleCount - ed - 1] = eh : ed < 9 ? this.modules[8][15 - ed - 1 + 1] = eh : this.modules[8][15 - ed - 1] = eh
          }
          this.modules[this.moduleCount - 8][8] = !J
        },
        mapData: function (J, et) {
          for (var eo = -1, el = this.moduleCount - 1, ed = 7, eh = 0, ep = this.moduleCount - 1; ep > 0; ep -= 2)
            for (6 == ep && ep--; ;) {
              for (var ef = 0; ef < 2; ef++)
                if (null == this.modules[el][ep - ef]) {
                  var em = !1;
                  eh < J.length && (em = (J[eh] >>> ed & 1) == 1),
                    ec.getMask(et, el, ep - ef) && (em = !em),
                    this.modules[el][ep - ef] = em,
                    -1 == --ed && (eh++,
                      ed = 7)
                }
              if ((el += eo) < 0 || this.moduleCount <= el) {
                el -= eo,
                  eo = -eo;
                break
              }
            }
        }
      },
      QRCodeModel.PAD0 = 236,
      QRCodeModel.PAD1 = 17,
      QRCodeModel.createData = function (J, et, eo) {
        for (var el = QRRSBlock.getRSBlocks(J, et), ed = new QRBitBuffer, eh = 0; eh < eo.length; eh++) {
          var ep = eo[eh];
          ed.put(ep.mode, 4),
            ed.put(ep.getLength(), ec.getLengthInBits(ep.mode, J)),
            ep.write(ed)
        }
        for (var ef = 0, eh = 0; eh < el.length; eh++)
          ef += el[eh].dataCount;
        if (ed.getLengthInBits() > 8 * ef)
          throw Error("code length overflow. (" + ed.getLengthInBits() + ">" + 8 * ef + ")");
        for (ed.getLengthInBits() + 4 <= 8 * ef && ed.put(0, 4); ed.getLengthInBits() % 8 != 0;)
          ed.putBit(!1);
        for (; !(ed.getLengthInBits() >= 8 * ef) && (ed.put(QRCodeModel.PAD0, 8),
          !(ed.getLengthInBits() >= 8 * ef));)
          ed.put(QRCodeModel.PAD1, 8);
        return QRCodeModel.createBytes(ed, el)
      }
      ,
      QRCodeModel.createBytes = function (J, et) {
        for (var eo = 0, el = 0, ed = 0, eh = Array(et.length), ep = Array(et.length), ef = 0; ef < et.length; ef++) {
          var em = et[ef].dataCount
            , eg = et[ef].totalCount - em;
          el = Math.max(el, em),
            ed = Math.max(ed, eg),
            eh[ef] = Array(em);
          for (var ey = 0; ey < eh[ef].length; ey++)
            eh[ef][ey] = 255 & J.buffer[ey + eo];
          eo += em;
          var eb = ec.getErrorCorrectPolynomial(eg)
            , ew = new QRPolynomial(eh[ef], eb.getLength() - 1).mod(eb);
          ep[ef] = Array(eb.getLength() - 1);
          for (var ey = 0; ey < ep[ef].length; ey++) {
            var e_ = ey + ew.getLength() - ep[ef].length;
            ep[ef][ey] = e_ >= 0 ? ew.get(e_) : 0
          }
        }
        for (var ex = 0, ey = 0; ey < et.length; ey++)
          ex += et[ey].totalCount;
        for (var eE = Array(ex), eC = 0, ey = 0; ey < el; ey++)
          for (var ef = 0; ef < et.length; ef++)
            ey < eh[ef].length && (eE[eC++] = eh[ef][ey]);
        for (var ey = 0; ey < ed; ey++)
          for (var ef = 0; ef < et.length; ef++)
            ey < ep[ef].length && (eE[eC++] = ep[ef][ey]);
        return eE
      }
      ;
    for (var et = {
      MODE_NUMBER: 1,
      MODE_ALPHA_NUM: 2,
      MODE_8BIT_BYTE: 4,
      MODE_KANJI: 8
    }, eo = {
      L: 1,
      M: 0,
      Q: 3,
      H: 2
    }, el = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    }, ec = {
      PATTERN_POSITION_TABLE: [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]],
      G15: 1335,
      G18: 7973,
      G15_MASK: 21522,
      getBCHTypeInfo: function (J) {
        for (var et = J << 10; ec.getBCHDigit(et) - ec.getBCHDigit(ec.G15) >= 0;)
          et ^= ec.G15 << ec.getBCHDigit(et) - ec.getBCHDigit(ec.G15);
        return (J << 10 | et) ^ ec.G15_MASK
      },
      getBCHTypeNumber: function (J) {
        for (var et = J << 12; ec.getBCHDigit(et) - ec.getBCHDigit(ec.G18) >= 0;)
          et ^= ec.G18 << ec.getBCHDigit(et) - ec.getBCHDigit(ec.G18);
        return J << 12 | et
      },
      getBCHDigit: function (J) {
        for (var et = 0; 0 != J;)
          et++,
            J >>>= 1;
        return et
      },
      getPatternPosition: function (J) {
        return ec.PATTERN_POSITION_TABLE[J - 1]
      },
      getMask: function (J, et, eo) {
        switch (J) {
          case el.PATTERN000:
            return (et + eo) % 2 == 0;
          case el.PATTERN001:
            return et % 2 == 0;
          case el.PATTERN010:
            return eo % 3 == 0;
          case el.PATTERN011:
            return (et + eo) % 3 == 0;
          case el.PATTERN100:
            return (Math.floor(et / 2) + Math.floor(eo / 3)) % 2 == 0;
          case el.PATTERN101:
            return et * eo % 2 + et * eo % 3 == 0;
          case el.PATTERN110:
            return (et * eo % 2 + et * eo % 3) % 2 == 0;
          case el.PATTERN111:
            return (et * eo % 3 + (et + eo) % 2) % 2 == 0;
          default:
            throw Error("bad maskPattern:" + J)
        }
      },
      getErrorCorrectPolynomial: function (J) {
        for (var et = new QRPolynomial([1], 0), eo = 0; eo < J; eo++)
          et = et.multiply(new QRPolynomial([1, ed.gexp(eo)], 0));
        return et
      },
      getLengthInBits: function (J, eo) {
        if (1 <= eo && eo < 10)
          switch (J) {
            case et.MODE_NUMBER:
              return 10;
            case et.MODE_ALPHA_NUM:
              return 9;
            case et.MODE_8BIT_BYTE:
            case et.MODE_KANJI:
              return 8;
            default:
              throw Error("mode:" + J)
          }
        else if (eo < 27)
          switch (J) {
            case et.MODE_NUMBER:
              return 12;
            case et.MODE_ALPHA_NUM:
              return 11;
            case et.MODE_8BIT_BYTE:
              return 16;
            case et.MODE_KANJI:
              return 10;
            default:
              throw Error("mode:" + J)
          }
        else if (eo < 41)
          switch (J) {
            case et.MODE_NUMBER:
              return 14;
            case et.MODE_ALPHA_NUM:
              return 13;
            case et.MODE_8BIT_BYTE:
              return 16;
            case et.MODE_KANJI:
              return 12;
            default:
              throw Error("mode:" + J)
          }
        else
          throw Error("type:" + eo)
      },
      getLostPoint: function (J) {
        for (var et = J.getModuleCount(), eo = 0, el = 0; el < et; el++)
          for (var ec = 0; ec < et; ec++) {
            for (var ed = 0, eh = J.isDark(el, ec), ep = -1; ep <= 1; ep++)
              if (!(el + ep < 0) && !(et <= el + ep))
                for (var ef = -1; ef <= 1; ef++)
                  !(ec + ef < 0) && !(et <= ec + ef) && (0 != ep || 0 != ef) && eh == J.isDark(el + ep, ec + ef) && ed++;
            ed > 5 && (eo += 3 + ed - 5)
          }
        for (var el = 0; el < et - 1; el++)
          for (var ec = 0; ec < et - 1; ec++) {
            var em = 0;
            J.isDark(el, ec) && em++,
              J.isDark(el + 1, ec) && em++,
              J.isDark(el, ec + 1) && em++,
              J.isDark(el + 1, ec + 1) && em++,
              (0 == em || 4 == em) && (eo += 3)
          }
        for (var el = 0; el < et; el++)
          for (var ec = 0; ec < et - 6; ec++)
            J.isDark(el, ec) && !J.isDark(el, ec + 1) && J.isDark(el, ec + 2) && J.isDark(el, ec + 3) && J.isDark(el, ec + 4) && !J.isDark(el, ec + 5) && J.isDark(el, ec + 6) && (eo += 40);
        for (var ec = 0; ec < et; ec++)
          for (var el = 0; el < et - 6; el++)
            J.isDark(el, ec) && !J.isDark(el + 1, ec) && J.isDark(el + 2, ec) && J.isDark(el + 3, ec) && J.isDark(el + 4, ec) && !J.isDark(el + 5, ec) && J.isDark(el + 6, ec) && (eo += 40);
        for (var eg = 0, ec = 0; ec < et; ec++)
          for (var el = 0; el < et; el++)
            J.isDark(el, ec) && eg++;
        return eo + 10 * (Math.abs(100 * eg / et / et - 50) / 5)
      }
    }, ed = {
      glog: function (J) {
        if (J < 1)
          throw Error("glog(" + J + ")");
        return ed.LOG_TABLE[J]
      },
      gexp: function (J) {
        for (; J < 0;)
          J += 255;
        for (; J >= 256;)
          J -= 255;
        return ed.EXP_TABLE[J]
      },
      EXP_TABLE: Array(256),
      LOG_TABLE: Array(256)
    }, eh = 0; eh < 8; eh++)
      ed.EXP_TABLE[eh] = 1 << eh;
    for (var eh = 8; eh < 256; eh++)
      ed.EXP_TABLE[eh] = ed.EXP_TABLE[eh - 4] ^ ed.EXP_TABLE[eh - 5] ^ ed.EXP_TABLE[eh - 6] ^ ed.EXP_TABLE[eh - 8];
    for (var eh = 0; eh < 255; eh++)
      ed.LOG_TABLE[ed.EXP_TABLE[eh]] = eh;
    function QRPolynomial(J, et) {
      if (void 0 == J.length)
        throw Error(J.length + "/" + et);
      for (var eo = 0; eo < J.length && 0 == J[eo];)
        eo++;
      this.num = Array(J.length - eo + et);
      for (var el = 0; el < J.length - eo; el++)
        this.num[el] = J[el + eo]
    }
    function QRRSBlock(J, et) {
      this.totalCount = J,
        this.dataCount = et
    }
    function QRBitBuffer() {
      this.buffer = [],
        this.length = 0
    }
    QRPolynomial.prototype = {
      get: function (J) {
        return this.num[J]
      },
      getLength: function () {
        return this.num.length
      },
      multiply: function (J) {
        for (var et = Array(this.getLength() + J.getLength() - 1), eo = 0; eo < this.getLength(); eo++)
          for (var el = 0; el < J.getLength(); el++)
            et[eo + el] ^= ed.gexp(ed.glog(this.get(eo)) + ed.glog(J.get(el)));
        return new QRPolynomial(et, 0)
      },
      mod: function (J) {
        if (this.getLength() - J.getLength() < 0)
          return this;
        for (var et = ed.glog(this.get(0)) - ed.glog(J.get(0)), eo = Array(this.getLength()), el = 0; el < this.getLength(); el++)
          eo[el] = this.get(el);
        for (var el = 0; el < J.getLength(); el++)
          eo[el] ^= ed.gexp(ed.glog(J.get(el)) + et);
        return new QRPolynomial(eo, 0).mod(J)
      }
    },
      QRRSBlock.RS_BLOCK_TABLE = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]],
      QRRSBlock.getRSBlocks = function (J, et) {
        var eo = QRRSBlock.getRsBlockTable(J, et);
        if (void 0 == eo)
          throw Error("bad rs block @ typeNumber:" + J + "/errorCorrectLevel:" + et);
        for (var el = eo.length / 3, ec = [], ed = 0; ed < el; ed++)
          for (var eh = eo[3 * ed + 0], ep = eo[3 * ed + 1], ef = eo[3 * ed + 2], em = 0; em < eh; em++)
            ec.push(new QRRSBlock(ep, ef));
        return ec
      }
      ,
      QRRSBlock.getRsBlockTable = function (J, et) {
        switch (et) {
          case eo.L:
            return QRRSBlock.RS_BLOCK_TABLE[(J - 1) * 4 + 0];
          case eo.M:
            return QRRSBlock.RS_BLOCK_TABLE[(J - 1) * 4 + 1];
          case eo.Q:
            return QRRSBlock.RS_BLOCK_TABLE[(J - 1) * 4 + 2];
          case eo.H:
            return QRRSBlock.RS_BLOCK_TABLE[(J - 1) * 4 + 3];
          default:
            return
        }
      }
      ,
      QRBitBuffer.prototype = {
        get: function (J) {
          var et = Math.floor(J / 8);
          return (this.buffer[et] >>> 7 - J % 8 & 1) == 1
        },
        put: function (J, et) {
          for (var eo = 0; eo < et; eo++)
            this.putBit((J >>> et - eo - 1 & 1) == 1)
        },
        getLengthInBits: function () {
          return this.length
        },
        putBit: function (J) {
          var et = Math.floor(this.length / 8);
          this.buffer.length <= et && this.buffer.push(0),
            J && (this.buffer[et] |= 128 >>> this.length % 8),
            this.length++
        }
      };
    var ep = [[17, 14, 11, 7], [32, 26, 20, 14], [53, 42, 32, 24], [78, 62, 46, 34], [106, 84, 60, 44], [134, 106, 74, 58], [154, 122, 86, 64], [192, 152, 108, 84], [230, 180, 130, 98], [271, 213, 151, 119], [321, 251, 177, 137], [367, 287, 203, 155], [425, 331, 241, 177], [458, 362, 258, 194], [520, 412, 292, 220], [586, 450, 322, 250], [644, 504, 364, 280], [718, 560, 394, 310], [792, 624, 442, 338], [858, 666, 482, 382], [929, 711, 509, 403], [1003, 779, 565, 439], [1091, 857, 611, 461], [1171, 911, 661, 511], [1273, 997, 715, 535], [1367, 1059, 751, 593], [1465, 1125, 805, 625], [1528, 1190, 868, 658], [1628, 1264, 908, 698], [1732, 1370, 982, 742], [1840, 1452, 1030, 790], [1952, 1538, 1112, 842], [2068, 1628, 1168, 898], [2188, 1722, 1228, 958], [2303, 1809, 1283, 983], [2431, 1911, 1351, 1051], [2563, 1989, 1423, 1093], [2699, 2099, 1499, 1139], [2809, 2213, 1579, 1219], [2953, 2331, 1663, 1273]];
    function QRCode(J) {
      if (this.options = {
        padding: 4,
        width: 256,
        height: 256,
        typeNumber: 4,
        color: "#000000",
        background: "#ffffff",
        ecl: "M",
        image: {
          svg: "",
          width: 0,
          height: 0
        }
      },
        "string" == typeof J && (J = {
          content: J
        }),
        J)
        for (var et in J)
          this.options[et] = J[et];
      if ("string" != typeof this.options.content)
        throw Error("Expected 'content' as string!");
      if (0 === this.options.content.length)
        throw Error("Expected 'content' to be non-empty!");
      if (!(this.options.padding >= 0))
        throw Error("Expected 'padding' value to be non-negative!");
      if (!(this.options.width > 0) || !(this.options.height > 0))
        throw Error("Expected 'width' or 'height' value to be higher than zero!");
      var el = this.options.content
        , ec = function (J, et) {
          for (var eo, el = (eo = encodeURI(J).toString().replace(/\%[0-9a-fA-F]{2}/g, "a")).length + (eo.length != J ? 3 : 0), ec = 1, ed = 0, eh = 0, ef = ep.length; eh <= ef; eh++) {
            var em = ep[eh];
            if (!em)
              throw Error("Content too long: expected " + ed + " but got " + el);
            switch (et) {
              case "L":
                ed = em[0];
                break;
              case "M":
                ed = em[1];
                break;
              case "Q":
                ed = em[2];
                break;
              case "H":
                ed = em[3];
                break;
              default:
                throw Error("Unknwon error correction level: " + et)
            }
            if (el <= ed)
              break;
            ec++
          }
          if (ec > ep.length)
            throw Error("Content too long");
          return ec
        }(el, this.options.ecl)
        , ed = function (J) {
          switch (J) {
            case "L":
              return eo.L;
            case "M":
              return eo.M;
            case "Q":
              return eo.Q;
            case "H":
              return eo.H;
            default:
              throw Error("Unknwon error correction level: " + J)
          }
        }(this.options.ecl);
      this.qrcode = new QRCodeModel(ec, ed),
        this.qrcode.addData(el),
        this.qrcode.make()
    }
    QRCode.prototype.svg = function (J) {
      var et = this.options || {}
        , eo = this.qrcode.modules;
      void 0 === J && (J = {
        container: et.container || "svg"
      });
      for (var el = void 0 === et.pretty || !!et.pretty, ec = el ? "  " : "", ed = el ? "\r\n" : "", eh = et.width, ep = et.height, ef = eo.length, em = eh / (ef + 2 * et.padding), eg = ep / (ef + 2 * et.padding), ey = void 0 !== et.join && !!et.join, eb = void 0 !== et.swap && !!et.swap, ew = void 0 === et.xmlDeclaration || !!et.xmlDeclaration, e_ = void 0 !== et.predefined && !!et.predefined, ex = e_ ? ec + '<defs><path id="qrmodule" d="M0 0 h' + eg + " v" + em + ' H0 z" style="fill:' + et.color + ';shape-rendering:crispEdges;" /></defs>' + ed : "", eE = ec + '<rect x="0" y="0" width="' + eh + '" height="' + ep + '" style="fill:' + et.background + ';shape-rendering:crispEdges;"/>' + ed, eC = "", eS = "", ek = 0; ek < ef; ek++)
        for (var eT = 0; eT < ef; eT++)
          if (eo[eT][ek]) {
            var eA = eT * em + et.padding * em
              , eP = ek * eg + et.padding * eg;
            if (eb) {
              var eR = eA;
              eA = eP,
                eP = eR
            }
            if (ey) {
              var eI = em + eA
                , eO = eg + eP;
              eA = Number.isInteger(eA) ? Number(eA) : eA.toFixed(2),
                eP = Number.isInteger(eP) ? Number(eP) : eP.toFixed(2),
                eI = Number.isInteger(eI) ? Number(eI) : eI.toFixed(2),
                eS += "M" + eA + "," + eP + " V" + (eO = Number.isInteger(eO) ? Number(eO) : eO.toFixed(2)) + " H" + eI + " V" + eP + " H" + eA + " Z "
            } else
              e_ ? eC += ec + '<use x="' + eA.toString() + '" y="' + eP.toString() + '" href="#qrmodule" />' + ed : eC += ec + '<rect x="' + eA.toString() + '" y="' + eP.toString() + '" width="' + em + '" height="' + eg + '" style="fill:' + et.color + ';shape-rendering:crispEdges;"/>' + ed
          }
      ey && (eC = ec + '<path x="0" y="0" style="fill:' + et.color + ';shape-rendering:crispEdges;" d="' + eS + '" />');
      let eN = "";
      if (void 0 !== this.options.image && this.options.image.svg) {
        let J = eh * this.options.image.width / 100
          , et = ep * this.options.image.height / 100;
        eN += `<svg x="${eh / 2 - J / 2}" y="${ep / 2 - et / 2}" width="${J}" height="${et}" viewBox="0 0 100 100" preserveAspectRatio="xMinYMin meet">` + (this.options.image.svg + ed) + "</svg>"
      }
      var eM = "";
      switch (J.container) {
        case "svg":
          ew && (eM += '<?xml version="1.0" standalone="yes"?>' + ed),
            eM += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="' + eh + '" height="' + ep + '">' + ed + (ex + eE + eC) + eN + "</svg>";
          break;
        case "svg-viewbox":
          ew && (eM += '<?xml version="1.0" standalone="yes"?>' + ed),
            eM += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 ' + eh + " " + ep + '">' + ed + (ex + eE + eC) + eN + "</svg>";
          break;
        case "g":
          eM += '<g width="' + eh + '" height="' + ep + '">' + ed + (ex + eE + eC) + eN + "</g>";
          break;
        default:
          eM += (ex + eE + eC + eN).replace(/^\s+/, "")
      }
      return eM
    }
      ,
      J.exports = QRCode
  },
  43604: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.LIB_VERSION = void 0,
      et.LIB_VERSION = "3.9.1"
  },
  74052: function (J, et, eo) {
    "use strict";
    eo.r(et),
      eo.d(et, {
        Component: function () {
          return b
        },
        Fragment: function () {
          return g
        },
        cloneElement: function () {
          return E
        },
        createContext: function () {
          return F
        },
        createElement: function () {
          return y
        },
        createRef: function () {
          return _
        },
        h: function () {
          return y
        },
        hydrate: function () {
          return B
        },
        isValidElement: function () {
          return eh
        },
        options: function () {
          return ec
        },
        render: function () {
          return q
        },
        toChildArray: function () {
          return function $(J, et) {
            return et = et || [],
              null == J || "boolean" == typeof J || (ex(J) ? J.some(function (J) {
                $(J, et)
              }) : et.push(J)),
              et
          }
        }
      });
    var el, ec, ed, eh, ep, ef, em, eg, ey, eb = {}, ew = [], e_ = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, ex = Array.isArray;
    function v(J, et) {
      for (var eo in et)
        J[eo] = et[eo];
      return J
    }
    function p(J) {
      var et = J.parentNode;
      et && et.removeChild(J)
    }
    function y(J, et, eo) {
      var ec, ed, eh, ep = {};
      for (eh in et)
        "key" == eh ? ec = et[eh] : "ref" == eh ? ed = et[eh] : ep[eh] = et[eh];
      if (arguments.length > 2 && (ep.children = arguments.length > 3 ? el.call(arguments, 2) : eo),
        "function" == typeof J && null != J.defaultProps)
        for (eh in J.defaultProps)
          void 0 === ep[eh] && (ep[eh] = J.defaultProps[eh]);
      return d(J, ep, ec, ed, null)
    }
    function d(J, et, eo, el, eh) {
      var ep = {
        type: J,
        props: et,
        key: eo,
        ref: el,
        __k: null,
        __: null,
        __b: 0,
        __e: null,
        __d: void 0,
        __c: null,
        constructor: void 0,
        __v: null == eh ? ++ed : eh,
        __i: -1,
        __u: 0
      };
      return null == eh && null != ec.vnode && ec.vnode(ep),
        ep
    }
    function _() {
      return {
        current: null
      }
    }
    function g(J) {
      return J.children
    }
    function b(J, et) {
      this.props = J,
        this.context = et
    }
    function m(J, et) {
      if (null == et)
        return J.__ ? m(J.__, J.__i + 1) : null;
      for (var eo; et < J.__k.length; et++)
        if (null != (eo = J.__k[et]) && null != eo.__e)
          return eo.__e;
      return "function" == typeof J.type ? m(J) : null
    }
    function w(J) {
      (!J.__d && (J.__d = !0) && ep.push(J) && !x.__r++ || ef !== ec.debounceRendering) && ((ef = ec.debounceRendering) || em)(x)
    }
    function x() {
      var J, et, eo, el, ed, eh, ef, em, ey;
      for (ep.sort(eg); J = ep.shift();)
        J.__d && (et = ep.length,
          el = void 0,
          eh = (ed = (eo = J).__v).__e,
          em = [],
          ey = [],
          (ef = eo.__P) && ((el = v({}, ed)).__v = ed.__v + 1,
            ec.vnode && ec.vnode(el),
            L(ef, el, ed, eo.__n, void 0 !== ef.ownerSVGElement, 32 & ed.__u ? [eh] : null, em, null == eh ? m(ed) : eh, !!(32 & ed.__u), ey),
            el.__.__k[el.__i] = el,
            M(em, el, ey),
            el.__e != eh && function k(J) {
              var et, eo;
              if (null != (J = J.__) && null != J.__c) {
                for (J.__e = J.__c.base = null,
                  et = 0; et < J.__k.length; et++)
                  if (null != (eo = J.__k[et]) && null != eo.__e) {
                    J.__e = J.__c.base = eo.__e;
                    break
                  }
                return k(J)
              }
            }(el)),
          ep.length > et && ep.sort(eg));
      x.__r = 0
    }
    function C(J, et, eo, el, ec, ed, eh, ep, ef, em, eg) {
      var ey, e_, eE, eC, eS, ek = el && el.__k || ew, eT = et.length;
      for (eo.__d = ef,
        function (J, et, eo) {
          var el, ec, ed, eh, ep, ef = et.length, em = eo.length, eg = em, ey = 0;
          for (J.__k = [],
            el = 0; el < ef; el++)
            null != (ec = J.__k[el] = null == (ec = et[el]) || "boolean" == typeof ec || "function" == typeof ec ? null : "string" == typeof ec || "number" == typeof ec || "bigint" == typeof ec || ec.constructor == String ? d(null, ec, null, null, ec) : ex(ec) ? d(g, {
              children: ec
            }, null, null, null) : void 0 === ec.constructor && ec.__b > 0 ? d(ec.type, ec.props, ec.key, ec.ref ? ec.ref : null, ec.__v) : ec) ? (ec.__ = J,
              ec.__b = J.__b + 1,
              ep = function (J, et, eo, el) {
                var ec = J.key
                  , ed = J.type
                  , eh = eo - 1
                  , ep = eo + 1
                  , ef = et[eo];
                if (null === ef || ef && ec == ef.key && ed === ef.type)
                  return eo;
                if (el > (null != ef && 0 == (131072 & ef.__u) ? 1 : 0))
                  for (; eh >= 0 || ep < et.length;) {
                    if (eh >= 0) {
                      if ((ef = et[eh]) && 0 == (131072 & ef.__u) && ec == ef.key && ed === ef.type)
                        return eh;
                      eh--
                    }
                    if (ep < et.length) {
                      if ((ef = et[ep]) && 0 == (131072 & ef.__u) && ec == ef.key && ed === ef.type)
                        return ep;
                      ep++
                    }
                  }
                return -1
              }(ec, eo, eh = el + ey, eg),
              ec.__i = ep,
              ed = null,
              -1 !== ep && (eg--,
                (ed = eo[ep]) && (ed.__u |= 131072)),
              null == ed || null === ed.__v ? (-1 == ep && ey--,
                "function" != typeof ec.type && (ec.__u |= 65536)) : ep !== eh && (ep === eh + 1 ? ey++ : ep > eh ? eg > ef - eh ? ey += ep - eh : ey-- : ey = ep < eh && ep == eh - 1 ? ep - eh : 0,
                  ep !== el + ey && (ec.__u |= 65536))) : (ed = eo[el]) && null == ed.key && ed.__e && (ed.__e == J.__d && (J.__d = m(ed)),
                    N(ed, ed, !1),
                    eo[el] = null,
                    eg--);
          if (eg)
            for (el = 0; el < em; el++)
              null != (ed = eo[el]) && 0 == (131072 & ed.__u) && (ed.__e == J.__d && (J.__d = m(ed)),
                N(ed, ed))
        }(eo, et, ek),
        ef = eo.__d,
        ey = 0; ey < eT; ey++)
        null != (eE = eo.__k[ey]) && "boolean" != typeof eE && "function" != typeof eE && (e_ = -1 === eE.__i ? eb : ek[eE.__i] || eb,
          eE.__i = ey,
          L(J, eE, e_, ec, ed, eh, ep, ef, em, eg),
          eC = eE.__e,
          eE.ref && e_.ref != eE.ref && (e_.ref && z(e_.ref, null, eE),
            eg.push(eE.ref, eE.__c || eC, eE)),
          null == eS && null != eC && (eS = eC),
          65536 & eE.__u || e_.__k === eE.__k ? ef = function S(J, et, eo) {
            var el, ec;
            if ("function" == typeof J.type) {
              for (el = J.__k,
                ec = 0; el && ec < el.length; ec++)
                el[ec] && (el[ec].__ = J,
                  et = S(el[ec], et, eo));
              return et
            }
            return J.__e != et && (eo.insertBefore(J.__e, et || null),
              et = J.__e),
              et && et.nextSibling
          }(eE, ef, J) : "function" == typeof eE.type && void 0 !== eE.__d ? ef = eE.__d : eC && (ef = eC.nextSibling),
          eE.__d = void 0,
          eE.__u &= -196609);
      eo.__d = ef,
        eo.__e = eS
    }
    function I(J, et, eo) {
      "-" === et[0] ? J.setProperty(et, null == eo ? "" : eo) : J[et] = null == eo ? "" : "number" != typeof eo || e_.test(et) ? eo : eo + "px"
    }
    function T(J, et, eo, el, ec) {
      var ed;
      e: if ("style" === et) {
        if ("string" == typeof eo)
          J.style.cssText = eo;
        else {
          if ("string" == typeof el && (J.style.cssText = el = ""),
            el)
            for (et in el)
              eo && et in eo || I(J.style, et, "");
          if (eo)
            for (et in eo)
              el && eo[et] === el[et] || I(J.style, et, eo[et])
        }
      } else if ("o" === et[0] && "n" === et[1])
        ed = et !== (et = et.replace(/(PointerCapture)$|Capture$/, "$1")),
          et = et.toLowerCase() in J ? et.toLowerCase().slice(2) : et.slice(2),
          J.l || (J.l = {}),
          J.l[et + ed] = eo,
          eo ? el ? eo.u = el.u : (eo.u = Date.now(),
            J.addEventListener(et, ed ? D : A, ed)) : J.removeEventListener(et, ed ? D : A, ed);
      else {
        if (ec)
          et = et.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
        else if ("width" !== et && "height" !== et && "href" !== et && "list" !== et && "form" !== et && "tabIndex" !== et && "download" !== et && "rowSpan" !== et && "colSpan" !== et && "role" !== et && et in J)
          try {
            J[et] = null == eo ? "" : eo;
            break e
          } catch (J) { }
        "function" == typeof eo || (null == eo || !1 === eo && "-" !== et[4] ? J.removeAttribute(et) : J.setAttribute(et, eo))
      }
    }
    function A(J) {
      var et = this.l[J.type + !1];
      if (J.t) {
        if (J.t <= et.u)
          return
      } else
        J.t = Date.now();
      return et(ec.event ? ec.event(J) : J)
    }
    function D(J) {
      return this.l[J.type + !0](ec.event ? ec.event(J) : J)
    }
    function L(J, et, eo, ed, eh, ep, ef, em, eg, ey) {
      var ew, e_, eE, eC, eS, ek, eT, eA, eP, eR, eI, eO, eN, eM, eD, ej = et.type;
      if (void 0 !== et.constructor)
        return null;
      128 & eo.__u && (eg = !!(32 & eo.__u),
        ep = [em = et.__e = eo.__e]),
        (ew = ec.__b) && ew(et);
      e: if ("function" == typeof ej)
        try {
          if (eA = et.props,
            eP = (ew = ej.contextType) && ed[ew.__c],
            eR = ew ? eP ? eP.props.value : ew.__ : ed,
            eo.__c ? eT = (e_ = et.__c = eo.__c).__ = e_.__E : ("prototype" in ej && ej.prototype.render ? et.__c = e_ = new ej(eA, eR) : (et.__c = e_ = new b(eA, eR),
              e_.constructor = ej,
              e_.render = O),
              eP && eP.sub(e_),
              e_.props = eA,
              e_.state || (e_.state = {}),
              e_.context = eR,
              e_.__n = ed,
              eE = e_.__d = !0,
              e_.__h = [],
              e_._sb = []),
            null == e_.__s && (e_.__s = e_.state),
            null != ej.getDerivedStateFromProps && (e_.__s == e_.state && (e_.__s = v({}, e_.__s)),
              v(e_.__s, ej.getDerivedStateFromProps(eA, e_.__s))),
            eC = e_.props,
            eS = e_.state,
            e_.__v = et,
            eE)
            null == ej.getDerivedStateFromProps && null != e_.componentWillMount && e_.componentWillMount(),
              null != e_.componentDidMount && e_.__h.push(e_.componentDidMount);
          else {
            if (null == ej.getDerivedStateFromProps && eA !== eC && null != e_.componentWillReceiveProps && e_.componentWillReceiveProps(eA, eR),
              !e_.__e && (null != e_.shouldComponentUpdate && !1 === e_.shouldComponentUpdate(eA, e_.__s, eR) || et.__v === eo.__v)) {
              for (et.__v !== eo.__v && (e_.props = eA,
                e_.state = e_.__s,
                e_.__d = !1),
                et.__e = eo.__e,
                et.__k = eo.__k,
                et.__k.forEach(function (J) {
                  J && (J.__ = et)
                }),
                eI = 0; eI < e_._sb.length; eI++)
                e_.__h.push(e_._sb[eI]);
              e_._sb = [],
                e_.__h.length && ef.push(e_);
              break e
            }
            null != e_.componentWillUpdate && e_.componentWillUpdate(eA, e_.__s, eR),
              null != e_.componentDidUpdate && e_.__h.push(function () {
                e_.componentDidUpdate(eC, eS, ek)
              })
          }
          if (e_.context = eR,
            e_.props = eA,
            e_.__P = J,
            e_.__e = !1,
            eO = ec.__r,
            eN = 0,
            "prototype" in ej && ej.prototype.render) {
            for (e_.state = e_.__s,
              e_.__d = !1,
              eO && eO(et),
              ew = e_.render(e_.props, e_.state, e_.context),
              eM = 0; eM < e_._sb.length; eM++)
              e_.__h.push(e_._sb[eM]);
            e_._sb = []
          } else
            do
              e_.__d = !1,
                eO && eO(et),
                ew = e_.render(e_.props, e_.state, e_.context),
                e_.state = e_.__s;
            while (e_.__d && ++eN < 25);
          e_.state = e_.__s,
            null != e_.getChildContext && (ed = v(v({}, ed), e_.getChildContext())),
            eE || null == e_.getSnapshotBeforeUpdate || (ek = e_.getSnapshotBeforeUpdate(eC, eS)),
            C(J, ex(eD = null != ew && ew.type === g && null == ew.key ? ew.props.children : ew) ? eD : [eD], et, eo, ed, eh, ep, ef, em, eg, ey),
            e_.base = et.__e,
            et.__u &= -161,
            e_.__h.length && ef.push(e_),
            eT && (e_.__E = e_.__ = null)
        } catch (J) {
          et.__v = null,
            eg || null != ep ? (et.__e = em,
              et.__u |= eg ? 160 : 32,
              ep[ep.indexOf(em)] = null) : (et.__e = eo.__e,
                et.__k = eo.__k),
            ec.__e(J, et, eo)
        }
      else
        null == ep && et.__v === eo.__v ? (et.__k = eo.__k,
          et.__e = eo.__e) : et.__e = function (J, et, eo, ec, ed, eh, ep, ef, em) {
            var eg, ey, ew, e_, eE, eC, eS, ek = eo.props, eT = et.props, eA = et.type;
            if ("svg" === eA && (ed = !0),
              null != eh) {
              for (eg = 0; eg < eh.length; eg++)
                if ((eE = eh[eg]) && "setAttribute" in eE == !!eA && (eA ? eE.localName === eA : 3 === eE.nodeType)) {
                  J = eE,
                    eh[eg] = null;
                  break
                }
            }
            if (null == J) {
              if (null === eA)
                return document.createTextNode(eT);
              J = ed ? document.createElementNS("http://www.w3.org/2000/svg", eA) : document.createElement(eA, eT.is && eT),
                eh = null,
                ef = !1
            }
            if (null === eA)
              ek === eT || ef && J.data === eT || (J.data = eT);
            else {
              if (eh = eh && el.call(J.childNodes),
                ek = eo.props || eb,
                !ef && null != eh)
                for (ek = {},
                  eg = 0; eg < J.attributes.length; eg++)
                  ek[(eE = J.attributes[eg]).name] = eE.value;
              for (eg in ek)
                eE = ek[eg],
                  "children" == eg || ("dangerouslySetInnerHTML" == eg ? ew = eE : "key" === eg || eg in eT || T(J, eg, null, eE, ed));
              for (eg in eT)
                eE = eT[eg],
                  "children" == eg ? e_ = eE : "dangerouslySetInnerHTML" == eg ? ey = eE : "value" == eg ? eC = eE : "checked" == eg ? eS = eE : "key" === eg || ef && "function" != typeof eE || ek[eg] === eE || T(J, eg, eE, ek[eg], ed);
              if (ey)
                ef || ew && (ey.__html === ew.__html || ey.__html === J.innerHTML) || (J.innerHTML = ey.__html),
                  et.__k = [];
              else if (ew && (J.innerHTML = ""),
                C(J, ex(e_) ? e_ : [e_], et, eo, ec, ed && "foreignObject" !== eA, eh, ep, eh ? eh[0] : eo.__k && m(eo, 0), ef, em),
                null != eh)
                for (eg = eh.length; eg--;)
                  null != eh[eg] && p(eh[eg]);
              ef || (eg = "value",
                void 0 === eC || eC === J[eg] && ("progress" !== eA || eC) && ("option" !== eA || eC === ek[eg]) || T(J, eg, eC, ek[eg], !1),
                eg = "checked",
                void 0 !== eS && eS !== J[eg] && T(J, eg, eS, ek[eg], !1))
            }
            return J
          }(eo.__e, et, eo, ed, eh, ep, ef, eg, ey);
      (ew = ec.diffed) && ew(et)
    }
    function M(J, et, eo) {
      et.__d = void 0;
      for (var el = 0; el < eo.length; el++)
        z(eo[el], eo[++el], eo[++el]);
      ec.__c && ec.__c(et, J),
        J.some(function (et) {
          try {
            J = et.__h,
              et.__h = [],
              J.some(function (J) {
                J.call(et)
              })
          } catch (J) {
            ec.__e(J, et.__v)
          }
        })
    }
    function z(J, et, eo) {
      try {
        "function" == typeof J ? J(et) : J.current = et
      } catch (J) {
        ec.__e(J, eo)
      }
    }
    function N(J, et, eo) {
      var el, ed;
      if (ec.unmount && ec.unmount(J),
        (el = J.ref) && (el.current && el.current !== J.__e || z(el, null, et)),
        null != (el = J.__c)) {
        if (el.componentWillUnmount)
          try {
            el.componentWillUnmount()
          } catch (J) {
            ec.__e(J, et)
          }
        el.base = el.__P = null,
          J.__c = void 0
      }
      if (el = J.__k)
        for (ed = 0; ed < el.length; ed++)
          el[ed] && N(el[ed], et, eo || "function" != typeof J.type);
      eo || null == J.__e || p(J.__e),
        J.__ = J.__e = J.__d = void 0
    }
    function O(J, et, eo) {
      return this.constructor(J, eo)
    }
    function q(J, et, eo) {
      var ed, eh, ep, ef;
      ec.__ && ec.__(J, et),
        eh = (ed = "function" == typeof eo) ? null : eo && eo.__k || et.__k,
        ep = [],
        ef = [],
        L(et, J = (!ed && eo || et).__k = y(g, null, [J]), eh || eb, eb, void 0 !== et.ownerSVGElement, !ed && eo ? [eo] : eh ? null : et.firstChild ? el.call(et.childNodes) : null, ep, !ed && eo ? eo : eh ? eh.__e : et.firstChild, ed, ef),
        M(ep, J, ef)
    }
    function B(J, et) {
      q(J, et, B)
    }
    function E(J, et, eo) {
      var ec, ed, eh, ep, ef = v({}, J.props);
      for (eh in J.type && J.type.defaultProps && (ep = J.type.defaultProps),
        et)
        "key" == eh ? ec = et[eh] : "ref" == eh ? ed = et[eh] : ef[eh] = void 0 === et[eh] && void 0 !== ep ? ep[eh] : et[eh];
      return arguments.length > 2 && (ef.children = arguments.length > 3 ? el.call(arguments, 2) : eo),
        d(J.type, ef, ec || J.key, ed || J.ref, null)
    }
    function F(J, et) {
      var eo = {
        __c: et = "__cC" + ey++,
        __: J,
        Consumer: function (J, et) {
          return J.children(et)
        },
        Provider: function (J) {
          var eo, el;
          return this.getChildContext || (eo = [],
            (el = {})[et] = this,
            this.getChildContext = function () {
              return el
            }
            ,
            this.shouldComponentUpdate = function (J) {
              this.props.value !== J.value && eo.some(function (J) {
                J.__e = !0,
                  w(J)
              })
            }
            ,
            this.sub = function (J) {
              eo.push(J);
              var et = J.componentWillUnmount;
              J.componentWillUnmount = function () {
                eo.splice(eo.indexOf(J), 1),
                  et && et.call(J)
              }
            }
          ),
            J.children
        }
      };
      return eo.Provider.__ = eo.Consumer.contextType = eo
    }
    el = ew.slice,
      ec = {
        __e: function (J, et, eo, el) {
          for (var ec, ed, eh; et = et.__;)
            if ((ec = et.__c) && !ec.__)
              try {
                if ((ed = ec.constructor) && null != ed.getDerivedStateFromError && (ec.setState(ed.getDerivedStateFromError(J)),
                  eh = ec.__d),
                  null != ec.componentDidCatch && (ec.componentDidCatch(J, el || {}),
                    eh = ec.__d),
                  eh)
                  return ec.__E = ec
              } catch (et) {
                J = et
              }
          throw J
        }
      },
      ed = 0,
      eh = function (J) {
        return null != J && null == J.constructor
      }
      ,
      b.prototype.setState = function (J, et) {
        var eo;
        eo = null != this.__s && this.__s !== this.state ? this.__s : this.__s = v({}, this.state),
          "function" == typeof J && (J = J(v({}, eo), this.props)),
          J && v(eo, J),
          null != J && this.__v && (et && this._sb.push(et),
            w(this))
      }
      ,
      b.prototype.forceUpdate = function (J) {
        this.__v && (this.__e = !0,
          J && this.__h.push(J),
          w(this))
      }
      ,
      b.prototype.render = g,
      ep = [],
      em = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout,
      eg = function (J, et) {
        return J.__v.__b - et.__v.__b
      }
      ,
      x.__r = 0,
      ey = 0
  },
  54971: function (J, et, eo) {
    "use strict";
    eo.r(et),
      eo.d(et, {
        useCallback: function () {
          return T
        },
        useContext: function () {
          return q
        },
        useDebugValue: function () {
          return x
        },
        useEffect: function () {
          return p
        },
        useErrorBoundary: function () {
          return P
        },
        useId: function () {
          return V
        },
        useImperativeHandle: function () {
          return A
        },
        useLayoutEffect: function () {
          return y
        },
        useMemo: function () {
          return F
        },
        useReducer: function () {
          return s
        },
        useRef: function () {
          return _
        },
        useState: function () {
          return h
        }
      });
    var el, ec, ed, eh, ep = eo(74052), ef = 0, em = [], eg = [], ey = ep.options.__b, eb = ep.options.__r, ew = ep.options.diffed, e_ = ep.options.__c, ex = ep.options.unmount;
    function d(J, et) {
      ep.options.__h && ep.options.__h(ec, J, ef || et),
        ef = 0;
      var eo = ec.__H || (ec.__H = {
        __: [],
        __h: []
      });
      return J >= eo.__.length && eo.__.push({
        __V: eg
      }),
        eo.__[J]
    }
    function h(J) {
      return ef = 1,
        s(B, J)
    }
    function s(J, et, eo) {
      var ed = d(el++, 2);
      if (ed.t = J,
        !ed.__c && (ed.__ = [eo ? eo(et) : B(void 0, et), function (J) {
          var et = ed.__N ? ed.__N[0] : ed.__[0]
            , eo = ed.t(et, J);
          et !== eo && (ed.__N = [eo, ed.__[1]],
            ed.__c.setState({}))
        }
        ],
          ed.__c = ec,
          !ec.u)) {
        var f = function (J, et, eo) {
          if (!ed.__c.__H)
            return !0;
          var el = ed.__c.__H.__.filter(function (J) {
            return J.__c
          });
          if (el.every(function (J) {
            return !J.__N
          }))
            return !eh || eh.call(this, J, et, eo);
          var ec = !1;
          return el.forEach(function (J) {
            if (J.__N) {
              var et = J.__[0];
              J.__ = J.__N,
                J.__N = void 0,
                et !== J.__[0] && (ec = !0)
            }
          }),
            !(!ec && ed.__c.props === J) && (!eh || eh.call(this, J, et, eo))
        };
        ec.u = !0;
        var eh = ec.shouldComponentUpdate
          , ep = ec.componentWillUpdate;
        ec.componentWillUpdate = function (J, et, eo) {
          if (this.__e) {
            var el = eh;
            eh = void 0,
              f(J, et, eo),
              eh = el
          }
          ep && ep.call(this, J, et, eo)
        }
          ,
          ec.shouldComponentUpdate = f
      }
      return ed.__N || ed.__
    }
    function p(J, et) {
      var eo = d(el++, 3);
      !ep.options.__s && z(eo.__H, et) && (eo.__ = J,
        eo.i = et,
        ec.__H.__h.push(eo))
    }
    function y(J, et) {
      var eo = d(el++, 4);
      !ep.options.__s && z(eo.__H, et) && (eo.__ = J,
        eo.i = et,
        ec.__h.push(eo))
    }
    function _(J) {
      return ef = 5,
        F(function () {
          return {
            current: J
          }
        }, [])
    }
    function A(J, et, eo) {
      ef = 6,
        y(function () {
          return "function" == typeof J ? (J(et()),
            function () {
              return J(null)
            }
          ) : J ? (J.current = et(),
            function () {
              return J.current = null
            }
          ) : void 0
        }, null == eo ? eo : eo.concat(J))
    }
    function F(J, et) {
      var eo = d(el++, 7);
      return z(eo.__H, et) ? (eo.__V = J(),
        eo.i = et,
        eo.__h = J,
        eo.__V) : eo.__
    }
    function T(J, et) {
      return ef = 8,
        F(function () {
          return J
        }, et)
    }
    function q(J) {
      var et = ec.context[J.__c]
        , eo = d(el++, 9);
      return eo.c = J,
        et ? (null == eo.__ && (eo.__ = !0,
          et.sub(ec)),
          et.props.value) : J.__
    }
    function x(J, et) {
      ep.options.useDebugValue && ep.options.useDebugValue(et ? et(J) : J)
    }
    function P(J) {
      var et = d(el++, 10)
        , eo = h();
      return et.__ = J,
        ec.componentDidCatch || (ec.componentDidCatch = function (J, el) {
          et.__ && et.__(J, el),
            eo[1](J)
        }
        ),
        [eo[0], function () {
          eo[1](void 0)
        }
        ]
    }
    function V() {
      var J = d(el++, 11);
      if (!J.__) {
        for (var et = ec.__v; null !== et && !et.__m && null !== et.__;)
          et = et.__;
        var eo = et.__m || (et.__m = [0, 0]);
        J.__ = "P" + eo[0] + "-" + eo[1]++
      }
      return J.__
    }
    function b() {
      for (var J; J = em.shift();)
        if (J.__P && J.__H)
          try {
            J.__H.__h.forEach(k),
              J.__H.__h.forEach(w),
              J.__H.__h = []
          } catch (et) {
            J.__H.__h = [],
              ep.options.__e(et, J.__v)
          }
    }
    ep.options.__b = function (J) {
      ec = null,
        ey && ey(J)
    }
      ,
      ep.options.__r = function (J) {
        eb && eb(J),
          el = 0;
        var et = (ec = J.__c).__H;
        et && (ed === ec ? (et.__h = [],
          ec.__h = [],
          et.__.forEach(function (J) {
            J.__N && (J.__ = J.__N),
              J.__V = eg,
              J.__N = J.i = void 0
          })) : (et.__h.forEach(k),
            et.__h.forEach(w),
            et.__h = [],
            el = 0)),
          ed = ec
      }
      ,
      ep.options.diffed = function (J) {
        ew && ew(J);
        var et = J.__c;
        et && et.__H && (et.__H.__h.length && (1 !== em.push(et) && eh === ep.options.requestAnimationFrame || ((eh = ep.options.requestAnimationFrame) || function (J) {
          var et, r = function () {
            clearTimeout(eo),
              eE && cancelAnimationFrame(et),
              setTimeout(J)
          }, eo = setTimeout(r, 100);
          eE && (et = requestAnimationFrame(r))
        }
        )(b)),
          et.__H.__.forEach(function (J) {
            J.i && (J.__H = J.i),
              J.__V !== eg && (J.__ = J.__V),
              J.i = void 0,
              J.__V = eg
          })),
          ed = ec = null
      }
      ,
      ep.options.__c = function (J, et) {
        et.some(function (J) {
          try {
            J.__h.forEach(k),
              J.__h = J.__h.filter(function (J) {
                return !J.__ || w(J)
              })
          } catch (eo) {
            et.some(function (J) {
              J.__h && (J.__h = [])
            }),
              et = [],
              ep.options.__e(eo, J.__v)
          }
        }),
          e_ && e_(J, et)
      }
      ,
      ep.options.unmount = function (J) {
        ex && ex(J);
        var et, eo = J.__c;
        eo && eo.__H && (eo.__H.__.forEach(function (J) {
          try {
            k(J)
          } catch (J) {
            et = J
          }
        }),
          eo.__H = void 0,
          et && ep.options.__e(et, eo.__v))
      }
      ;
    var eE = "function" == typeof requestAnimationFrame;
    function k(J) {
      var et = ec
        , eo = J.__c;
      "function" == typeof eo && (J.__c = void 0,
        eo()),
        ec = et
    }
    function w(J) {
      var et = ec;
      J.__c = J.__(),
        ec = et
    }
    function z(J, et) {
      return !J || J.length !== et.length || et.some(function (et, eo) {
        return et !== J[eo]
      })
    }
    function B(J, et) {
      return "function" == typeof et ? et(J) : et
    }
  },
  71068: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      Z: function () {
        return ed
      }
    });
    var el = eo(45042)
      , ec = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/
      , ed = (0,
        el.Z)(function (J) {
          return ec.test(J) || 111 === J.charCodeAt(0) && 110 === J.charCodeAt(1) && 91 > J.charCodeAt(2)
        })
  },
  45042: function (J, et, eo) {
    "use strict";
    function memoize(J) {
      var et = Object.create(null);
      return function (eo) {
        return void 0 === et[eo] && (et[eo] = J(eo)),
          et[eo]
      }
    }
    eo.d(et, {
      Z: function () {
        return memoize
      }
    })
  },
  19394: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    });
    let el = eo(17187);
    function safeApply(J, et, eo) {
      try {
        Reflect.apply(J, et, eo)
      } catch (J) {
        setTimeout(() => {
          throw J
        }
        )
      }
    }
    let SafeEventEmitter = class SafeEventEmitter extends el.EventEmitter {
      emit(J, ...et) {
        let eo = "error" === J
          , el = this._events;
        if (void 0 !== el)
          eo = eo && void 0 === el.error;
        else if (!eo)
          return !1;
        if (eo) {
          let J;
          if (et.length > 0 && ([J] = et),
            J instanceof Error)
            throw J;
          let eo = Error(`Unhandled error.${J ? ` (${J.message})` : ""}`);
          throw eo.context = J,
          eo
        }
        let ec = el[J];
        if (void 0 === ec)
          return !1;
        if ("function" == typeof ec)
          safeApply(ec, this, et);
        else {
          let J = ec.length
            , eo = function (J) {
              let et = J.length
                , eo = Array(et);
              for (let el = 0; el < et; el += 1)
                eo[el] = J[el];
              return eo
            }(ec);
          for (let el = 0; el < J; el += 1)
            safeApply(eo[el], this, et)
        }
        return !0
      }
    }
      ;
    et.default = SafeEventEmitter
  },
  31422: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.assertExhaustive = et.assertStruct = et.assert = et.AssertionError = void 0;
    let el = eo(97884);
    function getError(J, et) {
      var eo, el;
      return "string" == typeof (null === (el = null === (eo = null == J ? void 0 : J.prototype) || void 0 === eo ? void 0 : eo.constructor) || void 0 === el ? void 0 : el.name) ? new J({
        message: et
      }) : J({
        message: et
      })
    }
    let AssertionError = class AssertionError extends Error {
      constructor(J) {
        super(J.message),
          this.code = "ERR_ASSERTION"
      }
    }
      ;
    et.AssertionError = AssertionError,
      et.assert = function (J, et = "Assertion failed.", eo = AssertionError) {
        if (!J) {
          if (et instanceof Error)
            throw et;
          throw getError(eo, et)
        }
      }
      ,
      et.assertStruct = function (J, et, eo = "Assertion failed", ec = AssertionError) {
        try {
          (0,
            el.assert)(J, et)
        } catch (J) {
          throw getError(ec, `${eo}: ${function (J) {
            letet = "object" == typeof J && null !== J && "message" in J ? J.message : String(J);
            return et.endsWith(".") ? et.slice(0, -1) : et
          }(J)}.`)
        }
      }
      ,
      et.assertExhaustive = function (J) {
        throw Error("Invalid branch reached. Should be detected during compilation.")
      }
  },
  47207: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.base64 = void 0;
    let el = eo(97884)
      , ec = eo(31422);
    et.base64 = (J, et = {}) => {
      var eo, ed;
      let eh, ep;
      let ef = null !== (eo = et.paddingRequired) && void 0 !== eo && eo
        , em = null !== (ed = et.characterSet) && void 0 !== ed ? ed : "base64";
      return "base64" === em ? eh = String.raw`[A-Za-z0-9+\/]` : ((0,
        ec.assert)("base64url" === em),
        eh = String.raw`[-_A-Za-z0-9]`),
        ep = ef ? RegExp(`^(?:${eh}{4})*(?:${eh}{3}=|${eh}{2}==)?$`, "u") : RegExp(`^(?:${eh}{4})*(?:${eh}{2,3}|${eh}{3}=|${eh}{2}==)?$`, "u"),
        (0,
          el.pattern)(J, ep)
    }
  },
  8476: function (J, et, eo) {
    "use strict";
    var el = eo(48764).Buffer;
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.createDataView = et.concatBytes = et.valueToBytes = et.stringToBytes = et.numberToBytes = et.signedBigIntToBytes = et.bigIntToBytes = et.hexToBytes = et.bytesToString = et.bytesToNumber = et.bytesToSignedBigInt = et.bytesToBigInt = et.bytesToHex = et.assertIsBytes = et.isBytes = void 0;
    let ec = eo(31422)
      , ed = eo(62009)
      , eh = function () {
        let J = [];
        return () => {
          if (0 === J.length)
            for (let et = 0; et < 256; et++)
              J.push(et.toString(16).padStart(2, "0"));
          return J
        }
      }();
    function isBytes(J) {
      return J instanceof Uint8Array
    }
    function assertIsBytes(J) {
      (0,
        ec.assert)(isBytes(J), "Value must be a Uint8Array.")
    }
    function bytesToHex(J) {
      if (assertIsBytes(J),
        0 === J.length)
        return "0x";
      let et = eh()
        , eo = Array(J.length);
      for (let el = 0; el < J.length; el++)
        eo[el] = et[J[el]];
      return (0,
        ed.add0x)(eo.join(""))
    }
    function bytesToBigInt(J) {
      assertIsBytes(J);
      let et = bytesToHex(J);
      return BigInt(et)
    }
    function hexToBytes(J) {
      var et;
      if ((null === (et = null == J ? void 0 : J.toLowerCase) || void 0 === et ? void 0 : et.call(J)) === "0x")
        return new Uint8Array;
      (0,
        ed.assertIsHexString)(J);
      let eo = (0,
        ed.remove0x)(J).toLowerCase()
        , el = eo.length % 2 == 0 ? eo : `0${eo}`
        , ec = new Uint8Array(el.length / 2);
      for (let J = 0; J < ec.length; J++) {
        let et = el.charCodeAt(2 * J)
          , eo = el.charCodeAt(2 * J + 1)
          , ed = et - (et < 58 ? 48 : 87)
          , eh = eo - (eo < 58 ? 48 : 87);
        ec[J] = 16 * ed + eh
      }
      return ec
    }
    function bigIntToBytes(J) {
      (0,
        ec.assert)("bigint" == typeof J, "Value must be a bigint."),
        (0,
          ec.assert)(J >= BigInt(0), "Value must be a non-negative bigint.");
      let et = J.toString(16);
      return hexToBytes(et)
    }
    function numberToBytes(J) {
      (0,
        ec.assert)("number" == typeof J, "Value must be a number."),
        (0,
          ec.assert)(J >= 0, "Value must be a non-negative number."),
        (0,
          ec.assert)(Number.isSafeInteger(J), "Value is not a safe integer. Use `bigIntToBytes` instead.");
      let et = J.toString(16);
      return hexToBytes(et)
    }
    function stringToBytes(J) {
      return (0,
        ec.assert)("string" == typeof J, "Value must be a string."),
        new TextEncoder().encode(J)
    }
    function valueToBytes(J) {
      if ("bigint" == typeof J)
        return bigIntToBytes(J);
      if ("number" == typeof J)
        return numberToBytes(J);
      if ("string" == typeof J)
        return J.startsWith("0x") ? hexToBytes(J) : stringToBytes(J);
      if (isBytes(J))
        return J;
      throw TypeError(`Unsupported value type: "${typeof J}".`)
    }
    et.isBytes = isBytes,
      et.assertIsBytes = assertIsBytes,
      et.bytesToHex = bytesToHex,
      et.bytesToBigInt = bytesToBigInt,
      et.bytesToSignedBigInt = function (J) {
        assertIsBytes(J);
        let et = BigInt(0);
        for (let eo of J)
          et = (et << BigInt(8)) + BigInt(eo);
        return BigInt.asIntN(8 * J.length, et)
      }
      ,
      et.bytesToNumber = function (J) {
        assertIsBytes(J);
        let et = bytesToBigInt(J);
        return (0,
          ec.assert)(et <= BigInt(Number.MAX_SAFE_INTEGER), "Number is not a safe integer. Use `bytesToBigInt` instead."),
          Number(et)
      }
      ,
      et.bytesToString = function (J) {
        return assertIsBytes(J),
          new TextDecoder().decode(J)
      }
      ,
      et.hexToBytes = hexToBytes,
      et.bigIntToBytes = bigIntToBytes,
      et.signedBigIntToBytes = function (J, et) {
        (0,
          ec.assert)("bigint" == typeof J, "Value must be a bigint."),
          (0,
            ec.assert)("number" == typeof et, "Byte length must be a number."),
          (0,
            ec.assert)(et > 0, "Byte length must be greater than 0."),
          (0,
            ec.assert)(function (J, et) {
              (0,
                ec.assert)(et > 0);
              let eo = J >> BigInt(31);
              return !((~J & eo) + (J & ~eo) >> BigInt(8 * et + -1))
            }(J, et), "Byte length is too small to represent the given value.");
        let eo = J
          , el = new Uint8Array(et);
        for (let J = 0; J < el.length; J++)
          el[J] = Number(BigInt.asUintN(8, eo)),
            eo >>= BigInt(8);
        return el.reverse()
      }
      ,
      et.numberToBytes = numberToBytes,
      et.stringToBytes = stringToBytes,
      et.valueToBytes = valueToBytes,
      et.concatBytes = function (J) {
        let et = Array(J.length)
          , eo = 0;
        for (let el = 0; el < J.length; el++) {
          let ec = valueToBytes(J[el]);
          et[el] = ec,
            eo += ec.length
        }
        let el = new Uint8Array(eo);
        for (let J = 0, eo = 0; J < et.length; J++)
          el.set(et[J], eo),
            eo += et[J].length;
        return el
      }
      ,
      et.createDataView = function (J) {
        if (void 0 !== el && J instanceof el) {
          let et = J.buffer.slice(J.byteOffset, J.byteOffset + J.byteLength);
          return new DataView(et)
        }
        return new DataView(J.buffer, J.byteOffset, J.byteLength)
      }
  },
  85013: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.ChecksumStruct = void 0;
    let el = eo(97884)
      , ec = eo(47207);
    et.ChecksumStruct = (0,
      el.size)((0,
        ec.base64)((0,
          el.string)(), {
          paddingRequired: !0
        }), 44, 44)
  },
  73557: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.createHex = et.createBytes = et.createBigInt = et.createNumber = void 0;
    let el = eo(97884)
      , ec = eo(31422)
      , ed = eo(8476)
      , eh = eo(62009)
      , ep = (0,
        el.union)([(0,
          el.number)(), (0,
            el.bigint)(), (0,
              el.string)(), eh.StrictHexStruct])
      , ef = (0,
        el.coerce)((0,
          el.number)(), ep, Number)
      , em = (0,
        el.coerce)((0,
          el.bigint)(), ep, BigInt);
    (0,
      el.union)([eh.StrictHexStruct, (0,
        el.instance)(Uint8Array)]);
    let eg = (0,
      el.coerce)((0,
        el.instance)(Uint8Array), (0,
          el.union)([eh.StrictHexStruct]), ed.hexToBytes)
      , ey = (0,
        el.coerce)(eh.StrictHexStruct, (0,
          el.instance)(Uint8Array), ed.bytesToHex);
    et.createNumber = function (J) {
      try {
        let et = (0,
          el.create)(J, ef);
        return (0,
          ec.assert)(Number.isFinite(et), `Expected a number-like value, got "${J}".`),
          et
      } catch (et) {
        if (et instanceof el.StructError)
          throw Error(`Expected a number-like value, got "${J}".`);
        throw et
      }
    }
      ,
      et.createBigInt = function (J) {
        try {
          return (0,
            el.create)(J, em)
        } catch (J) {
          if (J instanceof el.StructError)
            throw Error(`Expected a number-like value, got "${String(J.value)}".`);
          throw J
        }
      }
      ,
      et.createBytes = function (J) {
        if ("string" == typeof J && "0x" === J.toLowerCase())
          return new Uint8Array;
        try {
          return (0,
            el.create)(J, eg)
        } catch (J) {
          if (J instanceof el.StructError)
            throw Error(`Expected a bytes-like value, got "${String(J.value)}".`);
          throw J
        }
      }
      ,
      et.createHex = function (J) {
        if (J instanceof Uint8Array && 0 === J.length || "string" == typeof J && "0x" === J.toLowerCase())
          return "0x";
        try {
          return (0,
            el.create)(J, ey)
        } catch (J) {
          if (J instanceof el.StructError)
            throw Error(`Expected a bytes-like value, got "${String(J.value)}".`);
          throw J
        }
      }
  },
  94283: function (J, et) {
    "use strict";
    var eo, el, ec = this && this.__classPrivateFieldSet || function (J, et, eo, el, ec) {
      if ("m" === el)
        throw TypeError("Private method is not writable");
      if ("a" === el && !ec)
        throw TypeError("Private accessor was defined without a setter");
      if ("function" == typeof et ? J !== et || !ec : !et.has(J))
        throw TypeError("Cannot write private member to an object whose class did not declare it");
      return "a" === el ? ec.call(J, eo) : ec ? ec.value = eo : et.set(J, eo),
        eo
    }
      , ed = this && this.__classPrivateFieldGet || function (J, et, eo, el) {
        if ("a" === eo && !el)
          throw TypeError("Private accessor was defined without a getter");
        if ("function" == typeof et ? J !== et || !el : !et.has(J))
          throw TypeError("Cannot read private member from an object whose class did not declare it");
        return "m" === eo ? el : "a" === eo ? el.call(J) : el ? el.value : et.get(J)
      }
      ;
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.FrozenSet = et.FrozenMap = void 0;
    let FrozenMap = class FrozenMap {
      constructor(J) {
        eo.set(this, void 0),
          ec(this, eo, new Map(J), "f"),
          Object.freeze(this)
      }
      get size() {
        return ed(this, eo, "f").size
      }
      [(eo = new WeakMap,
        Symbol.iterator)]() {
        return ed(this, eo, "f")[Symbol.iterator]()
      }
      entries() {
        return ed(this, eo, "f").entries()
      }
      forEach(J, et) {
        return ed(this, eo, "f").forEach((eo, el, ec) => J.call(et, eo, el, this))
      }
      get(J) {
        return ed(this, eo, "f").get(J)
      }
      has(J) {
        return ed(this, eo, "f").has(J)
      }
      keys() {
        return ed(this, eo, "f").keys()
      }
      values() {
        return ed(this, eo, "f").values()
      }
      toString() {
        return `FrozenMap(${this.size}) {${this.size > 0 ? ` ${[...this.entries()].map(([J, et]) => `${String(J)} => ${String(et)}`).join(", ")} ` : ""}}`
      }
    }
      ;
    et.FrozenMap = FrozenMap;
    let FrozenSet = class FrozenSet {
      constructor(J) {
        el.set(this, void 0),
          ec(this, el, new Set(J), "f"),
          Object.freeze(this)
      }
      get size() {
        return ed(this, el, "f").size
      }
      [(el = new WeakMap,
        Symbol.iterator)]() {
        return ed(this, el, "f")[Symbol.iterator]()
      }
      entries() {
        return ed(this, el, "f").entries()
      }
      forEach(J, et) {
        return ed(this, el, "f").forEach((eo, el, ec) => J.call(et, eo, el, this))
      }
      has(J) {
        return ed(this, el, "f").has(J)
      }
      keys() {
        return ed(this, el, "f").keys()
      }
      values() {
        return ed(this, el, "f").values()
      }
      toString() {
        return `FrozenSet(${this.size}) {${this.size > 0 ? ` ${[...this.values()].map(J => String(J)).join(", ")} ` : ""}}`
      }
    }
      ;
    et.FrozenSet = FrozenSet,
      Object.freeze(FrozenMap),
      Object.freeze(FrozenMap.prototype),
      Object.freeze(FrozenSet),
      Object.freeze(FrozenSet.prototype)
  },
  25345: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    })
  },
  62009: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.remove0x = et.add0x = et.assertIsStrictHexString = et.assertIsHexString = et.isStrictHexString = et.isHexString = et.StrictHexStruct = et.HexStruct = void 0;
    let el = eo(97884)
      , ec = eo(31422);
    function isHexString(J) {
      return (0,
        el.is)(J, et.HexStruct)
    }
    function isStrictHexString(J) {
      return (0,
        el.is)(J, et.StrictHexStruct)
    }
    et.HexStruct = (0,
      el.pattern)((0,
        el.string)(), /^(?:0x)?[0-9a-f]+$/iu),
      et.StrictHexStruct = (0,
        el.pattern)((0,
          el.string)(), /^0x[0-9a-f]+$/iu),
      et.isHexString = isHexString,
      et.isStrictHexString = isStrictHexString,
      et.assertIsHexString = function (J) {
        (0,
          ec.assert)(isHexString(J), "Value must be a hexadecimal string.")
      }
      ,
      et.assertIsStrictHexString = function (J) {
        (0,
          ec.assert)(isStrictHexString(J), 'Value must be a hexadecimal string, starting with "0x".')
      }
      ,
      et.add0x = function (J) {
        return J.startsWith("0x") ? J : J.startsWith("0X") ? `0x${J.substring(2)}` : `0x${J}`
      }
      ,
      et.remove0x = function (J) {
        return J.startsWith("0x") || J.startsWith("0X") ? J.substring(2) : J
      }
  },
  42451: function (J, et, eo) {
    "use strict";
    var el = this && this.__createBinding || (Object.create ? function (J, et, eo, el) {
      void 0 === el && (el = eo);
      var ec = Object.getOwnPropertyDescriptor(et, eo);
      (!ec || ("get" in ec ? !et.__esModule : ec.writable || ec.configurable)) && (ec = {
        enumerable: !0,
        get: function () {
          return et[eo]
        }
      }),
        Object.defineProperty(J, el, ec)
    }
      : function (J, et, eo, el) {
        void 0 === el && (el = eo),
          J[el] = et[eo]
      }
    )
      , ec = this && this.__exportStar || function (J, et) {
        for (var eo in J)
          "default" === eo || Object.prototype.hasOwnProperty.call(et, eo) || el(et, J, eo)
      }
      ;
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      ec(eo(31422), et),
      ec(eo(47207), et),
      ec(eo(8476), et),
      ec(eo(85013), et),
      ec(eo(73557), et),
      ec(eo(94283), et),
      ec(eo(25345), et),
      ec(eo(62009), et),
      ec(eo(22497), et),
      ec(eo(23732), et),
      ec(eo(20160), et),
      ec(eo(66215), et),
      ec(eo(89679), et),
      ec(eo(99108), et),
      ec(eo(97772), et),
      ec(eo(17749), et),
      ec(eo(88426), et)
  },
  22497: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.getJsonRpcIdValidator = et.assertIsJsonRpcError = et.isJsonRpcError = et.assertIsJsonRpcFailure = et.isJsonRpcFailure = et.assertIsJsonRpcSuccess = et.isJsonRpcSuccess = et.assertIsJsonRpcResponse = et.isJsonRpcResponse = et.assertIsPendingJsonRpcResponse = et.isPendingJsonRpcResponse = et.JsonRpcResponseStruct = et.JsonRpcFailureStruct = et.JsonRpcSuccessStruct = et.PendingJsonRpcResponseStruct = et.assertIsJsonRpcRequest = et.isJsonRpcRequest = et.assertIsJsonRpcNotification = et.isJsonRpcNotification = et.JsonRpcNotificationStruct = et.JsonRpcRequestStruct = et.JsonRpcParamsStruct = et.JsonRpcErrorStruct = et.JsonRpcIdStruct = et.JsonRpcVersionStruct = et.jsonrpc2 = et.getJsonSize = et.isValidJson = et.JsonStruct = et.UnsafeJsonStruct = void 0;
    let el = eo(97884)
      , ec = eo(31422);
    et.UnsafeJsonStruct = (0,
      el.union)([(0,
        el.literal)(null), (0,
          el.boolean)(), (0,
            el.define)("finite number", J => (0,
              el.is)(J, (0,
                el.number)()) && Number.isFinite(J)), (0,
                  el.string)(), (0,
                    el.array)((0,
                      el.lazy)(() => et.UnsafeJsonStruct)), (0,
                        el.record)((0,
                          el.string)(), (0,
                            el.lazy)(() => et.UnsafeJsonStruct))]),
      et.JsonStruct = (0,
        el.define)("Json", (J, eo) => {
          function checkStruct(J, et) {
            let el = et.validator(J, eo)
              , ec = [...el];
            return !(ec.length > 0) || ec
          }
          try {
            let eo = checkStruct(J, et.UnsafeJsonStruct);
            if (!0 !== eo)
              return eo;
            return checkStruct(JSON.parse(JSON.stringify(J)), et.UnsafeJsonStruct)
          } catch (J) {
            if (J instanceof RangeError)
              return "Circular reference detected";
            return !1
          }
        }
        ),
      et.isValidJson = function (J) {
        return (0,
          el.is)(J, et.JsonStruct)
      }
      ,
      et.getJsonSize = function (J) {
        (0,
          ec.assertStruct)(J, et.JsonStruct, "Invalid JSON value");
        let eo = JSON.stringify(J);
        return new TextEncoder().encode(eo).byteLength
      }
      ,
      et.jsonrpc2 = "2.0",
      et.JsonRpcVersionStruct = (0,
        el.literal)(et.jsonrpc2),
      et.JsonRpcIdStruct = (0,
        el.nullable)((0,
          el.union)([(0,
            el.number)(), (0,
              el.string)()])),
      et.JsonRpcErrorStruct = (0,
        el.object)({
          code: (0,
            el.integer)(),
          message: (0,
            el.string)(),
          data: (0,
            el.optional)(et.JsonStruct),
          stack: (0,
            el.optional)((0,
              el.string)())
        }),
      et.JsonRpcParamsStruct = (0,
        el.optional)((0,
          el.union)([(0,
            el.record)((0,
              el.string)(), et.JsonStruct), (0,
                el.array)(et.JsonStruct)])),
      et.JsonRpcRequestStruct = (0,
        el.object)({
          id: et.JsonRpcIdStruct,
          jsonrpc: et.JsonRpcVersionStruct,
          method: (0,
            el.string)(),
          params: et.JsonRpcParamsStruct
        }),
      et.JsonRpcNotificationStruct = (0,
        el.omit)(et.JsonRpcRequestStruct, ["id"]),
      et.isJsonRpcNotification = function (J) {
        return (0,
          el.is)(J, et.JsonRpcNotificationStruct)
      }
      ,
      et.assertIsJsonRpcNotification = function (J, eo) {
        (0,
          ec.assertStruct)(J, et.JsonRpcNotificationStruct, "Invalid JSON-RPC notification", eo)
      }
      ,
      et.isJsonRpcRequest = function (J) {
        return (0,
          el.is)(J, et.JsonRpcRequestStruct)
      }
      ,
      et.assertIsJsonRpcRequest = function (J, eo) {
        (0,
          ec.assertStruct)(J, et.JsonRpcRequestStruct, "Invalid JSON-RPC request", eo)
      }
      ,
      et.PendingJsonRpcResponseStruct = (0,
        el.object)({
          id: et.JsonRpcIdStruct,
          jsonrpc: et.JsonRpcVersionStruct,
          result: (0,
            el.optional)((0,
              el.unknown)()),
          error: (0,
            el.optional)(et.JsonRpcErrorStruct)
        }),
      et.JsonRpcSuccessStruct = (0,
        el.object)({
          id: et.JsonRpcIdStruct,
          jsonrpc: et.JsonRpcVersionStruct,
          result: et.JsonStruct
        }),
      et.JsonRpcFailureStruct = (0,
        el.object)({
          id: et.JsonRpcIdStruct,
          jsonrpc: et.JsonRpcVersionStruct,
          error: et.JsonRpcErrorStruct
        }),
      et.JsonRpcResponseStruct = (0,
        el.union)([et.JsonRpcSuccessStruct, et.JsonRpcFailureStruct]),
      et.isPendingJsonRpcResponse = function (J) {
        return (0,
          el.is)(J, et.PendingJsonRpcResponseStruct)
      }
      ,
      et.assertIsPendingJsonRpcResponse = function (J, eo) {
        (0,
          ec.assertStruct)(J, et.PendingJsonRpcResponseStruct, "Invalid pending JSON-RPC response", eo)
      }
      ,
      et.isJsonRpcResponse = function (J) {
        return (0,
          el.is)(J, et.JsonRpcResponseStruct)
      }
      ,
      et.assertIsJsonRpcResponse = function (J, eo) {
        (0,
          ec.assertStruct)(J, et.JsonRpcResponseStruct, "Invalid JSON-RPC response", eo)
      }
      ,
      et.isJsonRpcSuccess = function (J) {
        return (0,
          el.is)(J, et.JsonRpcSuccessStruct)
      }
      ,
      et.assertIsJsonRpcSuccess = function (J, eo) {
        (0,
          ec.assertStruct)(J, et.JsonRpcSuccessStruct, "Invalid JSON-RPC success response", eo)
      }
      ,
      et.isJsonRpcFailure = function (J) {
        return (0,
          el.is)(J, et.JsonRpcFailureStruct)
      }
      ,
      et.assertIsJsonRpcFailure = function (J, eo) {
        (0,
          ec.assertStruct)(J, et.JsonRpcFailureStruct, "Invalid JSON-RPC failure response", eo)
      }
      ,
      et.isJsonRpcError = function (J) {
        return (0,
          el.is)(J, et.JsonRpcErrorStruct)
      }
      ,
      et.assertIsJsonRpcError = function (J, eo) {
        (0,
          ec.assertStruct)(J, et.JsonRpcErrorStruct, "Invalid JSON-RPC error", eo)
      }
      ,
      et.getJsonRpcIdValidator = function (J) {
        let { permitEmptyString: et, permitFractions: eo, permitNull: el } = Object.assign({
          permitEmptyString: !0,
          permitFractions: !1,
          permitNull: !0
        }, J);
        return J => !!("number" == typeof J && (eo || Number.isInteger(J)) || "string" == typeof J && (et || J.length > 0) || el && null === J)
      }
  },
  23732: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    })
  },
  20160: function (J, et, eo) {
    "use strict";
    var el = this && this.__importDefault || function (J) {
      return J && J.__esModule ? J : {
        default: J
      }
    }
      ;
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.createModuleLogger = et.createProjectLogger = void 0;
    let ec = el(eo(11227))
      , ed = (0,
        ec.default)("metamask");
    et.createProjectLogger = function (J) {
      return ed.extend(J)
    }
      ,
      et.createModuleLogger = function (J, et) {
        return J.extend(et)
      }
  },
  66215: function (J, et) {
    "use strict";
    var eo;
    function isASCII(J) {
      return 127 >= J.charCodeAt(0)
    }
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.calculateNumberSize = et.calculateStringSize = et.isASCII = et.isPlainObject = et.ESCAPE_CHARACTERS_REGEXP = et.JsonSize = et.hasProperty = et.isObject = et.isNullOrUndefined = et.isNonEmptyArray = void 0,
      et.isNonEmptyArray = function (J) {
        return Array.isArray(J) && J.length > 0
      }
      ,
      et.isNullOrUndefined = function (J) {
        return null == J
      }
      ,
      et.isObject = function (J) {
        return !!J && "object" == typeof J && !Array.isArray(J)
      }
      ,
      et.hasProperty = (J, et) => Object.hasOwnProperty.call(J, et),
      (eo = et.JsonSize || (et.JsonSize = {}))[eo.Null = 4] = "Null",
      eo[eo.Comma = 1] = "Comma",
      eo[eo.Wrapper = 1] = "Wrapper",
      eo[eo.True = 4] = "True",
      eo[eo.False = 5] = "False",
      eo[eo.Quote = 1] = "Quote",
      eo[eo.Colon = 1] = "Colon",
      eo[eo.Date = 24] = "Date",
      et.ESCAPE_CHARACTERS_REGEXP = /"|\\|\n|\r|\t/gu,
      et.isPlainObject = function (J) {
        if ("object" != typeof J || null === J)
          return !1;
        try {
          let et = J;
          for (; null !== Object.getPrototypeOf(et);)
            et = Object.getPrototypeOf(et);
          return Object.getPrototypeOf(J) === et
        } catch (J) {
          return !1
        }
      }
      ,
      et.isASCII = isASCII,
      et.calculateStringSize = function (J) {
        var eo;
        let el = J.split("").reduce((J, et) => isASCII(et) ? J + 1 : J + 2, 0);
        return el + (null !== (eo = J.match(et.ESCAPE_CHARACTERS_REGEXP)) && void 0 !== eo ? eo : []).length
      }
      ,
      et.calculateNumberSize = function (J) {
        return J.toString().length
      }
  },
  89679: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.hexToBigInt = et.hexToNumber = et.bigIntToHex = et.numberToHex = void 0;
    let el = eo(31422)
      , ec = eo(62009);
    et.numberToHex = J => ((0,
      el.assert)("number" == typeof J, "Value must be a number."),
      (0,
        el.assert)(J >= 0, "Value must be a non-negative number."),
      (0,
        el.assert)(Number.isSafeInteger(J), "Value is not a safe integer. Use `bigIntToHex` instead."),
      (0,
        ec.add0x)(J.toString(16))),
      et.bigIntToHex = J => ((0,
        el.assert)("bigint" == typeof J, "Value must be a bigint."),
        (0,
          el.assert)(J >= 0, "Value must be a non-negative bigint."),
        (0,
          ec.add0x)(J.toString(16))),
      et.hexToNumber = J => {
        (0,
          ec.assertIsHexString)(J);
        let et = parseInt(J, 16);
        return (0,
          el.assert)(Number.isSafeInteger(et), "Value is not a safe integer. Use `hexToBigInt` instead."),
          et
      }
      ,
      et.hexToBigInt = J => ((0,
        ec.assertIsHexString)(J),
        BigInt((0,
          ec.add0x)(J)))
  },
  99108: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    })
  },
  97772: function (J, et) {
    "use strict";
    var eo;
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.timeSince = et.inMilliseconds = et.Duration = void 0,
      (eo = et.Duration || (et.Duration = {}))[eo.Millisecond = 1] = "Millisecond",
      eo[eo.Second = 1e3] = "Second",
      eo[eo.Minute = 6e4] = "Minute",
      eo[eo.Hour = 36e5] = "Hour",
      eo[eo.Day = 864e5] = "Day",
      eo[eo.Week = 6048e5] = "Week",
      eo[eo.Year = 31536e6] = "Year";
    let isNonNegativeInteger = J => Number.isInteger(J) && J >= 0
      , assertIsNonNegativeInteger = (J, et) => {
        if (!isNonNegativeInteger(J))
          throw Error(`"${et}" must be a non-negative integer. Received: "${J}".`)
      }
      ;
    et.inMilliseconds = function (J, et) {
      return assertIsNonNegativeInteger(J, "count"),
        J * et
    }
      ,
      et.timeSince = function (J) {
        return assertIsNonNegativeInteger(J, "timestamp"),
          Date.now() - J
      }
  },
  17749: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    })
  },
  88426: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.satisfiesVersionRange = et.gtRange = et.gtVersion = et.assertIsSemVerRange = et.assertIsSemVerVersion = et.isValidSemVerRange = et.isValidSemVerVersion = et.VersionRangeStruct = et.VersionStruct = void 0;
    let el = eo(45393)
      , ec = eo(97884)
      , ed = eo(31422);
    et.VersionStruct = (0,
      ec.refine)((0,
        ec.string)(), "Version", J => null !== (0,
          el.valid)(J) || `Expected SemVer version, got "${J}"`),
      et.VersionRangeStruct = (0,
        ec.refine)((0,
          ec.string)(), "Version range", J => null !== (0,
            el.validRange)(J) || `Expected SemVer range, got "${J}"`),
      et.isValidSemVerVersion = function (J) {
        return (0,
          ec.is)(J, et.VersionStruct)
      }
      ,
      et.isValidSemVerRange = function (J) {
        return (0,
          ec.is)(J, et.VersionRangeStruct)
      }
      ,
      et.assertIsSemVerVersion = function (J) {
        (0,
          ed.assertStruct)(J, et.VersionStruct)
      }
      ,
      et.assertIsSemVerRange = function (J) {
        (0,
          ed.assertStruct)(J, et.VersionRangeStruct)
      }
      ,
      et.gtVersion = function (J, et) {
        return (0,
          el.gt)(J, et)
      }
      ,
      et.gtRange = function (J, et) {
        return (0,
          el.gtr)(J, et)
      }
      ,
      et.satisfiesVersionRange = function (J, et) {
        return (0,
          el.satisfies)(J, et, {
            includePrerelease: !0
          })
      }
  },
  33066: function (J, et, eo) {
    "use strict";
    let el = eo(64403)
      , ec = Symbol("max")
      , ed = Symbol("length")
      , eh = Symbol("lengthCalculator")
      , ep = Symbol("allowStale")
      , ef = Symbol("maxAge")
      , em = Symbol("dispose")
      , eg = Symbol("noDisposeOnSet")
      , ey = Symbol("lruList")
      , eb = Symbol("cache")
      , ew = Symbol("updateAgeOnGet")
      , naiveLength = () => 1
      , get = (J, et, eo) => {
        let el = J[eb].get(et);
        if (el) {
          let et = el.value;
          if (isStale(J, et)) {
            if (del(J, el),
              !J[ep])
              return
          } else
            eo && (J[ew] && (el.value.now = Date.now()),
              J[ey].unshiftNode(el));
          return et.value
        }
      }
      , isStale = (J, et) => {
        if (!et || !et.maxAge && !J[ef])
          return !1;
        let eo = Date.now() - et.now;
        return et.maxAge ? eo > et.maxAge : J[ef] && eo > J[ef]
      }
      , trim = J => {
        if (J[ed] > J[ec])
          for (let et = J[ey].tail; J[ed] > J[ec] && null !== et;) {
            let eo = et.prev;
            del(J, et),
              et = eo
          }
      }
      , del = (J, et) => {
        if (et) {
          let eo = et.value;
          J[em] && J[em](eo.key, eo.value),
            J[ed] -= eo.length,
            J[eb].delete(eo.key),
            J[ey].removeNode(et)
        }
      }
      ;
    let Entry = class Entry {
      constructor(J, et, eo, el, ec) {
        this.key = J,
          this.value = et,
          this.length = eo,
          this.now = el,
          this.maxAge = ec || 0
      }
    }
      ;
    let forEachStep = (J, et, eo, el) => {
      let ec = eo.value;
      isStale(J, ec) && (del(J, eo),
        J[ep] || (ec = void 0)),
        ec && et.call(el, ec.value, ec.key, J)
    }
      ;
    J.exports = class {
      constructor(J) {
        if ("number" == typeof J && (J = {
          max: J
        }),
          J || (J = {}),
          J.max && ("number" != typeof J.max || J.max < 0))
          throw TypeError("max must be a non-negative number");
        this[ec] = J.max || 1 / 0;
        let et = J.length || naiveLength;
        if (this[eh] = "function" != typeof et ? naiveLength : et,
          this[ep] = J.stale || !1,
          J.maxAge && "number" != typeof J.maxAge)
          throw TypeError("maxAge must be a number");
        this[ef] = J.maxAge || 0,
          this[em] = J.dispose,
          this[eg] = J.noDisposeOnSet || !1,
          this[ew] = J.updateAgeOnGet || !1,
          this.reset()
      }
      set max(J) {
        if ("number" != typeof J || J < 0)
          throw TypeError("max must be a non-negative number");
        this[ec] = J || 1 / 0,
          trim(this)
      }
      get max() {
        return this[ec]
      }
      set allowStale(J) {
        this[ep] = !!J
      }
      get allowStale() {
        return this[ep]
      }
      set maxAge(J) {
        if ("number" != typeof J)
          throw TypeError("maxAge must be a non-negative number");
        this[ef] = J,
          trim(this)
      }
      get maxAge() {
        return this[ef]
      }
      set lengthCalculator(J) {
        "function" != typeof J && (J = naiveLength),
          J !== this[eh] && (this[eh] = J,
            this[ed] = 0,
            this[ey].forEach(J => {
              J.length = this[eh](J.value, J.key),
                this[ed] += J.length
            }
            )),
          trim(this)
      }
      get lengthCalculator() {
        return this[eh]
      }
      get length() {
        return this[ed]
      }
      get itemCount() {
        return this[ey].length
      }
      rforEach(J, et) {
        et = et || this;
        for (let eo = this[ey].tail; null !== eo;) {
          let el = eo.prev;
          forEachStep(this, J, eo, et),
            eo = el
        }
      }
      forEach(J, et) {
        et = et || this;
        for (let eo = this[ey].head; null !== eo;) {
          let el = eo.next;
          forEachStep(this, J, eo, et),
            eo = el
        }
      }
      keys() {
        return this[ey].toArray().map(J => J.key)
      }
      values() {
        return this[ey].toArray().map(J => J.value)
      }
      reset() {
        this[em] && this[ey] && this[ey].length && this[ey].forEach(J => this[em](J.key, J.value)),
          this[eb] = new Map,
          this[ey] = new el,
          this[ed] = 0
      }
      dump() {
        return this[ey].map(J => !isStale(this, J) && {
          k: J.key,
          v: J.value,
          e: J.now + (J.maxAge || 0)
        }).toArray().filter(J => J)
      }
      dumpLru() {
        return this[ey]
      }
      set(J, et, eo) {
        if ((eo = eo || this[ef]) && "number" != typeof eo)
          throw TypeError("maxAge must be a number");
        let el = eo ? Date.now() : 0
          , ep = this[eh](et, J);
        if (this[eb].has(J)) {
          if (ep > this[ec])
            return del(this, this[eb].get(J)),
              !1;
          let eh = this[eb].get(J)
            , ef = eh.value;
          return this[em] && !this[eg] && this[em](J, ef.value),
            ef.now = el,
            ef.maxAge = eo,
            ef.value = et,
            this[ed] += ep - ef.length,
            ef.length = ep,
            this.get(J),
            trim(this),
            !0
        }
        let ew = new Entry(J, et, ep, el, eo);
        return ew.length > this[ec] ? (this[em] && this[em](J, et),
          !1) : (this[ed] += ew.length,
            this[ey].unshift(ew),
            this[eb].set(J, this[ey].head),
            trim(this),
            !0)
      }
      has(J) {
        if (!this[eb].has(J))
          return !1;
        let et = this[eb].get(J).value;
        return !isStale(this, et)
      }
      get(J) {
        return get(this, J, !0)
      }
      peek(J) {
        return get(this, J, !1)
      }
      pop() {
        let J = this[ey].tail;
        return J ? (del(this, J),
          J.value) : null
      }
      del(J) {
        del(this, this[eb].get(J))
      }
      load(J) {
        this.reset();
        let et = Date.now();
        for (let eo = J.length - 1; eo >= 0; eo--) {
          let el = J[eo]
            , ec = el.e || 0;
          if (0 === ec)
            this.set(el.k, el.v);
          else {
            let J = ec - et;
            J > 0 && this.set(el.k, el.v, J)
          }
        }
      }
      prune() {
        this[eb].forEach((J, et) => get(this, et, !1))
      }
    }
  },
  67809: function (J, et, eo) {
    let el = Symbol("SemVer ANY");
    let Comparator = class Comparator {
      static get ANY() {
        return el
      }
      constructor(J, et) {
        if (et = ec(et),
          J instanceof Comparator) {
          if (!!et.loose === J.loose)
            return J;
          J = J.value
        }
        ef("comparator", J = J.trim().split(/\s+/).join(" "), et),
          this.options = et,
          this.loose = !!et.loose,
          this.parse(J),
          this.semver === el ? this.value = "" : this.value = this.operator + this.semver.version,
          ef("comp", this)
      }
      parse(J) {
        let et = this.options.loose ? ed[eh.COMPARATORLOOSE] : ed[eh.COMPARATOR]
          , eo = J.match(et);
        if (!eo)
          throw TypeError(`Invalid comparator: ${J}`);
        this.operator = void 0 !== eo[1] ? eo[1] : "",
          "=" === this.operator && (this.operator = ""),
          eo[2] ? this.semver = new em(eo[2], this.options.loose) : this.semver = el
      }
      toString() {
        return this.value
      }
      test(J) {
        if (ef("Comparator.test", J, this.options.loose),
          this.semver === el || J === el)
          return !0;
        if ("string" == typeof J)
          try {
            J = new em(J, this.options)
          } catch (J) {
            return !1
          }
        return ep(J, this.operator, this.semver, this.options)
      }
      intersects(J, et) {
        if (!(J instanceof Comparator))
          throw TypeError("a Comparator is required");
        return "" === this.operator ? "" === this.value || new eg(J.value, et).test(this.value) : "" === J.operator ? "" === J.value || new eg(this.value, et).test(J.semver) : !((et = ec(et)).includePrerelease && ("<0.0.0-0" === this.value || "<0.0.0-0" === J.value) || !et.includePrerelease && (this.value.startsWith("<0.0.0") || J.value.startsWith("<0.0.0"))) && !!(this.operator.startsWith(">") && J.operator.startsWith(">") || this.operator.startsWith("<") && J.operator.startsWith("<") || this.semver.version === J.semver.version && this.operator.includes("=") && J.operator.includes("=") || ep(this.semver, "<", J.semver, et) && this.operator.startsWith(">") && J.operator.startsWith("<") || ep(this.semver, ">", J.semver, et) && this.operator.startsWith("<") && J.operator.startsWith(">"))
      }
    }
      ;
    J.exports = Comparator;
    let ec = eo(33459)
      , { safeRe: ed, t: eh } = eo(98416)
      , ep = eo(12928)
      , ef = eo(12494)
      , em = eo(30808)
      , eg = eo(15579)
  },
  15579: function (J, et, eo) {
    let Range = class Range {
      constructor(J, et) {
        if (et = ed(et),
          J instanceof Range) {
          if (!!et.loose === J.loose && !!et.includePrerelease === J.includePrerelease)
            return J;
          return new Range(J.raw, et)
        }
        if (J instanceof eh)
          return this.raw = J.value,
            this.set = [[J]],
            this.format(),
            this;
        if (this.options = et,
          this.loose = !!et.loose,
          this.includePrerelease = !!et.includePrerelease,
          this.raw = J.trim().split(/\s+/).join(" "),
          this.set = this.raw.split("||").map(J => this.parseRange(J.trim())).filter(J => J.length),
          !this.set.length)
          throw TypeError(`Invalid SemVer Range: ${this.raw}`);
        if (this.set.length > 1) {
          let J = this.set[0];
          if (this.set = this.set.filter(J => !isNullSet(J[0])),
            0 === this.set.length)
            this.set = [J];
          else if (this.set.length > 1) {
            for (let J of this.set)
              if (1 === J.length && isAny(J[0])) {
                this.set = [J];
                break
              }
          }
        }
        this.format()
      }
      format() {
        return this.range = this.set.map(J => J.join(" ").trim()).join("||").trim(),
          this.range
      }
      toString() {
        return this.range
      }
      parseRange(J) {
        let et = (this.options.includePrerelease && e_) | (this.options.loose && ex)
          , eo = et + ":" + J
          , el = ec.get(eo);
        if (el)
          return el;
        let ed = this.options.loose
          , ef = ed ? em[eg.HYPHENRANGELOOSE] : em[eg.HYPHENRANGE];
        ep("hyphen replace", J = J.replace(ef, hyphenReplace(this.options.includePrerelease))),
          ep("comparator trim", J = J.replace(em[eg.COMPARATORTRIM], ey)),
          ep("tilde trim", J = J.replace(em[eg.TILDETRIM], eb)),
          ep("caret trim", J = J.replace(em[eg.CARETTRIM], ew));
        let eE = J.split(" ").map(J => parseComparator(J, this.options)).join(" ").split(/\s+/).map(J => replaceGTE0(J, this.options));
        ed && (eE = eE.filter(J => (ep("loose invalid filter", J, this.options),
          !!J.match(em[eg.COMPARATORLOOSE])))),
          ep("range list", eE);
        let eC = new Map
          , eS = eE.map(J => new eh(J, this.options));
        for (let J of eS) {
          if (isNullSet(J))
            return [J];
          eC.set(J.value, J)
        }
        eC.size > 1 && eC.has("") && eC.delete("");
        let ek = [...eC.values()];
        return ec.set(eo, ek),
          ek
      }
      intersects(J, et) {
        if (!(J instanceof Range))
          throw TypeError("a Range is required");
        return this.set.some(eo => isSatisfiable(eo, et) && J.set.some(J => isSatisfiable(J, et) && eo.every(eo => J.every(J => eo.intersects(J, et)))))
      }
      test(J) {
        if (!J)
          return !1;
        if ("string" == typeof J)
          try {
            J = new ef(J, this.options)
          } catch (J) {
            return !1
          }
        for (let et = 0; et < this.set.length; et++)
          if (testSet(this.set[et], J, this.options))
            return !0;
        return !1
      }
    }
      ;
    J.exports = Range;
    let el = eo(33066)
      , ec = new el({
        max: 1e3
      })
      , ed = eo(33459)
      , eh = eo(67809)
      , ep = eo(12494)
      , ef = eo(30808)
      , { safeRe: em, t: eg, comparatorTrimReplace: ey, tildeTrimReplace: eb, caretTrimReplace: ew } = eo(98416)
      , { FLAG_INCLUDE_PRERELEASE: e_, FLAG_LOOSE: ex } = eo(41493)
      , isNullSet = J => "<0.0.0-0" === J.value
      , isAny = J => "" === J.value
      , isSatisfiable = (J, et) => {
        let eo = !0
          , el = J.slice()
          , ec = el.pop();
        for (; eo && el.length;)
          eo = el.every(J => ec.intersects(J, et)),
            ec = el.pop();
        return eo
      }
      , parseComparator = (J, et) => (ep("comp", J, et),
        ep("caret", J = replaceCarets(J, et)),
        ep("tildes", J = replaceTildes(J, et)),
        ep("xrange", J = replaceXRanges(J, et)),
        ep("stars", J = replaceStars(J, et)),
        J)
      , isX = J => !J || "x" === J.toLowerCase() || "*" === J
      , replaceTildes = (J, et) => J.trim().split(/\s+/).map(J => replaceTilde(J, et)).join(" ")
      , replaceTilde = (J, et) => {
        let eo = et.loose ? em[eg.TILDELOOSE] : em[eg.TILDE];
        return J.replace(eo, (et, eo, el, ec, ed) => {
          let eh;
          return ep("tilde", J, et, eo, el, ec, ed),
            isX(eo) ? eh = "" : isX(el) ? eh = `>=${eo}.0.0 <${+eo + 1}.0.0-0` : isX(ec) ? eh = `>=${eo}.${el}.0 <${eo}.${+el + 1}.0-0` : ed ? (ep("replaceTilde pr", ed),
              eh = `>=${eo}.${el}.${ec}-${ed} <${eo}.${+el + 1}.0-0`) : eh = `>=${eo}.${el}.${ec} <${eo}.${+el + 1}.0-0`,
            ep("tilde return", eh),
            eh
        }
        )
      }
      , replaceCarets = (J, et) => J.trim().split(/\s+/).map(J => replaceCaret(J, et)).join(" ")
      , replaceCaret = (J, et) => {
        ep("caret", J, et);
        let eo = et.loose ? em[eg.CARETLOOSE] : em[eg.CARET]
          , el = et.includePrerelease ? "-0" : "";
        return J.replace(eo, (et, eo, ec, ed, eh) => {
          let ef;
          return ep("caret", J, et, eo, ec, ed, eh),
            isX(eo) ? ef = "" : isX(ec) ? ef = `>=${eo}.0.0${el} <${+eo + 1}.0.0-0` : isX(ed) ? ef = "0" === eo ? `>=${eo}.${ec}.0${el} <${eo}.${+ec + 1}.0-0` : `>=${eo}.${ec}.0${el} <${+eo + 1}.0.0-0` : eh ? (ep("replaceCaret pr", eh),
              ef = "0" === eo ? "0" === ec ? `>=${eo}.${ec}.${ed}-${eh} <${eo}.${ec}.${+ed + 1}-0` : `>=${eo}.${ec}.${ed}-${eh} <${eo}.${+ec + 1}.0-0` : `>=${eo}.${ec}.${ed}-${eh} <${+eo + 1}.0.0-0`) : (ep("no pr"),
                ef = "0" === eo ? "0" === ec ? `>=${eo}.${ec}.${ed}${el} <${eo}.${ec}.${+ed + 1}-0` : `>=${eo}.${ec}.${ed}${el} <${eo}.${+ec + 1}.0-0` : `>=${eo}.${ec}.${ed} <${+eo + 1}.0.0-0`),
            ep("caret return", ef),
            ef
        }
        )
      }
      , replaceXRanges = (J, et) => (ep("replaceXRanges", J, et),
        J.split(/\s+/).map(J => replaceXRange(J, et)).join(" "))
      , replaceXRange = (J, et) => {
        J = J.trim();
        let eo = et.loose ? em[eg.XRANGELOOSE] : em[eg.XRANGE];
        return J.replace(eo, (eo, el, ec, ed, eh, ef) => {
          ep("xRange", J, eo, el, ec, ed, eh, ef);
          let em = isX(ec)
            , eg = em || isX(ed)
            , ey = eg || isX(eh);
          return "=" === el && ey && (el = ""),
            ef = et.includePrerelease ? "-0" : "",
            em ? eo = ">" === el || "<" === el ? "<0.0.0-0" : "*" : el && ey ? (eg && (ed = 0),
              eh = 0,
              ">" === el ? (el = ">=",
                eg ? (ec = +ec + 1,
                  ed = 0) : ed = +ed + 1,
                eh = 0) : "<=" === el && (el = "<",
                  eg ? ec = +ec + 1 : ed = +ed + 1),
              "<" === el && (ef = "-0"),
              eo = `${el + ec}.${ed}.${eh}${ef}`) : eg ? eo = `>=${ec}.0.0${ef} <${+ec + 1}.0.0-0` : ey && (eo = `>=${ec}.${ed}.0${ef} <${ec}.${+ed + 1}.0-0`),
            ep("xRange return", eo),
            eo
        }
        )
      }
      , replaceStars = (J, et) => (ep("replaceStars", J, et),
        J.trim().replace(em[eg.STAR], ""))
      , replaceGTE0 = (J, et) => (ep("replaceGTE0", J, et),
        J.trim().replace(em[et.includePrerelease ? eg.GTE0PRE : eg.GTE0], ""))
      , hyphenReplace = J => (et, eo, el, ec, ed, eh, ep, ef, em, eg, ey, eb, ew) => (eo = isX(el) ? "" : isX(ec) ? `>=${el}.0.0${J ? "-0" : ""}` : isX(ed) ? `>=${el}.${ec}.0${J ? "-0" : ""}` : eh ? `>=${eo}` : `>=${eo}${J ? "-0" : ""}`,
        ef = isX(em) ? "" : isX(eg) ? `<${+em + 1}.0.0-0` : isX(ey) ? `<${em}.${+eg + 1}.0-0` : eb ? `<=${em}.${eg}.${ey}-${eb}` : J ? `<${em}.${eg}.${+ey + 1}-0` : `<=${ef}`,
        `${eo} ${ef}`.trim())
      , testSet = (J, et, eo) => {
        for (let eo = 0; eo < J.length; eo++)
          if (!J[eo].test(et))
            return !1;
        if (et.prerelease.length && !eo.includePrerelease) {
          for (let eo = 0; eo < J.length; eo++)
            if (ep(J[eo].semver),
              J[eo].semver !== eh.ANY && J[eo].semver.prerelease.length > 0) {
              let el = J[eo].semver;
              if (el.major === et.major && el.minor === et.minor && el.patch === et.patch)
                return !0
            }
          return !1
        }
        return !0
      }
  },
  30808: function (J, et, eo) {
    let el = eo(12494)
      , { MAX_LENGTH: ec, MAX_SAFE_INTEGER: ed } = eo(41493)
      , { safeRe: eh, t: ep } = eo(98416)
      , ef = eo(33459)
      , { compareIdentifiers: em } = eo(29417);
    let SemVer = class SemVer {
      constructor(J, et) {
        if (et = ef(et),
          J instanceof SemVer) {
          if (!!et.loose === J.loose && !!et.includePrerelease === J.includePrerelease)
            return J;
          J = J.version
        } else if ("string" != typeof J)
          throw TypeError(`Invalid version. Must be a string. Got type "${typeof J}".`);
        if (J.length > ec)
          throw TypeError(`version is longer than ${ec} characters`);
        el("SemVer", J, et),
          this.options = et,
          this.loose = !!et.loose,
          this.includePrerelease = !!et.includePrerelease;
        let eo = J.trim().match(et.loose ? eh[ep.LOOSE] : eh[ep.FULL]);
        if (!eo)
          throw TypeError(`Invalid Version: ${J}`);
        if (this.raw = J,
          this.major = +eo[1],
          this.minor = +eo[2],
          this.patch = +eo[3],
          this.major > ed || this.major < 0)
          throw TypeError("Invalid major version");
        if (this.minor > ed || this.minor < 0)
          throw TypeError("Invalid minor version");
        if (this.patch > ed || this.patch < 0)
          throw TypeError("Invalid patch version");
        eo[4] ? this.prerelease = eo[4].split(".").map(J => {
          if (/^[0-9]+$/.test(J)) {
            let et = +J;
            if (et >= 0 && et < ed)
              return et
          }
          return J
        }
        ) : this.prerelease = [],
          this.build = eo[5] ? eo[5].split(".") : [],
          this.format()
      }
      format() {
        return this.version = `${this.major}.${this.minor}.${this.patch}`,
          this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`),
          this.version
      }
      toString() {
        return this.version
      }
      compare(J) {
        if (el("SemVer.compare", this.version, this.options, J),
          !(J instanceof SemVer)) {
          if ("string" == typeof J && J === this.version)
            return 0;
          J = new SemVer(J, this.options)
        }
        return J.version === this.version ? 0 : this.compareMain(J) || this.comparePre(J)
      }
      compareMain(J) {
        return J instanceof SemVer || (J = new SemVer(J, this.options)),
          em(this.major, J.major) || em(this.minor, J.minor) || em(this.patch, J.patch)
      }
      comparePre(J) {
        if (J instanceof SemVer || (J = new SemVer(J, this.options)),
          this.prerelease.length && !J.prerelease.length)
          return -1;
        if (!this.prerelease.length && J.prerelease.length)
          return 1;
        if (!this.prerelease.length && !J.prerelease.length)
          return 0;
        let et = 0;
        do {
          let eo = this.prerelease[et]
            , ec = J.prerelease[et];
          if (el("prerelease compare", et, eo, ec),
            void 0 === eo && void 0 === ec)
            return 0;
          if (void 0 === ec)
            return 1;
          if (void 0 === eo)
            return -1;
          if (eo === ec)
            continue;
          else
            return em(eo, ec)
        } while (++et)
      }
      compareBuild(J) {
        J instanceof SemVer || (J = new SemVer(J, this.options));
        let et = 0;
        do {
          let eo = this.build[et]
            , ec = J.build[et];
          if (el("prerelease compare", et, eo, ec),
            void 0 === eo && void 0 === ec)
            return 0;
          if (void 0 === ec)
            return 1;
          if (void 0 === eo)
            return -1;
          if (eo === ec)
            continue;
          else
            return em(eo, ec)
        } while (++et)
      }
      inc(J, et, eo) {
        switch (J) {
          case "premajor":
            this.prerelease.length = 0,
              this.patch = 0,
              this.minor = 0,
              this.major++,
              this.inc("pre", et, eo);
            break;
          case "preminor":
            this.prerelease.length = 0,
              this.patch = 0,
              this.minor++,
              this.inc("pre", et, eo);
            break;
          case "prepatch":
            this.prerelease.length = 0,
              this.inc("patch", et, eo),
              this.inc("pre", et, eo);
            break;
          case "prerelease":
            0 === this.prerelease.length && this.inc("patch", et, eo),
              this.inc("pre", et, eo);
            break;
          case "major":
            (0 !== this.minor || 0 !== this.patch || 0 === this.prerelease.length) && this.major++,
              this.minor = 0,
              this.patch = 0,
              this.prerelease = [];
            break;
          case "minor":
            (0 !== this.patch || 0 === this.prerelease.length) && this.minor++,
              this.patch = 0,
              this.prerelease = [];
            break;
          case "patch":
            0 === this.prerelease.length && this.patch++,
              this.prerelease = [];
            break;
          case "pre":
            {
              let J = Number(eo) ? 1 : 0;
              if (!et && !1 === eo)
                throw Error("invalid increment argument: identifier is empty");
              if (0 === this.prerelease.length)
                this.prerelease = [J];
              else {
                let el = this.prerelease.length;
                for (; --el >= 0;)
                  "number" == typeof this.prerelease[el] && (this.prerelease[el]++,
                    el = -2);
                if (-1 === el) {
                  if (et === this.prerelease.join(".") && !1 === eo)
                    throw Error("invalid increment argument: identifier already exists");
                  this.prerelease.push(J)
                }
              }
              if (et) {
                let el = [et, J];
                !1 === eo && (el = [et]),
                  0 === em(this.prerelease[0], et) ? isNaN(this.prerelease[1]) && (this.prerelease = el) : this.prerelease = el
              }
              break
            }
          default:
            throw Error(`invalid increment argument: ${J}`)
        }
        return this.raw = this.format(),
          this.build.length && (this.raw += `+${this.build.join(".")}`),
          this
      }
    }
      ;
    J.exports = SemVer
  },
  97321: function (J, et, eo) {
    let el = eo(99706);
    J.exports = (J, et) => {
      let eo = el(J.trim().replace(/^[=v]+/, ""), et);
      return eo ? eo.version : null
    }
  },
  12928: function (J, et, eo) {
    let el = eo(26393)
      , ec = eo(70003)
      , ed = eo(690)
      , eh = eo(26155)
      , ep = eo(91675)
      , ef = eo(38800);
    J.exports = (J, et, eo, em) => {
      switch (et) {
        case "===":
          return "object" == typeof J && (J = J.version),
            "object" == typeof eo && (eo = eo.version),
            J === eo;
        case "!==":
          return "object" == typeof J && (J = J.version),
            "object" == typeof eo && (eo = eo.version),
            J !== eo;
        case "":
        case "=":
        case "==":
          return el(J, eo, em);
        case "!=":
          return ec(J, eo, em);
        case ">":
          return ed(J, eo, em);
        case ">=":
          return eh(J, eo, em);
        case "<":
          return ep(J, eo, em);
        case "<=":
          return ef(J, eo, em);
        default:
          throw TypeError(`Invalid operator: ${et}`)
      }
    }
  },
  65054: function (J, et, eo) {
    let el = eo(30808)
      , ec = eo(99706)
      , { safeRe: ed, t: eh } = eo(98416);
    J.exports = (J, et) => {
      if (J instanceof el)
        return J;
      if ("number" == typeof J && (J = String(J)),
        "string" != typeof J)
        return null;
      let eo = null;
      if ((et = et || {}).rtl) {
        let et;
        for (; (et = ed[eh.COERCERTL].exec(J)) && (!eo || eo.index + eo[0].length !== J.length);)
          eo && et.index + et[0].length === eo.index + eo[0].length || (eo = et),
            ed[eh.COERCERTL].lastIndex = et.index + et[1].length + et[2].length;
        ed[eh.COERCERTL].lastIndex = -1
      } else
        eo = J.match(ed[eh.COERCE]);
      return null === eo ? null : ec(`${eo[2]}.${eo[3] || "0"}.${eo[4] || "0"}`, et)
    }
  },
  39457: function (J, et, eo) {
    let el = eo(30808);
    J.exports = (J, et, eo) => {
      let ec = new el(J, eo)
        , ed = new el(et, eo);
      return ec.compare(ed) || ec.compareBuild(ed)
    }
  },
  18992: function (J, et, eo) {
    let el = eo(66837);
    J.exports = (J, et) => el(J, et, !0)
  },
  66837: function (J, et, eo) {
    let el = eo(30808);
    J.exports = (J, et, eo) => new el(J, eo).compare(new el(et, eo))
  },
  49603: function (J, et, eo) {
    let el = eo(99706);
    J.exports = (J, et) => {
      let eo = el(J, null, !0)
        , ec = el(et, null, !0)
        , ed = eo.compare(ec);
      if (0 === ed)
        return null;
      let eh = ed > 0
        , ep = eh ? eo : ec
        , ef = eh ? ec : eo
        , em = !!ep.prerelease.length
        , eg = !!ef.prerelease.length;
      if (eg && !em)
        return ef.patch || ef.minor ? ep.patch ? "patch" : ep.minor ? "minor" : "major" : "major";
      let ey = em ? "pre" : "";
      return eo.major !== ec.major ? ey + "major" : eo.minor !== ec.minor ? ey + "minor" : eo.patch !== ec.patch ? ey + "patch" : "prerelease"
    }
  },
  26393: function (J, et, eo) {
    let el = eo(66837);
    J.exports = (J, et, eo) => 0 === el(J, et, eo)
  },
  690: function (J, et, eo) {
    let el = eo(66837);
    J.exports = (J, et, eo) => el(J, et, eo) > 0
  },
  26155: function (J, et, eo) {
    let el = eo(66837);
    J.exports = (J, et, eo) => el(J, et, eo) >= 0
  },
  90624: function (J, et, eo) {
    let el = eo(30808);
    J.exports = (J, et, eo, ec, ed) => {
      "string" == typeof eo && (ed = ec,
        ec = eo,
        eo = void 0);
      try {
        return new el(J instanceof el ? J.version : J, eo).inc(et, ec, ed).version
      } catch (J) {
        return null
      }
    }
  },
  91675: function (J, et, eo) {
    let el = eo(66837);
    J.exports = (J, et, eo) => 0 > el(J, et, eo)
  },
  38800: function (J, et, eo) {
    let el = eo(66837);
    J.exports = (J, et, eo) => 0 >= el(J, et, eo)
  },
  4352: function (J, et, eo) {
    let el = eo(30808);
    J.exports = (J, et) => new el(J, et).major
  },
  71561: function (J, et, eo) {
    let el = eo(30808);
    J.exports = (J, et) => new el(J, et).minor
  },
  70003: function (J, et, eo) {
    let el = eo(66837);
    J.exports = (J, et, eo) => 0 !== el(J, et, eo)
  },
  99706: function (J, et, eo) {
    let el = eo(30808);
    J.exports = (J, et, eo = !1) => {
      if (J instanceof el)
        return J;
      try {
        return new el(J, et)
      } catch (J) {
        if (!eo)
          return null;
        throw J
      }
    }
  },
  8660: function (J, et, eo) {
    let el = eo(30808);
    J.exports = (J, et) => new el(J, et).patch
  },
  77674: function (J, et, eo) {
    let el = eo(99706);
    J.exports = (J, et) => {
      let eo = el(J, et);
      return eo && eo.prerelease.length ? eo.prerelease : null
    }
  },
  43370: function (J, et, eo) {
    let el = eo(66837);
    J.exports = (J, et, eo) => el(et, J, eo)
  },
  96646: function (J, et, eo) {
    let el = eo(39457);
    J.exports = (J, et) => J.sort((J, eo) => el(eo, J, et))
  },
  17819: function (J, et, eo) {
    let el = eo(15579);
    J.exports = (J, et, eo) => {
      try {
        et = new el(et, eo)
      } catch (J) {
        return !1
      }
      return et.test(J)
    }
  },
  53124: function (J, et, eo) {
    let el = eo(39457);
    J.exports = (J, et) => J.sort((J, eo) => el(J, eo, et))
  },
  85557: function (J, et, eo) {
    let el = eo(99706);
    J.exports = (J, et) => {
      let eo = el(J, et);
      return eo ? eo.version : null
    }
  },
  45393: function (J, et, eo) {
    let el = eo(98416)
      , ec = eo(41493)
      , ed = eo(30808)
      , eh = eo(29417)
      , ep = eo(99706)
      , ef = eo(85557)
      , em = eo(97321)
      , eg = eo(90624)
      , ey = eo(49603)
      , eb = eo(4352)
      , ew = eo(71561)
      , e_ = eo(8660)
      , ex = eo(77674)
      , eE = eo(66837)
      , eC = eo(43370)
      , eS = eo(18992)
      , ek = eo(39457)
      , eT = eo(53124)
      , eA = eo(96646)
      , eP = eo(690)
      , eR = eo(91675)
      , eI = eo(26393)
      , eO = eo(70003)
      , eN = eo(26155)
      , eM = eo(38800)
      , eD = eo(12928)
      , ej = eo(65054)
      , eL = eo(67809)
      , e$ = eo(15579)
      , eB = eo(17819)
      , eF = eo(40458)
      , eU = eo(76449)
      , ez = eo(21940)
      , eH = eo(20442)
      , eV = eo(77677)
      , eW = eo(39455)
      , eZ = eo(17922)
      , eG = eo(93670)
      , eY = eo(90451)
      , eK = eo(84501)
      , eJ = eo(94854);
    J.exports = {
      parse: ep,
      valid: ef,
      clean: em,
      inc: eg,
      diff: ey,
      major: eb,
      minor: ew,
      patch: e_,
      prerelease: ex,
      compare: eE,
      rcompare: eC,
      compareLoose: eS,
      compareBuild: ek,
      sort: eT,
      rsort: eA,
      gt: eP,
      lt: eR,
      eq: eI,
      neq: eO,
      gte: eN,
      lte: eM,
      cmp: eD,
      coerce: ej,
      Comparator: eL,
      Range: e$,
      satisfies: eB,
      toComparators: eF,
      maxSatisfying: eU,
      minSatisfying: ez,
      minVersion: eH,
      validRange: eV,
      outside: eW,
      gtr: eZ,
      ltr: eG,
      intersects: eY,
      simplifyRange: eK,
      subset: eJ,
      SemVer: ed,
      re: el.re,
      src: el.src,
      tokens: el.t,
      SEMVER_SPEC_VERSION: ec.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: ec.RELEASE_TYPES,
      compareIdentifiers: eh.compareIdentifiers,
      rcompareIdentifiers: eh.rcompareIdentifiers
    }
  },
  41493: function (J) {
    let et = Number.MAX_SAFE_INTEGER || 9007199254740991;
    J.exports = {
      MAX_LENGTH: 256,
      MAX_SAFE_COMPONENT_LENGTH: 16,
      MAX_SAFE_BUILD_LENGTH: 250,
      MAX_SAFE_INTEGER: et,
      RELEASE_TYPES: ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"],
      SEMVER_SPEC_VERSION: "2.0.0",
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    }
  },
  12494: function (J, et, eo) {
    var el = eo(83454);
    let ec = "object" == typeof el && el.env && el.env.NODE_DEBUG && /\bsemver\b/i.test(el.env.NODE_DEBUG) ? (...J) => console.error("SEMVER", ...J) : () => { }
      ;
    J.exports = ec
  },
  29417: function (J) {
    let et = /^[0-9]+$/
      , compareIdentifiers = (J, eo) => {
        let el = et.test(J)
          , ec = et.test(eo);
        return el && ec && (J = +J,
          eo = +eo),
          J === eo ? 0 : el && !ec ? -1 : ec && !el ? 1 : J < eo ? -1 : 1
      }
      ;
    J.exports = {
      compareIdentifiers,
      rcompareIdentifiers: (J, et) => compareIdentifiers(et, J)
    }
  },
  33459: function (J) {
    let et = Object.freeze({
      loose: !0
    })
      , eo = Object.freeze({});
    J.exports = J => J ? "object" != typeof J ? et : J : eo
  },
  98416: function (J, et, eo) {
    let { MAX_SAFE_COMPONENT_LENGTH: el, MAX_SAFE_BUILD_LENGTH: ec, MAX_LENGTH: ed } = eo(41493)
      , eh = eo(12494);
    et = J.exports = {};
    let ep = et.re = []
      , ef = et.safeRe = []
      , em = et.src = []
      , eg = et.t = {}
      , ey = 0
      , eb = "[a-zA-Z0-9-]"
      , ew = [["\\s", 1], ["\\d", ed], [eb, ec]]
      , makeSafeRegex = J => {
        for (let [et, eo] of ew)
          J = J.split(`${et}*`).join(`${et}{0,${eo}}`).split(`${et}+`).join(`${et}{1,${eo}}`);
        return J
      }
      , createToken = (J, et, eo) => {
        let el = makeSafeRegex(et)
          , ec = ey++;
        eh(J, ec, et),
          eg[J] = ec,
          em[ec] = et,
          ep[ec] = new RegExp(et, eo ? "g" : void 0),
          ef[ec] = new RegExp(el, eo ? "g" : void 0)
      }
      ;
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*"),
      createToken("NUMERICIDENTIFIERLOOSE", "\\d+"),
      createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${eb}*`),
      createToken("MAINVERSION", `(${em[eg.NUMERICIDENTIFIER]})\\.(${em[eg.NUMERICIDENTIFIER]})\\.(${em[eg.NUMERICIDENTIFIER]})`),
      createToken("MAINVERSIONLOOSE", `(${em[eg.NUMERICIDENTIFIERLOOSE]})\\.(${em[eg.NUMERICIDENTIFIERLOOSE]})\\.(${em[eg.NUMERICIDENTIFIERLOOSE]})`),
      createToken("PRERELEASEIDENTIFIER", `(?:${em[eg.NUMERICIDENTIFIER]}|${em[eg.NONNUMERICIDENTIFIER]})`),
      createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${em[eg.NUMERICIDENTIFIERLOOSE]}|${em[eg.NONNUMERICIDENTIFIER]})`),
      createToken("PRERELEASE", `(?:-(${em[eg.PRERELEASEIDENTIFIER]}(?:\\.${em[eg.PRERELEASEIDENTIFIER]})*))`),
      createToken("PRERELEASELOOSE", `(?:-?(${em[eg.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${em[eg.PRERELEASEIDENTIFIERLOOSE]})*))`),
      createToken("BUILDIDENTIFIER", `${eb}+`),
      createToken("BUILD", `(?:\\+(${em[eg.BUILDIDENTIFIER]}(?:\\.${em[eg.BUILDIDENTIFIER]})*))`),
      createToken("FULLPLAIN", `v?${em[eg.MAINVERSION]}${em[eg.PRERELEASE]}?${em[eg.BUILD]}?`),
      createToken("FULL", `^${em[eg.FULLPLAIN]}$`),
      createToken("LOOSEPLAIN", `[v=\\s]*${em[eg.MAINVERSIONLOOSE]}${em[eg.PRERELEASELOOSE]}?${em[eg.BUILD]}?`),
      createToken("LOOSE", `^${em[eg.LOOSEPLAIN]}$`),
      createToken("GTLT", "((?:<|>)?=?)"),
      createToken("XRANGEIDENTIFIERLOOSE", `${em[eg.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`),
      createToken("XRANGEIDENTIFIER", `${em[eg.NUMERICIDENTIFIER]}|x|X|\\*`),
      createToken("XRANGEPLAIN", `[v=\\s]*(${em[eg.XRANGEIDENTIFIER]})(?:\\.(${em[eg.XRANGEIDENTIFIER]})(?:\\.(${em[eg.XRANGEIDENTIFIER]})(?:${em[eg.PRERELEASE]})?${em[eg.BUILD]}?)?)?`),
      createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${em[eg.XRANGEIDENTIFIERLOOSE]})(?:\\.(${em[eg.XRANGEIDENTIFIERLOOSE]})(?:\\.(${em[eg.XRANGEIDENTIFIERLOOSE]})(?:${em[eg.PRERELEASELOOSE]})?${em[eg.BUILD]}?)?)?`),
      createToken("XRANGE", `^${em[eg.GTLT]}\\s*${em[eg.XRANGEPLAIN]}$`),
      createToken("XRANGELOOSE", `^${em[eg.GTLT]}\\s*${em[eg.XRANGEPLAINLOOSE]}$`),
      createToken("COERCE", `(^|[^\\d])(\\d{1,${el}})(?:\\.(\\d{1,${el}}))?(?:\\.(\\d{1,${el}}))?(?:$|[^\\d])`),
      createToken("COERCERTL", em[eg.COERCE], !0),
      createToken("LONETILDE", "(?:~>?)"),
      createToken("TILDETRIM", `(\\s*)${em[eg.LONETILDE]}\\s+`, !0),
      et.tildeTrimReplace = "$1~",
      createToken("TILDE", `^${em[eg.LONETILDE]}${em[eg.XRANGEPLAIN]}$`),
      createToken("TILDELOOSE", `^${em[eg.LONETILDE]}${em[eg.XRANGEPLAINLOOSE]}$`),
      createToken("LONECARET", "(?:\\^)"),
      createToken("CARETTRIM", `(\\s*)${em[eg.LONECARET]}\\s+`, !0),
      et.caretTrimReplace = "$1^",
      createToken("CARET", `^${em[eg.LONECARET]}${em[eg.XRANGEPLAIN]}$`),
      createToken("CARETLOOSE", `^${em[eg.LONECARET]}${em[eg.XRANGEPLAINLOOSE]}$`),
      createToken("COMPARATORLOOSE", `^${em[eg.GTLT]}\\s*(${em[eg.LOOSEPLAIN]})$|^$`),
      createToken("COMPARATOR", `^${em[eg.GTLT]}\\s*(${em[eg.FULLPLAIN]})$|^$`),
      createToken("COMPARATORTRIM", `(\\s*)${em[eg.GTLT]}\\s*(${em[eg.LOOSEPLAIN]}|${em[eg.XRANGEPLAIN]})`, !0),
      et.comparatorTrimReplace = "$1$2$3",
      createToken("HYPHENRANGE", `^\\s*(${em[eg.XRANGEPLAIN]})\\s+-\\s+(${em[eg.XRANGEPLAIN]})\\s*$`),
      createToken("HYPHENRANGELOOSE", `^\\s*(${em[eg.XRANGEPLAINLOOSE]})\\s+-\\s+(${em[eg.XRANGEPLAINLOOSE]})\\s*$`),
      createToken("STAR", "(<|>)?=?\\s*\\*"),
      createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"),
      createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$")
  },
  17922: function (J, et, eo) {
    let el = eo(39455);
    J.exports = (J, et, eo) => el(J, et, ">", eo)
  },
  90451: function (J, et, eo) {
    let el = eo(15579);
    J.exports = (J, et, eo) => (J = new el(J, eo),
      et = new el(et, eo),
      J.intersects(et, eo))
  },
  93670: function (J, et, eo) {
    let el = eo(39455);
    J.exports = (J, et, eo) => el(J, et, "<", eo)
  },
  76449: function (J, et, eo) {
    let el = eo(30808)
      , ec = eo(15579);
    J.exports = (J, et, eo) => {
      let ed = null
        , eh = null
        , ep = null;
      try {
        ep = new ec(et, eo)
      } catch (J) {
        return null
      }
      return J.forEach(J => {
        ep.test(J) && (!ed || -1 === eh.compare(J)) && (ed = J,
          eh = new el(ed, eo))
      }
      ),
        ed
    }
  },
  21940: function (J, et, eo) {
    let el = eo(30808)
      , ec = eo(15579);
    J.exports = (J, et, eo) => {
      let ed = null
        , eh = null
        , ep = null;
      try {
        ep = new ec(et, eo)
      } catch (J) {
        return null
      }
      return J.forEach(J => {
        ep.test(J) && (!ed || 1 === eh.compare(J)) && (ed = J,
          eh = new el(ed, eo))
      }
      ),
        ed
    }
  },
  20442: function (J, et, eo) {
    let el = eo(30808)
      , ec = eo(15579)
      , ed = eo(690);
    J.exports = (J, et) => {
      J = new ec(J, et);
      let eo = new el("0.0.0");
      if (J.test(eo) || (eo = new el("0.0.0-0"),
        J.test(eo)))
        return eo;
      eo = null;
      for (let et = 0; et < J.set.length; ++et) {
        let ec = J.set[et]
          , eh = null;
        ec.forEach(J => {
          let et = new el(J.semver.version);
          switch (J.operator) {
            case ">":
              0 === et.prerelease.length ? et.patch++ : et.prerelease.push(0),
                et.raw = et.format();
            case "":
            case ">=":
              (!eh || ed(et, eh)) && (eh = et);
              break;
            case "<":
            case "<=":
              break;
            default:
              throw Error(`Unexpected operation: ${J.operator}`)
          }
        }
        ),
          eh && (!eo || ed(eo, eh)) && (eo = eh)
      }
      return eo && J.test(eo) ? eo : null
    }
  },
  39455: function (J, et, eo) {
    let el = eo(30808)
      , ec = eo(67809)
      , { ANY: ed } = ec
      , eh = eo(15579)
      , ep = eo(17819)
      , ef = eo(690)
      , em = eo(91675)
      , eg = eo(38800)
      , ey = eo(26155);
    J.exports = (J, et, eo, eb) => {
      let ew, e_, ex, eE, eC;
      switch (J = new el(J, eb),
      et = new eh(et, eb),
      eo) {
        case ">":
          ew = ef,
            e_ = eg,
            ex = em,
            eE = ">",
            eC = ">=";
          break;
        case "<":
          ew = em,
            e_ = ey,
            ex = ef,
            eE = "<",
            eC = "<=";
          break;
        default:
          throw TypeError('Must provide a hilo val of "<" or ">"')
      }
      if (ep(J, et, eb))
        return !1;
      for (let eo = 0; eo < et.set.length; ++eo) {
        let el = et.set[eo]
          , eh = null
          , ep = null;
        if (el.forEach(J => {
          J.semver === ed && (J = new ec(">=0.0.0")),
            eh = eh || J,
            ep = ep || J,
            ew(J.semver, eh.semver, eb) ? eh = J : ex(J.semver, ep.semver, eb) && (ep = J)
        }
        ),
          eh.operator === eE || eh.operator === eC || (!ep.operator || ep.operator === eE) && e_(J, ep.semver) || ep.operator === eC && ex(J, ep.semver))
          return !1
      }
      return !0
    }
  },
  84501: function (J, et, eo) {
    let el = eo(17819)
      , ec = eo(66837);
    J.exports = (J, et, eo) => {
      let ed = []
        , eh = null
        , ep = null
        , ef = J.sort((J, et) => ec(J, et, eo));
      for (let J of ef) {
        let ec = el(J, et, eo);
        ec ? (ep = J,
          eh || (eh = J)) : (ep && ed.push([eh, ep]),
            ep = null,
            eh = null)
      }
      eh && ed.push([eh, null]);
      let em = [];
      for (let [J, et] of ed)
        J === et ? em.push(J) : et || J !== ef[0] ? et ? J === ef[0] ? em.push(`<=${et}`) : em.push(`${J} - ${et}`) : em.push(`>=${J}`) : em.push("*");
      let eg = em.join(" || ")
        , ey = "string" == typeof et.raw ? et.raw : String(et);
      return eg.length < ey.length ? eg : et
    }
  },
  94854: function (J, et, eo) {
    let el = eo(15579)
      , ec = eo(67809)
      , { ANY: ed } = ec
      , eh = eo(17819)
      , ep = eo(66837)
      , ef = [new ec(">=0.0.0-0")]
      , em = [new ec(">=0.0.0")]
      , simpleSubset = (J, et, eo) => {
        let el, ec, eg, ey, eb, ew, e_;
        if (J === et)
          return !0;
        if (1 === J.length && J[0].semver === ed) {
          if (1 === et.length && et[0].semver === ed)
            return !0;
          J = eo.includePrerelease ? ef : em
        }
        if (1 === et.length && et[0].semver === ed) {
          if (eo.includePrerelease)
            return !0;
          et = em
        }
        let ex = new Set;
        for (let et of J)
          ">" === et.operator || ">=" === et.operator ? el = higherGT(el, et, eo) : "<" === et.operator || "<=" === et.operator ? ec = lowerLT(ec, et, eo) : ex.add(et.semver);
        if (ex.size > 1 || el && ec && ((eg = ep(el.semver, ec.semver, eo)) > 0 || 0 === eg && (">=" !== el.operator || "<=" !== ec.operator)))
          return null;
        for (let J of ex) {
          if (el && !eh(J, String(el), eo) || ec && !eh(J, String(ec), eo))
            return null;
          for (let el of et)
            if (!eh(J, String(el), eo))
              return !1;
          return !0
        }
        let eE = !!ec && !eo.includePrerelease && !!ec.semver.prerelease.length && ec.semver
          , eC = !!el && !eo.includePrerelease && !!el.semver.prerelease.length && el.semver;
        for (let J of (eE && 1 === eE.prerelease.length && "<" === ec.operator && 0 === eE.prerelease[0] && (eE = !1),
          et)) {
          if (e_ = e_ || ">" === J.operator || ">=" === J.operator,
            ew = ew || "<" === J.operator || "<=" === J.operator,
            el) {
            if (eC && J.semver.prerelease && J.semver.prerelease.length && J.semver.major === eC.major && J.semver.minor === eC.minor && J.semver.patch === eC.patch && (eC = !1),
              ">" === J.operator || ">=" === J.operator) {
              if ((ey = higherGT(el, J, eo)) === J && ey !== el)
                return !1
            } else if (">=" === el.operator && !eh(el.semver, String(J), eo))
              return !1
          }
          if (ec) {
            if (eE && J.semver.prerelease && J.semver.prerelease.length && J.semver.major === eE.major && J.semver.minor === eE.minor && J.semver.patch === eE.patch && (eE = !1),
              "<" === J.operator || "<=" === J.operator) {
              if ((eb = lowerLT(ec, J, eo)) === J && eb !== ec)
                return !1
            } else if ("<=" === ec.operator && !eh(ec.semver, String(J), eo))
              return !1
          }
          if (!J.operator && (ec || el) && 0 !== eg)
            return !1
        }
        return (!el || !ew || !!ec || 0 === eg) && (!ec || !e_ || !!el || 0 === eg) && !eC && !eE
      }
      , higherGT = (J, et, eo) => {
        if (!J)
          return et;
        let el = ep(J.semver, et.semver, eo);
        return el > 0 ? J : el < 0 ? et : ">" === et.operator && ">=" === J.operator ? et : J
      }
      , lowerLT = (J, et, eo) => {
        if (!J)
          return et;
        let el = ep(J.semver, et.semver, eo);
        return el < 0 ? J : el > 0 ? et : "<" === et.operator && "<=" === J.operator ? et : J
      }
      ;
    J.exports = (J, et, eo = {}) => {
      if (J === et)
        return !0;
      J = new el(J, eo),
        et = new el(et, eo);
      let ec = !1;
      t: for (let el of J.set) {
        for (let J of et.set) {
          let et = simpleSubset(el, J, eo);
          if (ec = ec || null !== et,
            et)
            continue t
        }
        if (ec)
          return !1
      }
      return !0
    }
  },
  40458: function (J, et, eo) {
    let el = eo(15579);
    J.exports = (J, et) => new el(J, et).set.map(J => J.map(J => J.value).join(" ").trim().split(" "))
  },
  77677: function (J, et, eo) {
    let el = eo(15579);
    J.exports = (J, et) => {
      try {
        return new el(J, et).range || "*"
      } catch (J) {
        return null
      }
    }
  },
  29332: function (J) {
    "use strict";
    J.exports = function (J) {
      J.prototype[Symbol.iterator] = function* () {
        for (let J = this.head; J; J = J.next)
          yield J.value
      }
    }
  },
  64403: function (J, et, eo) {
    "use strict";
    function Yallist(J) {
      var et = this;
      if (et instanceof Yallist || (et = new Yallist),
        et.tail = null,
        et.head = null,
        et.length = 0,
        J && "function" == typeof J.forEach)
        J.forEach(function (J) {
          et.push(J)
        });
      else if (arguments.length > 0)
        for (var eo = 0, el = arguments.length; eo < el; eo++)
          et.push(arguments[eo]);
      return et
    }
    function Node(J, et, eo, el) {
      if (!(this instanceof Node))
        return new Node(J, et, eo, el);
      this.list = el,
        this.value = J,
        et ? (et.next = this,
          this.prev = et) : this.prev = null,
        eo ? (eo.prev = this,
          this.next = eo) : this.next = null
    }
    J.exports = Yallist,
      Yallist.Node = Node,
      Yallist.create = Yallist,
      Yallist.prototype.removeNode = function (J) {
        if (J.list !== this)
          throw Error("removing node which does not belong to this list");
        var et = J.next
          , eo = J.prev;
        return et && (et.prev = eo),
          eo && (eo.next = et),
          J === this.head && (this.head = et),
          J === this.tail && (this.tail = eo),
          J.list.length--,
          J.next = null,
          J.prev = null,
          J.list = null,
          et
      }
      ,
      Yallist.prototype.unshiftNode = function (J) {
        if (J !== this.head) {
          J.list && J.list.removeNode(J);
          var et = this.head;
          J.list = this,
            J.next = et,
            et && (et.prev = J),
            this.head = J,
            this.tail || (this.tail = J),
            this.length++
        }
      }
      ,
      Yallist.prototype.pushNode = function (J) {
        if (J !== this.tail) {
          J.list && J.list.removeNode(J);
          var et = this.tail;
          J.list = this,
            J.prev = et,
            et && (et.next = J),
            this.tail = J,
            this.head || (this.head = J),
            this.length++
        }
      }
      ,
      Yallist.prototype.push = function () {
        for (var J, et = 0, eo = arguments.length; et < eo; et++)
          J = arguments[et],
            this.tail = new Node(J, this.tail, null, this),
            this.head || (this.head = this.tail),
            this.length++;
        return this.length
      }
      ,
      Yallist.prototype.unshift = function () {
        for (var J, et = 0, eo = arguments.length; et < eo; et++)
          J = arguments[et],
            this.head = new Node(J, null, this.head, this),
            this.tail || (this.tail = this.head),
            this.length++;
        return this.length
      }
      ,
      Yallist.prototype.pop = function () {
        if (this.tail) {
          var J = this.tail.value;
          return this.tail = this.tail.prev,
            this.tail ? this.tail.next = null : this.head = null,
            this.length--,
            J
        }
      }
      ,
      Yallist.prototype.shift = function () {
        if (this.head) {
          var J = this.head.value;
          return this.head = this.head.next,
            this.head ? this.head.prev = null : this.tail = null,
            this.length--,
            J
        }
      }
      ,
      Yallist.prototype.forEach = function (J, et) {
        et = et || this;
        for (var eo = this.head, el = 0; null !== eo; el++)
          J.call(et, eo.value, el, this),
            eo = eo.next
      }
      ,
      Yallist.prototype.forEachReverse = function (J, et) {
        et = et || this;
        for (var eo = this.tail, el = this.length - 1; null !== eo; el--)
          J.call(et, eo.value, el, this),
            eo = eo.prev
      }
      ,
      Yallist.prototype.get = function (J) {
        for (var et = 0, eo = this.head; null !== eo && et < J; et++)
          eo = eo.next;
        if (et === J && null !== eo)
          return eo.value
      }
      ,
      Yallist.prototype.getReverse = function (J) {
        for (var et = 0, eo = this.tail; null !== eo && et < J; et++)
          eo = eo.prev;
        if (et === J && null !== eo)
          return eo.value
      }
      ,
      Yallist.prototype.map = function (J, et) {
        et = et || this;
        for (var eo = new Yallist, el = this.head; null !== el;)
          eo.push(J.call(et, el.value, this)),
            el = el.next;
        return eo
      }
      ,
      Yallist.prototype.mapReverse = function (J, et) {
        et = et || this;
        for (var eo = new Yallist, el = this.tail; null !== el;)
          eo.push(J.call(et, el.value, this)),
            el = el.prev;
        return eo
      }
      ,
      Yallist.prototype.reduce = function (J, et) {
        var eo, el = this.head;
        if (arguments.length > 1)
          eo = et;
        else if (this.head)
          el = this.head.next,
            eo = this.head.value;
        else
          throw TypeError("Reduce of empty list with no initial value");
        for (var ec = 0; null !== el; ec++)
          eo = J(eo, el.value, ec),
            el = el.next;
        return eo
      }
      ,
      Yallist.prototype.reduceReverse = function (J, et) {
        var eo, el = this.tail;
        if (arguments.length > 1)
          eo = et;
        else if (this.tail)
          el = this.tail.prev,
            eo = this.tail.value;
        else
          throw TypeError("Reduce of empty list with no initial value");
        for (var ec = this.length - 1; null !== el; ec--)
          eo = J(eo, el.value, ec),
            el = el.prev;
        return eo
      }
      ,
      Yallist.prototype.toArray = function () {
        for (var J = Array(this.length), et = 0, eo = this.head; null !== eo; et++)
          J[et] = eo.value,
            eo = eo.next;
        return J
      }
      ,
      Yallist.prototype.toArrayReverse = function () {
        for (var J = Array(this.length), et = 0, eo = this.tail; null !== eo; et++)
          J[et] = eo.value,
            eo = eo.prev;
        return J
      }
      ,
      Yallist.prototype.slice = function (J, et) {
        (et = et || this.length) < 0 && (et += this.length),
          (J = J || 0) < 0 && (J += this.length);
        var eo = new Yallist;
        if (et < J || et < 0)
          return eo;
        J < 0 && (J = 0),
          et > this.length && (et = this.length);
        for (var el = 0, ec = this.head; null !== ec && el < J; el++)
          ec = ec.next;
        for (; null !== ec && el < et; el++,
          ec = ec.next)
          eo.push(ec.value);
        return eo
      }
      ,
      Yallist.prototype.sliceReverse = function (J, et) {
        (et = et || this.length) < 0 && (et += this.length),
          (J = J || 0) < 0 && (J += this.length);
        var eo = new Yallist;
        if (et < J || et < 0)
          return eo;
        J < 0 && (J = 0),
          et > this.length && (et = this.length);
        for (var el = this.length, ec = this.tail; null !== ec && el > et; el--)
          ec = ec.prev;
        for (; null !== ec && el > J; el--,
          ec = ec.prev)
          eo.push(ec.value);
        return eo
      }
      ,
      Yallist.prototype.splice = function (J, et, ...eo) {
        J > this.length && (J = this.length - 1),
          J < 0 && (J = this.length + J);
        for (var el = 0, ec = this.head; null !== ec && el < J; el++)
          ec = ec.next;
        for (var ed = [], el = 0; ec && el < et; el++)
          ed.push(ec.value),
            ec = this.removeNode(ec);
        null === ec && (ec = this.tail),
          ec !== this.head && ec !== this.tail && (ec = ec.prev);
        for (var el = 0; el < eo.length; el++)
          ec = function (J, et, eo) {
            var el = et === J.head ? new Node(eo, null, et, J) : new Node(eo, et, et.next, J);
            return null === el.next && (J.tail = el),
              null === el.prev && (J.head = el),
              J.length++,
              el
          }(this, ec, eo[el]);
        return ed
      }
      ,
      Yallist.prototype.reverse = function () {
        for (var J = this.head, et = this.tail, eo = J; null !== eo; eo = eo.prev) {
          var el = eo.prev;
          eo.prev = eo.next,
            eo.next = el
        }
        return this.head = et,
          this.tail = J,
          this
      }
      ;
    try {
      eo(29332)(Yallist)
    } catch (J) { }
  },
  98099: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    });
    var el = eo(97117);
    function writeUint16BE(J, et, eo) {
      return void 0 === et && (et = new Uint8Array(2)),
        void 0 === eo && (eo = 0),
        et[eo + 0] = J >>> 8,
        et[eo + 1] = J >>> 0,
        et
    }
    function writeUint16LE(J, et, eo) {
      return void 0 === et && (et = new Uint8Array(2)),
        void 0 === eo && (eo = 0),
        et[eo + 0] = J >>> 0,
        et[eo + 1] = J >>> 8,
        et
    }
    function readInt32BE(J, et) {
      return void 0 === et && (et = 0),
        J[et] << 24 | J[et + 1] << 16 | J[et + 2] << 8 | J[et + 3]
    }
    function readUint32BE(J, et) {
      return void 0 === et && (et = 0),
        (J[et] << 24 | J[et + 1] << 16 | J[et + 2] << 8 | J[et + 3]) >>> 0
    }
    function readInt32LE(J, et) {
      return void 0 === et && (et = 0),
        J[et + 3] << 24 | J[et + 2] << 16 | J[et + 1] << 8 | J[et]
    }
    function readUint32LE(J, et) {
      return void 0 === et && (et = 0),
        (J[et + 3] << 24 | J[et + 2] << 16 | J[et + 1] << 8 | J[et]) >>> 0
    }
    function writeUint32BE(J, et, eo) {
      return void 0 === et && (et = new Uint8Array(4)),
        void 0 === eo && (eo = 0),
        et[eo + 0] = J >>> 24,
        et[eo + 1] = J >>> 16,
        et[eo + 2] = J >>> 8,
        et[eo + 3] = J >>> 0,
        et
    }
    function writeUint32LE(J, et, eo) {
      return void 0 === et && (et = new Uint8Array(4)),
        void 0 === eo && (eo = 0),
        et[eo + 0] = J >>> 0,
        et[eo + 1] = J >>> 8,
        et[eo + 2] = J >>> 16,
        et[eo + 3] = J >>> 24,
        et
    }
    function writeUint64BE(J, et, eo) {
      return void 0 === et && (et = new Uint8Array(8)),
        void 0 === eo && (eo = 0),
        writeUint32BE(J / 4294967296 >>> 0, et, eo),
        writeUint32BE(J >>> 0, et, eo + 4),
        et
    }
    function writeUint64LE(J, et, eo) {
      return void 0 === et && (et = new Uint8Array(8)),
        void 0 === eo && (eo = 0),
        writeUint32LE(J >>> 0, et, eo),
        writeUint32LE(J / 4294967296 >>> 0, et, eo + 4),
        et
    }
    et.readInt16BE = function (J, et) {
      return void 0 === et && (et = 0),
        (J[et + 0] << 8 | J[et + 1]) << 16 >> 16
    }
      ,
      et.readUint16BE = function (J, et) {
        return void 0 === et && (et = 0),
          (J[et + 0] << 8 | J[et + 1]) >>> 0
      }
      ,
      et.readInt16LE = function (J, et) {
        return void 0 === et && (et = 0),
          (J[et + 1] << 8 | J[et]) << 16 >> 16
      }
      ,
      et.readUint16LE = function (J, et) {
        return void 0 === et && (et = 0),
          (J[et + 1] << 8 | J[et]) >>> 0
      }
      ,
      et.writeUint16BE = writeUint16BE,
      et.writeInt16BE = writeUint16BE,
      et.writeUint16LE = writeUint16LE,
      et.writeInt16LE = writeUint16LE,
      et.readInt32BE = readInt32BE,
      et.readUint32BE = readUint32BE,
      et.readInt32LE = readInt32LE,
      et.readUint32LE = readUint32LE,
      et.writeUint32BE = writeUint32BE,
      et.writeInt32BE = writeUint32BE,
      et.writeUint32LE = writeUint32LE,
      et.writeInt32LE = writeUint32LE,
      et.readInt64BE = function (J, et) {
        void 0 === et && (et = 0);
        var eo = readInt32BE(J, et)
          , el = readInt32BE(J, et + 4);
        return 4294967296 * eo + el - (el >> 31) * 4294967296
      }
      ,
      et.readUint64BE = function (J, et) {
        return void 0 === et && (et = 0),
          4294967296 * readUint32BE(J, et) + readUint32BE(J, et + 4)
      }
      ,
      et.readInt64LE = function (J, et) {
        void 0 === et && (et = 0);
        var eo = readInt32LE(J, et);
        return 4294967296 * readInt32LE(J, et + 4) + eo - (eo >> 31) * 4294967296
      }
      ,
      et.readUint64LE = function (J, et) {
        void 0 === et && (et = 0);
        var eo = readUint32LE(J, et);
        return 4294967296 * readUint32LE(J, et + 4) + eo
      }
      ,
      et.writeUint64BE = writeUint64BE,
      et.writeInt64BE = writeUint64BE,
      et.writeUint64LE = writeUint64LE,
      et.writeInt64LE = writeUint64LE,
      et.readUintBE = function (J, et, eo) {
        if (void 0 === eo && (eo = 0),
          J % 8 != 0)
          throw Error("readUintBE supports only bitLengths divisible by 8");
        if (J / 8 > et.length - eo)
          throw Error("readUintBE: array is too short for the given bitLength");
        for (var el = 0, ec = 1, ed = J / 8 + eo - 1; ed >= eo; ed--)
          el += et[ed] * ec,
            ec *= 256;
        return el
      }
      ,
      et.readUintLE = function (J, et, eo) {
        if (void 0 === eo && (eo = 0),
          J % 8 != 0)
          throw Error("readUintLE supports only bitLengths divisible by 8");
        if (J / 8 > et.length - eo)
          throw Error("readUintLE: array is too short for the given bitLength");
        for (var el = 0, ec = 1, ed = eo; ed < eo + J / 8; ed++)
          el += et[ed] * ec,
            ec *= 256;
        return el
      }
      ,
      et.writeUintBE = function (J, et, eo, ec) {
        if (void 0 === eo && (eo = new Uint8Array(J / 8)),
          void 0 === ec && (ec = 0),
          J % 8 != 0)
          throw Error("writeUintBE supports only bitLengths divisible by 8");
        if (!el.isSafeInteger(et))
          throw Error("writeUintBE value must be an integer");
        for (var ed = 1, eh = J / 8 + ec - 1; eh >= ec; eh--)
          eo[eh] = et / ed & 255,
            ed *= 256;
        return eo
      }
      ,
      et.writeUintLE = function (J, et, eo, ec) {
        if (void 0 === eo && (eo = new Uint8Array(J / 8)),
          void 0 === ec && (ec = 0),
          J % 8 != 0)
          throw Error("writeUintLE supports only bitLengths divisible by 8");
        if (!el.isSafeInteger(et))
          throw Error("writeUintLE value must be an integer");
        for (var ed = 1, eh = ec; eh < ec + J / 8; eh++)
          eo[eh] = et / ed & 255,
            ed *= 256;
        return eo
      }
      ,
      et.readFloat32BE = function (J, et) {
        return void 0 === et && (et = 0),
          new DataView(J.buffer, J.byteOffset, J.byteLength).getFloat32(et)
      }
      ,
      et.readFloat32LE = function (J, et) {
        return void 0 === et && (et = 0),
          new DataView(J.buffer, J.byteOffset, J.byteLength).getFloat32(et, !0)
      }
      ,
      et.readFloat64BE = function (J, et) {
        return void 0 === et && (et = 0),
          new DataView(J.buffer, J.byteOffset, J.byteLength).getFloat64(et)
      }
      ,
      et.readFloat64LE = function (J, et) {
        return void 0 === et && (et = 0),
          new DataView(J.buffer, J.byteOffset, J.byteLength).getFloat64(et, !0)
      }
      ,
      et.writeFloat32BE = function (J, et, eo) {
        return void 0 === et && (et = new Uint8Array(4)),
          void 0 === eo && (eo = 0),
          new DataView(et.buffer, et.byteOffset, et.byteLength).setFloat32(eo, J),
          et
      }
      ,
      et.writeFloat32LE = function (J, et, eo) {
        return void 0 === et && (et = new Uint8Array(4)),
          void 0 === eo && (eo = 0),
          new DataView(et.buffer, et.byteOffset, et.byteLength).setFloat32(eo, J, !0),
          et
      }
      ,
      et.writeFloat64BE = function (J, et, eo) {
        return void 0 === et && (et = new Uint8Array(8)),
          void 0 === eo && (eo = 0),
          new DataView(et.buffer, et.byteOffset, et.byteLength).setFloat64(eo, J),
          et
      }
      ,
      et.writeFloat64LE = function (J, et, eo) {
        return void 0 === et && (et = new Uint8Array(8)),
          void 0 === eo && (eo = 0),
          new DataView(et.buffer, et.byteOffset, et.byteLength).setFloat64(eo, J, !0),
          et
      }
  },
  25439: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    });
    var el = eo(98099)
      , ec = eo(17309);
    function streamXOR(J, et, eo, ed, eh) {
      if (void 0 === eh && (eh = 0),
        32 !== J.length)
        throw Error("ChaCha: key size must be 32 bytes");
      if (ed.length < eo.length)
        throw Error("ChaCha: destination is shorter than source");
      if (0 === eh) {
        if (8 !== et.length && 12 !== et.length)
          throw Error("ChaCha nonce must be 8 or 12 bytes");
        ef = (ep = new Uint8Array(16)).length - et.length,
          ep.set(et, ef)
      } else {
        if (16 !== et.length)
          throw Error("ChaCha nonce with counter must be 16 bytes");
        ep = et,
          ef = eh
      }
      for (var ep, ef, em = new Uint8Array(64), eg = 0; eg < eo.length; eg += 64) {
        !function (J, et, eo) {
          for (var ec = eo[3] << 24 | eo[2] << 16 | eo[1] << 8 | eo[0], ed = eo[7] << 24 | eo[6] << 16 | eo[5] << 8 | eo[4], eh = eo[11] << 24 | eo[10] << 16 | eo[9] << 8 | eo[8], ep = eo[15] << 24 | eo[14] << 16 | eo[13] << 8 | eo[12], ef = eo[19] << 24 | eo[18] << 16 | eo[17] << 8 | eo[16], em = eo[23] << 24 | eo[22] << 16 | eo[21] << 8 | eo[20], eg = eo[27] << 24 | eo[26] << 16 | eo[25] << 8 | eo[24], ey = eo[31] << 24 | eo[30] << 16 | eo[29] << 8 | eo[28], eb = et[3] << 24 | et[2] << 16 | et[1] << 8 | et[0], ew = et[7] << 24 | et[6] << 16 | et[5] << 8 | et[4], e_ = et[11] << 24 | et[10] << 16 | et[9] << 8 | et[8], ex = et[15] << 24 | et[14] << 16 | et[13] << 8 | et[12], eE = 1634760805, eC = 857760878, eS = 2036477234, ek = 1797285236, eT = ec, eA = ed, eP = eh, eR = ep, eI = ef, eO = em, eN = eg, eM = ey, eD = eb, ej = ew, eL = e_, e$ = ex, eB = 0; eB < 20; eB += 2)
            eD ^= eE = eE + eT | 0,
              eT ^= eI = eI + (eD = eD >>> 16 | eD << 16) | 0,
              eT = eT >>> 20 | eT << 12,
              ej ^= eC = eC + eA | 0,
              eA ^= eO = eO + (ej = ej >>> 16 | ej << 16) | 0,
              eA = eA >>> 20 | eA << 12,
              eL ^= eS = eS + eP | 0,
              eP ^= eN = eN + (eL = eL >>> 16 | eL << 16) | 0,
              eP = eP >>> 20 | eP << 12,
              e$ ^= ek = ek + eR | 0,
              eR ^= eM = eM + (e$ = e$ >>> 16 | e$ << 16) | 0,
              eR = eR >>> 20 | eR << 12,
              eL ^= eS = eS + eP | 0,
              eP ^= eN = eN + (eL = eL >>> 24 | eL << 8) | 0,
              eP = eP >>> 25 | eP << 7,
              e$ ^= ek = ek + eR | 0,
              eR ^= eM = eM + (e$ = e$ >>> 24 | e$ << 8) | 0,
              eR = eR >>> 25 | eR << 7,
              ej ^= eC = eC + eA | 0,
              eA ^= eO = eO + (ej = ej >>> 24 | ej << 8) | 0,
              eA = eA >>> 25 | eA << 7,
              eD ^= eE = eE + eT | 0,
              eT ^= eI = eI + (eD = eD >>> 24 | eD << 8) | 0,
              eT = eT >>> 25 | eT << 7,
              e$ ^= eE = eE + eA | 0,
              eA ^= eN = eN + (e$ = e$ >>> 16 | e$ << 16) | 0,
              eA = eA >>> 20 | eA << 12,
              eD ^= eC = eC + eP | 0,
              eP ^= eM = eM + (eD = eD >>> 16 | eD << 16) | 0,
              eP = eP >>> 20 | eP << 12,
              ej ^= eS = eS + eR | 0,
              eR ^= eI = eI + (ej = ej >>> 16 | ej << 16) | 0,
              eR = eR >>> 20 | eR << 12,
              eL ^= ek = ek + eT | 0,
              eT ^= eO = eO + (eL = eL >>> 16 | eL << 16) | 0,
              eT = eT >>> 20 | eT << 12,
              ej ^= eS = eS + eR | 0,
              eR ^= eI = eI + (ej = ej >>> 24 | ej << 8) | 0,
              eR = eR >>> 25 | eR << 7,
              eL ^= ek = ek + eT | 0,
              eT ^= eO = eO + (eL = eL >>> 24 | eL << 8) | 0,
              eT = eT >>> 25 | eT << 7,
              eD ^= eC = eC + eP | 0,
              eP ^= eM = eM + (eD = eD >>> 24 | eD << 8) | 0,
              eP = eP >>> 25 | eP << 7,
              e$ ^= eE = eE + eA | 0,
              eA ^= eN = eN + (e$ = e$ >>> 24 | e$ << 8) | 0,
              eA = eA >>> 25 | eA << 7;
          el.writeUint32LE(eE + 1634760805 | 0, J, 0),
            el.writeUint32LE(eC + 857760878 | 0, J, 4),
            el.writeUint32LE(eS + 2036477234 | 0, J, 8),
            el.writeUint32LE(ek + 1797285236 | 0, J, 12),
            el.writeUint32LE(eT + ec | 0, J, 16),
            el.writeUint32LE(eA + ed | 0, J, 20),
            el.writeUint32LE(eP + eh | 0, J, 24),
            el.writeUint32LE(eR + ep | 0, J, 28),
            el.writeUint32LE(eI + ef | 0, J, 32),
            el.writeUint32LE(eO + em | 0, J, 36),
            el.writeUint32LE(eN + eg | 0, J, 40),
            el.writeUint32LE(eM + ey | 0, J, 44),
            el.writeUint32LE(eD + eb | 0, J, 48),
            el.writeUint32LE(ej + ew | 0, J, 52),
            el.writeUint32LE(eL + e_ | 0, J, 56),
            el.writeUint32LE(e$ + ex | 0, J, 60)
        }(em, ep, J);
        for (var ey = eg; ey < eg + 64 && ey < eo.length; ey++)
          ed[ey] = eo[ey] ^ em[ey - eg];
        !function (J, et, eo) {
          for (var el = 1; eo--;)
            el = el + (255 & J[et]) | 0,
              J[et] = 255 & el,
              el >>>= 8,
              et++;
          if (el > 0)
            throw Error("ChaCha: counter overflow")
        }(ep, 0, ef)
      }
      return ec.wipe(em),
        0 === eh && ec.wipe(ep),
        ed
    }
    et.streamXOR = streamXOR,
      et.stream = function (J, et, eo, el) {
        return void 0 === el && (el = 0),
          ec.wipe(eo),
          streamXOR(J, et, eo, eo, el)
      }
  },
  15501: function (J, et, eo) {
    "use strict";
    var el = eo(25439)
      , ec = eo(63027)
      , ed = eo(17309)
      , eh = eo(98099)
      , ep = eo(4153);
    et.Cv = 32,
      et.WH = 12,
      et.pg = 16;
    var ef = new Uint8Array(16)
      , em = function () {
        function ChaCha20Poly1305(J) {
          if (this.nonceLength = et.WH,
            this.tagLength = et.pg,
            J.length !== et.Cv)
            throw Error("ChaCha20Poly1305 needs 32-byte key");
          this._key = new Uint8Array(J)
        }
        return ChaCha20Poly1305.prototype.seal = function (J, et, eo, ec) {
          if (J.length > 16)
            throw Error("ChaCha20Poly1305: incorrect nonce length");
          var eh, ep = new Uint8Array(16);
          ep.set(J, ep.length - J.length);
          var ef = new Uint8Array(32);
          el.stream(this._key, ep, ef, 4);
          var em = et.length + this.tagLength;
          if (ec) {
            if (ec.length !== em)
              throw Error("ChaCha20Poly1305: incorrect destination length");
            eh = ec
          } else
            eh = new Uint8Array(em);
          return el.streamXOR(this._key, ep, et, eh, 4),
            this._authenticate(eh.subarray(eh.length - this.tagLength, eh.length), ef, eh.subarray(0, eh.length - this.tagLength), eo),
            ed.wipe(ep),
            eh
        }
          ,
          ChaCha20Poly1305.prototype.open = function (J, et, eo, ec) {
            if (J.length > 16)
              throw Error("ChaCha20Poly1305: incorrect nonce length");
            if (et.length < this.tagLength)
              return null;
            var eh, ef = new Uint8Array(16);
            ef.set(J, ef.length - J.length);
            var em = new Uint8Array(32);
            el.stream(this._key, ef, em, 4);
            var eg = new Uint8Array(this.tagLength);
            if (this._authenticate(eg, em, et.subarray(0, et.length - this.tagLength), eo),
              !ep.equal(eg, et.subarray(et.length - this.tagLength, et.length)))
              return null;
            var ey = et.length - this.tagLength;
            if (ec) {
              if (ec.length !== ey)
                throw Error("ChaCha20Poly1305: incorrect destination length");
              eh = ec
            } else
              eh = new Uint8Array(ey);
            return el.streamXOR(this._key, ef, et.subarray(0, et.length - this.tagLength), eh, 4),
              ed.wipe(ef),
              eh
          }
          ,
          ChaCha20Poly1305.prototype.clean = function () {
            return ed.wipe(this._key),
              this
          }
          ,
          ChaCha20Poly1305.prototype._authenticate = function (J, et, eo, el) {
            var ep = new ec.Poly1305(et);
            el && (ep.update(el),
              el.length % 16 > 0 && ep.update(ef.subarray(el.length % 16))),
              ep.update(eo),
              eo.length % 16 > 0 && ep.update(ef.subarray(eo.length % 16));
            var em = new Uint8Array(8);
            el && eh.writeUint64LE(el.length, em),
              ep.update(em),
              eh.writeUint64LE(eo.length, em),
              ep.update(em);
            for (var eg = ep.digest(), ey = 0; ey < eg.length; ey++)
              J[ey] = eg[ey];
            ep.clean(),
              ed.wipe(eg),
              ed.wipe(em)
          }
          ,
          ChaCha20Poly1305
      }();
    et.OK = em
  },
  4153: function (J, et) {
    "use strict";
    function compare(J, et) {
      if (J.length !== et.length)
        return 0;
      for (var eo = 0, el = 0; el < J.length; el++)
        eo |= J[el] ^ et[el];
      return 1 & eo - 1 >>> 8
    }
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.select = function (J, et, eo) {
        return ~(J - 1) & et | J - 1 & eo
      }
      ,
      et.lessOrEqual = function (J, et) {
        return (0 | J) - (0 | et) - 1 >>> 31 & 1
      }
      ,
      et.compare = compare,
      et.equal = function (J, et) {
        return 0 !== J.length && 0 !== et.length && 0 !== compare(J, et)
      }
  },
  31050: function (J, et, eo) {
    "use strict";
    et.Xx = et._w = et.aP = et.KS = et.jQ = void 0,
      eo(31416);
    let el = eo(93350);
    function gf(J) {
      let et = new Float64Array(16);
      if (J)
        for (let eo = 0; eo < J.length; eo++)
          et[eo] = J[eo];
      return et
    }
    eo(17309),
      et.jQ = 64,
      et.KS = 64,
      et.aP = 32;
    let ec = new Uint8Array(32);
    ec[0] = 9;
    let ed = gf()
      , eh = gf([1])
      , ep = (gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]),
        gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]))
      , ef = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553])
      , em = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]);
    function set25519(J, et) {
      for (let eo = 0; eo < 16; eo++)
        J[eo] = 0 | et[eo]
    }
    function car25519(J) {
      let et = 1;
      for (let eo = 0; eo < 16; eo++) {
        let el = J[eo] + et + 65535;
        et = Math.floor(el / 65536),
          J[eo] = el - 65536 * et
      }
      J[0] += et - 1 + 37 * (et - 1)
    }
    function sel25519(J, et, eo) {
      let el = ~(eo - 1);
      for (let eo = 0; eo < 16; eo++) {
        let ec = el & (J[eo] ^ et[eo]);
        J[eo] ^= ec,
          et[eo] ^= ec
      }
    }
    function pack25519(J, et) {
      let eo = gf()
        , el = gf();
      for (let J = 0; J < 16; J++)
        el[J] = et[J];
      car25519(el),
        car25519(el),
        car25519(el);
      for (let J = 0; J < 2; J++) {
        eo[0] = el[0] - 65517;
        for (let J = 1; J < 15; J++)
          eo[J] = el[J] - 65535 - (eo[J - 1] >> 16 & 1),
            eo[J - 1] &= 65535;
        eo[15] = el[15] - 32767 - (eo[14] >> 16 & 1);
        let J = eo[15] >> 16 & 1;
        eo[14] &= 65535,
          sel25519(el, eo, 1 - J)
      }
      for (let et = 0; et < 16; et++)
        J[2 * et] = 255 & el[et],
          J[2 * et + 1] = el[et] >> 8
    }
    gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function add(J, et, eo) {
      for (let el = 0; el < 16; el++)
        J[el] = et[el] + eo[el]
    }
    function sub(J, et, eo) {
      for (let el = 0; el < 16; el++)
        J[el] = et[el] - eo[el]
    }
    function mul(J, et, eo) {
      let el, ec, ed = 0, eh = 0, ep = 0, ef = 0, em = 0, eg = 0, ey = 0, eb = 0, ew = 0, e_ = 0, ex = 0, eE = 0, eC = 0, eS = 0, ek = 0, eT = 0, eA = 0, eP = 0, eR = 0, eI = 0, eO = 0, eN = 0, eM = 0, eD = 0, ej = 0, eL = 0, e$ = 0, eB = 0, eF = 0, eU = 0, ez = 0, eH = eo[0], eV = eo[1], eW = eo[2], eZ = eo[3], eG = eo[4], eY = eo[5], eK = eo[6], eJ = eo[7], eQ = eo[8], eX = eo[9], e0 = eo[10], e1 = eo[11], e2 = eo[12], e3 = eo[13], e5 = eo[14], e6 = eo[15];
      ed += (el = et[0]) * eH,
        eh += el * eV,
        ep += el * eW,
        ef += el * eZ,
        em += el * eG,
        eg += el * eY,
        ey += el * eK,
        eb += el * eJ,
        ew += el * eQ,
        e_ += el * eX,
        ex += el * e0,
        eE += el * e1,
        eC += el * e2,
        eS += el * e3,
        ek += el * e5,
        eT += el * e6,
        eh += (el = et[1]) * eH,
        ep += el * eV,
        ef += el * eW,
        em += el * eZ,
        eg += el * eG,
        ey += el * eY,
        eb += el * eK,
        ew += el * eJ,
        e_ += el * eQ,
        ex += el * eX,
        eE += el * e0,
        eC += el * e1,
        eS += el * e2,
        ek += el * e3,
        eT += el * e5,
        eA += el * e6,
        ep += (el = et[2]) * eH,
        ef += el * eV,
        em += el * eW,
        eg += el * eZ,
        ey += el * eG,
        eb += el * eY,
        ew += el * eK,
        e_ += el * eJ,
        ex += el * eQ,
        eE += el * eX,
        eC += el * e0,
        eS += el * e1,
        ek += el * e2,
        eT += el * e3,
        eA += el * e5,
        eP += el * e6,
        ef += (el = et[3]) * eH,
        em += el * eV,
        eg += el * eW,
        ey += el * eZ,
        eb += el * eG,
        ew += el * eY,
        e_ += el * eK,
        ex += el * eJ,
        eE += el * eQ,
        eC += el * eX,
        eS += el * e0,
        ek += el * e1,
        eT += el * e2,
        eA += el * e3,
        eP += el * e5,
        eR += el * e6,
        em += (el = et[4]) * eH,
        eg += el * eV,
        ey += el * eW,
        eb += el * eZ,
        ew += el * eG,
        e_ += el * eY,
        ex += el * eK,
        eE += el * eJ,
        eC += el * eQ,
        eS += el * eX,
        ek += el * e0,
        eT += el * e1,
        eA += el * e2,
        eP += el * e3,
        eR += el * e5,
        eI += el * e6,
        eg += (el = et[5]) * eH,
        ey += el * eV,
        eb += el * eW,
        ew += el * eZ,
        e_ += el * eG,
        ex += el * eY,
        eE += el * eK,
        eC += el * eJ,
        eS += el * eQ,
        ek += el * eX,
        eT += el * e0,
        eA += el * e1,
        eP += el * e2,
        eR += el * e3,
        eI += el * e5,
        eO += el * e6,
        ey += (el = et[6]) * eH,
        eb += el * eV,
        ew += el * eW,
        e_ += el * eZ,
        ex += el * eG,
        eE += el * eY,
        eC += el * eK,
        eS += el * eJ,
        ek += el * eQ,
        eT += el * eX,
        eA += el * e0,
        eP += el * e1,
        eR += el * e2,
        eI += el * e3,
        eO += el * e5,
        eN += el * e6,
        eb += (el = et[7]) * eH,
        ew += el * eV,
        e_ += el * eW,
        ex += el * eZ,
        eE += el * eG,
        eC += el * eY,
        eS += el * eK,
        ek += el * eJ,
        eT += el * eQ,
        eA += el * eX,
        eP += el * e0,
        eR += el * e1,
        eI += el * e2,
        eO += el * e3,
        eN += el * e5,
        eM += el * e6,
        ew += (el = et[8]) * eH,
        e_ += el * eV,
        ex += el * eW,
        eE += el * eZ,
        eC += el * eG,
        eS += el * eY,
        ek += el * eK,
        eT += el * eJ,
        eA += el * eQ,
        eP += el * eX,
        eR += el * e0,
        eI += el * e1,
        eO += el * e2,
        eN += el * e3,
        eM += el * e5,
        eD += el * e6,
        e_ += (el = et[9]) * eH,
        ex += el * eV,
        eE += el * eW,
        eC += el * eZ,
        eS += el * eG,
        ek += el * eY,
        eT += el * eK,
        eA += el * eJ,
        eP += el * eQ,
        eR += el * eX,
        eI += el * e0,
        eO += el * e1,
        eN += el * e2,
        eM += el * e3,
        eD += el * e5,
        ej += el * e6,
        ex += (el = et[10]) * eH,
        eE += el * eV,
        eC += el * eW,
        eS += el * eZ,
        ek += el * eG,
        eT += el * eY,
        eA += el * eK,
        eP += el * eJ,
        eR += el * eQ,
        eI += el * eX,
        eO += el * e0,
        eN += el * e1,
        eM += el * e2,
        eD += el * e3,
        ej += el * e5,
        eL += el * e6,
        eE += (el = et[11]) * eH,
        eC += el * eV,
        eS += el * eW,
        ek += el * eZ,
        eT += el * eG,
        eA += el * eY,
        eP += el * eK,
        eR += el * eJ,
        eI += el * eQ,
        eO += el * eX,
        eN += el * e0,
        eM += el * e1,
        eD += el * e2,
        ej += el * e3,
        eL += el * e5,
        e$ += el * e6,
        eC += (el = et[12]) * eH,
        eS += el * eV,
        ek += el * eW,
        eT += el * eZ,
        eA += el * eG,
        eP += el * eY,
        eR += el * eK,
        eI += el * eJ,
        eO += el * eQ,
        eN += el * eX,
        eM += el * e0,
        eD += el * e1,
        ej += el * e2,
        eL += el * e3,
        e$ += el * e5,
        eB += el * e6,
        eS += (el = et[13]) * eH,
        ek += el * eV,
        eT += el * eW,
        eA += el * eZ,
        eP += el * eG,
        eR += el * eY,
        eI += el * eK,
        eO += el * eJ,
        eN += el * eQ,
        eM += el * eX,
        eD += el * e0,
        ej += el * e1,
        eL += el * e2,
        e$ += el * e3,
        eB += el * e5,
        eF += el * e6,
        ek += (el = et[14]) * eH,
        eT += el * eV,
        eA += el * eW,
        eP += el * eZ,
        eR += el * eG,
        eI += el * eY,
        eO += el * eK,
        eN += el * eJ,
        eM += el * eQ,
        eD += el * eX,
        ej += el * e0,
        eL += el * e1,
        e$ += el * e2,
        eB += el * e3,
        eF += el * e5,
        eU += el * e6,
        eT += (el = et[15]) * eH,
        eA += el * eV,
        eP += el * eW,
        eR += el * eZ,
        eI += el * eG,
        eO += el * eY,
        eN += el * eK,
        eM += el * eJ,
        eD += el * eQ,
        ej += el * eX,
        eL += el * e0,
        e$ += el * e1,
        eB += el * e2,
        eF += el * e3,
        eU += el * e5,
        ez += el * e6,
        ed += 38 * eA,
        eh += 38 * eP,
        ep += 38 * eR,
        ef += 38 * eI,
        em += 38 * eO,
        eg += 38 * eN,
        ey += 38 * eM,
        eb += 38 * eD,
        ew += 38 * ej,
        e_ += 38 * eL,
        ex += 38 * e$,
        eE += 38 * eB,
        eC += 38 * eF,
        eS += 38 * eU,
        ek += 38 * ez,
        ec = Math.floor((el = ed + (ec = 1) + 65535) / 65536),
        ed = el - 65536 * ec,
        ec = Math.floor((el = eh + ec + 65535) / 65536),
        eh = el - 65536 * ec,
        ec = Math.floor((el = ep + ec + 65535) / 65536),
        ep = el - 65536 * ec,
        ec = Math.floor((el = ef + ec + 65535) / 65536),
        ef = el - 65536 * ec,
        ec = Math.floor((el = em + ec + 65535) / 65536),
        em = el - 65536 * ec,
        ec = Math.floor((el = eg + ec + 65535) / 65536),
        eg = el - 65536 * ec,
        ec = Math.floor((el = ey + ec + 65535) / 65536),
        ey = el - 65536 * ec,
        ec = Math.floor((el = eb + ec + 65535) / 65536),
        eb = el - 65536 * ec,
        ec = Math.floor((el = ew + ec + 65535) / 65536),
        ew = el - 65536 * ec,
        ec = Math.floor((el = e_ + ec + 65535) / 65536),
        e_ = el - 65536 * ec,
        ec = Math.floor((el = ex + ec + 65535) / 65536),
        ex = el - 65536 * ec,
        ec = Math.floor((el = eE + ec + 65535) / 65536),
        eE = el - 65536 * ec,
        ec = Math.floor((el = eC + ec + 65535) / 65536),
        eC = el - 65536 * ec,
        ec = Math.floor((el = eS + ec + 65535) / 65536),
        eS = el - 65536 * ec,
        ec = Math.floor((el = ek + ec + 65535) / 65536),
        ek = el - 65536 * ec,
        ec = Math.floor((el = eT + ec + 65535) / 65536),
        eT = el - 65536 * ec,
        ed += ec - 1 + 37 * (ec - 1),
        ec = Math.floor((el = ed + (ec = 1) + 65535) / 65536),
        ed = el - 65536 * ec,
        ec = Math.floor((el = eh + ec + 65535) / 65536),
        eh = el - 65536 * ec,
        ec = Math.floor((el = ep + ec + 65535) / 65536),
        ep = el - 65536 * ec,
        ec = Math.floor((el = ef + ec + 65535) / 65536),
        ef = el - 65536 * ec,
        ec = Math.floor((el = em + ec + 65535) / 65536),
        em = el - 65536 * ec,
        ec = Math.floor((el = eg + ec + 65535) / 65536),
        eg = el - 65536 * ec,
        ec = Math.floor((el = ey + ec + 65535) / 65536),
        ey = el - 65536 * ec,
        ec = Math.floor((el = eb + ec + 65535) / 65536),
        eb = el - 65536 * ec,
        ec = Math.floor((el = ew + ec + 65535) / 65536),
        ew = el - 65536 * ec,
        ec = Math.floor((el = e_ + ec + 65535) / 65536),
        e_ = el - 65536 * ec,
        ec = Math.floor((el = ex + ec + 65535) / 65536),
        ex = el - 65536 * ec,
        ec = Math.floor((el = eE + ec + 65535) / 65536),
        eE = el - 65536 * ec,
        ec = Math.floor((el = eC + ec + 65535) / 65536),
        eC = el - 65536 * ec,
        ec = Math.floor((el = eS + ec + 65535) / 65536),
        eS = el - 65536 * ec,
        ec = Math.floor((el = ek + ec + 65535) / 65536),
        ek = el - 65536 * ec,
        ec = Math.floor((el = eT + ec + 65535) / 65536),
        eT = el - 65536 * ec,
        ed += ec - 1 + 37 * (ec - 1),
        J[0] = ed,
        J[1] = eh,
        J[2] = ep,
        J[3] = ef,
        J[4] = em,
        J[5] = eg,
        J[6] = ey,
        J[7] = eb,
        J[8] = ew,
        J[9] = e_,
        J[10] = ex,
        J[11] = eE,
        J[12] = eC,
        J[13] = eS,
        J[14] = ek,
        J[15] = eT
    }
    function edadd(J, et) {
      let eo = gf()
        , el = gf()
        , ec = gf()
        , ed = gf()
        , eh = gf()
        , ef = gf()
        , em = gf()
        , eg = gf()
        , ey = gf();
      sub(eo, J[1], J[0]),
        sub(ey, et[1], et[0]),
        mul(eo, eo, ey),
        add(el, J[0], J[1]),
        add(ey, et[0], et[1]),
        mul(el, el, ey),
        mul(ec, J[3], et[3]),
        mul(ec, ec, ep),
        mul(ed, J[2], et[2]),
        add(ed, ed, ed),
        sub(eh, el, eo),
        sub(ef, ed, ec),
        add(em, ed, ec),
        add(eg, el, eo),
        mul(J[0], eh, ef),
        mul(J[1], eg, em),
        mul(J[2], em, ef),
        mul(J[3], eh, eg)
    }
    function cswap(J, et, eo) {
      for (let el = 0; el < 4; el++)
        sel25519(J[el], et[el], eo)
    }
    function pack(J, et) {
      let eo = gf()
        , el = gf()
        , ec = gf();
      (function (J, et) {
        let eo;
        let el = gf();
        for (eo = 0; eo < 16; eo++)
          el[eo] = et[eo];
        for (eo = 253; eo >= 0; eo--)
          mul(el, el, el),
            2 !== eo && 4 !== eo && mul(el, el, et);
        for (eo = 0; eo < 16; eo++)
          J[eo] = el[eo]
      }
      )(ec, et[2]),
        mul(eo, et[0], ec),
        mul(el, et[1], ec),
        pack25519(J, el),
        J[31] ^= function (J) {
          let et = new Uint8Array(32);
          return pack25519(et, J),
            1 & et[0]
        }(eo) << 7
    }
    function scalarbase(J, et) {
      let eo = [gf(), gf(), gf(), gf()];
      set25519(eo[0], ef),
        set25519(eo[1], em),
        set25519(eo[2], eh),
        mul(eo[3], ef, em),
        function (J, et, eo) {
          set25519(J[0], ed),
            set25519(J[1], eh),
            set25519(J[2], eh),
            set25519(J[3], ed);
          for (let el = 255; el >= 0; --el) {
            let ec = eo[el / 8 | 0] >> (7 & el) & 1;
            cswap(J, et, ec),
              edadd(et, J),
              edadd(J, J),
              cswap(J, et, ec)
          }
        }(J, eo, et)
    }
    et._w = function (J) {
      if (J.length !== et.aP)
        throw Error(`ed25519: seed must be ${et.aP} bytes`);
      let eo = (0,
        el.hash)(J);
      eo[0] &= 248,
        eo[31] &= 127,
        eo[31] |= 64;
      let ec = new Uint8Array(32)
        , ed = [gf(), gf(), gf(), gf()];
      scalarbase(ed, eo),
        pack(ec, ed);
      let eh = new Uint8Array(64);
      return eh.set(J),
        eh.set(ec, 32),
      {
        publicKey: ec,
        secretKey: eh
      }
    }
      ;
    let eg = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function modL(J, et) {
      let eo, el, ec, ed;
      for (el = 63; el >= 32; --el) {
        for (eo = 0,
          ec = el - 32,
          ed = el - 12; ec < ed; ++ec)
          et[ec] += eo - 16 * et[el] * eg[ec - (el - 32)],
            eo = Math.floor((et[ec] + 128) / 256),
            et[ec] -= 256 * eo;
        et[ec] += eo,
          et[el] = 0
      }
      for (ec = 0,
        eo = 0; ec < 32; ec++)
        et[ec] += eo - (et[31] >> 4) * eg[ec],
          eo = et[ec] >> 8,
          et[ec] &= 255;
      for (ec = 0; ec < 32; ec++)
        et[ec] -= eo * eg[ec];
      for (el = 0; el < 32; el++)
        et[el + 1] += et[el] >> 8,
          J[el] = 255 & et[el]
    }
    function reduce(J) {
      let et = new Float64Array(64);
      for (let eo = 0; eo < 64; eo++)
        et[eo] = J[eo];
      for (let et = 0; et < 64; et++)
        J[et] = 0;
      modL(J, et)
    }
    et.Xx = function (J, et) {
      let eo = new Float64Array(64)
        , ec = [gf(), gf(), gf(), gf()]
        , ed = (0,
          el.hash)(J.subarray(0, 32));
      ed[0] &= 248,
        ed[31] &= 127,
        ed[31] |= 64;
      let eh = new Uint8Array(64);
      eh.set(ed.subarray(32), 32);
      let ep = new el.SHA512;
      ep.update(eh.subarray(32)),
        ep.update(et);
      let ef = ep.digest();
      ep.clean(),
        reduce(ef),
        scalarbase(ec, ef),
        pack(eh, ec),
        ep.reset(),
        ep.update(eh.subarray(0, 32)),
        ep.update(J.subarray(32)),
        ep.update(et);
      let em = ep.digest();
      reduce(em);
      for (let J = 0; J < 32; J++)
        eo[J] = ef[J];
      for (let J = 0; J < 32; J++)
        for (let et = 0; et < 32; et++)
          eo[J + et] += em[J] * ed[et];
      return modL(eh.subarray(32), eo),
        eh
    }
  },
  79984: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.isSerializableHash = function (J) {
        return void 0 !== J.saveState && void 0 !== J.restoreState && void 0 !== J.cleanSavedState
      }
  },
  512: function (J, et, eo) {
    "use strict";
    var el = eo(25629)
      , ec = eo(17309)
      , ed = function () {
        function HKDF(J, et, eo, ec) {
          void 0 === eo && (eo = new Uint8Array(0)),
            this._counter = new Uint8Array(1),
            this._hash = J,
            this._info = ec;
          var ed = el.hmac(this._hash, eo, et);
          this._hmac = new el.HMAC(J, ed),
            this._buffer = new Uint8Array(this._hmac.digestLength),
            this._bufpos = this._buffer.length
        }
        return HKDF.prototype._fillBuffer = function () {
          this._counter[0]++;
          var J = this._counter[0];
          if (0 === J)
            throw Error("hkdf: cannot expand more");
          this._hmac.reset(),
            J > 1 && this._hmac.update(this._buffer),
            this._info && this._hmac.update(this._info),
            this._hmac.update(this._counter),
            this._hmac.finish(this._buffer),
            this._bufpos = 0
        }
          ,
          HKDF.prototype.expand = function (J) {
            for (var et = new Uint8Array(J), eo = 0; eo < et.length; eo++)
              this._bufpos === this._buffer.length && this._fillBuffer(),
                et[eo] = this._buffer[this._bufpos++];
            return et
          }
          ,
          HKDF.prototype.clean = function () {
            this._hmac.clean(),
              ec.wipe(this._buffer),
              ec.wipe(this._counter),
              this._bufpos = 0
          }
          ,
          HKDF
      }();
    et.t = ed
  },
  25629: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    });
    var el = eo(79984)
      , ec = eo(4153)
      , ed = eo(17309)
      , eh = function () {
        function HMAC(J, et) {
          this._finished = !1,
            this._inner = new J,
            this._outer = new J,
            this.blockSize = this._outer.blockSize,
            this.digestLength = this._outer.digestLength;
          var eo = new Uint8Array(this.blockSize);
          et.length > this.blockSize ? this._inner.update(et).finish(eo).clean() : eo.set(et);
          for (var ec = 0; ec < eo.length; ec++)
            eo[ec] ^= 54;
          this._inner.update(eo);
          for (var ec = 0; ec < eo.length; ec++)
            eo[ec] ^= 106;
          this._outer.update(eo),
            el.isSerializableHash(this._inner) && el.isSerializableHash(this._outer) && (this._innerKeyedState = this._inner.saveState(),
              this._outerKeyedState = this._outer.saveState()),
            ed.wipe(eo)
        }
        return HMAC.prototype.reset = function () {
          if (!el.isSerializableHash(this._inner) || !el.isSerializableHash(this._outer))
            throw Error("hmac: can't reset() because hash doesn't implement restoreState()");
          return this._inner.restoreState(this._innerKeyedState),
            this._outer.restoreState(this._outerKeyedState),
            this._finished = !1,
            this
        }
          ,
          HMAC.prototype.clean = function () {
            el.isSerializableHash(this._inner) && this._inner.cleanSavedState(this._innerKeyedState),
              el.isSerializableHash(this._outer) && this._outer.cleanSavedState(this._outerKeyedState),
              this._inner.clean(),
              this._outer.clean()
          }
          ,
          HMAC.prototype.update = function (J) {
            return this._inner.update(J),
              this
          }
          ,
          HMAC.prototype.finish = function (J) {
            return this._finished ? this._outer.finish(J) : (this._inner.finish(J),
              this._outer.update(J.subarray(0, this.digestLength)).finish(J),
              this._finished = !0),
              this
          }
          ,
          HMAC.prototype.digest = function () {
            var J = new Uint8Array(this.digestLength);
            return this.finish(J),
              J
          }
          ,
          HMAC.prototype.saveState = function () {
            if (!el.isSerializableHash(this._inner))
              throw Error("hmac: can't saveState() because hash doesn't implement it");
            return this._inner.saveState()
          }
          ,
          HMAC.prototype.restoreState = function (J) {
            if (!el.isSerializableHash(this._inner) || !el.isSerializableHash(this._outer))
              throw Error("hmac: can't restoreState() because hash doesn't implement it");
            return this._inner.restoreState(J),
              this._outer.restoreState(this._outerKeyedState),
              this._finished = !1,
              this
          }
          ,
          HMAC.prototype.cleanSavedState = function (J) {
            if (!el.isSerializableHash(this._inner))
              throw Error("hmac: can't cleanSavedState() because hash doesn't implement it");
            this._inner.cleanSavedState(J)
          }
          ,
          HMAC
      }();
    et.HMAC = eh,
      et.hmac = function (J, et, eo) {
        var el = new eh(J, et);
        el.update(eo);
        var ec = el.digest();
        return el.clean(),
          ec
      }
      ,
      et.equal = ec.equal
  },
  97117: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.mul = Math.imul || function (J, et) {
        var eo = 65535 & J
          , el = 65535 & et;
        return eo * el + ((J >>> 16 & 65535) * el + eo * (et >>> 16 & 65535) << 16 >>> 0) | 0
      }
      ,
      et.add = function (J, et) {
        return J + et | 0
      }
      ,
      et.sub = function (J, et) {
        return J - et | 0
      }
      ,
      et.rotl = function (J, et) {
        return J << et | J >>> 32 - et
      }
      ,
      et.rotr = function (J, et) {
        return J << 32 - et | J >>> et
      }
      ,
      et.isInteger = Number.isInteger || function (J) {
        return "number" == typeof J && isFinite(J) && Math.floor(J) === J
      }
      ,
      et.MAX_SAFE_INTEGER = 9007199254740991,
      et.isSafeInteger = function (J) {
        return et.isInteger(J) && J >= -et.MAX_SAFE_INTEGER && J <= et.MAX_SAFE_INTEGER
      }
  },
  63027: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    });
    var el = eo(4153)
      , ec = eo(17309);
    et.DIGEST_LENGTH = 16;
    var ed = function () {
      function Poly1305(J) {
        this.digestLength = et.DIGEST_LENGTH,
          this._buffer = new Uint8Array(16),
          this._r = new Uint16Array(10),
          this._h = new Uint16Array(10),
          this._pad = new Uint16Array(8),
          this._leftover = 0,
          this._fin = 0,
          this._finished = !1;
        var eo = J[0] | J[1] << 8;
        this._r[0] = 8191 & eo;
        var el = J[2] | J[3] << 8;
        this._r[1] = (eo >>> 13 | el << 3) & 8191;
        var ec = J[4] | J[5] << 8;
        this._r[2] = (el >>> 10 | ec << 6) & 7939;
        var ed = J[6] | J[7] << 8;
        this._r[3] = (ec >>> 7 | ed << 9) & 8191;
        var eh = J[8] | J[9] << 8;
        this._r[4] = (ed >>> 4 | eh << 12) & 255,
          this._r[5] = eh >>> 1 & 8190;
        var ep = J[10] | J[11] << 8;
        this._r[6] = (eh >>> 14 | ep << 2) & 8191;
        var ef = J[12] | J[13] << 8;
        this._r[7] = (ep >>> 11 | ef << 5) & 8065;
        var em = J[14] | J[15] << 8;
        this._r[8] = (ef >>> 8 | em << 8) & 8191,
          this._r[9] = em >>> 5 & 127,
          this._pad[0] = J[16] | J[17] << 8,
          this._pad[1] = J[18] | J[19] << 8,
          this._pad[2] = J[20] | J[21] << 8,
          this._pad[3] = J[22] | J[23] << 8,
          this._pad[4] = J[24] | J[25] << 8,
          this._pad[5] = J[26] | J[27] << 8,
          this._pad[6] = J[28] | J[29] << 8,
          this._pad[7] = J[30] | J[31] << 8
      }
      return Poly1305.prototype._blocks = function (J, et, eo) {
        for (var el = this._fin ? 0 : 2048, ec = this._h[0], ed = this._h[1], eh = this._h[2], ep = this._h[3], ef = this._h[4], em = this._h[5], eg = this._h[6], ey = this._h[7], eb = this._h[8], ew = this._h[9], e_ = this._r[0], ex = this._r[1], eE = this._r[2], eC = this._r[3], eS = this._r[4], ek = this._r[5], eT = this._r[6], eA = this._r[7], eP = this._r[8], eR = this._r[9]; eo >= 16;) {
          var eI, eO = J[et + 0] | J[et + 1] << 8;
          ec += 8191 & eO;
          var eN = J[et + 2] | J[et + 3] << 8;
          ed += (eO >>> 13 | eN << 3) & 8191;
          var eM = J[et + 4] | J[et + 5] << 8;
          eh += (eN >>> 10 | eM << 6) & 8191;
          var eD = J[et + 6] | J[et + 7] << 8;
          ep += (eM >>> 7 | eD << 9) & 8191;
          var ej = J[et + 8] | J[et + 9] << 8;
          ef += (eD >>> 4 | ej << 12) & 8191,
            em += ej >>> 1 & 8191;
          var eL = J[et + 10] | J[et + 11] << 8;
          eg += (ej >>> 14 | eL << 2) & 8191;
          var e$ = J[et + 12] | J[et + 13] << 8;
          ey += (eL >>> 11 | e$ << 5) & 8191;
          var eB = J[et + 14] | J[et + 15] << 8;
          eb += (e$ >>> 8 | eB << 8) & 8191,
            ew += eB >>> 5 | el;
          var eF = 0;
          eF = (eI = 0 + ec * e_ + ed * (5 * eR) + eh * (5 * eP) + ep * (5 * eA) + ef * (5 * eT)) >>> 13,
            eI &= 8191,
            eI += em * (5 * ek) + eg * (5 * eS) + ey * (5 * eC) + eb * (5 * eE) + ew * (5 * ex),
            eF += eI >>> 13,
            eI &= 8191;
          var eU = eF;
          eU += ec * ex + ed * e_ + eh * (5 * eR) + ep * (5 * eP) + ef * (5 * eA),
            eF = eU >>> 13,
            eU &= 8191,
            eU += em * (5 * eT) + eg * (5 * ek) + ey * (5 * eS) + eb * (5 * eC) + ew * (5 * eE),
            eF += eU >>> 13,
            eU &= 8191;
          var ez = eF;
          ez += ec * eE + ed * ex + eh * e_ + ep * (5 * eR) + ef * (5 * eP),
            eF = ez >>> 13,
            ez &= 8191,
            ez += em * (5 * eA) + eg * (5 * eT) + ey * (5 * ek) + eb * (5 * eS) + ew * (5 * eC),
            eF += ez >>> 13,
            ez &= 8191;
          var eH = eF;
          eH += ec * eC + ed * eE + eh * ex + ep * e_ + ef * (5 * eR),
            eF = eH >>> 13,
            eH &= 8191,
            eH += em * (5 * eP) + eg * (5 * eA) + ey * (5 * eT) + eb * (5 * ek) + ew * (5 * eS),
            eF += eH >>> 13,
            eH &= 8191;
          var eV = eF;
          eV += ec * eS + ed * eC + eh * eE + ep * ex + ef * e_,
            eF = eV >>> 13,
            eV &= 8191,
            eV += em * (5 * eR) + eg * (5 * eP) + ey * (5 * eA) + eb * (5 * eT) + ew * (5 * ek),
            eF += eV >>> 13,
            eV &= 8191;
          var eW = eF;
          eW += ec * ek + ed * eS + eh * eC + ep * eE + ef * ex,
            eF = eW >>> 13,
            eW &= 8191,
            eW += em * e_ + eg * (5 * eR) + ey * (5 * eP) + eb * (5 * eA) + ew * (5 * eT),
            eF += eW >>> 13,
            eW &= 8191;
          var eZ = eF;
          eZ += ec * eT + ed * ek + eh * eS + ep * eC + ef * eE,
            eF = eZ >>> 13,
            eZ &= 8191,
            eZ += em * ex + eg * e_ + ey * (5 * eR) + eb * (5 * eP) + ew * (5 * eA),
            eF += eZ >>> 13,
            eZ &= 8191;
          var eG = eF;
          eG += ec * eA + ed * eT + eh * ek + ep * eS + ef * eC,
            eF = eG >>> 13,
            eG &= 8191,
            eG += em * eE + eg * ex + ey * e_ + eb * (5 * eR) + ew * (5 * eP),
            eF += eG >>> 13,
            eG &= 8191;
          var eY = eF;
          eY += ec * eP + ed * eA + eh * eT + ep * ek + ef * eS,
            eF = eY >>> 13,
            eY &= 8191,
            eY += em * eC + eg * eE + ey * ex + eb * e_ + ew * (5 * eR),
            eF += eY >>> 13,
            eY &= 8191;
          var eK = eF;
          eK += ec * eR + ed * eP + eh * eA + ep * eT + ef * ek,
            eF = eK >>> 13,
            eK &= 8191,
            eK += em * eS + eg * eC + ey * eE + eb * ex + ew * e_,
            eF += eK >>> 13,
            eK &= 8191,
            eI = 8191 & (eF = (eF = (eF << 2) + eF | 0) + eI | 0),
            eF >>>= 13,
            eU += eF,
            ec = eI,
            ed = eU,
            eh = ez,
            ep = eH,
            ef = eV,
            em = eW,
            eg = eZ,
            ey = eG,
            eb = eY,
            ew = eK,
            et += 16,
            eo -= 16
        }
        this._h[0] = ec,
          this._h[1] = ed,
          this._h[2] = eh,
          this._h[3] = ep,
          this._h[4] = ef,
          this._h[5] = em,
          this._h[6] = eg,
          this._h[7] = ey,
          this._h[8] = eb,
          this._h[9] = ew
      }
        ,
        Poly1305.prototype.finish = function (J, et) {
          void 0 === et && (et = 0);
          var eo, el, ec, ed, eh = new Uint16Array(10);
          if (this._leftover) {
            for (ed = this._leftover,
              this._buffer[ed++] = 1; ed < 16; ed++)
              this._buffer[ed] = 0;
            this._fin = 1,
              this._blocks(this._buffer, 0, 16)
          }
          for (eo = this._h[1] >>> 13,
            this._h[1] &= 8191,
            ed = 2; ed < 10; ed++)
            this._h[ed] += eo,
              eo = this._h[ed] >>> 13,
              this._h[ed] &= 8191;
          for (this._h[0] += 5 * eo,
            eo = this._h[0] >>> 13,
            this._h[0] &= 8191,
            this._h[1] += eo,
            eo = this._h[1] >>> 13,
            this._h[1] &= 8191,
            this._h[2] += eo,
            eh[0] = this._h[0] + 5,
            eo = eh[0] >>> 13,
            eh[0] &= 8191,
            ed = 1; ed < 10; ed++)
            eh[ed] = this._h[ed] + eo,
              eo = eh[ed] >>> 13,
              eh[ed] &= 8191;
          for (eh[9] -= 8192,
            el = (1 ^ eo) - 1,
            ed = 0; ed < 10; ed++)
            eh[ed] &= el;
          for (ed = 0,
            el = ~el; ed < 10; ed++)
            this._h[ed] = this._h[ed] & el | eh[ed];
          for (ed = 1,
            this._h[0] = (this._h[0] | this._h[1] << 13) & 65535,
            this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535,
            this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535,
            this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535,
            this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535,
            this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535,
            this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535,
            this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535,
            ec = this._h[0] + this._pad[0],
            this._h[0] = 65535 & ec; ed < 8; ed++)
            ec = (this._h[ed] + this._pad[ed] | 0) + (ec >>> 16) | 0,
              this._h[ed] = 65535 & ec;
          return J[et + 0] = this._h[0] >>> 0,
            J[et + 1] = this._h[0] >>> 8,
            J[et + 2] = this._h[1] >>> 0,
            J[et + 3] = this._h[1] >>> 8,
            J[et + 4] = this._h[2] >>> 0,
            J[et + 5] = this._h[2] >>> 8,
            J[et + 6] = this._h[3] >>> 0,
            J[et + 7] = this._h[3] >>> 8,
            J[et + 8] = this._h[4] >>> 0,
            J[et + 9] = this._h[4] >>> 8,
            J[et + 10] = this._h[5] >>> 0,
            J[et + 11] = this._h[5] >>> 8,
            J[et + 12] = this._h[6] >>> 0,
            J[et + 13] = this._h[6] >>> 8,
            J[et + 14] = this._h[7] >>> 0,
            J[et + 15] = this._h[7] >>> 8,
            this._finished = !0,
            this
        }
        ,
        Poly1305.prototype.update = function (J) {
          var et, eo = 0, el = J.length;
          if (this._leftover) {
            (et = 16 - this._leftover) > el && (et = el);
            for (var ec = 0; ec < et; ec++)
              this._buffer[this._leftover + ec] = J[eo + ec];
            if (el -= et,
              eo += et,
              this._leftover += et,
              this._leftover < 16)
              return this;
            this._blocks(this._buffer, 0, 16),
              this._leftover = 0
          }
          if (el >= 16 && (et = el - el % 16,
            this._blocks(J, eo, et),
            eo += et,
            el -= et),
            el) {
            for (var ec = 0; ec < el; ec++)
              this._buffer[this._leftover + ec] = J[eo + ec];
            this._leftover += el
          }
          return this
        }
        ,
        Poly1305.prototype.digest = function () {
          if (this._finished)
            throw Error("Poly1305 was finished");
          var J = new Uint8Array(16);
          return this.finish(J),
            J
        }
        ,
        Poly1305.prototype.clean = function () {
          return ec.wipe(this._buffer),
            ec.wipe(this._r),
            ec.wipe(this._h),
            ec.wipe(this._pad),
            this._leftover = 0,
            this._fin = 0,
            this._finished = !0,
            this
        }
        ,
        Poly1305
    }();
    et.Poly1305 = ed,
      et.oneTimeAuth = function (J, et) {
        var eo = new ed(J);
        eo.update(et);
        var el = eo.digest();
        return eo.clean(),
          el
      }
      ,
      et.equal = function (J, eo) {
        return J.length === et.DIGEST_LENGTH && eo.length === et.DIGEST_LENGTH && el.equal(J, eo)
      }
  },
  31416: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.randomStringForEntropy = et.randomString = et.randomUint32 = et.randomBytes = et.defaultRandomSource = void 0;
    let el = eo(46008)
      , ec = eo(98099)
      , ed = eo(17309);
    function randomBytes(J, eo = et.defaultRandomSource) {
      return eo.randomBytes(J)
    }
    et.defaultRandomSource = new el.SystemRandomSource,
      et.randomBytes = randomBytes,
      et.randomUint32 = function (J = et.defaultRandomSource) {
        let eo = randomBytes(4, J)
          , el = (0,
            ec.readUint32LE)(eo);
        return (0,
          ed.wipe)(eo),
          el
      }
      ;
    let eh = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    function randomString(J, eo = eh, el = et.defaultRandomSource) {
      if (eo.length < 2)
        throw Error("randomString charset is too short");
      if (eo.length > 256)
        throw Error("randomString charset is too long");
      let ec = ""
        , ep = eo.length
        , ef = 256 - 256 % ep;
      for (; J > 0;) {
        let et = randomBytes(Math.ceil(256 * J / ef), el);
        for (let el = 0; el < et.length && J > 0; el++) {
          let ed = et[el];
          ed < ef && (ec += eo.charAt(ed % ep),
            J--)
        }
        (0,
          ed.wipe)(et)
      }
      return ec
    }
    et.randomString = randomString,
      et.randomStringForEntropy = function (J, eo = eh, el = et.defaultRandomSource) {
        let ec = Math.ceil(J / (Math.log(eo.length) / Math.LN2));
        return randomString(ec, eo, el)
      }
  },
  75455: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.BrowserRandomSource = void 0,
      et.BrowserRandomSource = class {
        constructor() {
          this.isAvailable = !1,
            this.isInstantiated = !1;
          let J = "undefined" != typeof self ? self.crypto || self.msCrypto : null;
          J && void 0 !== J.getRandomValues && (this._crypto = J,
            this.isAvailable = !0,
            this.isInstantiated = !0)
        }
        randomBytes(J) {
          if (!this.isAvailable || !this._crypto)
            throw Error("Browser random byte generator is not available.");
          let et = new Uint8Array(J);
          for (let J = 0; J < et.length; J += 65536)
            this._crypto.getRandomValues(et.subarray(J, J + Math.min(et.length - J, 65536)));
          return et
        }
      }
  },
  58871: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.NodeRandomSource = void 0;
    let el = eo(17309);
    et.NodeRandomSource = class {
      constructor() {
        this.isAvailable = !1,
          this.isInstantiated = !1;
        {
          let J = eo(35883);
          J && J.randomBytes && (this._crypto = J,
            this.isAvailable = !0,
            this.isInstantiated = !0)
        }
      }
      randomBytes(J) {
        if (!this.isAvailable || !this._crypto)
          throw Error("Node.js random byte generator is not available.");
        let et = this._crypto.randomBytes(J);
        if (et.length !== J)
          throw Error("NodeRandomSource: got fewer bytes than requested");
        let eo = new Uint8Array(J);
        for (let J = 0; J < eo.length; J++)
          eo[J] = et[J];
        return (0,
          el.wipe)(et),
          eo
      }
    }
  },
  46008: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.SystemRandomSource = void 0;
    let el = eo(75455)
      , ec = eo(58871);
    et.SystemRandomSource = class {
      constructor() {
        if (this.isAvailable = !1,
          this.name = "",
          this._source = new el.BrowserRandomSource,
          this._source.isAvailable) {
          this.isAvailable = !0,
            this.name = "Browser";
          return
        }
        if (this._source = new ec.NodeRandomSource,
          this._source.isAvailable) {
          this.isAvailable = !0,
            this.name = "Node";
          return
        }
      }
      randomBytes(J) {
        if (!this.isAvailable)
          throw Error("System random byte generator is not available.");
        return this._source.randomBytes(J)
      }
    }
  },
  73294: function (J, et, eo) {
    "use strict";
    var el = eo(98099)
      , ec = eo(17309);
    et.k = 32,
      et.cn = 64;
    var ed = function () {
      function SHA256() {
        this.digestLength = et.k,
          this.blockSize = et.cn,
          this._state = new Int32Array(8),
          this._temp = new Int32Array(64),
          this._buffer = new Uint8Array(128),
          this._bufferLength = 0,
          this._bytesHashed = 0,
          this._finished = !1,
          this.reset()
      }
      return SHA256.prototype._initState = function () {
        this._state[0] = 1779033703,
          this._state[1] = 3144134277,
          this._state[2] = 1013904242,
          this._state[3] = 2773480762,
          this._state[4] = 1359893119,
          this._state[5] = 2600822924,
          this._state[6] = 528734635,
          this._state[7] = 1541459225
      }
        ,
        SHA256.prototype.reset = function () {
          return this._initState(),
            this._bufferLength = 0,
            this._bytesHashed = 0,
            this._finished = !1,
            this
        }
        ,
        SHA256.prototype.clean = function () {
          ec.wipe(this._buffer),
            ec.wipe(this._temp),
            this.reset()
        }
        ,
        SHA256.prototype.update = function (J, et) {
          if (void 0 === et && (et = J.length),
            this._finished)
            throw Error("SHA256: can't update because hash was finished.");
          var eo = 0;
          if (this._bytesHashed += et,
            this._bufferLength > 0) {
            for (; this._bufferLength < this.blockSize && et > 0;)
              this._buffer[this._bufferLength++] = J[eo++],
                et--;
            this._bufferLength === this.blockSize && (hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize),
              this._bufferLength = 0)
          }
          for (et >= this.blockSize && (eo = hashBlocks(this._temp, this._state, J, eo, et),
            et %= this.blockSize); et > 0;)
            this._buffer[this._bufferLength++] = J[eo++],
              et--;
          return this
        }
        ,
        SHA256.prototype.finish = function (J) {
          if (!this._finished) {
            var et = this._bytesHashed
              , eo = this._bufferLength
              , ec = et % 64 < 56 ? 64 : 128;
            this._buffer[eo] = 128;
            for (var ed = eo + 1; ed < ec - 8; ed++)
              this._buffer[ed] = 0;
            el.writeUint32BE(et / 536870912 | 0, this._buffer, ec - 8),
              el.writeUint32BE(et << 3, this._buffer, ec - 4),
              hashBlocks(this._temp, this._state, this._buffer, 0, ec),
              this._finished = !0
          }
          for (var ed = 0; ed < this.digestLength / 4; ed++)
            el.writeUint32BE(this._state[ed], J, 4 * ed);
          return this
        }
        ,
        SHA256.prototype.digest = function () {
          var J = new Uint8Array(this.digestLength);
          return this.finish(J),
            J
        }
        ,
        SHA256.prototype.saveState = function () {
          if (this._finished)
            throw Error("SHA256: cannot save finished state");
          return {
            state: new Int32Array(this._state),
            buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
            bufferLength: this._bufferLength,
            bytesHashed: this._bytesHashed
          }
        }
        ,
        SHA256.prototype.restoreState = function (J) {
          return this._state.set(J.state),
            this._bufferLength = J.bufferLength,
            J.buffer && this._buffer.set(J.buffer),
            this._bytesHashed = J.bytesHashed,
            this._finished = !1,
            this
        }
        ,
        SHA256.prototype.cleanSavedState = function (J) {
          ec.wipe(J.state),
            J.buffer && ec.wipe(J.buffer),
            J.bufferLength = 0,
            J.bytesHashed = 0
        }
        ,
        SHA256
    }();
    et.mE = ed;
    var eh = new Int32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
    function hashBlocks(J, et, eo, ec, ed) {
      for (; ed >= 64;) {
        for (var ep = et[0], ef = et[1], em = et[2], eg = et[3], ey = et[4], eb = et[5], ew = et[6], e_ = et[7], ex = 0; ex < 16; ex++) {
          var eE = ec + 4 * ex;
          J[ex] = el.readUint32BE(eo, eE)
        }
        for (var ex = 16; ex < 64; ex++) {
          var eC = J[ex - 2]
            , eS = (eC >>> 17 | eC << 15) ^ (eC >>> 19 | eC << 13) ^ eC >>> 10
            , ek = ((eC = J[ex - 15]) >>> 7 | eC << 25) ^ (eC >>> 18 | eC << 14) ^ eC >>> 3;
          J[ex] = (eS + J[ex - 7] | 0) + (ek + J[ex - 16] | 0)
        }
        for (var ex = 0; ex < 64; ex++) {
          var eS = (((ey >>> 6 | ey << 26) ^ (ey >>> 11 | ey << 21) ^ (ey >>> 25 | ey << 7)) + (ey & eb ^ ~ey & ew) | 0) + (e_ + (eh[ex] + J[ex] | 0) | 0) | 0
            , ek = ((ep >>> 2 | ep << 30) ^ (ep >>> 13 | ep << 19) ^ (ep >>> 22 | ep << 10)) + (ep & ef ^ ep & em ^ ef & em) | 0;
          e_ = ew,
            ew = eb,
            eb = ey,
            ey = eg + eS | 0,
            eg = em,
            em = ef,
            ef = ep,
            ep = eS + ek | 0
        }
        et[0] += ep,
          et[1] += ef,
          et[2] += em,
          et[3] += eg,
          et[4] += ey,
          et[5] += eb,
          et[6] += ew,
          et[7] += e_,
          ec += 64,
          ed -= 64
      }
      return ec
    }
    et.vp = function (J) {
      var et = new ed;
      et.update(J);
      var eo = et.digest();
      return et.clean(),
        eo
    }
  },
  93350: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    });
    var el = eo(98099)
      , ec = eo(17309);
    et.DIGEST_LENGTH = 64,
      et.BLOCK_SIZE = 128;
    var ed = function () {
      function SHA512() {
        this.digestLength = et.DIGEST_LENGTH,
          this.blockSize = et.BLOCK_SIZE,
          this._stateHi = new Int32Array(8),
          this._stateLo = new Int32Array(8),
          this._tempHi = new Int32Array(16),
          this._tempLo = new Int32Array(16),
          this._buffer = new Uint8Array(256),
          this._bufferLength = 0,
          this._bytesHashed = 0,
          this._finished = !1,
          this.reset()
      }
      return SHA512.prototype._initState = function () {
        this._stateHi[0] = 1779033703,
          this._stateHi[1] = 3144134277,
          this._stateHi[2] = 1013904242,
          this._stateHi[3] = 2773480762,
          this._stateHi[4] = 1359893119,
          this._stateHi[5] = 2600822924,
          this._stateHi[6] = 528734635,
          this._stateHi[7] = 1541459225,
          this._stateLo[0] = 4089235720,
          this._stateLo[1] = 2227873595,
          this._stateLo[2] = 4271175723,
          this._stateLo[3] = 1595750129,
          this._stateLo[4] = 2917565137,
          this._stateLo[5] = 725511199,
          this._stateLo[6] = 4215389547,
          this._stateLo[7] = 327033209
      }
        ,
        SHA512.prototype.reset = function () {
          return this._initState(),
            this._bufferLength = 0,
            this._bytesHashed = 0,
            this._finished = !1,
            this
        }
        ,
        SHA512.prototype.clean = function () {
          ec.wipe(this._buffer),
            ec.wipe(this._tempHi),
            ec.wipe(this._tempLo),
            this.reset()
        }
        ,
        SHA512.prototype.update = function (J, eo) {
          if (void 0 === eo && (eo = J.length),
            this._finished)
            throw Error("SHA512: can't update because hash was finished.");
          var el = 0;
          if (this._bytesHashed += eo,
            this._bufferLength > 0) {
            for (; this._bufferLength < et.BLOCK_SIZE && eo > 0;)
              this._buffer[this._bufferLength++] = J[el++],
                eo--;
            this._bufferLength === this.blockSize && (hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize),
              this._bufferLength = 0)
          }
          for (eo >= this.blockSize && (el = hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, J, el, eo),
            eo %= this.blockSize); eo > 0;)
            this._buffer[this._bufferLength++] = J[el++],
              eo--;
          return this
        }
        ,
        SHA512.prototype.finish = function (J) {
          if (!this._finished) {
            var et = this._bytesHashed
              , eo = this._bufferLength
              , ec = et % 128 < 112 ? 128 : 256;
            this._buffer[eo] = 128;
            for (var ed = eo + 1; ed < ec - 8; ed++)
              this._buffer[ed] = 0;
            el.writeUint32BE(et / 536870912 | 0, this._buffer, ec - 8),
              el.writeUint32BE(et << 3, this._buffer, ec - 4),
              hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, ec),
              this._finished = !0
          }
          for (var ed = 0; ed < this.digestLength / 8; ed++)
            el.writeUint32BE(this._stateHi[ed], J, 8 * ed),
              el.writeUint32BE(this._stateLo[ed], J, 8 * ed + 4);
          return this
        }
        ,
        SHA512.prototype.digest = function () {
          var J = new Uint8Array(this.digestLength);
          return this.finish(J),
            J
        }
        ,
        SHA512.prototype.saveState = function () {
          if (this._finished)
            throw Error("SHA256: cannot save finished state");
          return {
            stateHi: new Int32Array(this._stateHi),
            stateLo: new Int32Array(this._stateLo),
            buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
            bufferLength: this._bufferLength,
            bytesHashed: this._bytesHashed
          }
        }
        ,
        SHA512.prototype.restoreState = function (J) {
          return this._stateHi.set(J.stateHi),
            this._stateLo.set(J.stateLo),
            this._bufferLength = J.bufferLength,
            J.buffer && this._buffer.set(J.buffer),
            this._bytesHashed = J.bytesHashed,
            this._finished = !1,
            this
        }
        ,
        SHA512.prototype.cleanSavedState = function (J) {
          ec.wipe(J.stateHi),
            ec.wipe(J.stateLo),
            J.buffer && ec.wipe(J.buffer),
            J.bufferLength = 0,
            J.bytesHashed = 0
        }
        ,
        SHA512
    }();
    et.SHA512 = ed;
    var eh = new Int32Array([1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591]);
    function hashBlocks(J, et, eo, ec, ed, ep, ef) {
      for (var em, eg, ey, eb, ew, e_, ex, eE, eC = eo[0], eS = eo[1], ek = eo[2], eT = eo[3], eA = eo[4], eP = eo[5], eR = eo[6], eI = eo[7], eO = ec[0], eN = ec[1], eM = ec[2], eD = ec[3], ej = ec[4], eL = ec[5], e$ = ec[6], eB = ec[7]; ef >= 128;) {
        for (var eF = 0; eF < 16; eF++) {
          var eU = 8 * eF + ep;
          J[eF] = el.readUint32BE(ed, eU),
            et[eF] = el.readUint32BE(ed, eU + 4)
        }
        for (var eF = 0; eF < 80; eF++) {
          var ez = eC
            , eH = eS
            , eV = ek
            , eW = eT
            , eZ = eA
            , eG = eP
            , eY = eR
            , eK = eI
            , eJ = eO
            , eQ = eN
            , eX = eM
            , e0 = eD
            , e1 = ej
            , e2 = eL
            , e3 = e$
            , e5 = eB;
          if (em = eI,
            ew = 65535 & (eg = eB),
            e_ = eg >>> 16,
            ex = 65535 & em,
            eE = em >>> 16,
            em = (eA >>> 14 | ej << 18) ^ (eA >>> 18 | ej << 14) ^ (ej >>> 9 | eA << 23),
            ew += 65535 & (eg = (ej >>> 14 | eA << 18) ^ (ej >>> 18 | eA << 14) ^ (eA >>> 9 | ej << 23)),
            e_ += eg >>> 16,
            ex += 65535 & em,
            eE += em >>> 16,
            em = eA & eP ^ ~eA & eR,
            ew += 65535 & (eg = ej & eL ^ ~ej & e$),
            e_ += eg >>> 16,
            ex += 65535 & em,
            eE += em >>> 16,
            em = eh[2 * eF],
            ew += 65535 & (eg = eh[2 * eF + 1]),
            e_ += eg >>> 16,
            ex += 65535 & em,
            eE += em >>> 16,
            em = J[eF % 16],
            ew += 65535 & (eg = et[eF % 16]),
            e_ += eg >>> 16,
            ex += 65535 & em,
            eE += em >>> 16,
            e_ += ew >>> 16,
            ex += e_ >>> 16,
            eE += ex >>> 16,
            ey = 65535 & ex | eE << 16,
            eb = 65535 & ew | e_ << 16,
            em = ey,
            ew = 65535 & (eg = eb),
            e_ = eg >>> 16,
            ex = 65535 & em,
            eE = em >>> 16,
            em = (eC >>> 28 | eO << 4) ^ (eO >>> 2 | eC << 30) ^ (eO >>> 7 | eC << 25),
            ew += 65535 & (eg = (eO >>> 28 | eC << 4) ^ (eC >>> 2 | eO << 30) ^ (eC >>> 7 | eO << 25)),
            e_ += eg >>> 16,
            ex += 65535 & em,
            eE += em >>> 16,
            em = eC & eS ^ eC & ek ^ eS & ek,
            ew += 65535 & (eg = eO & eN ^ eO & eM ^ eN & eM),
            e_ += eg >>> 16,
            ex += 65535 & em,
            eE += em >>> 16,
            e_ += ew >>> 16,
            ex += e_ >>> 16,
            eE += ex >>> 16,
            eK = 65535 & ex | eE << 16,
            e5 = 65535 & ew | e_ << 16,
            em = eW,
            ew = 65535 & (eg = e0),
            e_ = eg >>> 16,
            ex = 65535 & em,
            eE = em >>> 16,
            em = ey,
            ew += 65535 & (eg = eb),
            e_ += eg >>> 16,
            ex += 65535 & em,
            eE += em >>> 16,
            e_ += ew >>> 16,
            ex += e_ >>> 16,
            eE += ex >>> 16,
            eW = 65535 & ex | eE << 16,
            e0 = 65535 & ew | e_ << 16,
            eS = ez,
            ek = eH,
            eT = eV,
            eA = eW,
            eP = eZ,
            eR = eG,
            eI = eY,
            eC = eK,
            eN = eJ,
            eM = eQ,
            eD = eX,
            ej = e0,
            eL = e1,
            e$ = e2,
            eB = e3,
            eO = e5,
            eF % 16 == 15)
            for (var eU = 0; eU < 16; eU++)
              em = J[eU],
                ew = 65535 & (eg = et[eU]),
                e_ = eg >>> 16,
                ex = 65535 & em,
                eE = em >>> 16,
                em = J[(eU + 9) % 16],
                ew += 65535 & (eg = et[(eU + 9) % 16]),
                e_ += eg >>> 16,
                ex += 65535 & em,
                eE += em >>> 16,
                em = ((ey = J[(eU + 1) % 16]) >>> 1 | (eb = et[(eU + 1) % 16]) << 31) ^ (ey >>> 8 | eb << 24) ^ ey >>> 7,
                ew += 65535 & (eg = (eb >>> 1 | ey << 31) ^ (eb >>> 8 | ey << 24) ^ (eb >>> 7 | ey << 25)),
                e_ += eg >>> 16,
                ex += 65535 & em,
                eE += em >>> 16,
                em = ((ey = J[(eU + 14) % 16]) >>> 19 | (eb = et[(eU + 14) % 16]) << 13) ^ (eb >>> 29 | ey << 3) ^ ey >>> 6,
                ew += 65535 & (eg = (eb >>> 19 | ey << 13) ^ (ey >>> 29 | eb << 3) ^ (eb >>> 6 | ey << 26)),
                e_ += eg >>> 16,
                ex += 65535 & em,
                eE += em >>> 16,
                e_ += ew >>> 16,
                ex += e_ >>> 16,
                eE += ex >>> 16,
                J[eU] = 65535 & ex | eE << 16,
                et[eU] = 65535 & ew | e_ << 16
        }
        em = eC,
          ew = 65535 & (eg = eO),
          e_ = eg >>> 16,
          ex = 65535 & em,
          eE = em >>> 16,
          em = eo[0],
          ew += 65535 & (eg = ec[0]),
          e_ += eg >>> 16,
          ex += 65535 & em,
          eE += em >>> 16,
          e_ += ew >>> 16,
          ex += e_ >>> 16,
          eE += ex >>> 16,
          eo[0] = eC = 65535 & ex | eE << 16,
          ec[0] = eO = 65535 & ew | e_ << 16,
          em = eS,
          ew = 65535 & (eg = eN),
          e_ = eg >>> 16,
          ex = 65535 & em,
          eE = em >>> 16,
          em = eo[1],
          ew += 65535 & (eg = ec[1]),
          e_ += eg >>> 16,
          ex += 65535 & em,
          eE += em >>> 16,
          e_ += ew >>> 16,
          ex += e_ >>> 16,
          eE += ex >>> 16,
          eo[1] = eS = 65535 & ex | eE << 16,
          ec[1] = eN = 65535 & ew | e_ << 16,
          em = ek,
          ew = 65535 & (eg = eM),
          e_ = eg >>> 16,
          ex = 65535 & em,
          eE = em >>> 16,
          em = eo[2],
          ew += 65535 & (eg = ec[2]),
          e_ += eg >>> 16,
          ex += 65535 & em,
          eE += em >>> 16,
          e_ += ew >>> 16,
          ex += e_ >>> 16,
          eE += ex >>> 16,
          eo[2] = ek = 65535 & ex | eE << 16,
          ec[2] = eM = 65535 & ew | e_ << 16,
          em = eT,
          ew = 65535 & (eg = eD),
          e_ = eg >>> 16,
          ex = 65535 & em,
          eE = em >>> 16,
          em = eo[3],
          ew += 65535 & (eg = ec[3]),
          e_ += eg >>> 16,
          ex += 65535 & em,
          eE += em >>> 16,
          e_ += ew >>> 16,
          ex += e_ >>> 16,
          eE += ex >>> 16,
          eo[3] = eT = 65535 & ex | eE << 16,
          ec[3] = eD = 65535 & ew | e_ << 16,
          em = eA,
          ew = 65535 & (eg = ej),
          e_ = eg >>> 16,
          ex = 65535 & em,
          eE = em >>> 16,
          em = eo[4],
          ew += 65535 & (eg = ec[4]),
          e_ += eg >>> 16,
          ex += 65535 & em,
          eE += em >>> 16,
          e_ += ew >>> 16,
          ex += e_ >>> 16,
          eE += ex >>> 16,
          eo[4] = eA = 65535 & ex | eE << 16,
          ec[4] = ej = 65535 & ew | e_ << 16,
          em = eP,
          ew = 65535 & (eg = eL),
          e_ = eg >>> 16,
          ex = 65535 & em,
          eE = em >>> 16,
          em = eo[5],
          ew += 65535 & (eg = ec[5]),
          e_ += eg >>> 16,
          ex += 65535 & em,
          eE += em >>> 16,
          e_ += ew >>> 16,
          ex += e_ >>> 16,
          eE += ex >>> 16,
          eo[5] = eP = 65535 & ex | eE << 16,
          ec[5] = eL = 65535 & ew | e_ << 16,
          em = eR,
          ew = 65535 & (eg = e$),
          e_ = eg >>> 16,
          ex = 65535 & em,
          eE = em >>> 16,
          em = eo[6],
          ew += 65535 & (eg = ec[6]),
          e_ += eg >>> 16,
          ex += 65535 & em,
          eE += em >>> 16,
          e_ += ew >>> 16,
          ex += e_ >>> 16,
          eE += ex >>> 16,
          eo[6] = eR = 65535 & ex | eE << 16,
          ec[6] = e$ = 65535 & ew | e_ << 16,
          em = eI,
          ew = 65535 & (eg = eB),
          e_ = eg >>> 16,
          ex = 65535 & em,
          eE = em >>> 16,
          em = eo[7],
          ew += 65535 & (eg = ec[7]),
          e_ += eg >>> 16,
          ex += 65535 & em,
          eE += em >>> 16,
          e_ += ew >>> 16,
          ex += e_ >>> 16,
          eE += ex >>> 16,
          eo[7] = eI = 65535 & ex | eE << 16,
          ec[7] = eB = 65535 & ew | e_ << 16,
          ep += 128,
          ef -= 128
      }
      return ep
    }
    et.hash = function (J) {
      var et = new ed;
      et.update(J);
      var eo = et.digest();
      return et.clean(),
        eo
    }
  },
  17309: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.wipe = function (J) {
        for (var et = 0; et < J.length; et++)
          J[et] = 0;
        return J
      }
  },
  57664: function (J, et, eo) {
    "use strict";
    et.gi = et.Au = et.KS = et.kz = void 0;
    let el = eo(31416)
      , ec = eo(17309);
    function gf(J) {
      let et = new Float64Array(16);
      if (J)
        for (let eo = 0; eo < J.length; eo++)
          et[eo] = J[eo];
      return et
    }
    et.kz = 32,
      et.KS = 32;
    let ed = new Uint8Array(32);
    ed[0] = 9;
    let eh = gf([56129, 1]);
    function car25519(J) {
      let et = 1;
      for (let eo = 0; eo < 16; eo++) {
        let el = J[eo] + et + 65535;
        et = Math.floor(el / 65536),
          J[eo] = el - 65536 * et
      }
      J[0] += et - 1 + 37 * (et - 1)
    }
    function sel25519(J, et, eo) {
      let el = ~(eo - 1);
      for (let eo = 0; eo < 16; eo++) {
        let ec = el & (J[eo] ^ et[eo]);
        J[eo] ^= ec,
          et[eo] ^= ec
      }
    }
    function add(J, et, eo) {
      for (let el = 0; el < 16; el++)
        J[el] = et[el] + eo[el]
    }
    function sub(J, et, eo) {
      for (let el = 0; el < 16; el++)
        J[el] = et[el] - eo[el]
    }
    function mul(J, et, eo) {
      let el, ec, ed = 0, eh = 0, ep = 0, ef = 0, em = 0, eg = 0, ey = 0, eb = 0, ew = 0, e_ = 0, ex = 0, eE = 0, eC = 0, eS = 0, ek = 0, eT = 0, eA = 0, eP = 0, eR = 0, eI = 0, eO = 0, eN = 0, eM = 0, eD = 0, ej = 0, eL = 0, e$ = 0, eB = 0, eF = 0, eU = 0, ez = 0, eH = eo[0], eV = eo[1], eW = eo[2], eZ = eo[3], eG = eo[4], eY = eo[5], eK = eo[6], eJ = eo[7], eQ = eo[8], eX = eo[9], e0 = eo[10], e1 = eo[11], e2 = eo[12], e3 = eo[13], e5 = eo[14], e6 = eo[15];
      ed += (el = et[0]) * eH,
        eh += el * eV,
        ep += el * eW,
        ef += el * eZ,
        em += el * eG,
        eg += el * eY,
        ey += el * eK,
        eb += el * eJ,
        ew += el * eQ,
        e_ += el * eX,
        ex += el * e0,
        eE += el * e1,
        eC += el * e2,
        eS += el * e3,
        ek += el * e5,
        eT += el * e6,
        eh += (el = et[1]) * eH,
        ep += el * eV,
        ef += el * eW,
        em += el * eZ,
        eg += el * eG,
        ey += el * eY,
        eb += el * eK,
        ew += el * eJ,
        e_ += el * eQ,
        ex += el * eX,
        eE += el * e0,
        eC += el * e1,
        eS += el * e2,
        ek += el * e3,
        eT += el * e5,
        eA += el * e6,
        ep += (el = et[2]) * eH,
        ef += el * eV,
        em += el * eW,
        eg += el * eZ,
        ey += el * eG,
        eb += el * eY,
        ew += el * eK,
        e_ += el * eJ,
        ex += el * eQ,
        eE += el * eX,
        eC += el * e0,
        eS += el * e1,
        ek += el * e2,
        eT += el * e3,
        eA += el * e5,
        eP += el * e6,
        ef += (el = et[3]) * eH,
        em += el * eV,
        eg += el * eW,
        ey += el * eZ,
        eb += el * eG,
        ew += el * eY,
        e_ += el * eK,
        ex += el * eJ,
        eE += el * eQ,
        eC += el * eX,
        eS += el * e0,
        ek += el * e1,
        eT += el * e2,
        eA += el * e3,
        eP += el * e5,
        eR += el * e6,
        em += (el = et[4]) * eH,
        eg += el * eV,
        ey += el * eW,
        eb += el * eZ,
        ew += el * eG,
        e_ += el * eY,
        ex += el * eK,
        eE += el * eJ,
        eC += el * eQ,
        eS += el * eX,
        ek += el * e0,
        eT += el * e1,
        eA += el * e2,
        eP += el * e3,
        eR += el * e5,
        eI += el * e6,
        eg += (el = et[5]) * eH,
        ey += el * eV,
        eb += el * eW,
        ew += el * eZ,
        e_ += el * eG,
        ex += el * eY,
        eE += el * eK,
        eC += el * eJ,
        eS += el * eQ,
        ek += el * eX,
        eT += el * e0,
        eA += el * e1,
        eP += el * e2,
        eR += el * e3,
        eI += el * e5,
        eO += el * e6,
        ey += (el = et[6]) * eH,
        eb += el * eV,
        ew += el * eW,
        e_ += el * eZ,
        ex += el * eG,
        eE += el * eY,
        eC += el * eK,
        eS += el * eJ,
        ek += el * eQ,
        eT += el * eX,
        eA += el * e0,
        eP += el * e1,
        eR += el * e2,
        eI += el * e3,
        eO += el * e5,
        eN += el * e6,
        eb += (el = et[7]) * eH,
        ew += el * eV,
        e_ += el * eW,
        ex += el * eZ,
        eE += el * eG,
        eC += el * eY,
        eS += el * eK,
        ek += el * eJ,
        eT += el * eQ,
        eA += el * eX,
        eP += el * e0,
        eR += el * e1,
        eI += el * e2,
        eO += el * e3,
        eN += el * e5,
        eM += el * e6,
        ew += (el = et[8]) * eH,
        e_ += el * eV,
        ex += el * eW,
        eE += el * eZ,
        eC += el * eG,
        eS += el * eY,
        ek += el * eK,
        eT += el * eJ,
        eA += el * eQ,
        eP += el * eX,
        eR += el * e0,
        eI += el * e1,
        eO += el * e2,
        eN += el * e3,
        eM += el * e5,
        eD += el * e6,
        e_ += (el = et[9]) * eH,
        ex += el * eV,
        eE += el * eW,
        eC += el * eZ,
        eS += el * eG,
        ek += el * eY,
        eT += el * eK,
        eA += el * eJ,
        eP += el * eQ,
        eR += el * eX,
        eI += el * e0,
        eO += el * e1,
        eN += el * e2,
        eM += el * e3,
        eD += el * e5,
        ej += el * e6,
        ex += (el = et[10]) * eH,
        eE += el * eV,
        eC += el * eW,
        eS += el * eZ,
        ek += el * eG,
        eT += el * eY,
        eA += el * eK,
        eP += el * eJ,
        eR += el * eQ,
        eI += el * eX,
        eO += el * e0,
        eN += el * e1,
        eM += el * e2,
        eD += el * e3,
        ej += el * e5,
        eL += el * e6,
        eE += (el = et[11]) * eH,
        eC += el * eV,
        eS += el * eW,
        ek += el * eZ,
        eT += el * eG,
        eA += el * eY,
        eP += el * eK,
        eR += el * eJ,
        eI += el * eQ,
        eO += el * eX,
        eN += el * e0,
        eM += el * e1,
        eD += el * e2,
        ej += el * e3,
        eL += el * e5,
        e$ += el * e6,
        eC += (el = et[12]) * eH,
        eS += el * eV,
        ek += el * eW,
        eT += el * eZ,
        eA += el * eG,
        eP += el * eY,
        eR += el * eK,
        eI += el * eJ,
        eO += el * eQ,
        eN += el * eX,
        eM += el * e0,
        eD += el * e1,
        ej += el * e2,
        eL += el * e3,
        e$ += el * e5,
        eB += el * e6,
        eS += (el = et[13]) * eH,
        ek += el * eV,
        eT += el * eW,
        eA += el * eZ,
        eP += el * eG,
        eR += el * eY,
        eI += el * eK,
        eO += el * eJ,
        eN += el * eQ,
        eM += el * eX,
        eD += el * e0,
        ej += el * e1,
        eL += el * e2,
        e$ += el * e3,
        eB += el * e5,
        eF += el * e6,
        ek += (el = et[14]) * eH,
        eT += el * eV,
        eA += el * eW,
        eP += el * eZ,
        eR += el * eG,
        eI += el * eY,
        eO += el * eK,
        eN += el * eJ,
        eM += el * eQ,
        eD += el * eX,
        ej += el * e0,
        eL += el * e1,
        e$ += el * e2,
        eB += el * e3,
        eF += el * e5,
        eU += el * e6,
        eT += (el = et[15]) * eH,
        eA += el * eV,
        eP += el * eW,
        eR += el * eZ,
        eI += el * eG,
        eO += el * eY,
        eN += el * eK,
        eM += el * eJ,
        eD += el * eQ,
        ej += el * eX,
        eL += el * e0,
        e$ += el * e1,
        eB += el * e2,
        eF += el * e3,
        eU += el * e5,
        ez += el * e6,
        ed += 38 * eA,
        eh += 38 * eP,
        ep += 38 * eR,
        ef += 38 * eI,
        em += 38 * eO,
        eg += 38 * eN,
        ey += 38 * eM,
        eb += 38 * eD,
        ew += 38 * ej,
        e_ += 38 * eL,
        ex += 38 * e$,
        eE += 38 * eB,
        eC += 38 * eF,
        eS += 38 * eU,
        ek += 38 * ez,
        ec = Math.floor((el = ed + (ec = 1) + 65535) / 65536),
        ed = el - 65536 * ec,
        ec = Math.floor((el = eh + ec + 65535) / 65536),
        eh = el - 65536 * ec,
        ec = Math.floor((el = ep + ec + 65535) / 65536),
        ep = el - 65536 * ec,
        ec = Math.floor((el = ef + ec + 65535) / 65536),
        ef = el - 65536 * ec,
        ec = Math.floor((el = em + ec + 65535) / 65536),
        em = el - 65536 * ec,
        ec = Math.floor((el = eg + ec + 65535) / 65536),
        eg = el - 65536 * ec,
        ec = Math.floor((el = ey + ec + 65535) / 65536),
        ey = el - 65536 * ec,
        ec = Math.floor((el = eb + ec + 65535) / 65536),
        eb = el - 65536 * ec,
        ec = Math.floor((el = ew + ec + 65535) / 65536),
        ew = el - 65536 * ec,
        ec = Math.floor((el = e_ + ec + 65535) / 65536),
        e_ = el - 65536 * ec,
        ec = Math.floor((el = ex + ec + 65535) / 65536),
        ex = el - 65536 * ec,
        ec = Math.floor((el = eE + ec + 65535) / 65536),
        eE = el - 65536 * ec,
        ec = Math.floor((el = eC + ec + 65535) / 65536),
        eC = el - 65536 * ec,
        ec = Math.floor((el = eS + ec + 65535) / 65536),
        eS = el - 65536 * ec,
        ec = Math.floor((el = ek + ec + 65535) / 65536),
        ek = el - 65536 * ec,
        ec = Math.floor((el = eT + ec + 65535) / 65536),
        eT = el - 65536 * ec,
        ed += ec - 1 + 37 * (ec - 1),
        ec = Math.floor((el = ed + (ec = 1) + 65535) / 65536),
        ed = el - 65536 * ec,
        ec = Math.floor((el = eh + ec + 65535) / 65536),
        eh = el - 65536 * ec,
        ec = Math.floor((el = ep + ec + 65535) / 65536),
        ep = el - 65536 * ec,
        ec = Math.floor((el = ef + ec + 65535) / 65536),
        ef = el - 65536 * ec,
        ec = Math.floor((el = em + ec + 65535) / 65536),
        em = el - 65536 * ec,
        ec = Math.floor((el = eg + ec + 65535) / 65536),
        eg = el - 65536 * ec,
        ec = Math.floor((el = ey + ec + 65535) / 65536),
        ey = el - 65536 * ec,
        ec = Math.floor((el = eb + ec + 65535) / 65536),
        eb = el - 65536 * ec,
        ec = Math.floor((el = ew + ec + 65535) / 65536),
        ew = el - 65536 * ec,
        ec = Math.floor((el = e_ + ec + 65535) / 65536),
        e_ = el - 65536 * ec,
        ec = Math.floor((el = ex + ec + 65535) / 65536),
        ex = el - 65536 * ec,
        ec = Math.floor((el = eE + ec + 65535) / 65536),
        eE = el - 65536 * ec,
        ec = Math.floor((el = eC + ec + 65535) / 65536),
        eC = el - 65536 * ec,
        ec = Math.floor((el = eS + ec + 65535) / 65536),
        eS = el - 65536 * ec,
        ec = Math.floor((el = ek + ec + 65535) / 65536),
        ek = el - 65536 * ec,
        ec = Math.floor((el = eT + ec + 65535) / 65536),
        eT = el - 65536 * ec,
        ed += ec - 1 + 37 * (ec - 1),
        J[0] = ed,
        J[1] = eh,
        J[2] = ep,
        J[3] = ef,
        J[4] = em,
        J[5] = eg,
        J[6] = ey,
        J[7] = eb,
        J[8] = ew,
        J[9] = e_,
        J[10] = ex,
        J[11] = eE,
        J[12] = eC,
        J[13] = eS,
        J[14] = ek,
        J[15] = eT
    }
    function scalarMult(J, et) {
      let eo = new Uint8Array(32)
        , el = new Float64Array(80)
        , ec = gf()
        , ed = gf()
        , ep = gf()
        , ef = gf()
        , em = gf()
        , eg = gf();
      for (let et = 0; et < 31; et++)
        eo[et] = J[et];
      eo[31] = 127 & J[31] | 64,
        eo[0] &= 248,
        function (J, et) {
          for (let eo = 0; eo < 16; eo++)
            J[eo] = et[2 * eo] + (et[2 * eo + 1] << 8);
          J[15] &= 32767
        }(el, et);
      for (let J = 0; J < 16; J++)
        ed[J] = el[J];
      ec[0] = ef[0] = 1;
      for (let J = 254; J >= 0; --J) {
        let et = eo[J >>> 3] >>> (7 & J) & 1;
        sel25519(ec, ed, et),
          sel25519(ep, ef, et),
          add(em, ec, ep),
          sub(ec, ec, ep),
          add(ep, ed, ef),
          sub(ed, ed, ef),
          mul(ef, em, em),
          mul(eg, ec, ec),
          mul(ec, ep, ec),
          mul(ep, ed, em),
          add(em, ec, ep),
          sub(ec, ec, ep),
          mul(ed, ec, ec),
          sub(ep, ef, eg),
          mul(ec, ep, eh),
          add(ec, ec, ef),
          mul(ep, ep, ec),
          mul(ec, ef, eg),
          mul(ef, ed, el),
          mul(ed, em, em),
          sel25519(ec, ed, et),
          sel25519(ep, ef, et)
      }
      for (let J = 0; J < 16; J++)
        el[J + 16] = ec[J],
          el[J + 32] = ep[J],
          el[J + 48] = ed[J],
          el[J + 64] = ef[J];
      let ey = el.subarray(32)
        , eb = el.subarray(16);
      !function (J, et) {
        let eo = gf();
        for (let J = 0; J < 16; J++)
          eo[J] = et[J];
        for (let J = 253; J >= 0; J--)
          mul(eo, eo, eo),
            2 !== J && 4 !== J && mul(eo, eo, et);
        for (let et = 0; et < 16; et++)
          J[et] = eo[et]
      }(ey, ey),
        mul(eb, eb, ey);
      let ew = new Uint8Array(32);
      return !function (J, et) {
        let eo = gf()
          , el = gf();
        for (let J = 0; J < 16; J++)
          el[J] = et[J];
        car25519(el),
          car25519(el),
          car25519(el);
        for (let J = 0; J < 2; J++) {
          eo[0] = el[0] - 65517;
          for (let J = 1; J < 15; J++)
            eo[J] = el[J] - 65535 - (eo[J - 1] >> 16 & 1),
              eo[J - 1] &= 65535;
          eo[15] = el[15] - 32767 - (eo[14] >> 16 & 1);
          let J = eo[15] >> 16 & 1;
          eo[14] &= 65535,
            sel25519(el, eo, 1 - J)
        }
        for (let et = 0; et < 16; et++)
          J[2 * et] = 255 & el[et],
            J[2 * et + 1] = el[et] >> 8
      }(ew, eb),
        ew
    }
    et.Au = function (J) {
      let eo = (0,
        el.randomBytes)(32, J)
        , eh = function (J) {
          if (J.length !== et.KS)
            throw Error(`x25519: seed must be ${et.KS} bytes`);
          let eo = new Uint8Array(J)
            , el = scalarMult(eo, ed);
          return {
            publicKey: el,
            secretKey: eo
          }
        }(eo);
      return (0,
        ec.wipe)(eo),
        eh
    }
      ,
      et.gi = function (J, eo, el = !1) {
        if (J.length !== et.kz)
          throw Error("X25519: incorrect secret key length");
        if (eo.length !== et.kz)
          throw Error("X25519: incorrect public key length");
        let ec = scalarMult(J, eo);
        if (el) {
          let J = 0;
          for (let et = 0; et < ec.length; et++)
            J |= ec[et];
          if (0 === J)
            throw Error("X25519: invalid shared key")
        }
        return ec
      }
  },
  40926: function (J, et, eo) {
    "use strict";
    function getBrowerCrypto() {
      return (null === eo.g || void 0 === eo.g ? void 0 : eo.g.crypto) || (null === eo.g || void 0 === eo.g ? void 0 : eo.g.msCrypto) || {}
    }
    function getSubtleCrypto() {
      let J = getBrowerCrypto();
      return J.subtle || J.webkitSubtle
    }
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.isBrowserCryptoAvailable = et.getSubtleCrypto = et.getBrowerCrypto = void 0,
      et.getBrowerCrypto = getBrowerCrypto,
      et.getSubtleCrypto = getSubtleCrypto,
      et.isBrowserCryptoAvailable = function () {
        return !!getBrowerCrypto() && !!getSubtleCrypto()
      }
  },
  88618: function (J, et, eo) {
    "use strict";
    var el = eo(83454);
    function isReactNative() {
      return "undefined" == typeof document && "undefined" != typeof navigator && "ReactNative" === navigator.product
    }
    function isNode() {
      return void 0 !== el && void 0 !== el.versions && void 0 !== el.versions.node
    }
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.isBrowser = et.isNode = et.isReactNative = void 0,
      et.isReactNative = isReactNative,
      et.isNode = isNode,
      et.isBrowser = function () {
        return !isReactNative() && !isNode()
      }
  },
  1468: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    });
    let el = eo(70655);
    el.__exportStar(eo(40926), et),
      el.__exportStar(eo(88618), et)
  },
  38200: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      q: function () {
        return IEvents
      }
    });
    let IEvents = class IEvents {
    }
  },
  30997: function (J, et, eo) {
    "use strict";
    eo.r(et),
      eo.d(et, {
        IEvents: function () {
          return el.q
        }
      });
    var el = eo(38200)
  },
  32568: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.HEARTBEAT_EVENTS = et.HEARTBEAT_INTERVAL = void 0;
    let el = eo(66736);
    et.HEARTBEAT_INTERVAL = el.FIVE_SECONDS,
      et.HEARTBEAT_EVENTS = {
        pulse: "heartbeat_pulse"
      }
  },
  53401: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    });
    let el = eo(70655);
    el.__exportStar(eo(32568), et)
  },
  38969: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.HeartBeat = void 0;
    let el = eo(70655)
      , ec = eo(17187)
      , ed = eo(66736)
      , eh = eo(1614)
      , ep = eo(53401);
    let HeartBeat = class HeartBeat extends eh.IHeartBeat {
      constructor(J) {
        super(J),
          this.events = new ec.EventEmitter,
          this.interval = ep.HEARTBEAT_INTERVAL,
          this.interval = (null == J ? void 0 : J.interval) || ep.HEARTBEAT_INTERVAL
      }
      static init(J) {
        return el.__awaiter(this, void 0, void 0, function* () {
          let et = new HeartBeat(J);
          return yield et.init(),
            et
        })
      }
      init() {
        return el.__awaiter(this, void 0, void 0, function* () {
          yield this.initialize()
        })
      }
      stop() {
        clearInterval(this.intervalRef)
      }
      on(J, et) {
        this.events.on(J, et)
      }
      once(J, et) {
        this.events.once(J, et)
      }
      off(J, et) {
        this.events.off(J, et)
      }
      removeListener(J, et) {
        this.events.removeListener(J, et)
      }
      initialize() {
        return el.__awaiter(this, void 0, void 0, function* () {
          this.intervalRef = setInterval(() => this.pulse(), ed.toMiliseconds(this.interval))
        })
      }
      pulse() {
        this.events.emit(ep.HEARTBEAT_EVENTS.pulse)
      }
    }
      ;
    et.HeartBeat = HeartBeat
  },
  90772: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    });
    let el = eo(70655);
    el.__exportStar(eo(38969), et),
      el.__exportStar(eo(1614), et),
      el.__exportStar(eo(53401), et)
  },
  44174: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.IHeartBeat = void 0;
    let el = eo(30997);
    let IHeartBeat = class IHeartBeat extends el.IEvents {
      constructor(J) {
        super()
      }
    }
      ;
    et.IHeartBeat = IHeartBeat
  },
  1614: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    });
    let el = eo(70655);
    el.__exportStar(eo(44174), et)
  },
  72030: function (J) {
    "use strict";
    J.exports = function () {
      throw Error("ws does not work in the browser. Browser clients must use the native WebSocket object")
    }
  },
  65727: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.PINO_CUSTOM_CONTEXT_KEY = et.PINO_LOGGER_DEFAULTS = void 0,
      et.PINO_LOGGER_DEFAULTS = {
        level: "info"
      },
      et.PINO_CUSTOM_CONTEXT_KEY = "custom_context"
  },
  9107: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.pino = void 0;
    let el = eo(70655)
      , ec = el.__importDefault(eo(36559));
    Object.defineProperty(et, "pino", {
      enumerable: !0,
      get: function () {
        return ec.default
      }
    }),
      el.__exportStar(eo(65727), et),
      el.__exportStar(eo(58048), et)
  },
  58048: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.generateChildLogger = et.formatChildLoggerContext = et.getLoggerContext = et.setBrowserLoggerContext = et.getBrowserLoggerContext = et.getDefaultLoggerOptions = void 0;
    let el = eo(65727);
    function getBrowserLoggerContext(J, et = el.PINO_CUSTOM_CONTEXT_KEY) {
      return J[et] || ""
    }
    function setBrowserLoggerContext(J, et, eo = el.PINO_CUSTOM_CONTEXT_KEY) {
      return J[eo] = et,
        J
    }
    function getLoggerContext(J, et = el.PINO_CUSTOM_CONTEXT_KEY) {
      return void 0 === J.bindings ? getBrowserLoggerContext(J, et) : J.bindings().context || ""
    }
    function formatChildLoggerContext(J, et, eo = el.PINO_CUSTOM_CONTEXT_KEY) {
      let ec = getLoggerContext(J, eo)
        , ed = ec.trim() ? `${ec}/${et}` : et;
      return ed
    }
    et.getDefaultLoggerOptions = function (J) {
      return Object.assign(Object.assign({}, J), {
        level: (null == J ? void 0 : J.level) || el.PINO_LOGGER_DEFAULTS.level
      })
    }
      ,
      et.getBrowserLoggerContext = getBrowserLoggerContext,
      et.setBrowserLoggerContext = setBrowserLoggerContext,
      et.getLoggerContext = getLoggerContext,
      et.formatChildLoggerContext = formatChildLoggerContext,
      et.generateChildLogger = function (J, et, eo = el.PINO_CUSTOM_CONTEXT_KEY) {
        let ec = formatChildLoggerContext(J, et, eo)
          , ed = J.child({
            context: ec
          });
        return setBrowserLoggerContext(ed, ec, eo)
      }
  },
  61882: function () { },
  43014: function () { },
  36900: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    });
    let el = eo(70655);
    el.__exportStar(eo(46869), et),
      el.__exportStar(eo(88033), et)
  },
  46869: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.ONE_THOUSAND = et.ONE_HUNDRED = void 0,
      et.ONE_HUNDRED = 100,
      et.ONE_THOUSAND = 1e3
  },
  88033: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.ONE_YEAR = et.FOUR_WEEKS = et.THREE_WEEKS = et.TWO_WEEKS = et.ONE_WEEK = et.THIRTY_DAYS = et.SEVEN_DAYS = et.FIVE_DAYS = et.THREE_DAYS = et.ONE_DAY = et.TWENTY_FOUR_HOURS = et.TWELVE_HOURS = et.SIX_HOURS = et.THREE_HOURS = et.ONE_HOUR = et.SIXTY_MINUTES = et.THIRTY_MINUTES = et.TEN_MINUTES = et.FIVE_MINUTES = et.ONE_MINUTE = et.SIXTY_SECONDS = et.THIRTY_SECONDS = et.TEN_SECONDS = et.FIVE_SECONDS = et.ONE_SECOND = void 0,
      et.ONE_SECOND = 1,
      et.FIVE_SECONDS = 5,
      et.TEN_SECONDS = 10,
      et.THIRTY_SECONDS = 30,
      et.SIXTY_SECONDS = 60,
      et.ONE_MINUTE = et.SIXTY_SECONDS,
      et.FIVE_MINUTES = 5 * et.ONE_MINUTE,
      et.TEN_MINUTES = 10 * et.ONE_MINUTE,
      et.THIRTY_MINUTES = 30 * et.ONE_MINUTE,
      et.SIXTY_MINUTES = 60 * et.ONE_MINUTE,
      et.ONE_HOUR = et.SIXTY_MINUTES,
      et.THREE_HOURS = 3 * et.ONE_HOUR,
      et.SIX_HOURS = 6 * et.ONE_HOUR,
      et.TWELVE_HOURS = 12 * et.ONE_HOUR,
      et.TWENTY_FOUR_HOURS = 24 * et.ONE_HOUR,
      et.ONE_DAY = et.TWENTY_FOUR_HOURS,
      et.THREE_DAYS = 3 * et.ONE_DAY,
      et.FIVE_DAYS = 5 * et.ONE_DAY,
      et.SEVEN_DAYS = 7 * et.ONE_DAY,
      et.THIRTY_DAYS = 30 * et.ONE_DAY,
      et.ONE_WEEK = et.SEVEN_DAYS,
      et.TWO_WEEKS = 2 * et.ONE_WEEK,
      et.THREE_WEEKS = 3 * et.ONE_WEEK,
      et.FOUR_WEEKS = 4 * et.ONE_WEEK,
      et.ONE_YEAR = 365 * et.ONE_DAY
  },
  66736: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    });
    let el = eo(70655);
    el.__exportStar(eo(44273), et),
      el.__exportStar(eo(47001), et),
      el.__exportStar(eo(52939), et),
      el.__exportStar(eo(36900), et)
  },
  52939: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    });
    let el = eo(70655);
    el.__exportStar(eo(88766), et)
  },
  88766: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.IWatch = void 0,
      et.IWatch = class {
      }
  },
  83207: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.fromMiliseconds = et.toMiliseconds = void 0;
    let el = eo(36900);
    et.toMiliseconds = function (J) {
      return J * el.ONE_THOUSAND
    }
      ,
      et.fromMiliseconds = function (J) {
        return Math.floor(J / el.ONE_THOUSAND)
      }
  },
  83873: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.delay = void 0,
      et.delay = function (J) {
        return new Promise(et => {
          setTimeout(() => {
            et(!0)
          }
            , J)
        }
        )
      }
  },
  44273: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    });
    let el = eo(70655);
    el.__exportStar(eo(83873), et),
      el.__exportStar(eo(83207), et)
  },
  47001: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.Watch = void 0;
    let Watch = class Watch {
      constructor() {
        this.timestamps = new Map
      }
      start(J) {
        if (this.timestamps.has(J))
          throw Error(`Watch already started for label: ${J}`);
        this.timestamps.set(J, {
          started: Date.now()
        })
      }
      stop(J) {
        let et = this.get(J);
        if (void 0 !== et.elapsed)
          throw Error(`Watch already stopped for label: ${J}`);
        let eo = Date.now() - et.started;
        this.timestamps.set(J, {
          started: et.started,
          elapsed: eo
        })
      }
      get(J) {
        let et = this.timestamps.get(J);
        if (void 0 === et)
          throw Error(`No timestamp found for label: ${J}`);
        return et
      }
      elapsed(J) {
        let et = this.get(J)
          , eo = et.elapsed || Date.now() - et.started;
        return eo
      }
    }
      ;
    et.Watch = Watch,
      et.default = Watch
  },
  62873: function (J, et) {
    "use strict";
    function getFromWindow(J) {
      let et;
      return "undefined" != typeof window && void 0 !== window[J] && (et = window[J]),
        et
    }
    function getFromWindowOrThrow(J) {
      let et = getFromWindow(J);
      if (!et)
        throw Error(`${J} is not defined in Window`);
      return et
    }
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.getLocalStorage = et.getLocalStorageOrThrow = et.getCrypto = et.getCryptoOrThrow = et.getLocation = et.getLocationOrThrow = et.getNavigator = et.getNavigatorOrThrow = et.getDocument = et.getDocumentOrThrow = et.getFromWindowOrThrow = et.getFromWindow = void 0,
      et.getFromWindow = getFromWindow,
      et.getFromWindowOrThrow = getFromWindowOrThrow,
      et.getDocumentOrThrow = function () {
        return getFromWindowOrThrow("document")
      }
      ,
      et.getDocument = function () {
        return getFromWindow("document")
      }
      ,
      et.getNavigatorOrThrow = function () {
        return getFromWindowOrThrow("navigator")
      }
      ,
      et.getNavigator = function () {
        return getFromWindow("navigator")
      }
      ,
      et.getLocationOrThrow = function () {
        return getFromWindowOrThrow("location")
      }
      ,
      et.getLocation = function () {
        return getFromWindow("location")
      }
      ,
      et.getCryptoOrThrow = function () {
        return getFromWindowOrThrow("crypto")
      }
      ,
      et.getCrypto = function () {
        return getFromWindow("crypto")
      }
      ,
      et.getLocalStorageOrThrow = function () {
        return getFromWindowOrThrow("localStorage")
      }
      ,
      et.getLocalStorage = function () {
        return getFromWindow("localStorage")
      }
  },
  65755: function (J, et, eo) {
    "use strict";
    et.D = void 0;
    let el = eo(62873);
    et.D = function () {
      let J, et, eo;
      try {
        J = el.getDocumentOrThrow(),
          et = el.getLocationOrThrow()
      } catch (J) {
        return null
      }
      function getWindowMetadataOfAny(...et) {
        let eo = J.getElementsByTagName("meta");
        for (let J = 0; J < eo.length; J++) {
          let el = eo[J]
            , ec = ["itemprop", "property", "name"].map(J => el.getAttribute(J)).filter(J => !!J && et.includes(J));
          if (ec.length && ec) {
            let J = el.getAttribute("content");
            if (J)
              return J
          }
        }
        return ""
      }
      let ec = ((eo = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title")) || (eo = J.title),
        eo)
        , ed = function () {
          let J = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
          return J
        }()
        , eh = et.origin
        , ep = function () {
          let eo = J.getElementsByTagName("link")
            , el = [];
          for (let J = 0; J < eo.length; J++) {
            let ec = eo[J]
              , ed = ec.getAttribute("rel");
            if (ed && ed.toLowerCase().indexOf("icon") > -1) {
              let J = ec.getAttribute("href");
              if (J) {
                if (-1 === J.toLowerCase().indexOf("https:") && -1 === J.toLowerCase().indexOf("http:") && 0 !== J.indexOf("//")) {
                  let eo = et.protocol + "//" + et.host;
                  if (0 === J.indexOf("/"))
                    eo += J;
                  else {
                    let el = et.pathname.split("/");
                    el.pop();
                    let ec = el.join("/");
                    eo += ec + "/" + J
                  }
                  el.push(eo)
                } else if (0 === J.indexOf("//")) {
                  let eo = et.protocol + J;
                  el.push(eo)
                } else
                  el.push(J)
              }
            }
          }
          return el
        }();
      return {
        description: ed,
        url: eh,
        icons: ep,
        name: ec
      }
    }
  },
  85078: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    });
    var el = eo(33649)
      , ec = eo(2403)
      , ed = function () {
        function Mutex() {
          this._semaphore = new ec.default(1)
        }
        return Mutex.prototype.acquire = function () {
          return el.__awaiter(this, void 0, void 0, function () {
            return el.__generator(this, function (J) {
              switch (J.label) {
                case 0:
                  return [4, this._semaphore.acquire()];
                case 1:
                  return [2, J.sent()[1]]
              }
            })
          })
        }
          ,
          Mutex.prototype.runExclusive = function (J) {
            return this._semaphore.runExclusive(function () {
              return J()
            })
          }
          ,
          Mutex.prototype.isLocked = function () {
            return this._semaphore.isLocked()
          }
          ,
          Mutex.prototype.release = function () {
            this._semaphore.release()
          }
          ,
          Mutex
      }();
    et.default = ed
  },
  2403: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    });
    var el = eo(33649)
      , ec = function () {
        function Semaphore(J) {
          if (this._maxConcurrency = J,
            this._queue = [],
            J <= 0)
            throw Error("semaphore must be initialized to a positive value");
          this._value = J
        }
        return Semaphore.prototype.acquire = function () {
          var J = this
            , et = this.isLocked()
            , eo = new Promise(function (et) {
              return J._queue.push(et)
            }
            );
          return et || this._dispatch(),
            eo
        }
          ,
          Semaphore.prototype.runExclusive = function (J) {
            return el.__awaiter(this, void 0, void 0, function () {
              var et, eo, ec;
              return el.__generator(this, function (el) {
                switch (el.label) {
                  case 0:
                    return [4, this.acquire()];
                  case 1:
                    eo = (et = el.sent())[0],
                      ec = et[1],
                      el.label = 2;
                  case 2:
                    return el.trys.push([2, , 4, 5]),
                      [4, J(eo)];
                  case 3:
                    return [2, el.sent()];
                  case 4:
                    return ec(),
                      [7];
                  case 5:
                    return [2]
                }
              })
            })
          }
          ,
          Semaphore.prototype.isLocked = function () {
            return this._value <= 0
          }
          ,
          Semaphore.prototype.release = function () {
            if (this._maxConcurrency > 1)
              throw Error("this method is unavailabel on semaphores with concurrency > 1; use the scoped release returned by acquire instead");
            if (this._currentReleaser) {
              var J = this._currentReleaser;
              this._currentReleaser = void 0,
                J()
            }
          }
          ,
          Semaphore.prototype._dispatch = function () {
            var J = this
              , et = this._queue.shift();
            if (et) {
              var eo = !1;
              this._currentReleaser = function () {
                eo || (eo = !0,
                  J._value++,
                  J._dispatch())
              }
                ,
                et([this._value--, this._currentReleaser])
            }
          }
          ,
          Semaphore
      }();
    et.default = ec
  },
  48125: function (J, et, eo) {
    "use strict";
    et.WU = void 0;
    var el = eo(85078);
    Object.defineProperty(et, "WU", {
      enumerable: !0,
      get: function () {
        return el.default
      }
    }),
      eo(2403),
      eo(41960)
  },
  41960: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.withTimeout = void 0;
    var el = eo(33649);
    et.withTimeout = function (J, et, eo) {
      var ec = this;
      return void 0 === eo && (eo = Error("timeout")),
      {
        acquire: function () {
          return new Promise(function (ed, eh) {
            return el.__awaiter(ec, void 0, void 0, function () {
              var ec, ep;
              return el.__generator(this, function (el) {
                switch (el.label) {
                  case 0:
                    return ec = !1,
                      setTimeout(function () {
                        ec = !0,
                          eh(eo)
                      }, et),
                      [4, J.acquire()];
                  case 1:
                    return ep = el.sent(),
                      ec ? (Array.isArray(ep) ? ep[1] : ep)() : ed(ep),
                      [2]
                }
              })
            })
          }
          )
        },
        runExclusive: function (J) {
          return el.__awaiter(this, void 0, void 0, function () {
            var et, eo;
            return el.__generator(this, function (el) {
              switch (el.label) {
                case 0:
                  et = function () { }
                    ,
                    el.label = 1;
                case 1:
                  return el.trys.push([1, , 7, 8]),
                    [4, this.acquire()];
                case 2:
                  if (!Array.isArray(eo = el.sent()))
                    return [3, 4];
                  return et = eo[1],
                    [4, J(eo[0])];
                case 3:
                case 5:
                  return [2, el.sent()];
                case 4:
                  return et = eo,
                    [4, J()];
                case 6:
                  return [3, 8];
                case 7:
                  return et(),
                    [7];
                case 8:
                  return [2]
              }
            })
          })
        },
        release: function () {
          J.release()
        },
        isLocked: function () {
          return J.isLocked()
        }
      }
    }
  },
  9669: function (J, et, eo) {
    J.exports = eo(51609)
  },
  55448: function (J, et, eo) {
    "use strict";
    var el = eo(64867)
      , ec = eo(36026)
      , ed = eo(4372)
      , eh = eo(15327)
      , ep = eo(94097)
      , ef = eo(84109)
      , em = eo(67985)
      , eg = eo(85061)
      , ey = eo(77874)
      , eb = eo(65263);
    J.exports = function (J) {
      return new Promise(function (et, eo) {
        var ew, e_ = J.data, ex = J.headers, eE = J.responseType;
        function done() {
          J.cancelToken && J.cancelToken.unsubscribe(ew),
            J.signal && J.signal.removeEventListener("abort", ew)
        }
        el.isFormData(e_) && delete ex["Content-Type"];
        var eC = new XMLHttpRequest;
        if (J.auth) {
          var eS = J.auth.username || ""
            , ek = J.auth.password ? unescape(encodeURIComponent(J.auth.password)) : "";
          ex.Authorization = "Basic " + btoa(eS + ":" + ek)
        }
        var eT = ep(J.baseURL, J.url);
        function onloadend() {
          if (eC) {
            var el = "getAllResponseHeaders" in eC ? ef(eC.getAllResponseHeaders()) : null;
            ec(function (J) {
              et(J),
                done()
            }, function (J) {
              eo(J),
                done()
            }, {
              data: eE && "text" !== eE && "json" !== eE ? eC.response : eC.responseText,
              status: eC.status,
              statusText: eC.statusText,
              headers: el,
              config: J,
              request: eC
            }),
              eC = null
          }
        }
        if (eC.open(J.method.toUpperCase(), eh(eT, J.params, J.paramsSerializer), !0),
          eC.timeout = J.timeout,
          "onloadend" in eC ? eC.onloadend = onloadend : eC.onreadystatechange = function () {
            eC && 4 === eC.readyState && (0 !== eC.status || eC.responseURL && 0 === eC.responseURL.indexOf("file:")) && setTimeout(onloadend)
          }
          ,
          eC.onabort = function () {
            eC && (eo(eg("Request aborted", J, "ECONNABORTED", eC)),
              eC = null)
          }
          ,
          eC.onerror = function () {
            eo(eg("Network Error", J, null, eC)),
              eC = null
          }
          ,
          eC.ontimeout = function () {
            var et = J.timeout ? "timeout of " + J.timeout + "ms exceeded" : "timeout exceeded"
              , el = J.transitional || ey;
            J.timeoutErrorMessage && (et = J.timeoutErrorMessage),
              eo(eg(et, J, el.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", eC)),
              eC = null
          }
          ,
          el.isStandardBrowserEnv()) {
          var eA = (J.withCredentials || em(eT)) && J.xsrfCookieName ? ed.read(J.xsrfCookieName) : void 0;
          eA && (ex[J.xsrfHeaderName] = eA)
        }
        "setRequestHeader" in eC && el.forEach(ex, function (J, et) {
          void 0 === e_ && "content-type" === et.toLowerCase() ? delete ex[et] : eC.setRequestHeader(et, J)
        }),
          el.isUndefined(J.withCredentials) || (eC.withCredentials = !!J.withCredentials),
          eE && "json" !== eE && (eC.responseType = J.responseType),
          "function" == typeof J.onDownloadProgress && eC.addEventListener("progress", J.onDownloadProgress),
          "function" == typeof J.onUploadProgress && eC.upload && eC.upload.addEventListener("progress", J.onUploadProgress),
          (J.cancelToken || J.signal) && (ew = function (J) {
            eC && (eo(!J || J && J.type ? new eb("canceled") : J),
              eC.abort(),
              eC = null)
          }
            ,
            J.cancelToken && J.cancelToken.subscribe(ew),
            J.signal && (J.signal.aborted ? ew() : J.signal.addEventListener("abort", ew))),
          e_ || (e_ = null),
          eC.send(e_)
      }
      )
    }
  },
  51609: function (J, et, eo) {
    "use strict";
    var el = eo(64867)
      , ec = eo(91849)
      , ed = eo(30321)
      , eh = eo(47185)
      , ep = function createInstance(J) {
        var et = new ed(J)
          , eo = ec(ed.prototype.request, et);
        return el.extend(eo, ed.prototype, et),
          el.extend(eo, et),
          eo.create = function (et) {
            return createInstance(eh(J, et))
          }
          ,
          eo
      }(eo(45546));
    ep.Axios = ed,
      ep.Cancel = eo(65263),
      ep.CancelToken = eo(14972),
      ep.isCancel = eo(26502),
      ep.VERSION = eo(97288).version,
      ep.all = function (J) {
        return Promise.all(J)
      }
      ,
      ep.spread = eo(8713),
      ep.isAxiosError = eo(16268),
      J.exports = ep,
      J.exports.default = ep
  },
  65263: function (J) {
    "use strict";
    function Cancel(J) {
      this.message = J
    }
    Cancel.prototype.toString = function () {
      return "Cancel" + (this.message ? ": " + this.message : "")
    }
      ,
      Cancel.prototype.__CANCEL__ = !0,
      J.exports = Cancel
  },
  14972: function (J, et, eo) {
    "use strict";
    var el = eo(65263);
    function CancelToken(J) {
      if ("function" != typeof J)
        throw TypeError("executor must be a function.");
      this.promise = new Promise(function (J) {
        et = J
      }
      );
      var et, eo = this;
      this.promise.then(function (J) {
        if (eo._listeners) {
          var et, el = eo._listeners.length;
          for (et = 0; et < el; et++)
            eo._listeners[et](J);
          eo._listeners = null
        }
      }),
        this.promise.then = function (J) {
          var et, el = new Promise(function (J) {
            eo.subscribe(J),
              et = J
          }
          ).then(J);
          return el.cancel = function () {
            eo.unsubscribe(et)
          }
            ,
            el
        }
        ,
        J(function (J) {
          eo.reason || (eo.reason = new el(J),
            et(eo.reason))
        })
    }
    CancelToken.prototype.throwIfRequested = function () {
      if (this.reason)
        throw this.reason
    }
      ,
      CancelToken.prototype.subscribe = function (J) {
        if (this.reason) {
          J(this.reason);
          return
        }
        this._listeners ? this._listeners.push(J) : this._listeners = [J]
      }
      ,
      CancelToken.prototype.unsubscribe = function (J) {
        if (this._listeners) {
          var et = this._listeners.indexOf(J);
          -1 !== et && this._listeners.splice(et, 1)
        }
      }
      ,
      CancelToken.source = function () {
        var J;
        return {
          token: new CancelToken(function (et) {
            J = et
          }
          ),
          cancel: J
        }
      }
      ,
      J.exports = CancelToken
  },
  26502: function (J) {
    "use strict";
    J.exports = function (J) {
      return !!(J && J.__CANCEL__)
    }
  },
  30321: function (J, et, eo) {
    "use strict";
    var el = eo(64867)
      , ec = eo(15327)
      , ed = eo(80782)
      , eh = eo(13572)
      , ep = eo(47185)
      , ef = eo(54875)
      , em = ef.validators;
    function Axios(J) {
      this.defaults = J,
        this.interceptors = {
          request: new ed,
          response: new ed
        }
    }
    Axios.prototype.request = function (J, et) {
      "string" == typeof J ? (et = et || {}).url = J : et = J || {},
        (et = ep(this.defaults, et)).method ? et.method = et.method.toLowerCase() : this.defaults.method ? et.method = this.defaults.method.toLowerCase() : et.method = "get";
      var eo, el = et.transitional;
      void 0 !== el && ef.assertOptions(el, {
        silentJSONParsing: em.transitional(em.boolean),
        forcedJSONParsing: em.transitional(em.boolean),
        clarifyTimeoutError: em.transitional(em.boolean)
      }, !1);
      var ec = []
        , ed = !0;
      this.interceptors.request.forEach(function (J) {
        ("function" != typeof J.runWhen || !1 !== J.runWhen(et)) && (ed = ed && J.synchronous,
          ec.unshift(J.fulfilled, J.rejected))
      });
      var eg = [];
      if (this.interceptors.response.forEach(function (J) {
        eg.push(J.fulfilled, J.rejected)
      }),
        !ed) {
        var ey = [eh, void 0];
        for (Array.prototype.unshift.apply(ey, ec),
          ey = ey.concat(eg),
          eo = Promise.resolve(et); ey.length;)
          eo = eo.then(ey.shift(), ey.shift());
        return eo
      }
      for (var eb = et; ec.length;) {
        var ew = ec.shift()
          , e_ = ec.shift();
        try {
          eb = ew(eb)
        } catch (J) {
          e_(J);
          break
        }
      }
      try {
        eo = eh(eb)
      } catch (J) {
        return Promise.reject(J)
      }
      for (; eg.length;)
        eo = eo.then(eg.shift(), eg.shift());
      return eo
    }
      ,
      Axios.prototype.getUri = function (J) {
        return ec((J = ep(this.defaults, J)).url, J.params, J.paramsSerializer).replace(/^\?/, "")
      }
      ,
      el.forEach(["delete", "get", "head", "options"], function (J) {
        Axios.prototype[J] = function (et, eo) {
          return this.request(ep(eo || {}, {
            method: J,
            url: et,
            data: (eo || {}).data
          }))
        }
      }),
      el.forEach(["post", "put", "patch"], function (J) {
        Axios.prototype[J] = function (et, eo, el) {
          return this.request(ep(el || {}, {
            method: J,
            url: et,
            data: eo
          }))
        }
      }),
      J.exports = Axios
  },
  80782: function (J, et, eo) {
    "use strict";
    var el = eo(64867);
    function InterceptorManager() {
      this.handlers = []
    }
    InterceptorManager.prototype.use = function (J, et, eo) {
      return this.handlers.push({
        fulfilled: J,
        rejected: et,
        synchronous: !!eo && eo.synchronous,
        runWhen: eo ? eo.runWhen : null
      }),
        this.handlers.length - 1
    }
      ,
      InterceptorManager.prototype.eject = function (J) {
        this.handlers[J] && (this.handlers[J] = null)
      }
      ,
      InterceptorManager.prototype.forEach = function (J) {
        el.forEach(this.handlers, function (et) {
          null !== et && J(et)
        })
      }
      ,
      J.exports = InterceptorManager
  },
  94097: function (J, et, eo) {
    "use strict";
    var el = eo(91793)
      , ec = eo(7303);
    J.exports = function (J, et) {
      return J && !el(et) ? ec(J, et) : et
    }
  },
  85061: function (J, et, eo) {
    "use strict";
    var el = eo(80481);
    J.exports = function (J, et, eo, ec, ed) {
      return el(Error(J), et, eo, ec, ed)
    }
  },
  13572: function (J, et, eo) {
    "use strict";
    var el = eo(64867)
      , ec = eo(18527)
      , ed = eo(26502)
      , eh = eo(45546)
      , ep = eo(65263);
    function throwIfCancellationRequested(J) {
      if (J.cancelToken && J.cancelToken.throwIfRequested(),
        J.signal && J.signal.aborted)
        throw new ep("canceled")
    }
    J.exports = function (J) {
      return throwIfCancellationRequested(J),
        J.headers = J.headers || {},
        J.data = ec.call(J, J.data, J.headers, J.transformRequest),
        J.headers = el.merge(J.headers.common || {}, J.headers[J.method] || {}, J.headers),
        el.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function (et) {
          delete J.headers[et]
        }),
        (J.adapter || eh.adapter)(J).then(function (et) {
          return throwIfCancellationRequested(J),
            et.data = ec.call(J, et.data, et.headers, J.transformResponse),
            et
        }, function (et) {
          return !ed(et) && (throwIfCancellationRequested(J),
            et && et.response && (et.response.data = ec.call(J, et.response.data, et.response.headers, J.transformResponse))),
            Promise.reject(et)
        })
    }
  },
  80481: function (J) {
    "use strict";
    J.exports = function (J, et, eo, el, ec) {
      return J.config = et,
        eo && (J.code = eo),
        J.request = el,
        J.response = ec,
        J.isAxiosError = !0,
        J.toJSON = function () {
          return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: this.config,
            code: this.code,
            status: this.response && this.response.status ? this.response.status : null
          }
        }
        ,
        J
    }
  },
  47185: function (J, et, eo) {
    "use strict";
    var el = eo(64867);
    J.exports = function (J, et) {
      et = et || {};
      var eo = {};
      function getMergedValue(J, et) {
        return el.isPlainObject(J) && el.isPlainObject(et) ? el.merge(J, et) : el.isPlainObject(et) ? el.merge({}, et) : el.isArray(et) ? et.slice() : et
      }
      function mergeDeepProperties(eo) {
        return el.isUndefined(et[eo]) ? el.isUndefined(J[eo]) ? void 0 : getMergedValue(void 0, J[eo]) : getMergedValue(J[eo], et[eo])
      }
      function valueFromConfig2(J) {
        if (!el.isUndefined(et[J]))
          return getMergedValue(void 0, et[J])
      }
      function defaultToConfig2(eo) {
        return el.isUndefined(et[eo]) ? el.isUndefined(J[eo]) ? void 0 : getMergedValue(void 0, J[eo]) : getMergedValue(void 0, et[eo])
      }
      function mergeDirectKeys(eo) {
        return eo in et ? getMergedValue(J[eo], et[eo]) : eo in J ? getMergedValue(void 0, J[eo]) : void 0
      }
      var ec = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys
      };
      return el.forEach(Object.keys(J).concat(Object.keys(et)), function (J) {
        var et = ec[J] || mergeDeepProperties
          , ed = et(J);
        el.isUndefined(ed) && et !== mergeDirectKeys || (eo[J] = ed)
      }),
        eo
    }
  },
  36026: function (J, et, eo) {
    "use strict";
    var el = eo(85061);
    J.exports = function (J, et, eo) {
      var ec = eo.config.validateStatus;
      !eo.status || !ec || ec(eo.status) ? J(eo) : et(el("Request failed with status code " + eo.status, eo.config, null, eo.request, eo))
    }
  },
  18527: function (J, et, eo) {
    "use strict";
    var el = eo(64867)
      , ec = eo(45546);
    J.exports = function (J, et, eo) {
      var ed = this || ec;
      return el.forEach(eo, function (eo) {
        J = eo.call(ed, J, et)
      }),
        J
    }
  },
  45546: function (J, et, eo) {
    "use strict";
    var el, ec = eo(83454), ed = eo(64867), eh = eo(16016), ep = eo(80481), ef = eo(77874), em = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(J, et) {
      !ed.isUndefined(J) && ed.isUndefined(J["Content-Type"]) && (J["Content-Type"] = et)
    }
    var eg = {
      transitional: ef,
      adapter: ("undefined" != typeof XMLHttpRequest ? el = eo(55448) : void 0 !== ec && "[object process]" === Object.prototype.toString.call(ec) && (el = eo(55448)),
        el),
      transformRequest: [function (J, et) {
        return (eh(et, "Accept"),
          eh(et, "Content-Type"),
          ed.isFormData(J) || ed.isArrayBuffer(J) || ed.isBuffer(J) || ed.isStream(J) || ed.isFile(J) || ed.isBlob(J)) ? J : ed.isArrayBufferView(J) ? J.buffer : ed.isURLSearchParams(J) ? (setContentTypeIfUnset(et, "application/x-www-form-urlencoded;charset=utf-8"),
            J.toString()) : ed.isObject(J) || et && "application/json" === et["Content-Type"] ? (setContentTypeIfUnset(et, "application/json"),
              function (J, et, eo) {
                if (ed.isString(J))
                  try {
                    return (0,
                      JSON.parse)(J),
                      ed.trim(J)
                  } catch (J) {
                    if ("SyntaxError" !== J.name)
                      throw J
                  }
                return (0,
                  JSON.stringify)(J)
              }(J)) : J
      }
      ],
      transformResponse: [function (J) {
        var et = this.transitional || eg.transitional
          , eo = et && et.silentJSONParsing
          , el = et && et.forcedJSONParsing
          , ec = !eo && "json" === this.responseType;
        if (ec || el && ed.isString(J) && J.length)
          try {
            return JSON.parse(J)
          } catch (J) {
            if (ec) {
              if ("SyntaxError" === J.name)
                throw ep(J, this, "E_JSON_PARSE");
              throw J
            }
          }
        return J
      }
      ],
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function (J) {
        return J >= 200 && J < 300
      },
      headers: {
        common: {
          Accept: "application/json, text/plain, */*"
        }
      }
    };
    ed.forEach(["delete", "get", "head"], function (J) {
      eg.headers[J] = {}
    }),
      ed.forEach(["post", "put", "patch"], function (J) {
        eg.headers[J] = ed.merge(em)
      }),
      J.exports = eg
  },
  77874: function (J) {
    "use strict";
    J.exports = {
      silentJSONParsing: !0,
      forcedJSONParsing: !0,
      clarifyTimeoutError: !1
    }
  },
  97288: function (J) {
    J.exports = {
      version: "0.26.1"
    }
  },
  91849: function (J) {
    "use strict";
    J.exports = function (J, et) {
      return function () {
        for (var eo = Array(arguments.length), el = 0; el < eo.length; el++)
          eo[el] = arguments[el];
        return J.apply(et, eo)
      }
    }
  },
  15327: function (J, et, eo) {
    "use strict";
    var el = eo(64867);
    function encode(J) {
      return encodeURIComponent(J).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
    }
    J.exports = function (J, et, eo) {
      if (!et)
        return J;
      if (eo)
        ec = eo(et);
      else if (el.isURLSearchParams(et))
        ec = et.toString();
      else {
        var ec, ed = [];
        el.forEach(et, function (J, et) {
          null != J && (el.isArray(J) ? et += "[]" : J = [J],
            el.forEach(J, function (J) {
              el.isDate(J) ? J = J.toISOString() : el.isObject(J) && (J = JSON.stringify(J)),
                ed.push(encode(et) + "=" + encode(J))
            }))
        }),
          ec = ed.join("&")
      }
      if (ec) {
        var eh = J.indexOf("#");
        -1 !== eh && (J = J.slice(0, eh)),
          J += (-1 === J.indexOf("?") ? "?" : "&") + ec
      }
      return J
    }
  },
  7303: function (J) {
    "use strict";
    J.exports = function (J, et) {
      return et ? J.replace(/\/+$/, "") + "/" + et.replace(/^\/+/, "") : J
    }
  },
  4372: function (J, et, eo) {
    "use strict";
    var el = eo(64867);
    J.exports = el.isStandardBrowserEnv() ? {
      write: function (J, et, eo, ec, ed, eh) {
        var ep = [];
        ep.push(J + "=" + encodeURIComponent(et)),
          el.isNumber(eo) && ep.push("expires=" + new Date(eo).toGMTString()),
          el.isString(ec) && ep.push("path=" + ec),
          el.isString(ed) && ep.push("domain=" + ed),
          !0 === eh && ep.push("secure"),
          document.cookie = ep.join("; ")
      },
      read: function (J) {
        var et = document.cookie.match(RegExp("(^|;\\s*)(" + J + ")=([^;]*)"));
        return et ? decodeURIComponent(et[3]) : null
      },
      remove: function (J) {
        this.write(J, "", Date.now() - 864e5)
      }
    } : {
      write: function () { },
      read: function () {
        return null
      },
      remove: function () { }
    }
  },
  91793: function (J) {
    "use strict";
    J.exports = function (J) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(J)
    }
  },
  16268: function (J, et, eo) {
    "use strict";
    var el = eo(64867);
    J.exports = function (J) {
      return el.isObject(J) && !0 === J.isAxiosError
    }
  },
  67985: function (J, et, eo) {
    "use strict";
    var el = eo(64867);
    J.exports = el.isStandardBrowserEnv() ? function () {
      var J, et = /(msie|trident)/i.test(navigator.userAgent), eo = document.createElement("a");
      function resolveURL(J) {
        var el = J;
        return et && (eo.setAttribute("href", el),
          el = eo.href),
          eo.setAttribute("href", el),
        {
          href: eo.href,
          protocol: eo.protocol ? eo.protocol.replace(/:$/, "") : "",
          host: eo.host,
          search: eo.search ? eo.search.replace(/^\?/, "") : "",
          hash: eo.hash ? eo.hash.replace(/^#/, "") : "",
          hostname: eo.hostname,
          port: eo.port,
          pathname: "/" === eo.pathname.charAt(0) ? eo.pathname : "/" + eo.pathname
        }
      }
      return J = resolveURL(window.location.href),
        function (et) {
          var eo = el.isString(et) ? resolveURL(et) : et;
          return eo.protocol === J.protocol && eo.host === J.host
        }
    }() : function () {
      return !0
    }
  },
  16016: function (J, et, eo) {
    "use strict";
    var el = eo(64867);
    J.exports = function (J, et) {
      el.forEach(J, function (eo, el) {
        el !== et && el.toUpperCase() === et.toUpperCase() && (J[et] = eo,
          delete J[el])
      })
    }
  },
  84109: function (J, et, eo) {
    "use strict";
    var el = eo(64867)
      , ec = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"];
    J.exports = function (J) {
      var et, eo, ed, eh = {};
      return J && el.forEach(J.split("\n"), function (J) {
        ed = J.indexOf(":"),
          et = el.trim(J.substr(0, ed)).toLowerCase(),
          eo = el.trim(J.substr(ed + 1)),
          et && !(eh[et] && ec.indexOf(et) >= 0) && ("set-cookie" === et ? eh[et] = (eh[et] ? eh[et] : []).concat([eo]) : eh[et] = eh[et] ? eh[et] + ", " + eo : eo)
      }),
        eh
    }
  },
  8713: function (J) {
    "use strict";
    J.exports = function (J) {
      return function (et) {
        return J.apply(null, et)
      }
    }
  },
  54875: function (J, et, eo) {
    "use strict";
    var el = eo(97288).version
      , ec = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function (J, et) {
      ec[J] = function (eo) {
        return typeof eo === J || "a" + (et < 1 ? "n " : " ") + J
      }
    });
    var ed = {};
    ec.transitional = function (J, et, eo) {
      function formatMessage(J, et) {
        return "[Axios v" + el + "] Transitional option '" + J + "'" + et + (eo ? ". " + eo : "")
      }
      return function (eo, el, ec) {
        if (!1 === J)
          throw Error(formatMessage(el, " has been removed" + (et ? " in " + et : "")));
        return et && !ed[el] && (ed[el] = !0,
          console.warn(formatMessage(el, " has been deprecated since v" + et + " and will be removed in the near future"))),
          !J || J(eo, el, ec)
      }
    }
      ,
      J.exports = {
        assertOptions: function (J, et, eo) {
          if ("object" != typeof J)
            throw TypeError("options must be an object");
          for (var el = Object.keys(J), ec = el.length; ec-- > 0;) {
            var ed = el[ec]
              , eh = et[ed];
            if (eh) {
              var ep = J[ed]
                , ef = void 0 === ep || eh(ep, ed, J);
              if (!0 !== ef)
                throw TypeError("option " + ed + " must be " + ef);
              continue
            }
            if (!0 !== eo)
              throw Error("Unknown option " + ed)
          }
        },
        validators: ec
      }
  },
  64867: function (J, et, eo) {
    "use strict";
    var el = eo(91849)
      , ec = Object.prototype.toString;
    function isArray(J) {
      return Array.isArray(J)
    }
    function isUndefined(J) {
      return void 0 === J
    }
    function isArrayBuffer(J) {
      return "[object ArrayBuffer]" === ec.call(J)
    }
    function isObject(J) {
      return null !== J && "object" == typeof J
    }
    function isPlainObject(J) {
      if ("[object Object]" !== ec.call(J))
        return !1;
      var et = Object.getPrototypeOf(J);
      return null === et || et === Object.prototype
    }
    function isFunction(J) {
      return "[object Function]" === ec.call(J)
    }
    function forEach(J, et) {
      if (null != J) {
        if ("object" != typeof J && (J = [J]),
          isArray(J))
          for (var eo = 0, el = J.length; eo < el; eo++)
            et.call(null, J[eo], eo, J);
        else
          for (var ec in J)
            Object.prototype.hasOwnProperty.call(J, ec) && et.call(null, J[ec], ec, J)
      }
    }
    J.exports = {
      isArray: isArray,
      isArrayBuffer: isArrayBuffer,
      isBuffer: function (J) {
        return null !== J && !isUndefined(J) && null !== J.constructor && !isUndefined(J.constructor) && "function" == typeof J.constructor.isBuffer && J.constructor.isBuffer(J)
      },
      isFormData: function (J) {
        return "[object FormData]" === ec.call(J)
      },
      isArrayBufferView: function (J) {
        return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(J) : J && J.buffer && isArrayBuffer(J.buffer)
      },
      isString: function (J) {
        return "string" == typeof J
      },
      isNumber: function (J) {
        return "number" == typeof J
      },
      isObject: isObject,
      isPlainObject: isPlainObject,
      isUndefined: isUndefined,
      isDate: function (J) {
        return "[object Date]" === ec.call(J)
      },
      isFile: function (J) {
        return "[object File]" === ec.call(J)
      },
      isBlob: function (J) {
        return "[object Blob]" === ec.call(J)
      },
      isFunction: isFunction,
      isStream: function (J) {
        return isObject(J) && isFunction(J.pipe)
      },
      isURLSearchParams: function (J) {
        return "[object URLSearchParams]" === ec.call(J)
      },
      isStandardBrowserEnv: function () {
        return ("undefined" == typeof navigator || "ReactNative" !== navigator.product && "NativeScript" !== navigator.product && "NS" !== navigator.product) && "undefined" != typeof window && "undefined" != typeof document
      },
      forEach: forEach,
      merge: function merge() {
        var J = {};
        function assignValue(et, eo) {
          isPlainObject(J[eo]) && isPlainObject(et) ? J[eo] = merge(J[eo], et) : isPlainObject(et) ? J[eo] = merge({}, et) : isArray(et) ? J[eo] = et.slice() : J[eo] = et
        }
        for (var et = 0, eo = arguments.length; et < eo; et++)
          forEach(arguments[et], assignValue);
        return J
      },
      extend: function (J, et, eo) {
        return forEach(et, function (et, ec) {
          eo && "function" == typeof et ? J[ec] = el(et, eo) : J[ec] = et
        }),
          J
      },
      trim: function (J) {
        return J.trim ? J.trim() : J.replace(/^\s+|\s+$/g, "")
      },
      stripBOM: function (J) {
        return 65279 === J.charCodeAt(0) && (J = J.slice(1)),
          J
      }
    }
  },
  79742: function (J, et) {
    "use strict";
    et.byteLength = function (J) {
      var et = getLens(J)
        , eo = et[0]
        , el = et[1];
      return (eo + el) * 3 / 4 - el
    }
      ,
      et.toByteArray = function (J) {
        var et, eo, ed = getLens(J), eh = ed[0], ep = ed[1], ef = new ec((eh + ep) * 3 / 4 - ep), em = 0, eg = ep > 0 ? eh - 4 : eh;
        for (eo = 0; eo < eg; eo += 4)
          et = el[J.charCodeAt(eo)] << 18 | el[J.charCodeAt(eo + 1)] << 12 | el[J.charCodeAt(eo + 2)] << 6 | el[J.charCodeAt(eo + 3)],
            ef[em++] = et >> 16 & 255,
            ef[em++] = et >> 8 & 255,
            ef[em++] = 255 & et;
        return 2 === ep && (et = el[J.charCodeAt(eo)] << 2 | el[J.charCodeAt(eo + 1)] >> 4,
          ef[em++] = 255 & et),
          1 === ep && (et = el[J.charCodeAt(eo)] << 10 | el[J.charCodeAt(eo + 1)] << 4 | el[J.charCodeAt(eo + 2)] >> 2,
            ef[em++] = et >> 8 & 255,
            ef[em++] = 255 & et),
          ef
      }
      ,
      et.fromByteArray = function (J) {
        for (var et, el = J.length, ec = el % 3, ed = [], eh = 0, ep = el - ec; eh < ep; eh += 16383)
          ed.push(function (J, et, el) {
            for (var ec, ed = [], eh = et; eh < el; eh += 3)
              ed.push(eo[(ec = (J[eh] << 16 & 16711680) + (J[eh + 1] << 8 & 65280) + (255 & J[eh + 2])) >> 18 & 63] + eo[ec >> 12 & 63] + eo[ec >> 6 & 63] + eo[63 & ec]);
            return ed.join("")
          }(J, eh, eh + 16383 > ep ? ep : eh + 16383));
        return 1 === ec ? ed.push(eo[(et = J[el - 1]) >> 2] + eo[et << 4 & 63] + "==") : 2 === ec && ed.push(eo[(et = (J[el - 2] << 8) + J[el - 1]) >> 10] + eo[et >> 4 & 63] + eo[et << 2 & 63] + "="),
          ed.join("")
      }
      ;
    for (var eo = [], el = [], ec = "undefined" != typeof Uint8Array ? Uint8Array : Array, ed = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", eh = 0, ep = ed.length; eh < ep; ++eh)
      eo[eh] = ed[eh],
        el[ed.charCodeAt(eh)] = eh;
    function getLens(J) {
      var et = J.length;
      if (et % 4 > 0)
        throw Error("Invalid string. Length must be a multiple of 4");
      var eo = J.indexOf("=");
      -1 === eo && (eo = et);
      var el = eo === et ? 0 : 4 - eo % 4;
      return [eo, el]
    }
    el["-".charCodeAt(0)] = 62,
      el["_".charCodeAt(0)] = 63
  },
  13550: function (J, et, eo) {
    !function (J, et) {
      "use strict";
      function assert(J, et) {
        if (!J)
          throw Error(et || "Assertion failed")
      }
      function inherits(J, et) {
        J.super_ = et;
        var TempCtor = function () { };
        TempCtor.prototype = et.prototype,
          J.prototype = new TempCtor,
          J.prototype.constructor = J
      }
      function BN(J, et, eo) {
        if (BN.isBN(J))
          return J;
        this.negative = 0,
          this.words = null,
          this.length = 0,
          this.red = null,
          null !== J && (("le" === et || "be" === et) && (eo = et,
            et = 10),
            this._init(J || 0, et || 10, eo || "be"))
      }
      "object" == typeof J ? J.exports = BN : et.BN = BN,
        BN.BN = BN,
        BN.wordSize = 26;
      try {
        el = "undefined" != typeof window && void 0 !== window.Buffer ? window.Buffer : eo(46601).Buffer
      } catch (J) { }
      function parseHex4Bits(J, et) {
        var eo = J.charCodeAt(et);
        return eo >= 48 && eo <= 57 ? eo - 48 : eo >= 65 && eo <= 70 ? eo - 55 : eo >= 97 && eo <= 102 ? eo - 87 : void assert(!1, "Invalid character in " + J)
      }
      function parseHexByte(J, et, eo) {
        var el = parseHex4Bits(J, eo);
        return eo - 1 >= et && (el |= parseHex4Bits(J, eo - 1) << 4),
          el
      }
      function parseBase(J, et, eo, el) {
        for (var ec = 0, ed = 0, eh = Math.min(J.length, eo), ep = et; ep < eh; ep++) {
          var ef = J.charCodeAt(ep) - 48;
          ec *= el,
            ed = ef >= 49 ? ef - 49 + 10 : ef >= 17 ? ef - 17 + 10 : ef,
            assert(ef >= 0 && ed < el, "Invalid character"),
            ec += ed
        }
        return ec
      }
      function move(J, et) {
        J.words = et.words,
          J.length = et.length,
          J.negative = et.negative,
          J.red = et.red
      }
      if (BN.isBN = function (J) {
        return J instanceof BN || null !== J && "object" == typeof J && J.constructor.wordSize === BN.wordSize && Array.isArray(J.words)
      }
        ,
        BN.max = function (J, et) {
          return J.cmp(et) > 0 ? J : et
        }
        ,
        BN.min = function (J, et) {
          return 0 > J.cmp(et) ? J : et
        }
        ,
        BN.prototype._init = function (J, et, eo) {
          if ("number" == typeof J)
            return this._initNumber(J, et, eo);
          if ("object" == typeof J)
            return this._initArray(J, et, eo);
          "hex" === et && (et = 16),
            assert(et === (0 | et) && et >= 2 && et <= 36);
          var el = 0;
          "-" === (J = J.toString().replace(/\s+/g, ""))[0] && (el++,
            this.negative = 1),
            el < J.length && (16 === et ? this._parseHex(J, el, eo) : (this._parseBase(J, et, el),
              "le" === eo && this._initArray(this.toArray(), et, eo)))
        }
        ,
        BN.prototype._initNumber = function (J, et, eo) {
          J < 0 && (this.negative = 1,
            J = -J),
            J < 67108864 ? (this.words = [67108863 & J],
              this.length = 1) : J < 4503599627370496 ? (this.words = [67108863 & J, J / 67108864 & 67108863],
                this.length = 2) : (assert(J < 9007199254740992),
                  this.words = [67108863 & J, J / 67108864 & 67108863, 1],
                  this.length = 3),
            "le" === eo && this._initArray(this.toArray(), et, eo)
        }
        ,
        BN.prototype._initArray = function (J, et, eo) {
          if (assert("number" == typeof J.length),
            J.length <= 0)
            return this.words = [0],
              this.length = 1,
              this;
          this.length = Math.ceil(J.length / 3),
            this.words = Array(this.length);
          for (var el, ec, ed = 0; ed < this.length; ed++)
            this.words[ed] = 0;
          var eh = 0;
          if ("be" === eo)
            for (ed = J.length - 1,
              el = 0; ed >= 0; ed -= 3)
              ec = J[ed] | J[ed - 1] << 8 | J[ed - 2] << 16,
                this.words[el] |= ec << eh & 67108863,
                this.words[el + 1] = ec >>> 26 - eh & 67108863,
                (eh += 24) >= 26 && (eh -= 26,
                  el++);
          else if ("le" === eo)
            for (ed = 0,
              el = 0; ed < J.length; ed += 3)
              ec = J[ed] | J[ed + 1] << 8 | J[ed + 2] << 16,
                this.words[el] |= ec << eh & 67108863,
                this.words[el + 1] = ec >>> 26 - eh & 67108863,
                (eh += 24) >= 26 && (eh -= 26,
                  el++);
          return this._strip()
        }
        ,
        BN.prototype._parseHex = function (J, et, eo) {
          this.length = Math.ceil((J.length - et) / 6),
            this.words = Array(this.length);
          for (var el, ec = 0; ec < this.length; ec++)
            this.words[ec] = 0;
          var ed = 0
            , eh = 0;
          if ("be" === eo)
            for (ec = J.length - 1; ec >= et; ec -= 2)
              el = parseHexByte(J, et, ec) << ed,
                this.words[eh] |= 67108863 & el,
                ed >= 18 ? (ed -= 18,
                  eh += 1,
                  this.words[eh] |= el >>> 26) : ed += 8;
          else
            for (ec = (J.length - et) % 2 == 0 ? et + 1 : et; ec < J.length; ec += 2)
              el = parseHexByte(J, et, ec) << ed,
                this.words[eh] |= 67108863 & el,
                ed >= 18 ? (ed -= 18,
                  eh += 1,
                  this.words[eh] |= el >>> 26) : ed += 8;
          this._strip()
        }
        ,
        BN.prototype._parseBase = function (J, et, eo) {
          this.words = [0],
            this.length = 1;
          for (var el = 0, ec = 1; ec <= 67108863; ec *= et)
            el++;
          el--,
            ec = ec / et | 0;
          for (var ed = J.length - eo, eh = ed % el, ep = Math.min(ed, ed - eh) + eo, ef = 0, em = eo; em < ep; em += el)
            ef = parseBase(J, em, em + el, et),
              this.imuln(ec),
              this.words[0] + ef < 67108864 ? this.words[0] += ef : this._iaddn(ef);
          if (0 !== eh) {
            var eg = 1;
            for (ef = parseBase(J, em, J.length, et),
              em = 0; em < eh; em++)
              eg *= et;
            this.imuln(eg),
              this.words[0] + ef < 67108864 ? this.words[0] += ef : this._iaddn(ef)
          }
          this._strip()
        }
        ,
        BN.prototype.copy = function (J) {
          J.words = Array(this.length);
          for (var et = 0; et < this.length; et++)
            J.words[et] = this.words[et];
          J.length = this.length,
            J.negative = this.negative,
            J.red = this.red
        }
        ,
        BN.prototype._move = function (J) {
          move(J, this)
        }
        ,
        BN.prototype.clone = function () {
          var J = new BN(null);
          return this.copy(J),
            J
        }
        ,
        BN.prototype._expand = function (J) {
          for (; this.length < J;)
            this.words[this.length++] = 0;
          return this
        }
        ,
        BN.prototype._strip = function () {
          for (; this.length > 1 && 0 === this.words[this.length - 1];)
            this.length--;
          return this._normSign()
        }
        ,
        BN.prototype._normSign = function () {
          return 1 === this.length && 0 === this.words[0] && (this.negative = 0),
            this
        }
        ,
        "undefined" != typeof Symbol && "function" == typeof Symbol.for)
        try {
          BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect
        } catch (J) {
          BN.prototype.inspect = inspect
        }
      else
        BN.prototype.inspect = inspect;
      function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
      }
      var el, ec = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], ed = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], eh = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      function smallMulTo(J, et, eo) {
        eo.negative = et.negative ^ J.negative;
        var el = J.length + et.length | 0;
        eo.length = el,
          el = el - 1 | 0;
        var ec = 0 | J.words[0]
          , ed = 0 | et.words[0]
          , eh = ec * ed
          , ep = 67108863 & eh
          , ef = eh / 67108864 | 0;
        eo.words[0] = ep;
        for (var em = 1; em < el; em++) {
          for (var eg = ef >>> 26, ey = 67108863 & ef, eb = Math.min(em, et.length - 1), ew = Math.max(0, em - J.length + 1); ew <= eb; ew++) {
            var e_ = em - ew | 0;
            eg += (eh = (ec = 0 | J.words[e_]) * (ed = 0 | et.words[ew]) + ey) / 67108864 | 0,
              ey = 67108863 & eh
          }
          eo.words[em] = 0 | ey,
            ef = 0 | eg
        }
        return 0 !== ef ? eo.words[em] = 0 | ef : eo.length--,
          eo._strip()
      }
      BN.prototype.toString = function (J, et) {
        if (et = 0 | et || 1,
          16 === (J = J || 10) || "hex" === J) {
          eo = "";
          for (var eo, el = 0, ep = 0, ef = 0; ef < this.length; ef++) {
            var em = this.words[ef]
              , eg = ((em << el | ep) & 16777215).toString(16);
            ep = em >>> 24 - el & 16777215,
              (el += 2) >= 26 && (el -= 26,
                ef--),
              eo = 0 !== ep || ef !== this.length - 1 ? ec[6 - eg.length] + eg + eo : eg + eo
          }
          for (0 !== ep && (eo = ep.toString(16) + eo); eo.length % et != 0;)
            eo = "0" + eo;
          return 0 !== this.negative && (eo = "-" + eo),
            eo
        }
        if (J === (0 | J) && J >= 2 && J <= 36) {
          var ey = ed[J]
            , eb = eh[J];
          eo = "";
          var ew = this.clone();
          for (ew.negative = 0; !ew.isZero();) {
            var e_ = ew.modrn(eb).toString(J);
            eo = (ew = ew.idivn(eb)).isZero() ? e_ + eo : ec[ey - e_.length] + e_ + eo
          }
          for (this.isZero() && (eo = "0" + eo); eo.length % et != 0;)
            eo = "0" + eo;
          return 0 !== this.negative && (eo = "-" + eo),
            eo
        }
        assert(!1, "Base should be between 2 and 36")
      }
        ,
        BN.prototype.toNumber = function () {
          var J = this.words[0];
          return 2 === this.length ? J += 67108864 * this.words[1] : 3 === this.length && 1 === this.words[2] ? J += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && assert(!1, "Number can only safely store up to 53 bits"),
            0 !== this.negative ? -J : J
        }
        ,
        BN.prototype.toJSON = function () {
          return this.toString(16, 2)
        }
        ,
        el && (BN.prototype.toBuffer = function (J, et) {
          return this.toArrayLike(el, J, et)
        }
        ),
        BN.prototype.toArray = function (J, et) {
          return this.toArrayLike(Array, J, et)
        }
        ,
        BN.prototype.toArrayLike = function (J, et, eo) {
          this._strip();
          var el = this.byteLength()
            , ec = eo || Math.max(1, el);
          assert(el <= ec, "byte array longer than desired length"),
            assert(ec > 0, "Requested array length <= 0");
          var ed = J.allocUnsafe ? J.allocUnsafe(ec) : new J(ec);
          return this["_toArrayLike" + ("le" === et ? "LE" : "BE")](ed, el),
            ed
        }
        ,
        BN.prototype._toArrayLikeLE = function (J, et) {
          for (var eo = 0, el = 0, ec = 0, ed = 0; ec < this.length; ec++) {
            var eh = this.words[ec] << ed | el;
            J[eo++] = 255 & eh,
              eo < J.length && (J[eo++] = eh >> 8 & 255),
              eo < J.length && (J[eo++] = eh >> 16 & 255),
              6 === ed ? (eo < J.length && (J[eo++] = eh >> 24 & 255),
                el = 0,
                ed = 0) : (el = eh >>> 24,
                  ed += 2)
          }
          if (eo < J.length)
            for (J[eo++] = el; eo < J.length;)
              J[eo++] = 0
        }
        ,
        BN.prototype._toArrayLikeBE = function (J, et) {
          for (var eo = J.length - 1, el = 0, ec = 0, ed = 0; ec < this.length; ec++) {
            var eh = this.words[ec] << ed | el;
            J[eo--] = 255 & eh,
              eo >= 0 && (J[eo--] = eh >> 8 & 255),
              eo >= 0 && (J[eo--] = eh >> 16 & 255),
              6 === ed ? (eo >= 0 && (J[eo--] = eh >> 24 & 255),
                el = 0,
                ed = 0) : (el = eh >>> 24,
                  ed += 2)
          }
          if (eo >= 0)
            for (J[eo--] = el; eo >= 0;)
              J[eo--] = 0
        }
        ,
        Math.clz32 ? BN.prototype._countBits = function (J) {
          return 32 - Math.clz32(J)
        }
          : BN.prototype._countBits = function (J) {
            var et = J
              , eo = 0;
            return et >= 4096 && (eo += 13,
              et >>>= 13),
              et >= 64 && (eo += 7,
                et >>>= 7),
              et >= 8 && (eo += 4,
                et >>>= 4),
              et >= 2 && (eo += 2,
                et >>>= 2),
              eo + et
          }
        ,
        BN.prototype._zeroBits = function (J) {
          if (0 === J)
            return 26;
          var et = J
            , eo = 0;
          return (8191 & et) == 0 && (eo += 13,
            et >>>= 13),
            (127 & et) == 0 && (eo += 7,
              et >>>= 7),
            (15 & et) == 0 && (eo += 4,
              et >>>= 4),
            (3 & et) == 0 && (eo += 2,
              et >>>= 2),
            (1 & et) == 0 && eo++,
            eo
        }
        ,
        BN.prototype.bitLength = function () {
          var J = this.words[this.length - 1]
            , et = this._countBits(J);
          return (this.length - 1) * 26 + et
        }
        ,
        BN.prototype.zeroBits = function () {
          if (this.isZero())
            return 0;
          for (var J = 0, et = 0; et < this.length; et++) {
            var eo = this._zeroBits(this.words[et]);
            if (J += eo,
              26 !== eo)
              break
          }
          return J
        }
        ,
        BN.prototype.byteLength = function () {
          return Math.ceil(this.bitLength() / 8)
        }
        ,
        BN.prototype.toTwos = function (J) {
          return 0 !== this.negative ? this.abs().inotn(J).iaddn(1) : this.clone()
        }
        ,
        BN.prototype.fromTwos = function (J) {
          return this.testn(J - 1) ? this.notn(J).iaddn(1).ineg() : this.clone()
        }
        ,
        BN.prototype.isNeg = function () {
          return 0 !== this.negative
        }
        ,
        BN.prototype.neg = function () {
          return this.clone().ineg()
        }
        ,
        BN.prototype.ineg = function () {
          return this.isZero() || (this.negative ^= 1),
            this
        }
        ,
        BN.prototype.iuor = function (J) {
          for (; this.length < J.length;)
            this.words[this.length++] = 0;
          for (var et = 0; et < J.length; et++)
            this.words[et] = this.words[et] | J.words[et];
          return this._strip()
        }
        ,
        BN.prototype.ior = function (J) {
          return assert((this.negative | J.negative) == 0),
            this.iuor(J)
        }
        ,
        BN.prototype.or = function (J) {
          return this.length > J.length ? this.clone().ior(J) : J.clone().ior(this)
        }
        ,
        BN.prototype.uor = function (J) {
          return this.length > J.length ? this.clone().iuor(J) : J.clone().iuor(this)
        }
        ,
        BN.prototype.iuand = function (J) {
          var et;
          et = this.length > J.length ? J : this;
          for (var eo = 0; eo < et.length; eo++)
            this.words[eo] = this.words[eo] & J.words[eo];
          return this.length = et.length,
            this._strip()
        }
        ,
        BN.prototype.iand = function (J) {
          return assert((this.negative | J.negative) == 0),
            this.iuand(J)
        }
        ,
        BN.prototype.and = function (J) {
          return this.length > J.length ? this.clone().iand(J) : J.clone().iand(this)
        }
        ,
        BN.prototype.uand = function (J) {
          return this.length > J.length ? this.clone().iuand(J) : J.clone().iuand(this)
        }
        ,
        BN.prototype.iuxor = function (J) {
          this.length > J.length ? (et = this,
            eo = J) : (et = J,
              eo = this);
          for (var et, eo, el = 0; el < eo.length; el++)
            this.words[el] = et.words[el] ^ eo.words[el];
          if (this !== et)
            for (; el < et.length; el++)
              this.words[el] = et.words[el];
          return this.length = et.length,
            this._strip()
        }
        ,
        BN.prototype.ixor = function (J) {
          return assert((this.negative | J.negative) == 0),
            this.iuxor(J)
        }
        ,
        BN.prototype.xor = function (J) {
          return this.length > J.length ? this.clone().ixor(J) : J.clone().ixor(this)
        }
        ,
        BN.prototype.uxor = function (J) {
          return this.length > J.length ? this.clone().iuxor(J) : J.clone().iuxor(this)
        }
        ,
        BN.prototype.inotn = function (J) {
          assert("number" == typeof J && J >= 0);
          var et = 0 | Math.ceil(J / 26)
            , eo = J % 26;
          this._expand(et),
            eo > 0 && et--;
          for (var el = 0; el < et; el++)
            this.words[el] = 67108863 & ~this.words[el];
          return eo > 0 && (this.words[el] = ~this.words[el] & 67108863 >> 26 - eo),
            this._strip()
        }
        ,
        BN.prototype.notn = function (J) {
          return this.clone().inotn(J)
        }
        ,
        BN.prototype.setn = function (J, et) {
          assert("number" == typeof J && J >= 0);
          var eo = J / 26 | 0
            , el = J % 26;
          return this._expand(eo + 1),
            et ? this.words[eo] = this.words[eo] | 1 << el : this.words[eo] = this.words[eo] & ~(1 << el),
            this._strip()
        }
        ,
        BN.prototype.iadd = function (J) {
          if (0 !== this.negative && 0 === J.negative)
            return this.negative = 0,
              et = this.isub(J),
              this.negative ^= 1,
              this._normSign();
          if (0 === this.negative && 0 !== J.negative)
            return J.negative = 0,
              et = this.isub(J),
              J.negative = 1,
              et._normSign();
          this.length > J.length ? (eo = this,
            el = J) : (eo = J,
              el = this);
          for (var et, eo, el, ec = 0, ed = 0; ed < el.length; ed++)
            et = (0 | eo.words[ed]) + (0 | el.words[ed]) + ec,
              this.words[ed] = 67108863 & et,
              ec = et >>> 26;
          for (; 0 !== ec && ed < eo.length; ed++)
            et = (0 | eo.words[ed]) + ec,
              this.words[ed] = 67108863 & et,
              ec = et >>> 26;
          if (this.length = eo.length,
            0 !== ec)
            this.words[this.length] = ec,
              this.length++;
          else if (eo !== this)
            for (; ed < eo.length; ed++)
              this.words[ed] = eo.words[ed];
          return this
        }
        ,
        BN.prototype.add = function (J) {
          var et;
          return 0 !== J.negative && 0 === this.negative ? (J.negative = 0,
            et = this.sub(J),
            J.negative ^= 1,
            et) : 0 === J.negative && 0 !== this.negative ? (this.negative = 0,
              et = J.sub(this),
              this.negative = 1,
              et) : this.length > J.length ? this.clone().iadd(J) : J.clone().iadd(this)
        }
        ,
        BN.prototype.isub = function (J) {
          if (0 !== J.negative) {
            J.negative = 0;
            var et, eo, el = this.iadd(J);
            return J.negative = 1,
              el._normSign()
          }
          if (0 !== this.negative)
            return this.negative = 0,
              this.iadd(J),
              this.negative = 1,
              this._normSign();
          var ec = this.cmp(J);
          if (0 === ec)
            return this.negative = 0,
              this.length = 1,
              this.words[0] = 0,
              this;
          ec > 0 ? (et = this,
            eo = J) : (et = J,
              eo = this);
          for (var ed = 0, eh = 0; eh < eo.length; eh++)
            ed = (el = (0 | et.words[eh]) - (0 | eo.words[eh]) + ed) >> 26,
              this.words[eh] = 67108863 & el;
          for (; 0 !== ed && eh < et.length; eh++)
            ed = (el = (0 | et.words[eh]) + ed) >> 26,
              this.words[eh] = 67108863 & el;
          if (0 === ed && eh < et.length && et !== this)
            for (; eh < et.length; eh++)
              this.words[eh] = et.words[eh];
          return this.length = Math.max(this.length, eh),
            et !== this && (this.negative = 1),
            this._strip()
        }
        ,
        BN.prototype.sub = function (J) {
          return this.clone().isub(J)
        }
        ;
      var comb10MulTo = function (J, et, eo) {
        var el, ec, ed, eh = J.words, ep = et.words, ef = eo.words, em = 0, eg = 0 | eh[0], ey = 8191 & eg, eb = eg >>> 13, ew = 0 | eh[1], e_ = 8191 & ew, ex = ew >>> 13, eE = 0 | eh[2], eC = 8191 & eE, eS = eE >>> 13, ek = 0 | eh[3], eT = 8191 & ek, eA = ek >>> 13, eP = 0 | eh[4], eR = 8191 & eP, eI = eP >>> 13, eO = 0 | eh[5], eN = 8191 & eO, eM = eO >>> 13, eD = 0 | eh[6], ej = 8191 & eD, eL = eD >>> 13, e$ = 0 | eh[7], eB = 8191 & e$, eF = e$ >>> 13, eU = 0 | eh[8], ez = 8191 & eU, eH = eU >>> 13, eV = 0 | eh[9], eW = 8191 & eV, eZ = eV >>> 13, eG = 0 | ep[0], eY = 8191 & eG, eK = eG >>> 13, eJ = 0 | ep[1], eQ = 8191 & eJ, eX = eJ >>> 13, e0 = 0 | ep[2], e1 = 8191 & e0, e2 = e0 >>> 13, e3 = 0 | ep[3], e5 = 8191 & e3, e6 = e3 >>> 13, e4 = 0 | ep[4], e8 = 8191 & e4, e7 = e4 >>> 13, e9 = 0 | ep[5], tn = 8191 & e9, to = e9 >>> 13, ta = 0 | ep[6], tl = 8191 & ta, tc = ta >>> 13, td = 0 | ep[7], th = 8191 & td, tp = td >>> 13, tf = 0 | ep[8], tm = 8191 & tf, tg = tf >>> 13, ty = 0 | ep[9], tb = 8191 & ty, tw = ty >>> 13;
        eo.negative = J.negative ^ et.negative,
          eo.length = 19;
        var t_ = (em + (el = Math.imul(ey, eY)) | 0) + ((8191 & (ec = (ec = Math.imul(ey, eK)) + Math.imul(eb, eY) | 0)) << 13) | 0;
        em = ((ed = Math.imul(eb, eK)) + (ec >>> 13) | 0) + (t_ >>> 26) | 0,
          t_ &= 67108863,
          el = Math.imul(e_, eY),
          ec = (ec = Math.imul(e_, eK)) + Math.imul(ex, eY) | 0,
          ed = Math.imul(ex, eK);
        var tx = (em + (el = el + Math.imul(ey, eQ) | 0) | 0) + ((8191 & (ec = (ec = ec + Math.imul(ey, eX) | 0) + Math.imul(eb, eQ) | 0)) << 13) | 0;
        em = ((ed = ed + Math.imul(eb, eX) | 0) + (ec >>> 13) | 0) + (tx >>> 26) | 0,
          tx &= 67108863,
          el = Math.imul(eC, eY),
          ec = (ec = Math.imul(eC, eK)) + Math.imul(eS, eY) | 0,
          ed = Math.imul(eS, eK),
          el = el + Math.imul(e_, eQ) | 0,
          ec = (ec = ec + Math.imul(e_, eX) | 0) + Math.imul(ex, eQ) | 0,
          ed = ed + Math.imul(ex, eX) | 0;
        var tE = (em + (el = el + Math.imul(ey, e1) | 0) | 0) + ((8191 & (ec = (ec = ec + Math.imul(ey, e2) | 0) + Math.imul(eb, e1) | 0)) << 13) | 0;
        em = ((ed = ed + Math.imul(eb, e2) | 0) + (ec >>> 13) | 0) + (tE >>> 26) | 0,
          tE &= 67108863,
          el = Math.imul(eT, eY),
          ec = (ec = Math.imul(eT, eK)) + Math.imul(eA, eY) | 0,
          ed = Math.imul(eA, eK),
          el = el + Math.imul(eC, eQ) | 0,
          ec = (ec = ec + Math.imul(eC, eX) | 0) + Math.imul(eS, eQ) | 0,
          ed = ed + Math.imul(eS, eX) | 0,
          el = el + Math.imul(e_, e1) | 0,
          ec = (ec = ec + Math.imul(e_, e2) | 0) + Math.imul(ex, e1) | 0,
          ed = ed + Math.imul(ex, e2) | 0;
        var tC = (em + (el = el + Math.imul(ey, e5) | 0) | 0) + ((8191 & (ec = (ec = ec + Math.imul(ey, e6) | 0) + Math.imul(eb, e5) | 0)) << 13) | 0;
        em = ((ed = ed + Math.imul(eb, e6) | 0) + (ec >>> 13) | 0) + (tC >>> 26) | 0,
          tC &= 67108863,
          el = Math.imul(eR, eY),
          ec = (ec = Math.imul(eR, eK)) + Math.imul(eI, eY) | 0,
          ed = Math.imul(eI, eK),
          el = el + Math.imul(eT, eQ) | 0,
          ec = (ec = ec + Math.imul(eT, eX) | 0) + Math.imul(eA, eQ) | 0,
          ed = ed + Math.imul(eA, eX) | 0,
          el = el + Math.imul(eC, e1) | 0,
          ec = (ec = ec + Math.imul(eC, e2) | 0) + Math.imul(eS, e1) | 0,
          ed = ed + Math.imul(eS, e2) | 0,
          el = el + Math.imul(e_, e5) | 0,
          ec = (ec = ec + Math.imul(e_, e6) | 0) + Math.imul(ex, e5) | 0,
          ed = ed + Math.imul(ex, e6) | 0;
        var tS = (em + (el = el + Math.imul(ey, e8) | 0) | 0) + ((8191 & (ec = (ec = ec + Math.imul(ey, e7) | 0) + Math.imul(eb, e8) | 0)) << 13) | 0;
        em = ((ed = ed + Math.imul(eb, e7) | 0) + (ec >>> 13) | 0) + (tS >>> 26) | 0,
          tS &= 67108863,
          el = Math.imul(eN, eY),
          ec = (ec = Math.imul(eN, eK)) + Math.imul(eM, eY) | 0,
          ed = Math.imul(eM, eK),
          el = el + Math.imul(eR, eQ) | 0,
          ec = (ec = ec + Math.imul(eR, eX) | 0) + Math.imul(eI, eQ) | 0,
          ed = ed + Math.imul(eI, eX) | 0,
          el = el + Math.imul(eT, e1) | 0,
          ec = (ec = ec + Math.imul(eT, e2) | 0) + Math.imul(eA, e1) | 0,
          ed = ed + Math.imul(eA, e2) | 0,
          el = el + Math.imul(eC, e5) | 0,
          ec = (ec = ec + Math.imul(eC, e6) | 0) + Math.imul(eS, e5) | 0,
          ed = ed + Math.imul(eS, e6) | 0,
          el = el + Math.imul(e_, e8) | 0,
          ec = (ec = ec + Math.imul(e_, e7) | 0) + Math.imul(ex, e8) | 0,
          ed = ed + Math.imul(ex, e7) | 0;
        var tk = (em + (el = el + Math.imul(ey, tn) | 0) | 0) + ((8191 & (ec = (ec = ec + Math.imul(ey, to) | 0) + Math.imul(eb, tn) | 0)) << 13) | 0;
        em = ((ed = ed + Math.imul(eb, to) | 0) + (ec >>> 13) | 0) + (tk >>> 26) | 0,
          tk &= 67108863,
          el = Math.imul(ej, eY),
          ec = (ec = Math.imul(ej, eK)) + Math.imul(eL, eY) | 0,
          ed = Math.imul(eL, eK),
          el = el + Math.imul(eN, eQ) | 0,
          ec = (ec = ec + Math.imul(eN, eX) | 0) + Math.imul(eM, eQ) | 0,
          ed = ed + Math.imul(eM, eX) | 0,
          el = el + Math.imul(eR, e1) | 0,
          ec = (ec = ec + Math.imul(eR, e2) | 0) + Math.imul(eI, e1) | 0,
          ed = ed + Math.imul(eI, e2) | 0,
          el = el + Math.imul(eT, e5) | 0,
          ec = (ec = ec + Math.imul(eT, e6) | 0) + Math.imul(eA, e5) | 0,
          ed = ed + Math.imul(eA, e6) | 0,
          el = el + Math.imul(eC, e8) | 0,
          ec = (ec = ec + Math.imul(eC, e7) | 0) + Math.imul(eS, e8) | 0,
          ed = ed + Math.imul(eS, e7) | 0,
          el = el + Math.imul(e_, tn) | 0,
          ec = (ec = ec + Math.imul(e_, to) | 0) + Math.imul(ex, tn) | 0,
          ed = ed + Math.imul(ex, to) | 0;
        var tT = (em + (el = el + Math.imul(ey, tl) | 0) | 0) + ((8191 & (ec = (ec = ec + Math.imul(ey, tc) | 0) + Math.imul(eb, tl) | 0)) << 13) | 0;
        em = ((ed = ed + Math.imul(eb, tc) | 0) + (ec >>> 13) | 0) + (tT >>> 26) | 0,
          tT &= 67108863,
          el = Math.imul(eB, eY),
          ec = (ec = Math.imul(eB, eK)) + Math.imul(eF, eY) | 0,
          ed = Math.imul(eF, eK),
          el = el + Math.imul(ej, eQ) | 0,
          ec = (ec = ec + Math.imul(ej, eX) | 0) + Math.imul(eL, eQ) | 0,
          ed = ed + Math.imul(eL, eX) | 0,
          el = el + Math.imul(eN, e1) | 0,
          ec = (ec = ec + Math.imul(eN, e2) | 0) + Math.imul(eM, e1) | 0,
          ed = ed + Math.imul(eM, e2) | 0,
          el = el + Math.imul(eR, e5) | 0,
          ec = (ec = ec + Math.imul(eR, e6) | 0) + Math.imul(eI, e5) | 0,
          ed = ed + Math.imul(eI, e6) | 0,
          el = el + Math.imul(eT, e8) | 0,
          ec = (ec = ec + Math.imul(eT, e7) | 0) + Math.imul(eA, e8) | 0,
          ed = ed + Math.imul(eA, e7) | 0,
          el = el + Math.imul(eC, tn) | 0,
          ec = (ec = ec + Math.imul(eC, to) | 0) + Math.imul(eS, tn) | 0,
          ed = ed + Math.imul(eS, to) | 0,
          el = el + Math.imul(e_, tl) | 0,
          ec = (ec = ec + Math.imul(e_, tc) | 0) + Math.imul(ex, tl) | 0,
          ed = ed + Math.imul(ex, tc) | 0;
        var tA = (em + (el = el + Math.imul(ey, th) | 0) | 0) + ((8191 & (ec = (ec = ec + Math.imul(ey, tp) | 0) + Math.imul(eb, th) | 0)) << 13) | 0;
        em = ((ed = ed + Math.imul(eb, tp) | 0) + (ec >>> 13) | 0) + (tA >>> 26) | 0,
          tA &= 67108863,
          el = Math.imul(ez, eY),
          ec = (ec = Math.imul(ez, eK)) + Math.imul(eH, eY) | 0,
          ed = Math.imul(eH, eK),
          el = el + Math.imul(eB, eQ) | 0,
          ec = (ec = ec + Math.imul(eB, eX) | 0) + Math.imul(eF, eQ) | 0,
          ed = ed + Math.imul(eF, eX) | 0,
          el = el + Math.imul(ej, e1) | 0,
          ec = (ec = ec + Math.imul(ej, e2) | 0) + Math.imul(eL, e1) | 0,
          ed = ed + Math.imul(eL, e2) | 0,
          el = el + Math.imul(eN, e5) | 0,
          ec = (ec = ec + Math.imul(eN, e6) | 0) + Math.imul(eM, e5) | 0,
          ed = ed + Math.imul(eM, e6) | 0,
          el = el + Math.imul(eR, e8) | 0,
          ec = (ec = ec + Math.imul(eR, e7) | 0) + Math.imul(eI, e8) | 0,
          ed = ed + Math.imul(eI, e7) | 0,
          el = el + Math.imul(eT, tn) | 0,
          ec = (ec = ec + Math.imul(eT, to) | 0) + Math.imul(eA, tn) | 0,
          ed = ed + Math.imul(eA, to) | 0,
          el = el + Math.imul(eC, tl) | 0,
          ec = (ec = ec + Math.imul(eC, tc) | 0) + Math.imul(eS, tl) | 0,
          ed = ed + Math.imul(eS, tc) | 0,
          el = el + Math.imul(e_, th) | 0,
          ec = (ec = ec + Math.imul(e_, tp) | 0) + Math.imul(ex, th) | 0,
          ed = ed + Math.imul(ex, tp) | 0;
        var tP = (em + (el = el + Math.imul(ey, tm) | 0) | 0) + ((8191 & (ec = (ec = ec + Math.imul(ey, tg) | 0) + Math.imul(eb, tm) | 0)) << 13) | 0;
        em = ((ed = ed + Math.imul(eb, tg) | 0) + (ec >>> 13) | 0) + (tP >>> 26) | 0,
          tP &= 67108863,
          el = Math.imul(eW, eY),
          ec = (ec = Math.imul(eW, eK)) + Math.imul(eZ, eY) | 0,
          ed = Math.imul(eZ, eK),
          el = el + Math.imul(ez, eQ) | 0,
          ec = (ec = ec + Math.imul(ez, eX) | 0) + Math.imul(eH, eQ) | 0,
          ed = ed + Math.imul(eH, eX) | 0,
          el = el + Math.imul(eB, e1) | 0,
          ec = (ec = ec + Math.imul(eB, e2) | 0) + Math.imul(eF, e1) | 0,
          ed = ed + Math.imul(eF, e2) | 0,
          el = el + Math.imul(ej, e5) | 0,
          ec = (ec = ec + Math.imul(ej, e6) | 0) + Math.imul(eL, e5) | 0,
          ed = ed + Math.imul(eL, e6) | 0,
          el = el + Math.imul(eN, e8) | 0,
          ec = (ec = ec + Math.imul(eN, e7) | 0) + Math.imul(eM, e8) | 0,
          ed = ed + Math.imul(eM, e7) | 0,
          el = el + Math.imul(eR, tn) | 0,
          ec = (ec = ec + Math.imul(eR, to) | 0) + Math.imul(eI, tn) | 0,
          ed = ed + Math.imul(eI, to) | 0,
          el = el + Math.imul(eT, tl) | 0,
          ec = (ec = ec + Math.imul(eT, tc) | 0) + Math.imul(eA, tl) | 0,
          ed = ed + Math.imul(eA, tc) | 0,
          el = el + Math.imul(eC, th) | 0,
          ec = (ec = ec + Math.imul(eC, tp) | 0) + Math.imul(eS, th) | 0,
          ed = ed + Math.imul(eS, tp) | 0,
          el = el + Math.imul(e_, tm) | 0,
          ec = (ec = ec + Math.imul(e_, tg) | 0) + Math.imul(ex, tm) | 0,
          ed = ed + Math.imul(ex, tg) | 0;
        var tR = (em + (el = el + Math.imul(ey, tb) | 0) | 0) + ((8191 & (ec = (ec = ec + Math.imul(ey, tw) | 0) + Math.imul(eb, tb) | 0)) << 13) | 0;
        em = ((ed = ed + Math.imul(eb, tw) | 0) + (ec >>> 13) | 0) + (tR >>> 26) | 0,
          tR &= 67108863,
          el = Math.imul(eW, eQ),
          ec = (ec = Math.imul(eW, eX)) + Math.imul(eZ, eQ) | 0,
          ed = Math.imul(eZ, eX),
          el = el + Math.imul(ez, e1) | 0,
          ec = (ec = ec + Math.imul(ez, e2) | 0) + Math.imul(eH, e1) | 0,
          ed = ed + Math.imul(eH, e2) | 0,
          el = el + Math.imul(eB, e5) | 0,
          ec = (ec = ec + Math.imul(eB, e6) | 0) + Math.imul(eF, e5) | 0,
          ed = ed + Math.imul(eF, e6) | 0,
          el = el + Math.imul(ej, e8) | 0,
          ec = (ec = ec + Math.imul(ej, e7) | 0) + Math.imul(eL, e8) | 0,
          ed = ed + Math.imul(eL, e7) | 0,
          el = el + Math.imul(eN, tn) | 0,
          ec = (ec = ec + Math.imul(eN, to) | 0) + Math.imul(eM, tn) | 0,
          ed = ed + Math.imul(eM, to) | 0,
          el = el + Math.imul(eR, tl) | 0,
          ec = (ec = ec + Math.imul(eR, tc) | 0) + Math.imul(eI, tl) | 0,
          ed = ed + Math.imul(eI, tc) | 0,
          el = el + Math.imul(eT, th) | 0,
          ec = (ec = ec + Math.imul(eT, tp) | 0) + Math.imul(eA, th) | 0,
          ed = ed + Math.imul(eA, tp) | 0,
          el = el + Math.imul(eC, tm) | 0,
          ec = (ec = ec + Math.imul(eC, tg) | 0) + Math.imul(eS, tm) | 0,
          ed = ed + Math.imul(eS, tg) | 0;
        var tI = (em + (el = el + Math.imul(e_, tb) | 0) | 0) + ((8191 & (ec = (ec = ec + Math.imul(e_, tw) | 0) + Math.imul(ex, tb) | 0)) << 13) | 0;
        em = ((ed = ed + Math.imul(ex, tw) | 0) + (ec >>> 13) | 0) + (tI >>> 26) | 0,
          tI &= 67108863,
          el = Math.imul(eW, e1),
          ec = (ec = Math.imul(eW, e2)) + Math.imul(eZ, e1) | 0,
          ed = Math.imul(eZ, e2),
          el = el + Math.imul(ez, e5) | 0,
          ec = (ec = ec + Math.imul(ez, e6) | 0) + Math.imul(eH, e5) | 0,
          ed = ed + Math.imul(eH, e6) | 0,
          el = el + Math.imul(eB, e8) | 0,
          ec = (ec = ec + Math.imul(eB, e7) | 0) + Math.imul(eF, e8) | 0,
          ed = ed + Math.imul(eF, e7) | 0,
          el = el + Math.imul(ej, tn) | 0,
          ec = (ec = ec + Math.imul(ej, to) | 0) + Math.imul(eL, tn) | 0,
          ed = ed + Math.imul(eL, to) | 0,
          el = el + Math.imul(eN, tl) | 0,
          ec = (ec = ec + Math.imul(eN, tc) | 0) + Math.imul(eM, tl) | 0,
          ed = ed + Math.imul(eM, tc) | 0,
          el = el + Math.imul(eR, th) | 0,
          ec = (ec = ec + Math.imul(eR, tp) | 0) + Math.imul(eI, th) | 0,
          ed = ed + Math.imul(eI, tp) | 0,
          el = el + Math.imul(eT, tm) | 0,
          ec = (ec = ec + Math.imul(eT, tg) | 0) + Math.imul(eA, tm) | 0,
          ed = ed + Math.imul(eA, tg) | 0;
        var tO = (em + (el = el + Math.imul(eC, tb) | 0) | 0) + ((8191 & (ec = (ec = ec + Math.imul(eC, tw) | 0) + Math.imul(eS, tb) | 0)) << 13) | 0;
        em = ((ed = ed + Math.imul(eS, tw) | 0) + (ec >>> 13) | 0) + (tO >>> 26) | 0,
          tO &= 67108863,
          el = Math.imul(eW, e5),
          ec = (ec = Math.imul(eW, e6)) + Math.imul(eZ, e5) | 0,
          ed = Math.imul(eZ, e6),
          el = el + Math.imul(ez, e8) | 0,
          ec = (ec = ec + Math.imul(ez, e7) | 0) + Math.imul(eH, e8) | 0,
          ed = ed + Math.imul(eH, e7) | 0,
          el = el + Math.imul(eB, tn) | 0,
          ec = (ec = ec + Math.imul(eB, to) | 0) + Math.imul(eF, tn) | 0,
          ed = ed + Math.imul(eF, to) | 0,
          el = el + Math.imul(ej, tl) | 0,
          ec = (ec = ec + Math.imul(ej, tc) | 0) + Math.imul(eL, tl) | 0,
          ed = ed + Math.imul(eL, tc) | 0,
          el = el + Math.imul(eN, th) | 0,
          ec = (ec = ec + Math.imul(eN, tp) | 0) + Math.imul(eM, th) | 0,
          ed = ed + Math.imul(eM, tp) | 0,
          el = el + Math.imul(eR, tm) | 0,
          ec = (ec = ec + Math.imul(eR, tg) | 0) + Math.imul(eI, tm) | 0,
          ed = ed + Math.imul(eI, tg) | 0;
        var tN = (em + (el = el + Math.imul(eT, tb) | 0) | 0) + ((8191 & (ec = (ec = ec + Math.imul(eT, tw) | 0) + Math.imul(eA, tb) | 0)) << 13) | 0;
        em = ((ed = ed + Math.imul(eA, tw) | 0) + (ec >>> 13) | 0) + (tN >>> 26) | 0,
          tN &= 67108863,
          el = Math.imul(eW, e8),
          ec = (ec = Math.imul(eW, e7)) + Math.imul(eZ, e8) | 0,
          ed = Math.imul(eZ, e7),
          el = el + Math.imul(ez, tn) | 0,
          ec = (ec = ec + Math.imul(ez, to) | 0) + Math.imul(eH, tn) | 0,
          ed = ed + Math.imul(eH, to) | 0,
          el = el + Math.imul(eB, tl) | 0,
          ec = (ec = ec + Math.imul(eB, tc) | 0) + Math.imul(eF, tl) | 0,
          ed = ed + Math.imul(eF, tc) | 0,
          el = el + Math.imul(ej, th) | 0,
          ec = (ec = ec + Math.imul(ej, tp) | 0) + Math.imul(eL, th) | 0,
          ed = ed + Math.imul(eL, tp) | 0,
          el = el + Math.imul(eN, tm) | 0,
          ec = (ec = ec + Math.imul(eN, tg) | 0) + Math.imul(eM, tm) | 0,
          ed = ed + Math.imul(eM, tg) | 0;
        var tM = (em + (el = el + Math.imul(eR, tb) | 0) | 0) + ((8191 & (ec = (ec = ec + Math.imul(eR, tw) | 0) + Math.imul(eI, tb) | 0)) << 13) | 0;
        em = ((ed = ed + Math.imul(eI, tw) | 0) + (ec >>> 13) | 0) + (tM >>> 26) | 0,
          tM &= 67108863,
          el = Math.imul(eW, tn),
          ec = (ec = Math.imul(eW, to)) + Math.imul(eZ, tn) | 0,
          ed = Math.imul(eZ, to),
          el = el + Math.imul(ez, tl) | 0,
          ec = (ec = ec + Math.imul(ez, tc) | 0) + Math.imul(eH, tl) | 0,
          ed = ed + Math.imul(eH, tc) | 0,
          el = el + Math.imul(eB, th) | 0,
          ec = (ec = ec + Math.imul(eB, tp) | 0) + Math.imul(eF, th) | 0,
          ed = ed + Math.imul(eF, tp) | 0,
          el = el + Math.imul(ej, tm) | 0,
          ec = (ec = ec + Math.imul(ej, tg) | 0) + Math.imul(eL, tm) | 0,
          ed = ed + Math.imul(eL, tg) | 0;
        var tD = (em + (el = el + Math.imul(eN, tb) | 0) | 0) + ((8191 & (ec = (ec = ec + Math.imul(eN, tw) | 0) + Math.imul(eM, tb) | 0)) << 13) | 0;
        em = ((ed = ed + Math.imul(eM, tw) | 0) + (ec >>> 13) | 0) + (tD >>> 26) | 0,
          tD &= 67108863,
          el = Math.imul(eW, tl),
          ec = (ec = Math.imul(eW, tc)) + Math.imul(eZ, tl) | 0,
          ed = Math.imul(eZ, tc),
          el = el + Math.imul(ez, th) | 0,
          ec = (ec = ec + Math.imul(ez, tp) | 0) + Math.imul(eH, th) | 0,
          ed = ed + Math.imul(eH, tp) | 0,
          el = el + Math.imul(eB, tm) | 0,
          ec = (ec = ec + Math.imul(eB, tg) | 0) + Math.imul(eF, tm) | 0,
          ed = ed + Math.imul(eF, tg) | 0;
        var tj = (em + (el = el + Math.imul(ej, tb) | 0) | 0) + ((8191 & (ec = (ec = ec + Math.imul(ej, tw) | 0) + Math.imul(eL, tb) | 0)) << 13) | 0;
        em = ((ed = ed + Math.imul(eL, tw) | 0) + (ec >>> 13) | 0) + (tj >>> 26) | 0,
          tj &= 67108863,
          el = Math.imul(eW, th),
          ec = (ec = Math.imul(eW, tp)) + Math.imul(eZ, th) | 0,
          ed = Math.imul(eZ, tp),
          el = el + Math.imul(ez, tm) | 0,
          ec = (ec = ec + Math.imul(ez, tg) | 0) + Math.imul(eH, tm) | 0,
          ed = ed + Math.imul(eH, tg) | 0;
        var tL = (em + (el = el + Math.imul(eB, tb) | 0) | 0) + ((8191 & (ec = (ec = ec + Math.imul(eB, tw) | 0) + Math.imul(eF, tb) | 0)) << 13) | 0;
        em = ((ed = ed + Math.imul(eF, tw) | 0) + (ec >>> 13) | 0) + (tL >>> 26) | 0,
          tL &= 67108863,
          el = Math.imul(eW, tm),
          ec = (ec = Math.imul(eW, tg)) + Math.imul(eZ, tm) | 0,
          ed = Math.imul(eZ, tg);
        var t$ = (em + (el = el + Math.imul(ez, tb) | 0) | 0) + ((8191 & (ec = (ec = ec + Math.imul(ez, tw) | 0) + Math.imul(eH, tb) | 0)) << 13) | 0;
        em = ((ed = ed + Math.imul(eH, tw) | 0) + (ec >>> 13) | 0) + (t$ >>> 26) | 0,
          t$ &= 67108863;
        var tB = (em + (el = Math.imul(eW, tb)) | 0) + ((8191 & (ec = (ec = Math.imul(eW, tw)) + Math.imul(eZ, tb) | 0)) << 13) | 0;
        return em = ((ed = Math.imul(eZ, tw)) + (ec >>> 13) | 0) + (tB >>> 26) | 0,
          tB &= 67108863,
          ef[0] = t_,
          ef[1] = tx,
          ef[2] = tE,
          ef[3] = tC,
          ef[4] = tS,
          ef[5] = tk,
          ef[6] = tT,
          ef[7] = tA,
          ef[8] = tP,
          ef[9] = tR,
          ef[10] = tI,
          ef[11] = tO,
          ef[12] = tN,
          ef[13] = tM,
          ef[14] = tD,
          ef[15] = tj,
          ef[16] = tL,
          ef[17] = t$,
          ef[18] = tB,
          0 !== em && (ef[19] = em,
            eo.length++),
          eo
      };
      function bigMulTo(J, et, eo) {
        eo.negative = et.negative ^ J.negative,
          eo.length = J.length + et.length;
        for (var el = 0, ec = 0, ed = 0; ed < eo.length - 1; ed++) {
          var eh = ec;
          ec = 0;
          for (var ep = 67108863 & el, ef = Math.min(ed, et.length - 1), em = Math.max(0, ed - J.length + 1); em <= ef; em++) {
            var eg = ed - em
              , ey = (0 | J.words[eg]) * (0 | et.words[em])
              , eb = 67108863 & ey;
            eh = eh + (ey / 67108864 | 0) | 0,
              ep = 67108863 & (eb = eb + ep | 0),
              ec += (eh = eh + (eb >>> 26) | 0) >>> 26,
              eh &= 67108863
          }
          eo.words[ed] = ep,
            el = eh,
            eh = ec
        }
        return 0 !== el ? eo.words[ed] = el : eo.length--,
          eo._strip()
      }
      function FFTM(J, et) {
        this.x = J,
          this.y = et
      }
      Math.imul || (comb10MulTo = smallMulTo),
        BN.prototype.mulTo = function (J, et) {
          var eo, el = this.length + J.length;
          return 10 === this.length && 10 === J.length ? comb10MulTo(this, J, et) : el < 63 ? smallMulTo(this, J, et) : bigMulTo(this, J, et)
        }
        ,
        FFTM.prototype.makeRBT = function (J) {
          for (var et = Array(J), eo = BN.prototype._countBits(J) - 1, el = 0; el < J; el++)
            et[el] = this.revBin(el, eo, J);
          return et
        }
        ,
        FFTM.prototype.revBin = function (J, et, eo) {
          if (0 === J || J === eo - 1)
            return J;
          for (var el = 0, ec = 0; ec < et; ec++)
            el |= (1 & J) << et - ec - 1,
              J >>= 1;
          return el
        }
        ,
        FFTM.prototype.permute = function (J, et, eo, el, ec, ed) {
          for (var eh = 0; eh < ed; eh++)
            el[eh] = et[J[eh]],
              ec[eh] = eo[J[eh]]
        }
        ,
        FFTM.prototype.transform = function (J, et, eo, el, ec, ed) {
          this.permute(ed, J, et, eo, el, ec);
          for (var eh = 1; eh < ec; eh <<= 1)
            for (var ep = eh << 1, ef = Math.cos(2 * Math.PI / ep), em = Math.sin(2 * Math.PI / ep), eg = 0; eg < ec; eg += ep)
              for (var ey = ef, eb = em, ew = 0; ew < eh; ew++) {
                var e_ = eo[eg + ew]
                  , ex = el[eg + ew]
                  , eE = eo[eg + ew + eh]
                  , eC = el[eg + ew + eh]
                  , eS = ey * eE - eb * eC;
                eC = ey * eC + eb * eE,
                  eE = eS,
                  eo[eg + ew] = e_ + eE,
                  el[eg + ew] = ex + eC,
                  eo[eg + ew + eh] = e_ - eE,
                  el[eg + ew + eh] = ex - eC,
                  ew !== ep && (eS = ef * ey - em * eb,
                    eb = ef * eb + em * ey,
                    ey = eS)
              }
        }
        ,
        FFTM.prototype.guessLen13b = function (J, et) {
          var eo = 1 | Math.max(et, J)
            , el = 1 & eo
            , ec = 0;
          for (eo = eo / 2 | 0; eo; eo >>>= 1)
            ec++;
          return 1 << ec + 1 + el
        }
        ,
        FFTM.prototype.conjugate = function (J, et, eo) {
          if (!(eo <= 1))
            for (var el = 0; el < eo / 2; el++) {
              var ec = J[el];
              J[el] = J[eo - el - 1],
                J[eo - el - 1] = ec,
                ec = et[el],
                et[el] = -et[eo - el - 1],
                et[eo - el - 1] = -ec
            }
        }
        ,
        FFTM.prototype.normalize13b = function (J, et) {
          for (var eo = 0, el = 0; el < et / 2; el++) {
            var ec = 8192 * Math.round(J[2 * el + 1] / et) + Math.round(J[2 * el] / et) + eo;
            J[el] = 67108863 & ec,
              eo = ec < 67108864 ? 0 : ec / 67108864 | 0
          }
          return J
        }
        ,
        FFTM.prototype.convert13b = function (J, et, eo, el) {
          for (var ec = 0, ed = 0; ed < et; ed++)
            ec += 0 | J[ed],
              eo[2 * ed] = 8191 & ec,
              ec >>>= 13,
              eo[2 * ed + 1] = 8191 & ec,
              ec >>>= 13;
          for (ed = 2 * et; ed < el; ++ed)
            eo[ed] = 0;
          assert(0 === ec),
            assert((-8192 & ec) == 0)
        }
        ,
        FFTM.prototype.stub = function (J) {
          for (var et = Array(J), eo = 0; eo < J; eo++)
            et[eo] = 0;
          return et
        }
        ,
        FFTM.prototype.mulp = function (J, et, eo) {
          var el = 2 * this.guessLen13b(J.length, et.length)
            , ec = this.makeRBT(el)
            , ed = this.stub(el)
            , eh = Array(el)
            , ep = Array(el)
            , ef = Array(el)
            , em = Array(el)
            , eg = Array(el)
            , ey = Array(el)
            , eb = eo.words;
          eb.length = el,
            this.convert13b(J.words, J.length, eh, el),
            this.convert13b(et.words, et.length, em, el),
            this.transform(eh, ed, ep, ef, el, ec),
            this.transform(em, ed, eg, ey, el, ec);
          for (var ew = 0; ew < el; ew++) {
            var e_ = ep[ew] * eg[ew] - ef[ew] * ey[ew];
            ef[ew] = ep[ew] * ey[ew] + ef[ew] * eg[ew],
              ep[ew] = e_
          }
          return this.conjugate(ep, ef, el),
            this.transform(ep, ef, eb, ed, el, ec),
            this.conjugate(eb, ed, el),
            this.normalize13b(eb, el),
            eo.negative = J.negative ^ et.negative,
            eo.length = J.length + et.length,
            eo._strip()
        }
        ,
        BN.prototype.mul = function (J) {
          var et = new BN(null);
          return et.words = Array(this.length + J.length),
            this.mulTo(J, et)
        }
        ,
        BN.prototype.mulf = function (J) {
          var et = new BN(null);
          return et.words = Array(this.length + J.length),
            bigMulTo(this, J, et)
        }
        ,
        BN.prototype.imul = function (J) {
          return this.clone().mulTo(J, this)
        }
        ,
        BN.prototype.imuln = function (J) {
          var et = J < 0;
          et && (J = -J),
            assert("number" == typeof J),
            assert(J < 67108864);
          for (var eo = 0, el = 0; el < this.length; el++) {
            var ec = (0 | this.words[el]) * J
              , ed = (67108863 & ec) + (67108863 & eo);
            eo >>= 26,
              eo += (ec / 67108864 | 0) + (ed >>> 26),
              this.words[el] = 67108863 & ed
          }
          return 0 !== eo && (this.words[el] = eo,
            this.length++),
            et ? this.ineg() : this
        }
        ,
        BN.prototype.muln = function (J) {
          return this.clone().imuln(J)
        }
        ,
        BN.prototype.sqr = function () {
          return this.mul(this)
        }
        ,
        BN.prototype.isqr = function () {
          return this.imul(this.clone())
        }
        ,
        BN.prototype.pow = function (J) {
          var et = function (J) {
            for (var et = Array(J.bitLength()), eo = 0; eo < et.length; eo++) {
              var el = eo / 26 | 0
                , ec = eo % 26;
              et[eo] = J.words[el] >>> ec & 1
            }
            return et
          }(J);
          if (0 === et.length)
            return new BN(1);
          for (var eo = this, el = 0; el < et.length && 0 === et[el]; el++,
            eo = eo.sqr())
            ;
          if (++el < et.length)
            for (var ec = eo.sqr(); el < et.length; el++,
              ec = ec.sqr())
              0 !== et[el] && (eo = eo.mul(ec));
          return eo
        }
        ,
        BN.prototype.iushln = function (J) {
          assert("number" == typeof J && J >= 0);
          var et, eo = J % 26, el = (J - eo) / 26, ec = 67108863 >>> 26 - eo << 26 - eo;
          if (0 !== eo) {
            var ed = 0;
            for (et = 0; et < this.length; et++) {
              var eh = this.words[et] & ec
                , ep = (0 | this.words[et]) - eh << eo;
              this.words[et] = ep | ed,
                ed = eh >>> 26 - eo
            }
            ed && (this.words[et] = ed,
              this.length++)
          }
          if (0 !== el) {
            for (et = this.length - 1; et >= 0; et--)
              this.words[et + el] = this.words[et];
            for (et = 0; et < el; et++)
              this.words[et] = 0;
            this.length += el
          }
          return this._strip()
        }
        ,
        BN.prototype.ishln = function (J) {
          return assert(0 === this.negative),
            this.iushln(J)
        }
        ,
        BN.prototype.iushrn = function (J, et, eo) {
          assert("number" == typeof J && J >= 0),
            el = et ? (et - et % 26) / 26 : 0;
          var el, ec = J % 26, ed = Math.min((J - ec) / 26, this.length), eh = 67108863 ^ 67108863 >>> ec << ec;
          if (el -= ed,
            el = Math.max(0, el),
            eo) {
            for (var ep = 0; ep < ed; ep++)
              eo.words[ep] = this.words[ep];
            eo.length = ed
          }
          if (0 === ed)
            ;
          else if (this.length > ed)
            for (this.length -= ed,
              ep = 0; ep < this.length; ep++)
              this.words[ep] = this.words[ep + ed];
          else
            this.words[0] = 0,
              this.length = 1;
          var ef = 0;
          for (ep = this.length - 1; ep >= 0 && (0 !== ef || ep >= el); ep--) {
            var em = 0 | this.words[ep];
            this.words[ep] = ef << 26 - ec | em >>> ec,
              ef = em & eh
          }
          return eo && 0 !== ef && (eo.words[eo.length++] = ef),
            0 === this.length && (this.words[0] = 0,
              this.length = 1),
            this._strip()
        }
        ,
        BN.prototype.ishrn = function (J, et, eo) {
          return assert(0 === this.negative),
            this.iushrn(J, et, eo)
        }
        ,
        BN.prototype.shln = function (J) {
          return this.clone().ishln(J)
        }
        ,
        BN.prototype.ushln = function (J) {
          return this.clone().iushln(J)
        }
        ,
        BN.prototype.shrn = function (J) {
          return this.clone().ishrn(J)
        }
        ,
        BN.prototype.ushrn = function (J) {
          return this.clone().iushrn(J)
        }
        ,
        BN.prototype.testn = function (J) {
          assert("number" == typeof J && J >= 0);
          var et = J % 26
            , eo = (J - et) / 26;
          return !(this.length <= eo) && !!(this.words[eo] & 1 << et)
        }
        ,
        BN.prototype.imaskn = function (J) {
          assert("number" == typeof J && J >= 0);
          var et = J % 26
            , eo = (J - et) / 26;
          return (assert(0 === this.negative, "imaskn works only with positive numbers"),
            this.length <= eo) ? this : (0 !== et && eo++,
              this.length = Math.min(eo, this.length),
              0 !== et && (this.words[this.length - 1] &= 67108863 ^ 67108863 >>> et << et),
              this._strip())
        }
        ,
        BN.prototype.maskn = function (J) {
          return this.clone().imaskn(J)
        }
        ,
        BN.prototype.iaddn = function (J) {
          return (assert("number" == typeof J),
            assert(J < 67108864),
            J < 0) ? this.isubn(-J) : 0 !== this.negative ? (1 === this.length && (0 | this.words[0]) <= J ? (this.words[0] = J - (0 | this.words[0]),
              this.negative = 0) : (this.negative = 0,
                this.isubn(J),
                this.negative = 1),
              this) : this._iaddn(J)
        }
        ,
        BN.prototype._iaddn = function (J) {
          this.words[0] += J;
          for (var et = 0; et < this.length && this.words[et] >= 67108864; et++)
            this.words[et] -= 67108864,
              et === this.length - 1 ? this.words[et + 1] = 1 : this.words[et + 1]++;
          return this.length = Math.max(this.length, et + 1),
            this
        }
        ,
        BN.prototype.isubn = function (J) {
          if (assert("number" == typeof J),
            assert(J < 67108864),
            J < 0)
            return this.iaddn(-J);
          if (0 !== this.negative)
            return this.negative = 0,
              this.iaddn(J),
              this.negative = 1,
              this;
          if (this.words[0] -= J,
            1 === this.length && this.words[0] < 0)
            this.words[0] = -this.words[0],
              this.negative = 1;
          else
            for (var et = 0; et < this.length && this.words[et] < 0; et++)
              this.words[et] += 67108864,
                this.words[et + 1] -= 1;
          return this._strip()
        }
        ,
        BN.prototype.addn = function (J) {
          return this.clone().iaddn(J)
        }
        ,
        BN.prototype.subn = function (J) {
          return this.clone().isubn(J)
        }
        ,
        BN.prototype.iabs = function () {
          return this.negative = 0,
            this
        }
        ,
        BN.prototype.abs = function () {
          return this.clone().iabs()
        }
        ,
        BN.prototype._ishlnsubmul = function (J, et, eo) {
          var el, ec, ed = J.length + eo;
          this._expand(ed);
          var eh = 0;
          for (el = 0; el < J.length; el++) {
            ec = (0 | this.words[el + eo]) + eh;
            var ep = (0 | J.words[el]) * et;
            ec -= 67108863 & ep,
              eh = (ec >> 26) - (ep / 67108864 | 0),
              this.words[el + eo] = 67108863 & ec
          }
          for (; el < this.length - eo; el++)
            eh = (ec = (0 | this.words[el + eo]) + eh) >> 26,
              this.words[el + eo] = 67108863 & ec;
          if (0 === eh)
            return this._strip();
          for (assert(-1 === eh),
            eh = 0,
            el = 0; el < this.length; el++)
            eh = (ec = -(0 | this.words[el]) + eh) >> 26,
              this.words[el] = 67108863 & ec;
          return this.negative = 1,
            this._strip()
        }
        ,
        BN.prototype._wordDiv = function (J, et) {
          var eo, el = this.length - J.length, ec = this.clone(), ed = J, eh = 0 | ed.words[ed.length - 1];
          0 != (el = 26 - this._countBits(eh)) && (ed = ed.ushln(el),
            ec.iushln(el),
            eh = 0 | ed.words[ed.length - 1]);
          var ep = ec.length - ed.length;
          if ("mod" !== et) {
            (eo = new BN(null)).length = ep + 1,
              eo.words = Array(eo.length);
            for (var ef = 0; ef < eo.length; ef++)
              eo.words[ef] = 0
          }
          var em = ec.clone()._ishlnsubmul(ed, 1, ep);
          0 === em.negative && (ec = em,
            eo && (eo.words[ep] = 1));
          for (var eg = ep - 1; eg >= 0; eg--) {
            var ey = (0 | ec.words[ed.length + eg]) * 67108864 + (0 | ec.words[ed.length + eg - 1]);
            for (ey = Math.min(ey / eh | 0, 67108863),
              ec._ishlnsubmul(ed, ey, eg); 0 !== ec.negative;)
              ey--,
                ec.negative = 0,
                ec._ishlnsubmul(ed, 1, eg),
                ec.isZero() || (ec.negative ^= 1);
            eo && (eo.words[eg] = ey)
          }
          return eo && eo._strip(),
            ec._strip(),
            "div" !== et && 0 !== el && ec.iushrn(el),
          {
            div: eo || null,
            mod: ec
          }
        }
        ,
        BN.prototype.divmod = function (J, et, eo) {
          var el, ec, ed;
          return (assert(!J.isZero()),
            this.isZero()) ? {
            div: new BN(0),
            mod: new BN(0)
          } : 0 !== this.negative && 0 === J.negative ? (ed = this.neg().divmod(J, et),
            "mod" !== et && (el = ed.div.neg()),
            "div" !== et && (ec = ed.mod.neg(),
              eo && 0 !== ec.negative && ec.iadd(J)),
          {
            div: el,
            mod: ec
          }) : 0 === this.negative && 0 !== J.negative ? (ed = this.divmod(J.neg(), et),
            "mod" !== et && (el = ed.div.neg()),
          {
            div: el,
            mod: ed.mod
          }) : (this.negative & J.negative) != 0 ? (ed = this.neg().divmod(J.neg(), et),
            "div" !== et && (ec = ed.mod.neg(),
              eo && 0 !== ec.negative && ec.isub(J)),
          {
            div: ed.div,
            mod: ec
          }) : J.length > this.length || 0 > this.cmp(J) ? {
            div: new BN(0),
            mod: this
          } : 1 === J.length ? "div" === et ? {
            div: this.divn(J.words[0]),
            mod: null
          } : "mod" === et ? {
            div: null,
            mod: new BN(this.modrn(J.words[0]))
          } : {
            div: this.divn(J.words[0]),
            mod: new BN(this.modrn(J.words[0]))
          } : this._wordDiv(J, et)
        }
        ,
        BN.prototype.div = function (J) {
          return this.divmod(J, "div", !1).div
        }
        ,
        BN.prototype.mod = function (J) {
          return this.divmod(J, "mod", !1).mod
        }
        ,
        BN.prototype.umod = function (J) {
          return this.divmod(J, "mod", !0).mod
        }
        ,
        BN.prototype.divRound = function (J) {
          var et = this.divmod(J);
          if (et.mod.isZero())
            return et.div;
          var eo = 0 !== et.div.negative ? et.mod.isub(J) : et.mod
            , el = J.ushrn(1)
            , ec = J.andln(1)
            , ed = eo.cmp(el);
          return ed < 0 || 1 === ec && 0 === ed ? et.div : 0 !== et.div.negative ? et.div.isubn(1) : et.div.iaddn(1)
        }
        ,
        BN.prototype.modrn = function (J) {
          var et = J < 0;
          et && (J = -J),
            assert(J <= 67108863);
          for (var eo = 67108864 % J, el = 0, ec = this.length - 1; ec >= 0; ec--)
            el = (eo * el + (0 | this.words[ec])) % J;
          return et ? -el : el
        }
        ,
        BN.prototype.modn = function (J) {
          return this.modrn(J)
        }
        ,
        BN.prototype.idivn = function (J) {
          var et = J < 0;
          et && (J = -J),
            assert(J <= 67108863);
          for (var eo = 0, el = this.length - 1; el >= 0; el--) {
            var ec = (0 | this.words[el]) + 67108864 * eo;
            this.words[el] = ec / J | 0,
              eo = ec % J
          }
          return this._strip(),
            et ? this.ineg() : this
        }
        ,
        BN.prototype.divn = function (J) {
          return this.clone().idivn(J)
        }
        ,
        BN.prototype.egcd = function (J) {
          assert(0 === J.negative),
            assert(!J.isZero());
          var et = this
            , eo = J.clone();
          et = 0 !== et.negative ? et.umod(J) : et.clone();
          for (var el = new BN(1), ec = new BN(0), ed = new BN(0), eh = new BN(1), ep = 0; et.isEven() && eo.isEven();)
            et.iushrn(1),
              eo.iushrn(1),
              ++ep;
          for (var ef = eo.clone(), em = et.clone(); !et.isZero();) {
            for (var eg = 0, ey = 1; (et.words[0] & ey) == 0 && eg < 26; ++eg,
              ey <<= 1)
              ;
            if (eg > 0)
              for (et.iushrn(eg); eg-- > 0;)
                (el.isOdd() || ec.isOdd()) && (el.iadd(ef),
                  ec.isub(em)),
                  el.iushrn(1),
                  ec.iushrn(1);
            for (var eb = 0, ew = 1; (eo.words[0] & ew) == 0 && eb < 26; ++eb,
              ew <<= 1)
              ;
            if (eb > 0)
              for (eo.iushrn(eb); eb-- > 0;)
                (ed.isOdd() || eh.isOdd()) && (ed.iadd(ef),
                  eh.isub(em)),
                  ed.iushrn(1),
                  eh.iushrn(1);
            et.cmp(eo) >= 0 ? (et.isub(eo),
              el.isub(ed),
              ec.isub(eh)) : (eo.isub(et),
                ed.isub(el),
                eh.isub(ec))
          }
          return {
            a: ed,
            b: eh,
            gcd: eo.iushln(ep)
          }
        }
        ,
        BN.prototype._invmp = function (J) {
          assert(0 === J.negative),
            assert(!J.isZero());
          var et, eo = this, el = J.clone();
          eo = 0 !== eo.negative ? eo.umod(J) : eo.clone();
          for (var ec = new BN(1), ed = new BN(0), eh = el.clone(); eo.cmpn(1) > 0 && el.cmpn(1) > 0;) {
            for (var ep = 0, ef = 1; (eo.words[0] & ef) == 0 && ep < 26; ++ep,
              ef <<= 1)
              ;
            if (ep > 0)
              for (eo.iushrn(ep); ep-- > 0;)
                ec.isOdd() && ec.iadd(eh),
                  ec.iushrn(1);
            for (var em = 0, eg = 1; (el.words[0] & eg) == 0 && em < 26; ++em,
              eg <<= 1)
              ;
            if (em > 0)
              for (el.iushrn(em); em-- > 0;)
                ed.isOdd() && ed.iadd(eh),
                  ed.iushrn(1);
            eo.cmp(el) >= 0 ? (eo.isub(el),
              ec.isub(ed)) : (el.isub(eo),
                ed.isub(ec))
          }
          return 0 > (et = 0 === eo.cmpn(1) ? ec : ed).cmpn(0) && et.iadd(J),
            et
        }
        ,
        BN.prototype.gcd = function (J) {
          if (this.isZero())
            return J.abs();
          if (J.isZero())
            return this.abs();
          var et = this.clone()
            , eo = J.clone();
          et.negative = 0,
            eo.negative = 0;
          for (var el = 0; et.isEven() && eo.isEven(); el++)
            et.iushrn(1),
              eo.iushrn(1);
          for (; ;) {
            for (; et.isEven();)
              et.iushrn(1);
            for (; eo.isEven();)
              eo.iushrn(1);
            var ec = et.cmp(eo);
            if (ec < 0) {
              var ed = et;
              et = eo,
                eo = ed
            } else if (0 === ec || 0 === eo.cmpn(1))
              break;
            et.isub(eo)
          }
          return eo.iushln(el)
        }
        ,
        BN.prototype.invm = function (J) {
          return this.egcd(J).a.umod(J)
        }
        ,
        BN.prototype.isEven = function () {
          return (1 & this.words[0]) == 0
        }
        ,
        BN.prototype.isOdd = function () {
          return (1 & this.words[0]) == 1
        }
        ,
        BN.prototype.andln = function (J) {
          return this.words[0] & J
        }
        ,
        BN.prototype.bincn = function (J) {
          assert("number" == typeof J);
          var et = J % 26
            , eo = (J - et) / 26
            , el = 1 << et;
          if (this.length <= eo)
            return this._expand(eo + 1),
              this.words[eo] |= el,
              this;
          for (var ec = el, ed = eo; 0 !== ec && ed < this.length; ed++) {
            var eh = 0 | this.words[ed];
            eh += ec,
              ec = eh >>> 26,
              eh &= 67108863,
              this.words[ed] = eh
          }
          return 0 !== ec && (this.words[ed] = ec,
            this.length++),
            this
        }
        ,
        BN.prototype.isZero = function () {
          return 1 === this.length && 0 === this.words[0]
        }
        ,
        BN.prototype.cmpn = function (J) {
          var et, eo = J < 0;
          if (0 !== this.negative && !eo)
            return -1;
          if (0 === this.negative && eo)
            return 1;
          if (this._strip(),
            this.length > 1)
            et = 1;
          else {
            eo && (J = -J),
              assert(J <= 67108863, "Number is too big");
            var el = 0 | this.words[0];
            et = el === J ? 0 : el < J ? -1 : 1
          }
          return 0 !== this.negative ? 0 | -et : et
        }
        ,
        BN.prototype.cmp = function (J) {
          if (0 !== this.negative && 0 === J.negative)
            return -1;
          if (0 === this.negative && 0 !== J.negative)
            return 1;
          var et = this.ucmp(J);
          return 0 !== this.negative ? 0 | -et : et
        }
        ,
        BN.prototype.ucmp = function (J) {
          if (this.length > J.length)
            return 1;
          if (this.length < J.length)
            return -1;
          for (var et = 0, eo = this.length - 1; eo >= 0; eo--) {
            var el = 0 | this.words[eo]
              , ec = 0 | J.words[eo];
            if (el !== ec) {
              el < ec ? et = -1 : el > ec && (et = 1);
              break
            }
          }
          return et
        }
        ,
        BN.prototype.gtn = function (J) {
          return 1 === this.cmpn(J)
        }
        ,
        BN.prototype.gt = function (J) {
          return 1 === this.cmp(J)
        }
        ,
        BN.prototype.gten = function (J) {
          return this.cmpn(J) >= 0
        }
        ,
        BN.prototype.gte = function (J) {
          return this.cmp(J) >= 0
        }
        ,
        BN.prototype.ltn = function (J) {
          return -1 === this.cmpn(J)
        }
        ,
        BN.prototype.lt = function (J) {
          return -1 === this.cmp(J)
        }
        ,
        BN.prototype.lten = function (J) {
          return 0 >= this.cmpn(J)
        }
        ,
        BN.prototype.lte = function (J) {
          return 0 >= this.cmp(J)
        }
        ,
        BN.prototype.eqn = function (J) {
          return 0 === this.cmpn(J)
        }
        ,
        BN.prototype.eq = function (J) {
          return 0 === this.cmp(J)
        }
        ,
        BN.red = function (J) {
          return new Red(J)
        }
        ,
        BN.prototype.toRed = function (J) {
          return assert(!this.red, "Already a number in reduction context"),
            assert(0 === this.negative, "red works only with positives"),
            J.convertTo(this)._forceRed(J)
        }
        ,
        BN.prototype.fromRed = function () {
          return assert(this.red, "fromRed works only with numbers in reduction context"),
            this.red.convertFrom(this)
        }
        ,
        BN.prototype._forceRed = function (J) {
          return this.red = J,
            this
        }
        ,
        BN.prototype.forceRed = function (J) {
          return assert(!this.red, "Already a number in reduction context"),
            this._forceRed(J)
        }
        ,
        BN.prototype.redAdd = function (J) {
          return assert(this.red, "redAdd works only with red numbers"),
            this.red.add(this, J)
        }
        ,
        BN.prototype.redIAdd = function (J) {
          return assert(this.red, "redIAdd works only with red numbers"),
            this.red.iadd(this, J)
        }
        ,
        BN.prototype.redSub = function (J) {
          return assert(this.red, "redSub works only with red numbers"),
            this.red.sub(this, J)
        }
        ,
        BN.prototype.redISub = function (J) {
          return assert(this.red, "redISub works only with red numbers"),
            this.red.isub(this, J)
        }
        ,
        BN.prototype.redShl = function (J) {
          return assert(this.red, "redShl works only with red numbers"),
            this.red.shl(this, J)
        }
        ,
        BN.prototype.redMul = function (J) {
          return assert(this.red, "redMul works only with red numbers"),
            this.red._verify2(this, J),
            this.red.mul(this, J)
        }
        ,
        BN.prototype.redIMul = function (J) {
          return assert(this.red, "redMul works only with red numbers"),
            this.red._verify2(this, J),
            this.red.imul(this, J)
        }
        ,
        BN.prototype.redSqr = function () {
          return assert(this.red, "redSqr works only with red numbers"),
            this.red._verify1(this),
            this.red.sqr(this)
        }
        ,
        BN.prototype.redISqr = function () {
          return assert(this.red, "redISqr works only with red numbers"),
            this.red._verify1(this),
            this.red.isqr(this)
        }
        ,
        BN.prototype.redSqrt = function () {
          return assert(this.red, "redSqrt works only with red numbers"),
            this.red._verify1(this),
            this.red.sqrt(this)
        }
        ,
        BN.prototype.redInvm = function () {
          return assert(this.red, "redInvm works only with red numbers"),
            this.red._verify1(this),
            this.red.invm(this)
        }
        ,
        BN.prototype.redNeg = function () {
          return assert(this.red, "redNeg works only with red numbers"),
            this.red._verify1(this),
            this.red.neg(this)
        }
        ,
        BN.prototype.redPow = function (J) {
          return assert(this.red && !J.red, "redPow(normalNum)"),
            this.red._verify1(this),
            this.red.pow(this, J)
        }
        ;
      var ep = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(J, et) {
        this.name = J,
          this.p = new BN(et, 16),
          this.n = this.p.bitLength(),
          this.k = new BN(1).iushln(this.n).isub(this.p),
          this.tmp = this._tmp()
      }
      function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
      }
      function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
      }
      function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
      }
      function P25519() {
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
      }
      function Red(J) {
        if ("string" == typeof J) {
          var et = BN._prime(J);
          this.m = et.p,
            this.prime = et
        } else
          assert(J.gtn(1), "modulus must be greater than 1"),
            this.m = J,
            this.prime = null
      }
      function Mont(J) {
        Red.call(this, J),
          this.shift = this.m.bitLength(),
          this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26),
          this.r = new BN(1).iushln(this.shift),
          this.r2 = this.imod(this.r.sqr()),
          this.rinv = this.r._invmp(this.m),
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m),
          this.minv = this.minv.umod(this.r),
          this.minv = this.r.sub(this.minv)
      }
      MPrime.prototype._tmp = function () {
        var J = new BN(null);
        return J.words = Array(Math.ceil(this.n / 13)),
          J
      }
        ,
        MPrime.prototype.ireduce = function (J) {
          var et, eo = J;
          do
            this.split(eo, this.tmp),
              et = (eo = (eo = this.imulK(eo)).iadd(this.tmp)).bitLength();
          while (et > this.n);
          var el = et < this.n ? -1 : eo.ucmp(this.p);
          return 0 === el ? (eo.words[0] = 0,
            eo.length = 1) : el > 0 ? eo.isub(this.p) : void 0 !== eo.strip ? eo.strip() : eo._strip(),
            eo
        }
        ,
        MPrime.prototype.split = function (J, et) {
          J.iushrn(this.n, 0, et)
        }
        ,
        MPrime.prototype.imulK = function (J) {
          return J.imul(this.k)
        }
        ,
        inherits(K256, MPrime),
        K256.prototype.split = function (J, et) {
          for (var eo = Math.min(J.length, 9), el = 0; el < eo; el++)
            et.words[el] = J.words[el];
          if (et.length = eo,
            J.length <= 9) {
            J.words[0] = 0,
              J.length = 1;
            return
          }
          var ec = J.words[9];
          for (el = 10,
            et.words[et.length++] = 4194303 & ec; el < J.length; el++) {
            var ed = 0 | J.words[el];
            J.words[el - 10] = (4194303 & ed) << 4 | ec >>> 22,
              ec = ed
          }
          ec >>>= 22,
            J.words[el - 10] = ec,
            0 === ec && J.length > 10 ? J.length -= 10 : J.length -= 9
        }
        ,
        K256.prototype.imulK = function (J) {
          J.words[J.length] = 0,
            J.words[J.length + 1] = 0,
            J.length += 2;
          for (var et = 0, eo = 0; eo < J.length; eo++) {
            var el = 0 | J.words[eo];
            et += 977 * el,
              J.words[eo] = 67108863 & et,
              et = 64 * el + (et / 67108864 | 0)
          }
          return 0 === J.words[J.length - 1] && (J.length--,
            0 === J.words[J.length - 1] && J.length--),
            J
        }
        ,
        inherits(P224, MPrime),
        inherits(P192, MPrime),
        inherits(P25519, MPrime),
        P25519.prototype.imulK = function (J) {
          for (var et = 0, eo = 0; eo < J.length; eo++) {
            var el = (0 | J.words[eo]) * 19 + et
              , ec = 67108863 & el;
            el >>>= 26,
              J.words[eo] = ec,
              et = el
          }
          return 0 !== et && (J.words[J.length++] = et),
            J
        }
        ,
        BN._prime = function (J) {
          var et;
          if (ep[J])
            return ep[J];
          if ("k256" === J)
            et = new K256;
          else if ("p224" === J)
            et = new P224;
          else if ("p192" === J)
            et = new P192;
          else if ("p25519" === J)
            et = new P25519;
          else
            throw Error("Unknown prime " + J);
          return ep[J] = et,
            et
        }
        ,
        Red.prototype._verify1 = function (J) {
          assert(0 === J.negative, "red works only with positives"),
            assert(J.red, "red works only with red numbers")
        }
        ,
        Red.prototype._verify2 = function (J, et) {
          assert((J.negative | et.negative) == 0, "red works only with positives"),
            assert(J.red && J.red === et.red, "red works only with red numbers")
        }
        ,
        Red.prototype.imod = function (J) {
          return this.prime ? this.prime.ireduce(J)._forceRed(this) : (move(J, J.umod(this.m)._forceRed(this)),
            J)
        }
        ,
        Red.prototype.neg = function (J) {
          return J.isZero() ? J.clone() : this.m.sub(J)._forceRed(this)
        }
        ,
        Red.prototype.add = function (J, et) {
          this._verify2(J, et);
          var eo = J.add(et);
          return eo.cmp(this.m) >= 0 && eo.isub(this.m),
            eo._forceRed(this)
        }
        ,
        Red.prototype.iadd = function (J, et) {
          this._verify2(J, et);
          var eo = J.iadd(et);
          return eo.cmp(this.m) >= 0 && eo.isub(this.m),
            eo
        }
        ,
        Red.prototype.sub = function (J, et) {
          this._verify2(J, et);
          var eo = J.sub(et);
          return 0 > eo.cmpn(0) && eo.iadd(this.m),
            eo._forceRed(this)
        }
        ,
        Red.prototype.isub = function (J, et) {
          this._verify2(J, et);
          var eo = J.isub(et);
          return 0 > eo.cmpn(0) && eo.iadd(this.m),
            eo
        }
        ,
        Red.prototype.shl = function (J, et) {
          return this._verify1(J),
            this.imod(J.ushln(et))
        }
        ,
        Red.prototype.imul = function (J, et) {
          return this._verify2(J, et),
            this.imod(J.imul(et))
        }
        ,
        Red.prototype.mul = function (J, et) {
          return this._verify2(J, et),
            this.imod(J.mul(et))
        }
        ,
        Red.prototype.isqr = function (J) {
          return this.imul(J, J.clone())
        }
        ,
        Red.prototype.sqr = function (J) {
          return this.mul(J, J)
        }
        ,
        Red.prototype.sqrt = function (J) {
          if (J.isZero())
            return J.clone();
          var et = this.m.andln(3);
          if (assert(et % 2 == 1),
            3 === et) {
            var eo = this.m.add(new BN(1)).iushrn(2);
            return this.pow(J, eo)
          }
          for (var el = this.m.subn(1), ec = 0; !el.isZero() && 0 === el.andln(1);)
            ec++,
              el.iushrn(1);
          assert(!el.isZero());
          var ed = new BN(1).toRed(this)
            , eh = ed.redNeg()
            , ep = this.m.subn(1).iushrn(1)
            , ef = this.m.bitLength();
          for (ef = new BN(2 * ef * ef).toRed(this); 0 !== this.pow(ef, ep).cmp(eh);)
            ef.redIAdd(eh);
          for (var em = this.pow(ef, el), eg = this.pow(J, el.addn(1).iushrn(1)), ey = this.pow(J, el), eb = ec; 0 !== ey.cmp(ed);) {
            for (var ew = ey, e_ = 0; 0 !== ew.cmp(ed); e_++)
              ew = ew.redSqr();
            assert(e_ < eb);
            var ex = this.pow(em, new BN(1).iushln(eb - e_ - 1));
            eg = eg.redMul(ex),
              em = ex.redSqr(),
              ey = ey.redMul(em),
              eb = e_
          }
          return eg
        }
        ,
        Red.prototype.invm = function (J) {
          var et = J._invmp(this.m);
          return 0 !== et.negative ? (et.negative = 0,
            this.imod(et).redNeg()) : this.imod(et)
        }
        ,
        Red.prototype.pow = function (J, et) {
          if (et.isZero())
            return new BN(1).toRed(this);
          if (0 === et.cmpn(1))
            return J.clone();
          var eo = Array(16);
          eo[0] = new BN(1).toRed(this),
            eo[1] = J;
          for (var el = 2; el < eo.length; el++)
            eo[el] = this.mul(eo[el - 1], J);
          var ec = eo[0]
            , ed = 0
            , eh = 0
            , ep = et.bitLength() % 26;
          for (0 === ep && (ep = 26),
            el = et.length - 1; el >= 0; el--) {
            for (var ef = et.words[el], em = ep - 1; em >= 0; em--) {
              var eg = ef >> em & 1;
              if (ec !== eo[0] && (ec = this.sqr(ec)),
                0 === eg && 0 === ed) {
                eh = 0;
                continue
              }
              ed <<= 1,
                ed |= eg,
                (4 == ++eh || 0 === el && 0 === em) && (ec = this.mul(ec, eo[ed]),
                  eh = 0,
                  ed = 0)
            }
            ep = 26
          }
          return ec
        }
        ,
        Red.prototype.convertTo = function (J) {
          var et = J.umod(this.m);
          return et === J ? et.clone() : et
        }
        ,
        Red.prototype.convertFrom = function (J) {
          var et = J.clone();
          return et.red = null,
            et
        }
        ,
        BN.mont = function (J) {
          return new Mont(J)
        }
        ,
        inherits(Mont, Red),
        Mont.prototype.convertTo = function (J) {
          return this.imod(J.ushln(this.shift))
        }
        ,
        Mont.prototype.convertFrom = function (J) {
          var et = this.imod(J.mul(this.rinv));
          return et.red = null,
            et
        }
        ,
        Mont.prototype.imul = function (J, et) {
          if (J.isZero() || et.isZero())
            return J.words[0] = 0,
              J.length = 1,
              J;
          var eo = J.imul(et)
            , el = eo.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
            , ec = eo.isub(el).iushrn(this.shift)
            , ed = ec;
          return ec.cmp(this.m) >= 0 ? ed = ec.isub(this.m) : 0 > ec.cmpn(0) && (ed = ec.iadd(this.m)),
            ed._forceRed(this)
        }
        ,
        Mont.prototype.mul = function (J, et) {
          if (J.isZero() || et.isZero())
            return new BN(0)._forceRed(this);
          var eo = J.mul(et)
            , el = eo.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
            , ec = eo.isub(el).iushrn(this.shift)
            , ed = ec;
          return ec.cmp(this.m) >= 0 ? ed = ec.isub(this.m) : 0 > ec.cmpn(0) && (ed = ec.iadd(this.m)),
            ed._forceRed(this)
        }
        ,
        Mont.prototype.invm = function (J) {
          return this.imod(J._invmp(this.m).mul(this.r2))._forceRed(this)
        }
    }(J = eo.nmd(J), this)
  },
  48764: function (J, et, eo) {
    "use strict";
    /*!
* The buffer module from node.js, for the browser.
*
* @author   Feross Aboukhadijeh <https://feross.org>
* @license  MIT
*/
    let el = eo(79742)
      , ec = eo(80645)
      , ed = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
    function createBuffer(J) {
      if (J > 2147483647)
        throw RangeError('The value "' + J + '" is invalid for option "size"');
      let et = new Uint8Array(J);
      return Object.setPrototypeOf(et, Buffer.prototype),
        et
    }
    function Buffer(J, et, eo) {
      if ("number" == typeof J) {
        if ("string" == typeof et)
          throw TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(J)
      }
      return from(J, et, eo)
    }
    function from(J, et, eo) {
      if ("string" == typeof J)
        return function (J, et) {
          if (("string" != typeof et || "" === et) && (et = "utf8"),
            !Buffer.isEncoding(et))
            throw TypeError("Unknown encoding: " + et);
          let eo = 0 | byteLength(J, et)
            , el = createBuffer(eo)
            , ec = el.write(J, et);
          return ec !== eo && (el = el.slice(0, ec)),
            el
        }(J, et);
      if (ArrayBuffer.isView(J))
        return function (J) {
          if (isInstance(J, Uint8Array)) {
            let et = new Uint8Array(J);
            return fromArrayBuffer(et.buffer, et.byteOffset, et.byteLength)
          }
          return fromArrayLike(J)
        }(J);
      if (null == J)
        throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof J);
      if (isInstance(J, ArrayBuffer) || J && isInstance(J.buffer, ArrayBuffer) || "undefined" != typeof SharedArrayBuffer && (isInstance(J, SharedArrayBuffer) || J && isInstance(J.buffer, SharedArrayBuffer)))
        return fromArrayBuffer(J, et, eo);
      if ("number" == typeof J)
        throw TypeError('The "value" argument must not be of type number. Received type number');
      let el = J.valueOf && J.valueOf();
      if (null != el && el !== J)
        return Buffer.from(el, et, eo);
      let ec = function (J) {
        var et;
        if (Buffer.isBuffer(J)) {
          let et = 0 | checked(J.length)
            , eo = createBuffer(et);
          return 0 === eo.length || J.copy(eo, 0, 0, et),
            eo
        }
        return void 0 !== J.length ? "number" != typeof J.length || (et = J.length) != et ? createBuffer(0) : fromArrayLike(J) : "Buffer" === J.type && Array.isArray(J.data) ? fromArrayLike(J.data) : void 0
      }(J);
      if (ec)
        return ec;
      if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof J[Symbol.toPrimitive])
        return Buffer.from(J[Symbol.toPrimitive]("string"), et, eo);
      throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof J)
    }
    function assertSize(J) {
      if ("number" != typeof J)
        throw TypeError('"size" argument must be of type number');
      if (J < 0)
        throw RangeError('The value "' + J + '" is invalid for option "size"')
    }
    function allocUnsafe(J) {
      return assertSize(J),
        createBuffer(J < 0 ? 0 : 0 | checked(J))
    }
    function fromArrayLike(J) {
      let et = J.length < 0 ? 0 : 0 | checked(J.length)
        , eo = createBuffer(et);
      for (let el = 0; el < et; el += 1)
        eo[el] = 255 & J[el];
      return eo
    }
    function fromArrayBuffer(J, et, eo) {
      let el;
      if (et < 0 || J.byteLength < et)
        throw RangeError('"offset" is outside of buffer bounds');
      if (J.byteLength < et + (eo || 0))
        throw RangeError('"length" is outside of buffer bounds');
      return Object.setPrototypeOf(el = void 0 === et && void 0 === eo ? new Uint8Array(J) : void 0 === eo ? new Uint8Array(J, et) : new Uint8Array(J, et, eo), Buffer.prototype),
        el
    }
    function checked(J) {
      if (J >= 2147483647)
        throw RangeError("Attempt to allocate Buffer larger than maximum size: 0x7fffffff bytes");
      return 0 | J
    }
    function byteLength(J, et) {
      if (Buffer.isBuffer(J))
        return J.length;
      if (ArrayBuffer.isView(J) || isInstance(J, ArrayBuffer))
        return J.byteLength;
      if ("string" != typeof J)
        throw TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof J);
      let eo = J.length
        , el = arguments.length > 2 && !0 === arguments[2];
      if (!el && 0 === eo)
        return 0;
      let ec = !1;
      for (; ;)
        switch (et) {
          case "ascii":
          case "latin1":
          case "binary":
            return eo;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(J).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return 2 * eo;
          case "hex":
            return eo >>> 1;
          case "base64":
            return base64ToBytes(J).length;
          default:
            if (ec)
              return el ? -1 : utf8ToBytes(J).length;
            et = ("" + et).toLowerCase(),
              ec = !0
        }
    }
    function slowToString(J, et, eo) {
      let ec = !1;
      if ((void 0 === et || et < 0) && (et = 0),
        et > this.length || ((void 0 === eo || eo > this.length) && (eo = this.length),
          eo <= 0 || (eo >>>= 0) <= (et >>>= 0)))
        return "";
      for (J || (J = "utf8"); ;)
        switch (J) {
          case "hex":
            return function (J, et, eo) {
              let el = J.length;
              (!et || et < 0) && (et = 0),
                (!eo || eo < 0 || eo > el) && (eo = el);
              let ec = "";
              for (let el = et; el < eo; ++el)
                ec += ef[J[el]];
              return ec
            }(this, et, eo);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, et, eo);
          case "ascii":
            return function (J, et, eo) {
              let el = "";
              eo = Math.min(J.length, eo);
              for (let ec = et; ec < eo; ++ec)
                el += String.fromCharCode(127 & J[ec]);
              return el
            }(this, et, eo);
          case "latin1":
          case "binary":
            return function (J, et, eo) {
              let el = "";
              eo = Math.min(J.length, eo);
              for (let ec = et; ec < eo; ++ec)
                el += String.fromCharCode(J[ec]);
              return el
            }(this, et, eo);
          case "base64":
            var ed, eh;
            return ed = et,
              eh = eo,
              0 === ed && eh === this.length ? el.fromByteArray(this) : el.fromByteArray(this.slice(ed, eh));
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return function (J, et, eo) {
              let el = J.slice(et, eo)
                , ec = "";
              for (let J = 0; J < el.length - 1; J += 2)
                ec += String.fromCharCode(el[J] + 256 * el[J + 1]);
              return ec
            }(this, et, eo);
          default:
            if (ec)
              throw TypeError("Unknown encoding: " + J);
            J = (J + "").toLowerCase(),
              ec = !0
        }
    }
    function swap(J, et, eo) {
      let el = J[et];
      J[et] = J[eo],
        J[eo] = el
    }
    function bidirectionalIndexOf(J, et, eo, el, ec) {
      var ed;
      if (0 === J.length)
        return -1;
      if ("string" == typeof eo ? (el = eo,
        eo = 0) : eo > 2147483647 ? eo = 2147483647 : eo < -2147483648 && (eo = -2147483648),
        (ed = eo = +eo) != ed && (eo = ec ? 0 : J.length - 1),
        eo < 0 && (eo = J.length + eo),
        eo >= J.length) {
        if (ec)
          return -1;
        eo = J.length - 1
      } else if (eo < 0) {
        if (!ec)
          return -1;
        eo = 0
      }
      if ("string" == typeof et && (et = Buffer.from(et, el)),
        Buffer.isBuffer(et))
        return 0 === et.length ? -1 : arrayIndexOf(J, et, eo, el, ec);
      if ("number" == typeof et)
        return (et &= 255,
          "function" == typeof Uint8Array.prototype.indexOf) ? ec ? Uint8Array.prototype.indexOf.call(J, et, eo) : Uint8Array.prototype.lastIndexOf.call(J, et, eo) : arrayIndexOf(J, [et], eo, el, ec);
      throw TypeError("val must be string, number or Buffer")
    }
    function arrayIndexOf(J, et, eo, el, ec) {
      let ed, eh = 1, ep = J.length, ef = et.length;
      if (void 0 !== el && ("ucs2" === (el = String(el).toLowerCase()) || "ucs-2" === el || "utf16le" === el || "utf-16le" === el)) {
        if (J.length < 2 || et.length < 2)
          return -1;
        eh = 2,
          ep /= 2,
          ef /= 2,
          eo /= 2
      }
      function read(J, et) {
        return 1 === eh ? J[et] : J.readUInt16BE(et * eh)
      }
      if (ec) {
        let el = -1;
        for (ed = eo; ed < ep; ed++)
          if (read(J, ed) === read(et, -1 === el ? 0 : ed - el)) {
            if (-1 === el && (el = ed),
              ed - el + 1 === ef)
              return el * eh
          } else
            -1 !== el && (ed -= ed - el),
              el = -1
      } else
        for (eo + ef > ep && (eo = ep - ef),
          ed = eo; ed >= 0; ed--) {
          let eo = !0;
          for (let el = 0; el < ef; el++)
            if (read(J, ed + el) !== read(et, el)) {
              eo = !1;
              break
            }
          if (eo)
            return ed
        }
      return -1
    }
    function utf8Slice(J, et, eo) {
      eo = Math.min(J.length, eo);
      let el = []
        , ec = et;
      for (; ec < eo;) {
        let et = J[ec]
          , ed = null
          , eh = et > 239 ? 4 : et > 223 ? 3 : et > 191 ? 2 : 1;
        if (ec + eh <= eo) {
          let eo, el, ep, ef;
          switch (eh) {
            case 1:
              et < 128 && (ed = et);
              break;
            case 2:
              (192 & (eo = J[ec + 1])) == 128 && (ef = (31 & et) << 6 | 63 & eo) > 127 && (ed = ef);
              break;
            case 3:
              eo = J[ec + 1],
                el = J[ec + 2],
                (192 & eo) == 128 && (192 & el) == 128 && (ef = (15 & et) << 12 | (63 & eo) << 6 | 63 & el) > 2047 && (ef < 55296 || ef > 57343) && (ed = ef);
              break;
            case 4:
              eo = J[ec + 1],
                el = J[ec + 2],
                ep = J[ec + 3],
                (192 & eo) == 128 && (192 & el) == 128 && (192 & ep) == 128 && (ef = (15 & et) << 18 | (63 & eo) << 12 | (63 & el) << 6 | 63 & ep) > 65535 && ef < 1114112 && (ed = ef)
          }
        }
        null === ed ? (ed = 65533,
          eh = 1) : ed > 65535 && (ed -= 65536,
            el.push(ed >>> 10 & 1023 | 55296),
            ed = 56320 | 1023 & ed),
          el.push(ed),
          ec += eh
      }
      return function (J) {
        let et = J.length;
        if (et <= 4096)
          return String.fromCharCode.apply(String, J);
        let eo = ""
          , el = 0;
        for (; el < et;)
          eo += String.fromCharCode.apply(String, J.slice(el, el += 4096));
        return eo
      }(el)
    }
    function checkOffset(J, et, eo) {
      if (J % 1 != 0 || J < 0)
        throw RangeError("offset is not uint");
      if (J + et > eo)
        throw RangeError("Trying to access beyond buffer length")
    }
    function checkInt(J, et, eo, el, ec, ed) {
      if (!Buffer.isBuffer(J))
        throw TypeError('"buffer" argument must be a Buffer instance');
      if (et > ec || et < ed)
        throw RangeError('"value" argument is out of bounds');
      if (eo + el > J.length)
        throw RangeError("Index out of range")
    }
    function wrtBigUInt64LE(J, et, eo, el, ec) {
      checkIntBI(et, el, ec, J, eo, 7);
      let ed = Number(et & BigInt(4294967295));
      J[eo++] = ed,
        ed >>= 8,
        J[eo++] = ed,
        ed >>= 8,
        J[eo++] = ed,
        ed >>= 8,
        J[eo++] = ed;
      let eh = Number(et >> BigInt(32) & BigInt(4294967295));
      return J[eo++] = eh,
        eh >>= 8,
        J[eo++] = eh,
        eh >>= 8,
        J[eo++] = eh,
        eh >>= 8,
        J[eo++] = eh,
        eo
    }
    function wrtBigUInt64BE(J, et, eo, el, ec) {
      checkIntBI(et, el, ec, J, eo, 7);
      let ed = Number(et & BigInt(4294967295));
      J[eo + 7] = ed,
        ed >>= 8,
        J[eo + 6] = ed,
        ed >>= 8,
        J[eo + 5] = ed,
        ed >>= 8,
        J[eo + 4] = ed;
      let eh = Number(et >> BigInt(32) & BigInt(4294967295));
      return J[eo + 3] = eh,
        eh >>= 8,
        J[eo + 2] = eh,
        eh >>= 8,
        J[eo + 1] = eh,
        eh >>= 8,
        J[eo] = eh,
        eo + 8
    }
    function checkIEEE754(J, et, eo, el, ec, ed) {
      if (eo + el > J.length || eo < 0)
        throw RangeError("Index out of range")
    }
    function writeFloat(J, et, eo, el, ed) {
      return et = +et,
        eo >>>= 0,
        ed || checkIEEE754(J, et, eo, 4, 34028234663852886e22, -34028234663852886e22),
        ec.write(J, et, eo, el, 23, 4),
        eo + 4
    }
    function writeDouble(J, et, eo, el, ed) {
      return et = +et,
        eo >>>= 0,
        ed || checkIEEE754(J, et, eo, 8, 17976931348623157e292, -17976931348623157e292),
        ec.write(J, et, eo, el, 52, 8),
        eo + 8
    }
    et.Buffer = Buffer,
      et.SlowBuffer = function (J) {
        return +J != J && (J = 0),
          Buffer.alloc(+J)
      }
      ,
      et.INSPECT_MAX_BYTES = 50,
      et.kMaxLength = 2147483647,
      Buffer.TYPED_ARRAY_SUPPORT = function () {
        try {
          let J = new Uint8Array(1)
            , et = {
              foo: function () {
                return 42
              }
            };
          return Object.setPrototypeOf(et, Uint8Array.prototype),
            Object.setPrototypeOf(J, et),
            42 === J.foo()
        } catch (J) {
          return !1
        }
      }(),
      Buffer.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),
      Object.defineProperty(Buffer.prototype, "parent", {
        enumerable: !0,
        get: function () {
          if (Buffer.isBuffer(this))
            return this.buffer
        }
      }),
      Object.defineProperty(Buffer.prototype, "offset", {
        enumerable: !0,
        get: function () {
          if (Buffer.isBuffer(this))
            return this.byteOffset
        }
      }),
      Buffer.poolSize = 8192,
      Buffer.from = function (J, et, eo) {
        return from(J, et, eo)
      }
      ,
      Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype),
      Object.setPrototypeOf(Buffer, Uint8Array),
      Buffer.alloc = function (J, et, eo) {
        return (assertSize(J),
          J <= 0) ? createBuffer(J) : void 0 !== et ? "string" == typeof eo ? createBuffer(J).fill(et, eo) : createBuffer(J).fill(et) : createBuffer(J)
      }
      ,
      Buffer.allocUnsafe = function (J) {
        return allocUnsafe(J)
      }
      ,
      Buffer.allocUnsafeSlow = function (J) {
        return allocUnsafe(J)
      }
      ,
      Buffer.isBuffer = function (J) {
        return null != J && !0 === J._isBuffer && J !== Buffer.prototype
      }
      ,
      Buffer.compare = function (J, et) {
        if (isInstance(J, Uint8Array) && (J = Buffer.from(J, J.offset, J.byteLength)),
          isInstance(et, Uint8Array) && (et = Buffer.from(et, et.offset, et.byteLength)),
          !Buffer.isBuffer(J) || !Buffer.isBuffer(et))
          throw TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (J === et)
          return 0;
        let eo = J.length
          , el = et.length;
        for (let ec = 0, ed = Math.min(eo, el); ec < ed; ++ec)
          if (J[ec] !== et[ec]) {
            eo = J[ec],
              el = et[ec];
            break
          }
        return eo < el ? -1 : el < eo ? 1 : 0
      }
      ,
      Buffer.isEncoding = function (J) {
        switch (String(J).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return !0;
          default:
            return !1
        }
      }
      ,
      Buffer.concat = function (J, et) {
        let eo;
        if (!Array.isArray(J))
          throw TypeError('"list" argument must be an Array of Buffers');
        if (0 === J.length)
          return Buffer.alloc(0);
        if (void 0 === et)
          for (eo = 0,
            et = 0; eo < J.length; ++eo)
            et += J[eo].length;
        let el = Buffer.allocUnsafe(et)
          , ec = 0;
        for (eo = 0; eo < J.length; ++eo) {
          let et = J[eo];
          if (isInstance(et, Uint8Array))
            ec + et.length > el.length ? (Buffer.isBuffer(et) || (et = Buffer.from(et)),
              et.copy(el, ec)) : Uint8Array.prototype.set.call(el, et, ec);
          else if (Buffer.isBuffer(et))
            et.copy(el, ec);
          else
            throw TypeError('"list" argument must be an Array of Buffers');
          ec += et.length
        }
        return el
      }
      ,
      Buffer.byteLength = byteLength,
      Buffer.prototype._isBuffer = !0,
      Buffer.prototype.swap16 = function () {
        let J = this.length;
        if (J % 2 != 0)
          throw RangeError("Buffer size must be a multiple of 16-bits");
        for (let et = 0; et < J; et += 2)
          swap(this, et, et + 1);
        return this
      }
      ,
      Buffer.prototype.swap32 = function () {
        let J = this.length;
        if (J % 4 != 0)
          throw RangeError("Buffer size must be a multiple of 32-bits");
        for (let et = 0; et < J; et += 4)
          swap(this, et, et + 3),
            swap(this, et + 1, et + 2);
        return this
      }
      ,
      Buffer.prototype.swap64 = function () {
        let J = this.length;
        if (J % 8 != 0)
          throw RangeError("Buffer size must be a multiple of 64-bits");
        for (let et = 0; et < J; et += 8)
          swap(this, et, et + 7),
            swap(this, et + 1, et + 6),
            swap(this, et + 2, et + 5),
            swap(this, et + 3, et + 4);
        return this
      }
      ,
      Buffer.prototype.toString = function () {
        let J = this.length;
        return 0 === J ? "" : 0 == arguments.length ? utf8Slice(this, 0, J) : slowToString.apply(this, arguments)
      }
      ,
      Buffer.prototype.toLocaleString = Buffer.prototype.toString,
      Buffer.prototype.equals = function (J) {
        if (!Buffer.isBuffer(J))
          throw TypeError("Argument must be a Buffer");
        return this === J || 0 === Buffer.compare(this, J)
      }
      ,
      Buffer.prototype.inspect = function () {
        let J = ""
          , eo = et.INSPECT_MAX_BYTES;
        return J = this.toString("hex", 0, eo).replace(/(.{2})/g, "$1 ").trim(),
          this.length > eo && (J += " ... "),
          "<Buffer " + J + ">"
      }
      ,
      ed && (Buffer.prototype[ed] = Buffer.prototype.inspect),
      Buffer.prototype.compare = function (J, et, eo, el, ec) {
        if (isInstance(J, Uint8Array) && (J = Buffer.from(J, J.offset, J.byteLength)),
          !Buffer.isBuffer(J))
          throw TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof J);
        if (void 0 === et && (et = 0),
          void 0 === eo && (eo = J ? J.length : 0),
          void 0 === el && (el = 0),
          void 0 === ec && (ec = this.length),
          et < 0 || eo > J.length || el < 0 || ec > this.length)
          throw RangeError("out of range index");
        if (el >= ec && et >= eo)
          return 0;
        if (el >= ec)
          return -1;
        if (et >= eo)
          return 1;
        if (et >>>= 0,
          eo >>>= 0,
          el >>>= 0,
          ec >>>= 0,
          this === J)
          return 0;
        let ed = ec - el
          , eh = eo - et
          , ep = Math.min(ed, eh)
          , ef = this.slice(el, ec)
          , em = J.slice(et, eo);
        for (let J = 0; J < ep; ++J)
          if (ef[J] !== em[J]) {
            ed = ef[J],
              eh = em[J];
            break
          }
        return ed < eh ? -1 : eh < ed ? 1 : 0
      }
      ,
      Buffer.prototype.includes = function (J, et, eo) {
        return -1 !== this.indexOf(J, et, eo)
      }
      ,
      Buffer.prototype.indexOf = function (J, et, eo) {
        return bidirectionalIndexOf(this, J, et, eo, !0)
      }
      ,
      Buffer.prototype.lastIndexOf = function (J, et, eo) {
        return bidirectionalIndexOf(this, J, et, eo, !1)
      }
      ,
      Buffer.prototype.write = function (J, et, eo, el) {
        var ec, ed, eh, ep, ef, em, eg, ey;
        if (void 0 === et)
          el = "utf8",
            eo = this.length,
            et = 0;
        else if (void 0 === eo && "string" == typeof et)
          el = et,
            eo = this.length,
            et = 0;
        else if (isFinite(et))
          et >>>= 0,
            isFinite(eo) ? (eo >>>= 0,
              void 0 === el && (el = "utf8")) : (el = eo,
                eo = void 0);
        else
          throw Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        let eb = this.length - et;
        if ((void 0 === eo || eo > eb) && (eo = eb),
          J.length > 0 && (eo < 0 || et < 0) || et > this.length)
          throw RangeError("Attempt to write outside buffer bounds");
        el || (el = "utf8");
        let ew = !1;
        for (; ;)
          switch (el) {
            case "hex":
              return function (J, et, eo, el) {
                let ec;
                eo = Number(eo) || 0;
                let ed = J.length - eo;
                el ? (el = Number(el)) > ed && (el = ed) : el = ed;
                let eh = et.length;
                for (el > eh / 2 && (el = eh / 2),
                  ec = 0; ec < el; ++ec) {
                  let el = parseInt(et.substr(2 * ec, 2), 16);
                  if (el != el)
                    break;
                  J[eo + ec] = el
                }
                return ec
              }(this, J, et, eo);
            case "utf8":
            case "utf-8":
              return ec = et,
                ed = eo,
                blitBuffer(utf8ToBytes(J, this.length - ec), this, ec, ed);
            case "ascii":
            case "latin1":
            case "binary":
              return eh = et,
                ep = eo,
                blitBuffer(function (J) {
                  let et = [];
                  for (let eo = 0; eo < J.length; ++eo)
                    et.push(255 & J.charCodeAt(eo));
                  return et
                }(J), this, eh, ep);
            case "base64":
              return ef = et,
                em = eo,
                blitBuffer(base64ToBytes(J), this, ef, em);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return eg = et,
                ey = eo,
                blitBuffer(function (J, et) {
                  let eo, el;
                  let ec = [];
                  for (let ed = 0; ed < J.length && !((et -= 2) < 0); ++ed)
                    el = (eo = J.charCodeAt(ed)) >> 8,
                      ec.push(eo % 256),
                      ec.push(el);
                  return ec
                }(J, this.length - eg), this, eg, ey);
            default:
              if (ew)
                throw TypeError("Unknown encoding: " + el);
              el = ("" + el).toLowerCase(),
                ew = !0
          }
      }
      ,
      Buffer.prototype.toJSON = function () {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        }
      }
      ,
      Buffer.prototype.slice = function (J, et) {
        let eo = this.length;
        J = ~~J,
          et = void 0 === et ? eo : ~~et,
          J < 0 ? (J += eo) < 0 && (J = 0) : J > eo && (J = eo),
          et < 0 ? (et += eo) < 0 && (et = 0) : et > eo && (et = eo),
          et < J && (et = J);
        let el = this.subarray(J, et);
        return Object.setPrototypeOf(el, Buffer.prototype),
          el
      }
      ,
      Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function (J, et, eo) {
        J >>>= 0,
          et >>>= 0,
          eo || checkOffset(J, et, this.length);
        let el = this[J]
          , ec = 1
          , ed = 0;
        for (; ++ed < et && (ec *= 256);)
          el += this[J + ed] * ec;
        return el
      }
      ,
      Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function (J, et, eo) {
        J >>>= 0,
          et >>>= 0,
          eo || checkOffset(J, et, this.length);
        let el = this[J + --et]
          , ec = 1;
        for (; et > 0 && (ec *= 256);)
          el += this[J + --et] * ec;
        return el
      }
      ,
      Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function (J, et) {
        return J >>>= 0,
          et || checkOffset(J, 1, this.length),
          this[J]
      }
      ,
      Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function (J, et) {
        return J >>>= 0,
          et || checkOffset(J, 2, this.length),
          this[J] | this[J + 1] << 8
      }
      ,
      Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function (J, et) {
        return J >>>= 0,
          et || checkOffset(J, 2, this.length),
          this[J] << 8 | this[J + 1]
      }
      ,
      Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function (J, et) {
        return J >>>= 0,
          et || checkOffset(J, 4, this.length),
          (this[J] | this[J + 1] << 8 | this[J + 2] << 16) + 16777216 * this[J + 3]
      }
      ,
      Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function (J, et) {
        return J >>>= 0,
          et || checkOffset(J, 4, this.length),
          16777216 * this[J] + (this[J + 1] << 16 | this[J + 2] << 8 | this[J + 3])
      }
      ,
      Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function (J) {
        validateNumber(J >>>= 0, "offset");
        let et = this[J]
          , eo = this[J + 7];
        (void 0 === et || void 0 === eo) && boundsError(J, this.length - 8);
        let el = et + 256 * this[++J] + 65536 * this[++J] + 16777216 * this[++J]
          , ec = this[++J] + 256 * this[++J] + 65536 * this[++J] + 16777216 * eo;
        return BigInt(el) + (BigInt(ec) << BigInt(32))
      }),
      Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function (J) {
        validateNumber(J >>>= 0, "offset");
        let et = this[J]
          , eo = this[J + 7];
        (void 0 === et || void 0 === eo) && boundsError(J, this.length - 8);
        let el = 16777216 * et + 65536 * this[++J] + 256 * this[++J] + this[++J]
          , ec = 16777216 * this[++J] + 65536 * this[++J] + 256 * this[++J] + eo;
        return (BigInt(el) << BigInt(32)) + BigInt(ec)
      }),
      Buffer.prototype.readIntLE = function (J, et, eo) {
        J >>>= 0,
          et >>>= 0,
          eo || checkOffset(J, et, this.length);
        let el = this[J]
          , ec = 1
          , ed = 0;
        for (; ++ed < et && (ec *= 256);)
          el += this[J + ed] * ec;
        return el >= (ec *= 128) && (el -= Math.pow(2, 8 * et)),
          el
      }
      ,
      Buffer.prototype.readIntBE = function (J, et, eo) {
        J >>>= 0,
          et >>>= 0,
          eo || checkOffset(J, et, this.length);
        let el = et
          , ec = 1
          , ed = this[J + --el];
        for (; el > 0 && (ec *= 256);)
          ed += this[J + --el] * ec;
        return ed >= (ec *= 128) && (ed -= Math.pow(2, 8 * et)),
          ed
      }
      ,
      Buffer.prototype.readInt8 = function (J, et) {
        return (J >>>= 0,
          et || checkOffset(J, 1, this.length),
          128 & this[J]) ? -((255 - this[J] + 1) * 1) : this[J]
      }
      ,
      Buffer.prototype.readInt16LE = function (J, et) {
        J >>>= 0,
          et || checkOffset(J, 2, this.length);
        let eo = this[J] | this[J + 1] << 8;
        return 32768 & eo ? 4294901760 | eo : eo
      }
      ,
      Buffer.prototype.readInt16BE = function (J, et) {
        J >>>= 0,
          et || checkOffset(J, 2, this.length);
        let eo = this[J + 1] | this[J] << 8;
        return 32768 & eo ? 4294901760 | eo : eo
      }
      ,
      Buffer.prototype.readInt32LE = function (J, et) {
        return J >>>= 0,
          et || checkOffset(J, 4, this.length),
          this[J] | this[J + 1] << 8 | this[J + 2] << 16 | this[J + 3] << 24
      }
      ,
      Buffer.prototype.readInt32BE = function (J, et) {
        return J >>>= 0,
          et || checkOffset(J, 4, this.length),
          this[J] << 24 | this[J + 1] << 16 | this[J + 2] << 8 | this[J + 3]
      }
      ,
      Buffer.prototype.readBigInt64LE = defineBigIntMethod(function (J) {
        validateNumber(J >>>= 0, "offset");
        let et = this[J]
          , eo = this[J + 7];
        (void 0 === et || void 0 === eo) && boundsError(J, this.length - 8);
        let el = this[J + 4] + 256 * this[J + 5] + 65536 * this[J + 6] + (eo << 24);
        return (BigInt(el) << BigInt(32)) + BigInt(et + 256 * this[++J] + 65536 * this[++J] + 16777216 * this[++J])
      }),
      Buffer.prototype.readBigInt64BE = defineBigIntMethod(function (J) {
        validateNumber(J >>>= 0, "offset");
        let et = this[J]
          , eo = this[J + 7];
        (void 0 === et || void 0 === eo) && boundsError(J, this.length - 8);
        let el = (et << 24) + 65536 * this[++J] + 256 * this[++J] + this[++J];
        return (BigInt(el) << BigInt(32)) + BigInt(16777216 * this[++J] + 65536 * this[++J] + 256 * this[++J] + eo)
      }),
      Buffer.prototype.readFloatLE = function (J, et) {
        return J >>>= 0,
          et || checkOffset(J, 4, this.length),
          ec.read(this, J, !0, 23, 4)
      }
      ,
      Buffer.prototype.readFloatBE = function (J, et) {
        return J >>>= 0,
          et || checkOffset(J, 4, this.length),
          ec.read(this, J, !1, 23, 4)
      }
      ,
      Buffer.prototype.readDoubleLE = function (J, et) {
        return J >>>= 0,
          et || checkOffset(J, 8, this.length),
          ec.read(this, J, !0, 52, 8)
      }
      ,
      Buffer.prototype.readDoubleBE = function (J, et) {
        return J >>>= 0,
          et || checkOffset(J, 8, this.length),
          ec.read(this, J, !1, 52, 8)
      }
      ,
      Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function (J, et, eo, el) {
        if (J = +J,
          et >>>= 0,
          eo >>>= 0,
          !el) {
          let el = Math.pow(2, 8 * eo) - 1;
          checkInt(this, J, et, eo, el, 0)
        }
        let ec = 1
          , ed = 0;
        for (this[et] = 255 & J; ++ed < eo && (ec *= 256);)
          this[et + ed] = J / ec & 255;
        return et + eo
      }
      ,
      Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function (J, et, eo, el) {
        if (J = +J,
          et >>>= 0,
          eo >>>= 0,
          !el) {
          let el = Math.pow(2, 8 * eo) - 1;
          checkInt(this, J, et, eo, el, 0)
        }
        let ec = eo - 1
          , ed = 1;
        for (this[et + ec] = 255 & J; --ec >= 0 && (ed *= 256);)
          this[et + ec] = J / ed & 255;
        return et + eo
      }
      ,
      Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function (J, et, eo) {
        return J = +J,
          et >>>= 0,
          eo || checkInt(this, J, et, 1, 255, 0),
          this[et] = 255 & J,
          et + 1
      }
      ,
      Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function (J, et, eo) {
        return J = +J,
          et >>>= 0,
          eo || checkInt(this, J, et, 2, 65535, 0),
          this[et] = 255 & J,
          this[et + 1] = J >>> 8,
          et + 2
      }
      ,
      Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function (J, et, eo) {
        return J = +J,
          et >>>= 0,
          eo || checkInt(this, J, et, 2, 65535, 0),
          this[et] = J >>> 8,
          this[et + 1] = 255 & J,
          et + 2
      }
      ,
      Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function (J, et, eo) {
        return J = +J,
          et >>>= 0,
          eo || checkInt(this, J, et, 4, 4294967295, 0),
          this[et + 3] = J >>> 24,
          this[et + 2] = J >>> 16,
          this[et + 1] = J >>> 8,
          this[et] = 255 & J,
          et + 4
      }
      ,
      Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function (J, et, eo) {
        return J = +J,
          et >>>= 0,
          eo || checkInt(this, J, et, 4, 4294967295, 0),
          this[et] = J >>> 24,
          this[et + 1] = J >>> 16,
          this[et + 2] = J >>> 8,
          this[et + 3] = 255 & J,
          et + 4
      }
      ,
      Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function (J, et = 0) {
        return wrtBigUInt64LE(this, J, et, BigInt(0), BigInt("0xffffffffffffffff"))
      }),
      Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function (J, et = 0) {
        return wrtBigUInt64BE(this, J, et, BigInt(0), BigInt("0xffffffffffffffff"))
      }),
      Buffer.prototype.writeIntLE = function (J, et, eo, el) {
        if (J = +J,
          et >>>= 0,
          !el) {
          let el = Math.pow(2, 8 * eo - 1);
          checkInt(this, J, et, eo, el - 1, -el)
        }
        let ec = 0
          , ed = 1
          , eh = 0;
        for (this[et] = 255 & J; ++ec < eo && (ed *= 256);)
          J < 0 && 0 === eh && 0 !== this[et + ec - 1] && (eh = 1),
            this[et + ec] = (J / ed >> 0) - eh & 255;
        return et + eo
      }
      ,
      Buffer.prototype.writeIntBE = function (J, et, eo, el) {
        if (J = +J,
          et >>>= 0,
          !el) {
          let el = Math.pow(2, 8 * eo - 1);
          checkInt(this, J, et, eo, el - 1, -el)
        }
        let ec = eo - 1
          , ed = 1
          , eh = 0;
        for (this[et + ec] = 255 & J; --ec >= 0 && (ed *= 256);)
          J < 0 && 0 === eh && 0 !== this[et + ec + 1] && (eh = 1),
            this[et + ec] = (J / ed >> 0) - eh & 255;
        return et + eo
      }
      ,
      Buffer.prototype.writeInt8 = function (J, et, eo) {
        return J = +J,
          et >>>= 0,
          eo || checkInt(this, J, et, 1, 127, -128),
          J < 0 && (J = 255 + J + 1),
          this[et] = 255 & J,
          et + 1
      }
      ,
      Buffer.prototype.writeInt16LE = function (J, et, eo) {
        return J = +J,
          et >>>= 0,
          eo || checkInt(this, J, et, 2, 32767, -32768),
          this[et] = 255 & J,
          this[et + 1] = J >>> 8,
          et + 2
      }
      ,
      Buffer.prototype.writeInt16BE = function (J, et, eo) {
        return J = +J,
          et >>>= 0,
          eo || checkInt(this, J, et, 2, 32767, -32768),
          this[et] = J >>> 8,
          this[et + 1] = 255 & J,
          et + 2
      }
      ,
      Buffer.prototype.writeInt32LE = function (J, et, eo) {
        return J = +J,
          et >>>= 0,
          eo || checkInt(this, J, et, 4, 2147483647, -2147483648),
          this[et] = 255 & J,
          this[et + 1] = J >>> 8,
          this[et + 2] = J >>> 16,
          this[et + 3] = J >>> 24,
          et + 4
      }
      ,
      Buffer.prototype.writeInt32BE = function (J, et, eo) {
        return J = +J,
          et >>>= 0,
          eo || checkInt(this, J, et, 4, 2147483647, -2147483648),
          J < 0 && (J = 4294967295 + J + 1),
          this[et] = J >>> 24,
          this[et + 1] = J >>> 16,
          this[et + 2] = J >>> 8,
          this[et + 3] = 255 & J,
          et + 4
      }
      ,
      Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function (J, et = 0) {
        return wrtBigUInt64LE(this, J, et, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
      }),
      Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function (J, et = 0) {
        return wrtBigUInt64BE(this, J, et, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
      }),
      Buffer.prototype.writeFloatLE = function (J, et, eo) {
        return writeFloat(this, J, et, !0, eo)
      }
      ,
      Buffer.prototype.writeFloatBE = function (J, et, eo) {
        return writeFloat(this, J, et, !1, eo)
      }
      ,
      Buffer.prototype.writeDoubleLE = function (J, et, eo) {
        return writeDouble(this, J, et, !0, eo)
      }
      ,
      Buffer.prototype.writeDoubleBE = function (J, et, eo) {
        return writeDouble(this, J, et, !1, eo)
      }
      ,
      Buffer.prototype.copy = function (J, et, eo, el) {
        if (!Buffer.isBuffer(J))
          throw TypeError("argument should be a Buffer");
        if (eo || (eo = 0),
          el || 0 === el || (el = this.length),
          et >= J.length && (et = J.length),
          et || (et = 0),
          el > 0 && el < eo && (el = eo),
          el === eo || 0 === J.length || 0 === this.length)
          return 0;
        if (et < 0)
          throw RangeError("targetStart out of bounds");
        if (eo < 0 || eo >= this.length)
          throw RangeError("Index out of range");
        if (el < 0)
          throw RangeError("sourceEnd out of bounds");
        el > this.length && (el = this.length),
          J.length - et < el - eo && (el = J.length - et + eo);
        let ec = el - eo;
        return this === J && "function" == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(et, eo, el) : Uint8Array.prototype.set.call(J, this.subarray(eo, el), et),
          ec
      }
      ,
      Buffer.prototype.fill = function (J, et, eo, el) {
        let ec;
        if ("string" == typeof J) {
          if ("string" == typeof et ? (el = et,
            et = 0,
            eo = this.length) : "string" == typeof eo && (el = eo,
              eo = this.length),
            void 0 !== el && "string" != typeof el)
            throw TypeError("encoding must be a string");
          if ("string" == typeof el && !Buffer.isEncoding(el))
            throw TypeError("Unknown encoding: " + el);
          if (1 === J.length) {
            let et = J.charCodeAt(0);
            ("utf8" === el && et < 128 || "latin1" === el) && (J = et)
          }
        } else
          "number" == typeof J ? J &= 255 : "boolean" == typeof J && (J = Number(J));
        if (et < 0 || this.length < et || this.length < eo)
          throw RangeError("Out of range index");
        if (eo <= et)
          return this;
        if (et >>>= 0,
          eo = void 0 === eo ? this.length : eo >>> 0,
          J || (J = 0),
          "number" == typeof J)
          for (ec = et; ec < eo; ++ec)
            this[ec] = J;
        else {
          let ed = Buffer.isBuffer(J) ? J : Buffer.from(J, el)
            , eh = ed.length;
          if (0 === eh)
            throw TypeError('The value "' + J + '" is invalid for argument "value"');
          for (ec = 0; ec < eo - et; ++ec)
            this[ec + et] = ed[ec % eh]
        }
        return this
      }
      ;
    let eh = {};
    function E(J, et, eo) {
      eh[J] = class extends eo {
        constructor() {
          super(),
            Object.defineProperty(this, "message", {
              value: et.apply(this, arguments),
              writable: !0,
              configurable: !0
            }),
            this.name = `${this.name} [${J}]`,
            this.stack,
            delete this.name
        }
        get code() {
          return J
        }
        set code(J) {
          Object.defineProperty(this, "code", {
            configurable: !0,
            enumerable: !0,
            value: J,
            writable: !0
          })
        }
        toString() {
          return `${this.name} [${J}]: ${this.message}`
        }
      }
    }
    function addNumericalSeparator(J) {
      let et = ""
        , eo = J.length
        , el = "-" === J[0] ? 1 : 0;
      for (; eo >= el + 4; eo -= 3)
        et = `_${J.slice(eo - 3, eo)}${et}`;
      return `${J.slice(0, eo)}${et}`
    }
    function checkIntBI(J, et, eo, el, ec, ed) {
      if (J > eo || J < et) {
        let el;
        let ec = "bigint" == typeof et ? "n" : "";
        throw el = ed > 3 ? 0 === et || et === BigInt(0) ? `>= 0${ec} and < 2${ec} ** ${(ed + 1) * 8}${ec}` : `>= -(2${ec} ** ${(ed + 1) * 8 - 1}${ec}) and < 2 ** ${(ed + 1) * 8 - 1}${ec}` : `>= ${et}${ec} and <= ${eo}${ec}`,
        new eh.ERR_OUT_OF_RANGE("value", el, J)
      }
      validateNumber(ec, "offset"),
        (void 0 === el[ec] || void 0 === el[ec + ed]) && boundsError(ec, el.length - (ed + 1))
    }
    function validateNumber(J, et) {
      if ("number" != typeof J)
        throw new eh.ERR_INVALID_ARG_TYPE(et, "number", J)
    }
    function boundsError(J, et, eo) {
      if (Math.floor(J) !== J)
        throw validateNumber(J, eo),
        new eh.ERR_OUT_OF_RANGE(eo || "offset", "an integer", J);
      if (et < 0)
        throw new eh.ERR_BUFFER_OUT_OF_BOUNDS;
      throw new eh.ERR_OUT_OF_RANGE(eo || "offset", `>= ${eo ? 1 : 0} and <= ${et}`, J)
    }
    E("ERR_BUFFER_OUT_OF_BOUNDS", function (J) {
      return J ? `${J} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
    }, RangeError),
      E("ERR_INVALID_ARG_TYPE", function (J, et) {
        return `The "${J}" argument must be of type number. Received type ${typeof et}`
      }, TypeError),
      E("ERR_OUT_OF_RANGE", function (J, et, eo) {
        let el = `The value of "${J}" is out of range.`
          , ec = eo;
        return Number.isInteger(eo) && Math.abs(eo) > 4294967296 ? ec = addNumericalSeparator(String(eo)) : "bigint" == typeof eo && (ec = String(eo),
          (eo > BigInt(2) ** BigInt(32) || eo < -(BigInt(2) ** BigInt(32))) && (ec = addNumericalSeparator(ec)),
          ec += "n"),
          el += ` It must be ${et}. Received ${ec}`
      }, RangeError);
    let ep = /[^+/0-9A-Za-z-_]/g;
    function utf8ToBytes(J, et) {
      let eo;
      et = et || 1 / 0;
      let el = J.length
        , ec = null
        , ed = [];
      for (let eh = 0; eh < el; ++eh) {
        if ((eo = J.charCodeAt(eh)) > 55295 && eo < 57344) {
          if (!ec) {
            if (eo > 56319 || eh + 1 === el) {
              (et -= 3) > -1 && ed.push(239, 191, 189);
              continue
            }
            ec = eo;
            continue
          }
          if (eo < 56320) {
            (et -= 3) > -1 && ed.push(239, 191, 189),
              ec = eo;
            continue
          }
          eo = (ec - 55296 << 10 | eo - 56320) + 65536
        } else
          ec && (et -= 3) > -1 && ed.push(239, 191, 189);
        if (ec = null,
          eo < 128) {
          if ((et -= 1) < 0)
            break;
          ed.push(eo)
        } else if (eo < 2048) {
          if ((et -= 2) < 0)
            break;
          ed.push(eo >> 6 | 192, 63 & eo | 128)
        } else if (eo < 65536) {
          if ((et -= 3) < 0)
            break;
          ed.push(eo >> 12 | 224, eo >> 6 & 63 | 128, 63 & eo | 128)
        } else if (eo < 1114112) {
          if ((et -= 4) < 0)
            break;
          ed.push(eo >> 18 | 240, eo >> 12 & 63 | 128, eo >> 6 & 63 | 128, 63 & eo | 128)
        } else
          throw Error("Invalid code point")
      }
      return ed
    }
    function base64ToBytes(J) {
      return el.toByteArray(function (J) {
        if ((J = (J = J.split("=")[0]).trim().replace(ep, "")).length < 2)
          return "";
        for (; J.length % 4 != 0;)
          J += "=";
        return J
      }(J))
    }
    function blitBuffer(J, et, eo, el) {
      let ec;
      for (ec = 0; ec < el && !(ec + eo >= et.length) && !(ec >= J.length); ++ec)
        et[ec + eo] = J[ec];
      return ec
    }
    function isInstance(J, et) {
      return J instanceof et || null != J && null != J.constructor && null != J.constructor.name && J.constructor.name === et.name
    }
    let ef = function () {
      let J = "0123456789abcdef"
        , et = Array(256);
      for (let eo = 0; eo < 16; ++eo) {
        let el = 16 * eo;
        for (let ec = 0; ec < 16; ++ec)
          et[el + ec] = J[eo] + J[ec]
      }
      return et
    }();
    function defineBigIntMethod(J) {
      return "undefined" == typeof BigInt ? BufferBigIntNotDefined : J
    }
    function BufferBigIntNotDefined() {
      throw Error("BigInt not supported")
    }
  },
  86010: function (J, et, eo) {
    "use strict";
    function clsx() {
      for (var J, et, eo = 0, el = ""; eo < arguments.length;)
        (J = arguments[eo++]) && (et = function r(J) {
          var et, eo, el = "";
          if ("string" == typeof J || "number" == typeof J)
            el += J;
          else if ("object" == typeof J) {
            if (Array.isArray(J))
              for (et = 0; et < J.length; et++)
                J[et] && (eo = r(J[et])) && (el && (el += " "),
                  el += eo);
            else
              for (et in J)
                J[et] && (el && (el += " "),
                  el += et)
          }
          return el
        }(J)) && (el && (el += " "),
          el += et);
      return el
    }
    eo.r(et),
      eo.d(et, {
        clsx: function () {
          return clsx
        }
      }),
      et.default = clsx
  },
  76489: function (J, et) {
    "use strict";
    /*!
* cookie
* Copyright(c) 2012-2014 Roman Shtylman
* Copyright(c) 2015 Douglas Christopher Wilson
* MIT Licensed
*/
    et.parse = function (J, et) {
      if ("string" != typeof J)
        throw TypeError("argument str must be a string");
      for (var el = {}, ec = J.split(";"), ed = (et || {}).decode || eo, eh = 0; eh < ec.length; eh++) {
        var ep = ec[eh]
          , ef = ep.indexOf("=");
        if (!(ef < 0)) {
          var em = ep.substring(0, ef).trim();
          if (void 0 == el[em]) {
            var eg = ep.substring(ef + 1, ep.length).trim();
            '"' === eg[0] && (eg = eg.slice(1, -1)),
              el[em] = function (J, et) {
                try {
                  return et(J)
                } catch (et) {
                  return J
                }
              }(eg, ed)
          }
        }
      }
      return el
    }
      ,
      et.serialize = function (J, et, eo) {
        var ed = eo || {}
          , eh = ed.encode || el;
        if ("function" != typeof eh)
          throw TypeError("option encode is invalid");
        if (!ec.test(J))
          throw TypeError("argument name is invalid");
        var ep = eh(et);
        if (ep && !ec.test(ep))
          throw TypeError("argument val is invalid");
        var ef = J + "=" + ep;
        if (null != ed.maxAge) {
          var em = ed.maxAge - 0;
          if (isNaN(em) || !isFinite(em))
            throw TypeError("option maxAge is invalid");
          ef += "; Max-Age=" + Math.floor(em)
        }
        if (ed.domain) {
          if (!ec.test(ed.domain))
            throw TypeError("option domain is invalid");
          ef += "; Domain=" + ed.domain
        }
        if (ed.path) {
          if (!ec.test(ed.path))
            throw TypeError("option path is invalid");
          ef += "; Path=" + ed.path
        }
        if (ed.expires) {
          if ("function" != typeof ed.expires.toUTCString)
            throw TypeError("option expires is invalid");
          ef += "; Expires=" + ed.expires.toUTCString()
        }
        if (ed.httpOnly && (ef += "; HttpOnly"),
          ed.secure && (ef += "; Secure"),
          ed.sameSite)
          switch ("string" == typeof ed.sameSite ? ed.sameSite.toLowerCase() : ed.sameSite) {
            case !0:
            case "strict":
              ef += "; SameSite=Strict";
              break;
            case "lax":
              ef += "; SameSite=Lax";
              break;
            case "none":
              ef += "; SameSite=None";
              break;
            default:
              throw TypeError("option sameSite is invalid")
          }
        return ef
      }
      ;
    var eo = decodeURIComponent
      , el = encodeURIComponent
      , ec = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/
  },
  47041: function (J, et, eo) {
    "use strict";
    var el = this && this.__assign || function () {
      return (el = Object.assign || function (J) {
        for (var et, eo = 1, el = arguments.length; eo < el; eo++)
          for (var ec in et = arguments[eo])
            Object.prototype.hasOwnProperty.call(et, ec) && (J[ec] = et[ec]);
        return J
      }
      ).apply(this, arguments)
    }
      , ec = this && this.__rest || function (J, et) {
        var eo = {};
        for (var el in J)
          Object.prototype.hasOwnProperty.call(J, el) && 0 > et.indexOf(el) && (eo[el] = J[el]);
        if (null != J && "function" == typeof Object.getOwnPropertySymbols)
          for (var ec = 0, el = Object.getOwnPropertySymbols(J); ec < el.length; ec++)
            0 > et.indexOf(el[ec]) && Object.prototype.propertyIsEnumerable.call(J, el[ec]) && (eo[el[ec]] = J[el[ec]]);
        return eo
      }
      ;
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.checkCookies = et.hasCookie = et.removeCookies = et.deleteCookie = et.setCookies = et.setCookie = et.getCookie = et.getCookies = void 0;
    var ed = eo(76489)
      , isClientSide = function () {
        return "undefined" != typeof window
      }
      , stringify = function (J) {
        void 0 === J && (J = "");
        try {
          var et = JSON.stringify(J);
          return /^[\{\[]/.test(et) ? et : J
        } catch (et) {
          return J
        }
      };
    et.getCookies = function (J) {
      if (J && (et = J.req),
        !isClientSide())
        return et && et.cookies ? et.cookies : et && et.headers && et.headers.cookie ? (0,
          ed.parse)(et.headers.cookie) : {};
      for (var et, eo = {}, el = document.cookie ? document.cookie.split("; ") : [], ec = 0, eh = el.length; ec < eh; ec++) {
        var ep = el[ec].split("=")
          , ef = ep.slice(1).join("=");
        eo[ep[0]] = ef
      }
      return eo
    }
      ,
      et.getCookie = function (J, eo) {
        var el, ec = (0,
          et.getCookies)(eo)[J];
        if (void 0 !== ec)
          return "true" === (el = ec ? ec.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent) : ec) || "false" !== el && ("undefined" !== el ? "null" === el ? null : el : void 0)
      }
      ,
      et.setCookie = function (J, et, eo) {
        if (eo) {
          var eh, ep, ef, em = eo.req, eg = eo.res, ey = ec(eo, ["req", "res"]);
          ep = em,
            ef = eg,
            eh = ey
        }
        var eb = (0,
          ed.serialize)(J, stringify(et), el({
            path: "/"
          }, eh));
        if (isClientSide())
          document.cookie = eb;
        else if (ef && ep) {
          var ew = ef.getHeader("Set-Cookie");
          if (Array.isArray(ew) || (ew = ew ? [String(ew)] : []),
            ef.setHeader("Set-Cookie", ew.concat(eb)),
            ep && ep.cookies) {
            var e_ = ep.cookies;
            "" === et ? delete e_[J] : e_[J] = stringify(et)
          }
          if (ep && ep.headers && ep.headers.cookie) {
            var e_ = (0,
              ed.parse)(ep.headers.cookie);
            "" === et ? delete e_[J] : e_[J] = stringify(et),
              ep.headers.cookie = Object.entries(e_).reduce(function (J, et) {
                return J.concat("".concat(et[0], "=").concat(et[1], ";"))
              }, "")
          }
        }
      }
      ,
      et.setCookies = function (J, eo, el) {
        return console.warn("[WARN]: setCookies was deprecated. It will be deleted in the new version. Use setCookie instead."),
          (0,
            et.setCookie)(J, eo, el)
      }
      ,
      et.deleteCookie = function (J, eo) {
        return (0,
          et.setCookie)(J, "", el(el({}, eo), {
            maxAge: -1
          }))
      }
      ,
      et.removeCookies = function (J, eo) {
        return console.warn("[WARN]: removeCookies was deprecated. It will be deleted in the new version. Use deleteCookie instead."),
          (0,
            et.deleteCookie)(J, eo)
      }
      ,
      et.hasCookie = function (J, eo) {
        return !!J && (0,
          et.getCookies)(eo).hasOwnProperty(J)
      }
      ,
      et.checkCookies = function (J, eo) {
        return console.warn("[WARN]: checkCookies was deprecated. It will be deleted in the new version. Use hasCookie instead."),
          (0,
            et.hasCookie)(J, eo)
      }
  },
  54098: function (J, et) {
    var eo = "undefined" != typeof self ? self : this
      , el = function () {
        function F() {
          this.fetch = !1,
            this.DOMException = eo.DOMException
        }
        return F.prototype = eo,
          new F
      }();
    (function (J) {
      var et = {
        searchParams: "URLSearchParams" in el,
        iterable: "Symbol" in el && "iterator" in Symbol,
        blob: "FileReader" in el && "Blob" in el && function () {
          try {
            return new Blob,
              !0
          } catch (J) {
            return !1
          }
        }(),
        formData: "FormData" in el,
        arrayBuffer: "ArrayBuffer" in el
      };
      if (et.arrayBuffer)
        var eo = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"]
          , ec = ArrayBuffer.isView || function (J) {
            return J && eo.indexOf(Object.prototype.toString.call(J)) > -1
          }
          ;
      function normalizeName(J) {
        if ("string" != typeof J && (J = String(J)),
          /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(J))
          throw TypeError("Invalid character in header field name");
        return J.toLowerCase()
      }
      function normalizeValue(J) {
        return "string" != typeof J && (J = String(J)),
          J
      }
      function iteratorFor(J) {
        var eo = {
          next: function () {
            var et = J.shift();
            return {
              done: void 0 === et,
              value: et
            }
          }
        };
        return et.iterable && (eo[Symbol.iterator] = function () {
          return eo
        }
        ),
          eo
      }
      function Headers(J) {
        this.map = {},
          J instanceof Headers ? J.forEach(function (J, et) {
            this.append(et, J)
          }, this) : Array.isArray(J) ? J.forEach(function (J) {
            this.append(J[0], J[1])
          }, this) : J && Object.getOwnPropertyNames(J).forEach(function (et) {
            this.append(et, J[et])
          }, this)
      }
      function consumed(J) {
        if (J.bodyUsed)
          return Promise.reject(TypeError("Already read"));
        J.bodyUsed = !0
      }
      function fileReaderReady(J) {
        return new Promise(function (et, eo) {
          J.onload = function () {
            et(J.result)
          }
            ,
            J.onerror = function () {
              eo(J.error)
            }
        }
        )
      }
      function readBlobAsArrayBuffer(J) {
        var et = new FileReader
          , eo = fileReaderReady(et);
        return et.readAsArrayBuffer(J),
          eo
      }
      function bufferClone(J) {
        if (J.slice)
          return J.slice(0);
        var et = new Uint8Array(J.byteLength);
        return et.set(new Uint8Array(J)),
          et.buffer
      }
      function Body() {
        return this.bodyUsed = !1,
          this._initBody = function (J) {
            if (this._bodyInit = J,
              J) {
              if ("string" == typeof J)
                this._bodyText = J;
              else if (et.blob && Blob.prototype.isPrototypeOf(J))
                this._bodyBlob = J;
              else if (et.formData && FormData.prototype.isPrototypeOf(J))
                this._bodyFormData = J;
              else if (et.searchParams && URLSearchParams.prototype.isPrototypeOf(J))
                this._bodyText = J.toString();
              else {
                var eo;
                et.arrayBuffer && et.blob && (eo = J) && DataView.prototype.isPrototypeOf(eo) ? (this._bodyArrayBuffer = bufferClone(J.buffer),
                  this._bodyInit = new Blob([this._bodyArrayBuffer])) : et.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(J) || ec(J)) ? this._bodyArrayBuffer = bufferClone(J) : this._bodyText = J = Object.prototype.toString.call(J)
              }
            } else
              this._bodyText = "";
            !this.headers.get("content-type") && ("string" == typeof J ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : et.searchParams && URLSearchParams.prototype.isPrototypeOf(J) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
          }
          ,
          et.blob && (this.blob = function () {
            var J = consumed(this);
            if (J)
              return J;
            if (this._bodyBlob)
              return Promise.resolve(this._bodyBlob);
            if (this._bodyArrayBuffer)
              return Promise.resolve(new Blob([this._bodyArrayBuffer]));
            if (!this._bodyFormData)
              return Promise.resolve(new Blob([this._bodyText]));
            throw Error("could not read FormData body as blob")
          }
            ,
            this.arrayBuffer = function () {
              return this._bodyArrayBuffer ? consumed(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(readBlobAsArrayBuffer)
            }
          ),
          this.text = function () {
            var J, et, eo, el = consumed(this);
            if (el)
              return el;
            if (this._bodyBlob)
              return J = this._bodyBlob,
                eo = fileReaderReady(et = new FileReader),
                et.readAsText(J),
                eo;
            if (this._bodyArrayBuffer)
              return Promise.resolve(function (J) {
                for (var et = new Uint8Array(J), eo = Array(et.length), el = 0; el < et.length; el++)
                  eo[el] = String.fromCharCode(et[el]);
                return eo.join("")
              }(this._bodyArrayBuffer));
            if (!this._bodyFormData)
              return Promise.resolve(this._bodyText);
            throw Error("could not read FormData body as text")
          }
          ,
          et.formData && (this.formData = function () {
            return this.text().then(decode)
          }
          ),
          this.json = function () {
            return this.text().then(JSON.parse)
          }
          ,
          this
      }
      Headers.prototype.append = function (J, et) {
        J = normalizeName(J),
          et = normalizeValue(et);
        var eo = this.map[J];
        this.map[J] = eo ? eo + ", " + et : et
      }
        ,
        Headers.prototype.delete = function (J) {
          delete this.map[normalizeName(J)]
        }
        ,
        Headers.prototype.get = function (J) {
          return J = normalizeName(J),
            this.has(J) ? this.map[J] : null
        }
        ,
        Headers.prototype.has = function (J) {
          return this.map.hasOwnProperty(normalizeName(J))
        }
        ,
        Headers.prototype.set = function (J, et) {
          this.map[normalizeName(J)] = normalizeValue(et)
        }
        ,
        Headers.prototype.forEach = function (J, et) {
          for (var eo in this.map)
            this.map.hasOwnProperty(eo) && J.call(et, this.map[eo], eo, this)
        }
        ,
        Headers.prototype.keys = function () {
          var J = [];
          return this.forEach(function (et, eo) {
            J.push(eo)
          }),
            iteratorFor(J)
        }
        ,
        Headers.prototype.values = function () {
          var J = [];
          return this.forEach(function (et) {
            J.push(et)
          }),
            iteratorFor(J)
        }
        ,
        Headers.prototype.entries = function () {
          var J = [];
          return this.forEach(function (et, eo) {
            J.push([eo, et])
          }),
            iteratorFor(J)
        }
        ,
        et.iterable && (Headers.prototype[Symbol.iterator] = Headers.prototype.entries);
      var ed = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function Request(J, et) {
        var eo, el, ec = (et = et || {}).body;
        if (J instanceof Request) {
          if (J.bodyUsed)
            throw TypeError("Already read");
          this.url = J.url,
            this.credentials = J.credentials,
            et.headers || (this.headers = new Headers(J.headers)),
            this.method = J.method,
            this.mode = J.mode,
            this.signal = J.signal,
            ec || null == J._bodyInit || (ec = J._bodyInit,
              J.bodyUsed = !0)
        } else
          this.url = String(J);
        if (this.credentials = et.credentials || this.credentials || "same-origin",
          (et.headers || !this.headers) && (this.headers = new Headers(et.headers)),
          this.method = (el = (eo = et.method || this.method || "GET").toUpperCase(),
            ed.indexOf(el) > -1 ? el : eo),
          this.mode = et.mode || this.mode || null,
          this.signal = et.signal || this.signal,
          this.referrer = null,
          ("GET" === this.method || "HEAD" === this.method) && ec)
          throw TypeError("Body not allowed for GET or HEAD requests");
        this._initBody(ec)
      }
      function decode(J) {
        var et = new FormData;
        return J.trim().split("&").forEach(function (J) {
          if (J) {
            var eo = J.split("=")
              , el = eo.shift().replace(/\+/g, " ")
              , ec = eo.join("=").replace(/\+/g, " ");
            et.append(decodeURIComponent(el), decodeURIComponent(ec))
          }
        }),
          et
      }
      function Response(J, et) {
        et || (et = {}),
          this.type = "default",
          this.status = void 0 === et.status ? 200 : et.status,
          this.ok = this.status >= 200 && this.status < 300,
          this.statusText = "statusText" in et ? et.statusText : "OK",
          this.headers = new Headers(et.headers),
          this.url = et.url || "",
          this._initBody(J)
      }
      Request.prototype.clone = function () {
        return new Request(this, {
          body: this._bodyInit
        })
      }
        ,
        Body.call(Request.prototype),
        Body.call(Response.prototype),
        Response.prototype.clone = function () {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          })
        }
        ,
        Response.error = function () {
          var J = new Response(null, {
            status: 0,
            statusText: ""
          });
          return J.type = "error",
            J
        }
        ;
      var eh = [301, 302, 303, 307, 308];
      Response.redirect = function (J, et) {
        if (-1 === eh.indexOf(et))
          throw RangeError("Invalid status code");
        return new Response(null, {
          status: et,
          headers: {
            location: J
          }
        })
      }
        ,
        J.DOMException = el.DOMException;
      try {
        new J.DOMException
      } catch (et) {
        J.DOMException = function (J, et) {
          this.message = J,
            this.name = et;
          var eo = Error(J);
          this.stack = eo.stack
        }
          ,
          J.DOMException.prototype = Object.create(Error.prototype),
          J.DOMException.prototype.constructor = J.DOMException
      }
      function fetch(eo, el) {
        return new Promise(function (ec, ed) {
          var eh = new Request(eo, el);
          if (eh.signal && eh.signal.aborted)
            return ed(new J.DOMException("Aborted", "AbortError"));
          var ep = new XMLHttpRequest;
          function abortXhr() {
            ep.abort()
          }
          ep.onload = function () {
            var J, et, eo = {
              status: ep.status,
              statusText: ep.statusText,
              headers: (J = ep.getAllResponseHeaders() || "",
                et = new Headers,
                J.replace(/\r?\n[\t ]+/g, " ").split(/\r?\n/).forEach(function (J) {
                  var eo = J.split(":")
                    , el = eo.shift().trim();
                  if (el) {
                    var ec = eo.join(":").trim();
                    et.append(el, ec)
                  }
                }),
                et)
            };
            eo.url = "responseURL" in ep ? ep.responseURL : eo.headers.get("X-Request-URL");
            var el = "response" in ep ? ep.response : ep.responseText;
            ec(new Response(el, eo))
          }
            ,
            ep.onerror = function () {
              ed(TypeError("Network request failed"))
            }
            ,
            ep.ontimeout = function () {
              ed(TypeError("Network request failed"))
            }
            ,
            ep.onabort = function () {
              ed(new J.DOMException("Aborted", "AbortError"))
            }
            ,
            ep.open(eh.method, eh.url, !0),
            "include" === eh.credentials ? ep.withCredentials = !0 : "omit" === eh.credentials && (ep.withCredentials = !1),
            "responseType" in ep && et.blob && (ep.responseType = "blob"),
            eh.headers.forEach(function (J, et) {
              ep.setRequestHeader(et, J)
            }),
            eh.signal && (eh.signal.addEventListener("abort", abortXhr),
              ep.onreadystatechange = function () {
                4 === ep.readyState && eh.signal.removeEventListener("abort", abortXhr)
              }
            ),
            ep.send(void 0 === eh._bodyInit ? null : eh._bodyInit)
        }
        )
      }
      fetch.polyfill = !0,
        el.fetch || (el.fetch = fetch,
          el.Headers = Headers,
          el.Request = Request,
          el.Response = Response),
        J.Headers = Headers,
        J.Request = Request,
        J.Response = Response,
        J.fetch = fetch,
        Object.defineProperty(J, "__esModule", {
          value: !0
        })
    }
    )({}),
      el.fetch.ponyfill = !0,
      delete el.fetch.polyfill,
      (et = el.fetch).default = el.fetch,
      et.fetch = el.fetch,
      et.Headers = el.Headers,
      et.Request = el.Request,
      et.Response = el.Response,
      J.exports = et
  },
  27484: function (J) {
    var et, eo, el, ec, ed, eh, ep, ef, em, eg, ey, eb, ew, e_, ex, eE, eC, eS, ek, eT, eA, eP;
    J.exports = (et = "millisecond",
      eo = "second",
      el = "minute",
      ec = "hour",
      ed = "week",
      eh = "month",
      ep = "quarter",
      ef = "year",
      em = "date",
      eg = "Invalid Date",
      ey = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
      eb = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
      ew = function (J, et, eo) {
        var el = String(J);
        return !el || el.length >= et ? J : "" + Array(et + 1 - el.length).join(eo) + J
      }
      ,
      (ex = {})[e_ = "en"] = {
        name: "en",
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        ordinal: function (J) {
          var et = ["th", "st", "nd", "rd"]
            , eo = J % 100;
          return "[" + J + (et[(eo - 20) % 10] || et[eo] || "th") + "]"
        }
      },
      eE = "$isDayjsObject",
      eC = function (J) {
        return J instanceof eA || !(!J || !J[eE])
      }
      ,
      eS = function t(J, et, eo) {
        var el;
        if (!J)
          return e_;
        if ("string" == typeof J) {
          var ec = J.toLowerCase();
          ex[ec] && (el = ec),
            et && (ex[ec] = et,
              el = ec);
          var ed = J.split("-");
          if (!el && ed.length > 1)
            return t(ed[0])
        } else {
          var eh = J.name;
          ex[eh] = J,
            el = eh
        }
        return !eo && el && (e_ = el),
          el || !eo && e_
      }
      ,
      ek = function (J, et) {
        if (eC(J))
          return J.clone();
        var eo = "object" == typeof et ? et : {};
        return eo.date = J,
          eo.args = arguments,
          new eA(eo)
      }
      ,
      (eT = {
        s: ew,
        z: function (J) {
          var et = -J.utcOffset()
            , eo = Math.abs(et);
          return (et <= 0 ? "+" : "-") + ew(Math.floor(eo / 60), 2, "0") + ":" + ew(eo % 60, 2, "0")
        },
        m: function t(J, et) {
          if (J.date() < et.date())
            return -t(et, J);
          var eo = 12 * (et.year() - J.year()) + (et.month() - J.month())
            , el = J.clone().add(eo, eh)
            , ec = et - el < 0
            , ed = J.clone().add(eo + (ec ? -1 : 1), eh);
          return +(-(eo + (et - el) / (ec ? el - ed : ed - el)) || 0)
        },
        a: function (J) {
          return J < 0 ? Math.ceil(J) || 0 : Math.floor(J)
        },
        p: function (J) {
          return ({
            M: eh,
            y: ef,
            w: ed,
            d: "day",
            D: em,
            h: ec,
            m: el,
            s: eo,
            ms: et,
            Q: ep
          })[J] || String(J || "").toLowerCase().replace(/s$/, "")
        },
        u: function (J) {
          return void 0 === J
        }
      }).l = eS,
      eT.i = eC,
      eT.w = function (J, et) {
        return ek(J, {
          locale: et.$L,
          utc: et.$u,
          x: et.$x,
          $offset: et.$offset
        })
      }
      ,
      eP = (eA = function () {
        function M(J) {
          this.$L = eS(J.locale, null, !0),
            this.parse(J),
            this.$x = this.$x || J.x || {},
            this[eE] = !0
        }
        var J = M.prototype;
        return J.parse = function (J) {
          this.$d = function (J) {
            var et = J.date
              , eo = J.utc;
            if (null === et)
              return new Date(NaN);
            if (eT.u(et))
              return new Date;
            if (et instanceof Date)
              return new Date(et);
            if ("string" == typeof et && !/Z$/i.test(et)) {
              var el = et.match(ey);
              if (el) {
                var ec = el[2] - 1 || 0
                  , ed = (el[7] || "0").substring(0, 3);
                return eo ? new Date(Date.UTC(el[1], ec, el[3] || 1, el[4] || 0, el[5] || 0, el[6] || 0, ed)) : new Date(el[1], ec, el[3] || 1, el[4] || 0, el[5] || 0, el[6] || 0, ed)
              }
            }
            return new Date(et)
          }(J),
            this.init()
        }
          ,
          J.init = function () {
            var J = this.$d;
            this.$y = J.getFullYear(),
              this.$M = J.getMonth(),
              this.$D = J.getDate(),
              this.$W = J.getDay(),
              this.$H = J.getHours(),
              this.$m = J.getMinutes(),
              this.$s = J.getSeconds(),
              this.$ms = J.getMilliseconds()
          }
          ,
          J.$utils = function () {
            return eT
          }
          ,
          J.isValid = function () {
            return this.$d.toString() !== eg
          }
          ,
          J.isSame = function (J, et) {
            var eo = ek(J);
            return this.startOf(et) <= eo && eo <= this.endOf(et)
          }
          ,
          J.isAfter = function (J, et) {
            return ek(J) < this.startOf(et)
          }
          ,
          J.isBefore = function (J, et) {
            return this.endOf(et) < ek(J)
          }
          ,
          J.$g = function (J, et, eo) {
            return eT.u(J) ? this[et] : this.set(eo, J)
          }
          ,
          J.unix = function () {
            return Math.floor(this.valueOf() / 1e3)
          }
          ,
          J.valueOf = function () {
            return this.$d.getTime()
          }
          ,
          J.startOf = function (J, et) {
            var ep = this
              , eg = !!eT.u(et) || et
              , ey = eT.p(J)
              , l = function (J, et) {
                var eo = eT.w(ep.$u ? Date.UTC(ep.$y, et, J) : new Date(ep.$y, et, J), ep);
                return eg ? eo : eo.endOf("day")
              }
              , $ = function (J, et) {
                return eT.w(ep.toDate()[J].apply(ep.toDate("s"), (eg ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(et)), ep)
              }
              , eb = this.$W
              , ew = this.$M
              , e_ = this.$D
              , ex = "set" + (this.$u ? "UTC" : "");
            switch (ey) {
              case ef:
                return eg ? l(1, 0) : l(31, 11);
              case eh:
                return eg ? l(1, ew) : l(0, ew + 1);
              case ed:
                var eE = this.$locale().weekStart || 0
                  , eC = (eb < eE ? eb + 7 : eb) - eE;
                return l(eg ? e_ - eC : e_ + (6 - eC), ew);
              case "day":
              case em:
                return $(ex + "Hours", 0);
              case ec:
                return $(ex + "Minutes", 1);
              case el:
                return $(ex + "Seconds", 2);
              case eo:
                return $(ex + "Milliseconds", 3);
              default:
                return this.clone()
            }
          }
          ,
          J.endOf = function (J) {
            return this.startOf(J, !1)
          }
          ,
          J.$set = function (J, ed) {
            var ep, eg = eT.p(J), ey = "set" + (this.$u ? "UTC" : ""), eb = ((ep = {}).day = ey + "Date",
              ep[em] = ey + "Date",
              ep[eh] = ey + "Month",
              ep[ef] = ey + "FullYear",
              ep[ec] = ey + "Hours",
              ep[el] = ey + "Minutes",
              ep[eo] = ey + "Seconds",
              ep[et] = ey + "Milliseconds",
              ep)[eg], ew = "day" === eg ? this.$D + (ed - this.$W) : ed;
            if (eg === eh || eg === ef) {
              var e_ = this.clone().set(em, 1);
              e_.$d[eb](ew),
                e_.init(),
                this.$d = e_.set(em, Math.min(this.$D, e_.daysInMonth())).$d
            } else
              eb && this.$d[eb](ew);
            return this.init(),
              this
          }
          ,
          J.set = function (J, et) {
            return this.clone().$set(J, et)
          }
          ,
          J.get = function (J) {
            return this[eT.p(J)]()
          }
          ,
          J.add = function (J, et) {
            var ep, em = this;
            J = Number(J);
            var eg = eT.p(et)
              , y = function (et) {
                var eo = ek(em);
                return eT.w(eo.date(eo.date() + Math.round(et * J)), em)
              };
            if (eg === eh)
              return this.set(eh, this.$M + J);
            if (eg === ef)
              return this.set(ef, this.$y + J);
            if ("day" === eg)
              return y(1);
            if (eg === ed)
              return y(7);
            var ey = ((ep = {})[el] = 6e4,
              ep[ec] = 36e5,
              ep[eo] = 1e3,
              ep)[eg] || 1
              , eb = this.$d.getTime() + J * ey;
            return eT.w(eb, this)
          }
          ,
          J.subtract = function (J, et) {
            return this.add(-1 * J, et)
          }
          ,
          J.format = function (J) {
            var et = this
              , eo = this.$locale();
            if (!this.isValid())
              return eo.invalidDate || eg;
            var el = J || "YYYY-MM-DDTHH:mm:ssZ"
              , ec = eT.z(this)
              , ed = this.$H
              , eh = this.$m
              , ep = this.$M
              , ef = eo.weekdays
              , em = eo.months
              , ey = eo.meridiem
              , h = function (J, eo, ec, ed) {
                return J && (J[eo] || J(et, el)) || ec[eo].slice(0, ed)
              }
              , d = function (J) {
                return eT.s(ed % 12 || 12, J, "0")
              }
              , ew = ey || function (J, et, eo) {
                var el = J < 12 ? "AM" : "PM";
                return eo ? el.toLowerCase() : el
              }
              ;
            return el.replace(eb, function (J, el) {
              return el || function (J) {
                switch (J) {
                  case "YY":
                    return String(et.$y).slice(-2);
                  case "YYYY":
                    return eT.s(et.$y, 4, "0");
                  case "M":
                    return ep + 1;
                  case "MM":
                    return eT.s(ep + 1, 2, "0");
                  case "MMM":
                    return h(eo.monthsShort, ep, em, 3);
                  case "MMMM":
                    return h(em, ep);
                  case "D":
                    return et.$D;
                  case "DD":
                    return eT.s(et.$D, 2, "0");
                  case "d":
                    return String(et.$W);
                  case "dd":
                    return h(eo.weekdaysMin, et.$W, ef, 2);
                  case "ddd":
                    return h(eo.weekdaysShort, et.$W, ef, 3);
                  case "dddd":
                    return ef[et.$W];
                  case "H":
                    return String(ed);
                  case "HH":
                    return eT.s(ed, 2, "0");
                  case "h":
                    return d(1);
                  case "hh":
                    return d(2);
                  case "a":
                    return ew(ed, eh, !0);
                  case "A":
                    return ew(ed, eh, !1);
                  case "m":
                    return String(eh);
                  case "mm":
                    return eT.s(eh, 2, "0");
                  case "s":
                    return String(et.$s);
                  case "ss":
                    return eT.s(et.$s, 2, "0");
                  case "SSS":
                    return eT.s(et.$ms, 3, "0");
                  case "Z":
                    return ec
                }
                return null
              }(J) || ec.replace(":", "")
            })
          }
          ,
          J.utcOffset = function () {
            return -(15 * Math.round(this.$d.getTimezoneOffset() / 15))
          }
          ,
          J.diff = function (J, et, em) {
            var eg, ey = this, eb = eT.p(et), ew = ek(J), e_ = (ew.utcOffset() - this.utcOffset()) * 6e4, ex = this - ew, D = function () {
              return eT.m(ey, ew)
            };
            switch (eb) {
              case ef:
                eg = D() / 12;
                break;
              case eh:
                eg = D();
                break;
              case ep:
                eg = D() / 3;
                break;
              case ed:
                eg = (ex - e_) / 6048e5;
                break;
              case "day":
                eg = (ex - e_) / 864e5;
                break;
              case ec:
                eg = ex / 36e5;
                break;
              case el:
                eg = ex / 6e4;
                break;
              case eo:
                eg = ex / 1e3;
                break;
              default:
                eg = ex
            }
            return em ? eg : eT.a(eg)
          }
          ,
          J.daysInMonth = function () {
            return this.endOf(eh).$D
          }
          ,
          J.$locale = function () {
            return ex[this.$L]
          }
          ,
          J.locale = function (J, et) {
            if (!J)
              return this.$L;
            var eo = this.clone()
              , el = eS(J, et, !0);
            return el && (eo.$L = el),
              eo
          }
          ,
          J.clone = function () {
            return eT.w(this.$d, this)
          }
          ,
          J.toDate = function () {
            return new Date(this.valueOf())
          }
          ,
          J.toJSON = function () {
            return this.isValid() ? this.toISOString() : null
          }
          ,
          J.toISOString = function () {
            return this.$d.toISOString()
          }
          ,
          J.toString = function () {
            return this.$d.toUTCString()
          }
          ,
          M
      }()).prototype,
      ek.prototype = eP,
      [["$ms", et], ["$s", eo], ["$m", el], ["$H", ec], ["$W", "day"], ["$M", eh], ["$y", ef], ["$D", em]].forEach(function (J) {
        eP[J[1]] = function (et) {
          return this.$g(et, J[0], J[1])
        }
      }),
      ek.extend = function (J, et) {
        return J.$i || (J(et, eA, ek),
          J.$i = !0),
          ek
      }
      ,
      ek.locale = eS,
      ek.isDayjs = eC,
      ek.unix = function (J) {
        return ek(1e3 * J)
      }
      ,
      ek.en = ex[e_],
      ek.Ls = ex,
      ek.p = {},
      ek)
  },
  84110: function (J) {
    J.exports = function (J, et, eo) {
      J = J || {};
      var el = et.prototype
        , ec = {
          future: "in %s",
          past: "%s ago",
          s: "a few seconds",
          m: "a minute",
          mm: "%d minutes",
          h: "an hour",
          hh: "%d hours",
          d: "a day",
          dd: "%d days",
          M: "a month",
          MM: "%d months",
          y: "a year",
          yy: "%d years"
        };
      function i(J, et, eo, ec) {
        return el.fromToBase(J, et, eo, ec)
      }
      eo.en.relativeTime = ec,
        el.fromToBase = function (et, el, ed, eh, ep) {
          for (var ef, em, eg, ey = ed.$locale().relativeTime || ec, eb = J.thresholds || [{
            l: "s",
            r: 44,
            d: "second"
          }, {
            l: "m",
            r: 89
          }, {
            l: "mm",
            r: 44,
            d: "minute"
          }, {
            l: "h",
            r: 89
          }, {
            l: "hh",
            r: 21,
            d: "hour"
          }, {
            l: "d",
            r: 35
          }, {
            l: "dd",
            r: 25,
            d: "day"
          }, {
            l: "M",
            r: 45
          }, {
            l: "MM",
            r: 10,
            d: "month"
          }, {
            l: "y",
            r: 17
          }, {
            l: "yy",
            d: "year"
          }], ew = eb.length, e_ = 0; e_ < ew; e_ += 1) {
            var ex = eb[e_];
            ex.d && (ef = eh ? eo(et).diff(ed, ex.d, !0) : ed.diff(et, ex.d, !0));
            var eE = (J.rounding || Math.round)(Math.abs(ef));
            if (eg = ef > 0,
              eE <= ex.r || !ex.r) {
              eE <= 1 && e_ > 0 && (ex = eb[e_ - 1]);
              var eC = ey[ex.l];
              ep && (eE = ep("" + eE)),
                em = "string" == typeof eC ? eC.replace("%d", eE) : eC(eE, el, ex.l, eg);
              break
            }
          }
          if (el)
            return em;
          var eS = eg ? ey.future : ey.past;
          return "function" == typeof eS ? eS(em) : eS.replace("%s", em)
        }
        ,
        el.to = function (J, et) {
          return i(J, et, this, !0)
        }
        ,
        el.from = function (J, et) {
          return i(J, et, this)
        }
        ;
      var d = function (J) {
        return J.$u ? eo.utc() : eo()
      };
      el.toNow = function (J) {
        return this.to(d(this), J)
      }
        ,
        el.fromNow = function (J) {
          return this.from(d(this), J)
        }
    }
  },
  70660: function (J) {
    J.exports = function (J, et, eo) {
      eo.updateLocale = function (J, et) {
        var el = eo.Ls[J];
        if (el)
          return (et ? Object.keys(et) : []).forEach(function (J) {
            el[J] = et[J]
          }),
            el
      }
    }
  },
  11227: function (J, et, eo) {
    let el;
    var ec = eo(83454);
    et.formatArgs = function (et) {
      if (et[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + et[0] + (this.useColors ? "%c " : " ") + "+" + J.exports.humanize(this.diff),
        !this.useColors)
        return;
      let eo = "color: " + this.color;
      et.splice(1, 0, eo, "color: inherit");
      let el = 0
        , ec = 0;
      et[0].replace(/%[a-zA-Z%]/g, J => {
        "%%" !== J && (el++,
          "%c" === J && (ec = el))
      }
      ),
        et.splice(ec, 0, eo)
    }
      ,
      et.save = function (J) {
        try {
          J ? et.storage.setItem("debug", J) : et.storage.removeItem("debug")
        } catch (J) { }
      }
      ,
      et.load = function () {
        let J;
        try {
          J = et.storage.getItem("debug")
        } catch (J) { }
        return !J && void 0 !== ec && "env" in ec && (J = ec.env.DEBUG),
          J
      }
      ,
      et.useColors = function () {
        return "undefined" != typeof window && !!window.process && ("renderer" === window.process.type || !!window.process.__nwjs) || !("undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) && ("undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
      }
      ,
      et.storage = function () {
        try {
          return localStorage
        } catch (J) { }
      }(),
      et.destroy = (el = !1,
        () => {
          el || (el = !0,
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))
        }
      ),
      et.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"],
      et.log = console.debug || console.log || (() => { }
      ),
      J.exports = eo(82447)(et);
    let { formatters: ed } = J.exports;
    ed.j = function (J) {
      try {
        return JSON.stringify(J)
      } catch (J) {
        return "[UnexpectedJSONParseError]: " + J.message
      }
    }
  },
  82447: function (J, et, eo) {
    J.exports = function (J) {
      function createDebug(J) {
        let et, eo, el;
        let ec = null;
        function debug(...J) {
          if (!debug.enabled)
            return;
          let eo = Number(new Date)
            , el = eo - (et || eo);
          debug.diff = el,
            debug.prev = et,
            debug.curr = eo,
            et = eo,
            J[0] = createDebug.coerce(J[0]),
            "string" != typeof J[0] && J.unshift("%O");
          let ec = 0;
          J[0] = J[0].replace(/%([a-zA-Z%])/g, (et, eo) => {
            if ("%%" === et)
              return "%";
            ec++;
            let el = createDebug.formatters[eo];
            if ("function" == typeof el) {
              let eo = J[ec];
              et = el.call(debug, eo),
                J.splice(ec, 1),
                ec--
            }
            return et
          }
          ),
            createDebug.formatArgs.call(debug, J);
          let ed = debug.log || createDebug.log;
          ed.apply(debug, J)
        }
        return debug.namespace = J,
          debug.useColors = createDebug.useColors(),
          debug.color = createDebug.selectColor(J),
          debug.extend = extend,
          debug.destroy = createDebug.destroy,
          Object.defineProperty(debug, "enabled", {
            enumerable: !0,
            configurable: !1,
            get: () => null !== ec ? ec : (eo !== createDebug.namespaces && (eo = createDebug.namespaces,
              el = createDebug.enabled(J)),
              el),
            set: J => {
              ec = J
            }
          }),
          "function" == typeof createDebug.init && createDebug.init(debug),
          debug
      }
      function extend(J, et) {
        let eo = createDebug(this.namespace + (void 0 === et ? ":" : et) + J);
        return eo.log = this.log,
          eo
      }
      function toNamespace(J) {
        return J.toString().substring(2, J.toString().length - 2).replace(/\.\*\?$/, "*")
      }
      return createDebug.debug = createDebug,
        createDebug.default = createDebug,
        createDebug.coerce = function (J) {
          return J instanceof Error ? J.stack || J.message : J
        }
        ,
        createDebug.disable = function () {
          let J = [...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map(J => "-" + J)].join(",");
          return createDebug.enable(""),
            J
        }
        ,
        createDebug.enable = function (J) {
          let et;
          createDebug.save(J),
            createDebug.namespaces = J,
            createDebug.names = [],
            createDebug.skips = [];
          let eo = ("string" == typeof J ? J : "").split(/[\s,]+/)
            , el = eo.length;
          for (et = 0; et < el; et++)
            eo[et] && ("-" === (J = eo[et].replace(/\*/g, ".*?"))[0] ? createDebug.skips.push(RegExp("^" + J.slice(1) + "$")) : createDebug.names.push(RegExp("^" + J + "$")))
        }
        ,
        createDebug.enabled = function (J) {
          let et, eo;
          if ("*" === J[J.length - 1])
            return !0;
          for (et = 0,
            eo = createDebug.skips.length; et < eo; et++)
            if (createDebug.skips[et].test(J))
              return !1;
          for (et = 0,
            eo = createDebug.names.length; et < eo; et++)
            if (createDebug.names[et].test(J))
              return !0;
          return !1
        }
        ,
        createDebug.humanize = eo(57824),
        createDebug.destroy = function () {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")
        }
        ,
        Object.keys(J).forEach(et => {
          createDebug[et] = J[et]
        }
        ),
        createDebug.names = [],
        createDebug.skips = [],
        createDebug.formatters = {},
        createDebug.selectColor = function (J) {
          let et = 0;
          for (let eo = 0; eo < J.length; eo++)
            et = (et << 5) - et + J.charCodeAt(eo) | 0;
          return createDebug.colors[Math.abs(et) % createDebug.colors.length]
        }
        ,
        createDebug.enable(createDebug.load()),
        createDebug
    }
  },
  44020: function (J) {
    "use strict";
    var et = "%[a-f0-9]{2}"
      , eo = RegExp("(" + et + ")|([^%]+?)", "gi")
      , el = RegExp("(" + et + ")+", "gi");
    J.exports = function (J) {
      if ("string" != typeof J)
        throw TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof J + "`");
      try {
        return J = J.replace(/\+/g, " "),
          decodeURIComponent(J)
      } catch (et) {
        return function (J) {
          for (var et = {
            "%FE%FF": "��",
            "%FF%FE": "��"
          }, ec = el.exec(J); ec;) {
            try {
              et[ec[0]] = decodeURIComponent(ec[0])
            } catch (J) {
              var ed = function (J) {
                try {
                  return decodeURIComponent(J)
                } catch (ec) {
                  for (var et = J.match(eo) || [], el = 1; el < et.length; el++)
                    et = (J = (function decodeComponents(J, et) {
                      try {
                        return [decodeURIComponent(J.join(""))]
                      } catch (J) { }
                      if (1 === J.length)
                        return J;
                      et = et || 1;
                      var eo = J.slice(0, et)
                        , el = J.slice(et);
                      return Array.prototype.concat.call([], decodeComponents(eo), decodeComponents(el))
                    }
                    )(et, el).join("")).match(eo) || [];
                  return J
                }
              }(ec[0]);
              ed !== ec[0] && (et[ec[0]] = ed)
            }
            ec = el.exec(J)
          }
          et["%C2"] = "�";
          for (var eh = Object.keys(et), ep = 0; ep < eh.length; ep++) {
            var ef = eh[ep];
            J = J.replace(RegExp(ef, "g"), et[ef])
          }
          return J
        }(J)
      }
    }
  },
  65987: function (J) {
    "use strict";
    var et = {
      single_source_shortest_paths: function (J, eo, el) {
        var ec, ed, eh, ep, ef, em, eg, ey = {}, eb = {};
        eb[eo] = 0;
        var ew = et.PriorityQueue.make();
        for (ew.push(eo, 0); !ew.empty();)
          for (eh in ed = (ec = ew.pop()).value,
            ep = ec.cost,
            ef = J[ed] || {})
            ef.hasOwnProperty(eh) && (em = ep + ef[eh],
              eg = eb[eh],
              (void 0 === eb[eh] || eg > em) && (eb[eh] = em,
                ew.push(eh, em),
                ey[eh] = ed));
        if (void 0 !== el && void 0 === eb[el])
          throw Error(["Could not find a path from ", eo, " to ", el, "."].join(""));
        return ey
      },
      extract_shortest_path_from_predecessor_list: function (J, et) {
        for (var eo = [], el = et; el;)
          eo.push(el),
            J[el],
            el = J[el];
        return eo.reverse(),
          eo
      },
      find_path: function (J, eo, el) {
        var ec = et.single_source_shortest_paths(J, eo, el);
        return et.extract_shortest_path_from_predecessor_list(ec, el)
      },
      PriorityQueue: {
        make: function (J) {
          var eo, el = et.PriorityQueue, ec = {};
          for (eo in J = J || {},
            el)
            el.hasOwnProperty(eo) && (ec[eo] = el[eo]);
          return ec.queue = [],
            ec.sorter = J.sorter || el.default_sorter,
            ec
        },
        default_sorter: function (J, et) {
          return J.cost - et.cost
        },
        push: function (J, et) {
          this.queue.push({
            value: J,
            cost: et
          }),
            this.queue.sort(this.sorter)
        },
        pop: function () {
          return this.queue.shift()
        },
        empty: function () {
          return 0 === this.queue.length
        }
      }
    };
    J.exports = et
  },
  62378: function (J) {
    "use strict";
    J.exports = function (J) {
      for (var et = [], eo = J.length, el = 0; el < eo; el++) {
        var ec = J.charCodeAt(el);
        if (ec >= 55296 && ec <= 56319 && eo > el + 1) {
          var ed = J.charCodeAt(el + 1);
          ed >= 56320 && ed <= 57343 && (ec = (ec - 55296) * 1024 + ed - 56320 + 65536,
            el += 1)
        }
        if (ec < 128) {
          et.push(ec);
          continue
        }
        if (ec < 2048) {
          et.push(ec >> 6 | 192),
            et.push(63 & ec | 128);
          continue
        }
        if (ec < 55296 || ec >= 57344 && ec < 65536) {
          et.push(ec >> 12 | 224),
            et.push(ec >> 6 & 63 | 128),
            et.push(63 & ec | 128);
          continue
        }
        if (ec >= 65536 && ec <= 1114111) {
          et.push(ec >> 18 | 240),
            et.push(ec >> 12 & 63 | 128),
            et.push(ec >> 6 & 63 | 128),
            et.push(63 & ec | 128);
          continue
        }
        et.push(239, 191, 189)
      }
      return new Uint8Array(et).buffer
    }
  },
  60190: function (J, et, eo) {
    "use strict";
    var el = this && this.__importDefault || function (J) {
      return J && J.__esModule ? J : {
        default: J
      }
    }
      ;
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.BaseBlockTracker = void 0;
    let ec = el(eo(19394))
      , calculateSum = (J, et) => J + et
      , ed = ["sync", "latest"];
    let BaseBlockTracker = class BaseBlockTracker extends ec.default {
      constructor(J) {
        super(),
          this._blockResetDuration = J.blockResetDuration || 2e4,
          this._usePastBlocks = J.usePastBlocks || !1,
          this._currentBlock = null,
          this._isRunning = !1,
          this._onNewListener = this._onNewListener.bind(this),
          this._onRemoveListener = this._onRemoveListener.bind(this),
          this._resetCurrentBlock = this._resetCurrentBlock.bind(this),
          this._setupInternalEvents()
      }
      async destroy() {
        this._cancelBlockResetTimeout(),
          await this._maybeEnd(),
          super.removeAllListeners()
      }
      isRunning() {
        return this._isRunning
      }
      getCurrentBlock() {
        return this._currentBlock
      }
      async getLatestBlock() {
        if (this._currentBlock)
          return this._currentBlock;
        let J = await new Promise(J => this.once("latest", J));
        return J
      }
      removeAllListeners(J) {
        return J ? super.removeAllListeners(J) : super.removeAllListeners(),
          this._setupInternalEvents(),
          this._onRemoveListener(),
          this
      }
      _setupInternalEvents() {
        this.removeListener("newListener", this._onNewListener),
          this.removeListener("removeListener", this._onRemoveListener),
          this.on("newListener", this._onNewListener),
          this.on("removeListener", this._onRemoveListener)
      }
      _onNewListener(J) {
        ed.includes(J) && this._maybeStart()
      }
      _onRemoveListener() {
        this._getBlockTrackerEventCount() > 0 || this._maybeEnd()
      }
      async _maybeStart() {
        this._isRunning || (this._isRunning = !0,
          this._cancelBlockResetTimeout(),
          await this._start(),
          this.emit("_started"))
      }
      async _maybeEnd() {
        this._isRunning && (this._isRunning = !1,
          this._setupBlockResetTimeout(),
          await this._end(),
          this.emit("_ended"))
      }
      _getBlockTrackerEventCount() {
        return ed.map(J => this.listenerCount(J)).reduce(calculateSum)
      }
      _shouldUseNewBlock(J) {
        let et = this._currentBlock;
        if (!et)
          return !0;
        let eo = hexToInt(J)
          , el = hexToInt(et);
        return this._usePastBlocks && eo < el || eo > el
      }
      _newPotentialLatest(J) {
        this._shouldUseNewBlock(J) && this._setCurrentBlock(J)
      }
      _setCurrentBlock(J) {
        let et = this._currentBlock;
        this._currentBlock = J,
          this.emit("latest", J),
          this.emit("sync", {
            oldBlock: et,
            newBlock: J
          })
      }
      _setupBlockResetTimeout() {
        this._cancelBlockResetTimeout(),
          this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration),
          this._blockResetTimeout.unref && this._blockResetTimeout.unref()
      }
      _cancelBlockResetTimeout() {
        this._blockResetTimeout && clearTimeout(this._blockResetTimeout)
      }
      _resetCurrentBlock() {
        this._currentBlock = null
      }
    }
      ;
    function hexToInt(J) {
      return Number.parseInt(J, 16)
    }
    et.BaseBlockTracker = BaseBlockTracker
  },
  30790: function (J, et, eo) {
    "use strict";
    var el = this && this.__importDefault || function (J) {
      return J && J.__esModule ? J : {
        default: J
      }
    }
      ;
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.PollingBlockTracker = void 0;
    let ec = el(eo(23420))
      , ed = el(eo(53786))
      , eh = eo(60190)
      , ep = eo(59579)
      , ef = (0,
        ep.createModuleLogger)(ep.projectLogger, "polling-block-tracker")
      , em = (0,
        ec.default)();
    let PollingBlockTracker = class PollingBlockTracker extends eh.BaseBlockTracker {
      constructor(J = {}) {
        var et;
        if (!J.provider)
          throw Error("PollingBlockTracker - no provider specified.");
        super(Object.assign(Object.assign({}, J), {
          blockResetDuration: null !== (et = J.blockResetDuration) && void 0 !== et ? et : J.pollingInterval
        })),
          this._provider = J.provider,
          this._pollingInterval = J.pollingInterval || 2e4,
          this._retryTimeout = J.retryTimeout || this._pollingInterval / 10,
          this._keepEventLoopActive = void 0 === J.keepEventLoopActive || J.keepEventLoopActive,
          this._setSkipCacheFlag = J.setSkipCacheFlag || !1
      }
      async checkForLatestBlock() {
        return await this._updateLatestBlock(),
          await this.getLatestBlock()
      }
      async _start() {
        this._synchronize()
      }
      async _end() { }
      async _synchronize() {
        for (var J; this._isRunning;)
          try {
            await this._updateLatestBlock();
            let J = timeout(this._pollingInterval, !this._keepEventLoopActive);
            this.emit("_waitingForNextIteration"),
              await J
          } catch (el) {
            let et = Error(`PollingBlockTracker - encountered an error while attempting to update latest block:
${null !== (J = el.stack) && void 0 !== J ? J : el}`);
            try {
              this.emit("error", et)
            } catch (J) {
              console.error(et)
            }
            let eo = timeout(this._retryTimeout, !this._keepEventLoopActive);
            this.emit("_waitingForNextIteration"),
              await eo
          }
      }
      async _updateLatestBlock() {
        let J = await this._fetchLatestBlock();
        this._newPotentialLatest(J)
      }
      async _fetchLatestBlock() {
        let J = {
          jsonrpc: "2.0",
          id: em(),
          method: "eth_blockNumber",
          params: []
        };
        this._setSkipCacheFlag && (J.skipCache = !0),
          ef("Making request", J);
        let et = await (0,
          ed.default)(et => this._provider.sendAsync(J, et))();
        if (ef("Got response", et),
          et.error)
          throw Error(`PollingBlockTracker - encountered error fetching block:
${et.error.message}`);
        return et.result
      }
    }
      ;
    function timeout(J, et) {
      return new Promise(eo => {
        let el = setTimeout(eo, J);
        el.unref && et && el.unref()
      }
      )
    }
    et.PollingBlockTracker = PollingBlockTracker
  },
  66767: function (J, et, eo) {
    "use strict";
    var el = this && this.__importDefault || function (J) {
      return J && J.__esModule ? J : {
        default: J
      }
    }
      ;
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.SubscribeBlockTracker = void 0;
    let ec = el(eo(23420))
      , ed = eo(60190)
      , eh = (0,
        ec.default)();
    let SubscribeBlockTracker = class SubscribeBlockTracker extends ed.BaseBlockTracker {
      constructor(J = {}) {
        if (!J.provider)
          throw Error("SubscribeBlockTracker - no provider specified.");
        super(J),
          this._provider = J.provider,
          this._subscriptionId = null
      }
      async checkForLatestBlock() {
        return await this.getLatestBlock()
      }
      async _start() {
        if (void 0 === this._subscriptionId || null === this._subscriptionId)
          try {
            let J = await this._call("eth_blockNumber");
            this._subscriptionId = await this._call("eth_subscribe", "newHeads"),
              this._provider.on("data", this._handleSubData.bind(this)),
              this._newPotentialLatest(J)
          } catch (J) {
            this.emit("error", J)
          }
      }
      async _end() {
        if (null !== this._subscriptionId && void 0 !== this._subscriptionId)
          try {
            await this._call("eth_unsubscribe", this._subscriptionId),
              this._subscriptionId = null
          } catch (J) {
            this.emit("error", J)
          }
      }
      _call(J, ...et) {
        return new Promise((eo, el) => {
          this._provider.sendAsync({
            id: eh(),
            method: J,
            params: et,
            jsonrpc: "2.0"
          }, (J, et) => {
            J ? el(J) : eo(et.result)
          }
          )
        }
        )
      }
      _handleSubData(J, et) {
        var eo;
        "eth_subscription" === et.method && (null === (eo = et.params) || void 0 === eo ? void 0 : eo.subscription) === this._subscriptionId && this._newPotentialLatest(et.params.result.number)
      }
    }
      ;
    et.SubscribeBlockTracker = SubscribeBlockTracker
  },
  6842: function (J, et, eo) {
    "use strict";
    var el = this && this.__createBinding || (Object.create ? function (J, et, eo, el) {
      void 0 === el && (el = eo),
        Object.defineProperty(J, el, {
          enumerable: !0,
          get: function () {
            return et[eo]
          }
        })
    }
      : function (J, et, eo, el) {
        void 0 === el && (el = eo),
          J[el] = et[eo]
      }
    )
      , ec = this && this.__exportStar || function (J, et) {
        for (var eo in J)
          "default" === eo || Object.prototype.hasOwnProperty.call(et, eo) || el(et, J, eo)
      }
      ;
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      ec(eo(30790), et),
      ec(eo(66767), et)
  },
  59579: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.createModuleLogger = et.projectLogger = void 0;
    let el = eo(42451);
    Object.defineProperty(et, "createModuleLogger", {
      enumerable: !0,
      get: function () {
        return el.createModuleLogger
      }
    }),
      et.projectLogger = (0,
        el.createProjectLogger)("eth-block-tracker")
  },
  53786: function (J) {
    "use strict";
    let processFn = (J, et) => function () {
      let eo = et.promiseModule
        , el = Array(arguments.length);
      for (let J = 0; J < arguments.length; J++)
        el[J] = arguments[J];
      return new eo((eo, ec) => {
        et.errorFirst ? el.push(function (J, el) {
          if (et.multiArgs) {
            let et = Array(arguments.length - 1);
            for (let J = 1; J < arguments.length; J++)
              et[J - 1] = arguments[J];
            J ? (et.unshift(J),
              ec(et)) : eo(et)
          } else
            J ? ec(J) : eo(el)
        }) : el.push(function (J) {
          if (et.multiArgs) {
            let J = Array(arguments.length - 1);
            for (let et = 0; et < arguments.length; et++)
              J[et] = arguments[et];
            eo(J)
          } else
            eo(J)
        }),
          J.apply(this, el)
      }
      )
    }
      ;
    J.exports = (J, et) => {
      let eo;
      et = Object.assign({
        exclude: [/.+(Sync|Stream)$/],
        errorFirst: !0,
        promiseModule: Promise
      }, et);
      let filter = J => {
        let match = et => "string" == typeof et ? J === et : et.test(J);
        return et.include ? et.include.some(match) : !et.exclude.some(match)
      }
        ;
      for (let el in eo = "function" == typeof J ? function () {
        return et.excludeMain ? J.apply(this, arguments) : processFn(J, et).apply(this, arguments)
      }
        : Object.create(Object.getPrototypeOf(J)),
        J) {
        let ec = J[el];
        eo[el] = "function" == typeof ec && filter(el) ? processFn(ec, et) : ec
      }
      return eo
    }
  },
  23256: function (J, et, eo) {
    let el = eo(76622);
    J.exports = class extends el {
      constructor() {
        super(),
          this.allResults = []
      }
      async update() {
        throw Error("BaseFilterWithHistory - no update method specified")
      }
      addResults(J) {
        this.allResults = this.allResults.concat(J),
          super.addResults(J)
      }
      addInitialResults(J) {
        this.allResults = this.allResults.concat(J),
          super.addInitialResults(J)
      }
      getAllResults() {
        return this.allResults
      }
    }
  },
  76622: function (J, et, eo) {
    let el = eo(19394).default;
    J.exports = class extends el {
      constructor() {
        super(),
          this.updates = []
      }
      async initialize() { }
      async update() {
        throw Error("BaseFilter - no update method specified")
      }
      addResults(J) {
        this.updates = this.updates.concat(J),
          J.forEach(J => this.emit("update", J))
      }
      addInitialResults(J) { }
      getChangesAndClear() {
        let J = this.updates;
        return this.updates = [],
          J
      }
    }
  },
  72785: function (J, et, eo) {
    let el = eo(76622)
      , ec = eo(40207)
      , { incrementHexInt: ed } = eo(98112);
    J.exports = class extends el {
      constructor({ provider: J, params: et }) {
        super(),
          this.type = "block",
          this.provider = J
      }
      async update({ oldBlock: J, newBlock: et }) {
        let eo = ed(J)
          , el = await ec({
            provider: this.provider,
            fromBlock: eo,
            toBlock: et
          })
          , eh = el.map(J => J.hash);
        this.addResults(eh)
      }
    }
  },
  40207: function (J) {
    async function getBlocksForRange({ provider: J, fromBlock: et, toBlock: eo }) {
      et || (et = eo);
      let el = hexToInt(et)
        , ec = hexToInt(eo)
        , ed = ec - el + 1
        , eh = Array(ed).fill().map((J, et) => el + et).map(intToHex);
      return (await Promise.all(eh.map(et => query(J, "eth_getBlockByNumber", [et, !1])))).filter(J => null !== J)
    }
    function hexToInt(J) {
      return null == J ? J : Number.parseInt(J, 16)
    }
    function intToHex(J) {
      if (null == J)
        return J;
      let et = J.toString(16);
      return "0x" + et
    }
    async function query(J, et, eo) {
      for (let el = 0; el < 3; el++)
        try {
          return await function (J, et) {
            return new Promise((eo, el) => {
              J.sendAsync(et, (J, et) => {
                J ? el(J) : et.error ? el(et.error) : et.result ? eo(et.result) : el(Error("Result was empty"))
              }
              )
            }
            )
          }(J, {
            id: 1,
            jsonrpc: "2.0",
            method: et,
            params: eo
          })
        } catch (J) {
          console.error(`provider.sendAsync failed: ${J.stack || J.message || J}`)
        }
      return null
    }
    J.exports = getBlocksForRange
  },
  98112: function (J) {
    function sortBlockRefs(J) {
      return J.sort((J, et) => "latest" === J || "earliest" === et ? 1 : "latest" === et || "earliest" === J ? -1 : hexToInt(J) - hexToInt(et))
    }
    function hexToInt(J) {
      return null == J ? J : Number.parseInt(J, 16)
    }
    function intToHex(J) {
      if (null == J)
        return J;
      let et = J.toString(16)
        , eo = et.length % 2;
      return eo && (et = "0" + et),
        "0x" + et
    }
    function unsafeRandomNibble() {
      return Math.floor(16 * Math.random()).toString(16)
    }
    J.exports = {
      minBlockRef: function (...J) {
        let et = sortBlockRefs(J);
        return et[0]
      },
      maxBlockRef: function (...J) {
        let et = sortBlockRefs(J);
        return et[et.length - 1]
      },
      sortBlockRefs,
      bnToHex: function (J) {
        return "0x" + J.toString(16)
      },
      blockRefIsNumber: function (J) {
        return J && !["earliest", "latest", "pending"].includes(J)
      },
      hexToInt,
      incrementHexInt: function (J) {
        if (null == J)
          return J;
        let et = hexToInt(J);
        return intToHex(et + 1)
      },
      intToHex,
      unsafeRandomBytes: function (J) {
        let et = "0x";
        for (let eo = 0; eo < J; eo++)
          et += unsafeRandomNibble() + unsafeRandomNibble();
        return et
      }
    }
  },
  98406: function (J, et, eo) {
    let el = eo(48125).WU
      , { createAsyncMiddleware: ec, createScaffoldMiddleware: ed } = eo(88625)
      , eh = eo(81663)
      , ep = eo(72785)
      , ef = eo(25792)
      , { intToHex: em, hexToInt: eg } = eo(98112);
    function toFilterCreationMiddleware(J) {
      return toAsyncRpcMiddleware(async (...et) => {
        let eo = await J(...et)
          , el = em(eo.id);
        return el
      }
      )
    }
    function toAsyncRpcMiddleware(J) {
      return ec(async (et, eo) => {
        let el = await J.apply(null, et.params);
        eo.result = el
      }
      )
    }
    function objValues(J, et) {
      let eo = [];
      for (let et in J)
        eo.push(J[et]);
      return eo
    }
    J.exports = function ({ blockTracker: J, provider: et }) {
      let eo = 0
        , ec = {}
        , ey = new el
        , eb = function ({ mutex: J }) {
          return et => async (eo, el, ec, ed) => {
            let eh = await J.acquire();
            eh(),
              et(eo, el, ec, ed)
          }
        }({
          mutex: ey
        })
        , ew = ed({
          eth_newFilter: eb(toFilterCreationMiddleware(newLogFilter)),
          eth_newBlockFilter: eb(toFilterCreationMiddleware(newBlockFilter)),
          eth_newPendingTransactionFilter: eb(toFilterCreationMiddleware(newPendingTransactionFilter)),
          eth_uninstallFilter: eb(toAsyncRpcMiddleware(uninstallFilterHandler)),
          eth_getFilterChanges: eb(toAsyncRpcMiddleware(getFilterChanges)),
          eth_getFilterLogs: eb(toAsyncRpcMiddleware(getFilterLogs))
        })
        , filterUpdater = async ({ oldBlock: J, newBlock: et }) => {
          if (0 === ec.length)
            return;
          let eo = await ey.acquire();
          try {
            await Promise.all(objValues(ec).map(async eo => {
              try {
                await eo.update({
                  oldBlock: J,
                  newBlock: et
                })
              } catch (J) {
                console.error(J)
              }
            }
            ))
          } catch (J) {
            console.error(J)
          }
          eo()
        }
        ;
      return ew.newLogFilter = newLogFilter,
        ew.newBlockFilter = newBlockFilter,
        ew.newPendingTransactionFilter = newPendingTransactionFilter,
        ew.uninstallFilter = uninstallFilterHandler,
        ew.getFilterChanges = getFilterChanges,
        ew.getFilterLogs = getFilterLogs,
        ew.destroy = () => {
          uninstallAllFilters()
        }
        ,
        ew;
      async function newLogFilter(J) {
        let eo = new eh({
          provider: et,
          params: J
        });
        return await installFilter(eo),
          eo
      }
      async function newBlockFilter() {
        let J = new ep({
          provider: et
        });
        return await installFilter(J),
          J
      }
      async function newPendingTransactionFilter() {
        let J = new ef({
          provider: et
        });
        return await installFilter(J),
          J
      }
      async function getFilterChanges(J) {
        let et = eg(J)
          , eo = ec[et];
        if (!eo)
          throw Error(`No filter for index "${et}"`);
        let el = eo.getChangesAndClear();
        return el
      }
      async function getFilterLogs(J) {
        let et = eg(J)
          , eo = ec[et];
        if (!eo)
          throw Error(`No filter for index "${et}"`);
        let el = [];
        return "log" === eo.type && (el = eo.getAllResults()),
          el
      }
      async function uninstallFilterHandler(J) {
        let et = eg(J)
          , eo = ec[et]
          , el = !!eo;
        return el && await uninstallFilter(et),
          el
      }
      async function installFilter(et) {
        let el = objValues(ec).length
          , ed = await J.getLatestBlock();
        await et.initialize({
          currentBlock: ed
        }),
          ec[++eo] = et,
          et.id = eo,
          et.idHex = em(eo);
        let eh = objValues(ec).length;
        return updateBlockTrackerSubs({
          prevFilterCount: el,
          newFilterCount: eh
        }),
          eo
      }
      async function uninstallFilter(J) {
        let et = objValues(ec).length;
        delete ec[J];
        let eo = objValues(ec).length;
        updateBlockTrackerSubs({
          prevFilterCount: et,
          newFilterCount: eo
        })
      }
      async function uninstallAllFilters() {
        let J = objValues(ec).length;
        ec = {},
          updateBlockTrackerSubs({
            prevFilterCount: J,
            newFilterCount: 0
          })
      }
      function updateBlockTrackerSubs({ prevFilterCount: et, newFilterCount: eo }) {
        if (0 === et && eo > 0) {
          J.on("sync", filterUpdater);
          return
        }
        if (et > 0 && 0 === eo) {
          J.removeListener("sync", filterUpdater);
          return
        }
      }
    }
  },
  81663: function (J, et, eo) {
    let el = eo(75682)
      , ec = eo(6417)
      , ed = eo(23256)
      , { bnToHex: eh, hexToInt: ep, incrementHexInt: ef, minBlockRef: em, blockRefIsNumber: eg } = eo(98112);
    J.exports = class extends ed {
      constructor({ provider: J, params: et }) {
        super(),
          this.type = "log",
          this.ethQuery = new el(J),
          this.params = Object.assign({
            fromBlock: "latest",
            toBlock: "latest",
            address: void 0,
            topics: []
          }, et),
          this.params.address && (Array.isArray(this.params.address) || (this.params.address = [this.params.address]),
            this.params.address = this.params.address.map(J => J.toLowerCase()))
      }
      async initialize({ currentBlock: J }) {
        let et = this.params.fromBlock;
        ["latest", "pending"].includes(et) && (et = J),
          "earliest" === et && (et = "0x0"),
          this.params.fromBlock = et;
        let eo = em(this.params.toBlock, J)
          , el = Object.assign({}, this.params, {
            toBlock: eo
          })
          , ec = await this._fetchLogs(el);
        this.addInitialResults(ec)
      }
      async update({ oldBlock: J, newBlock: et }) {
        let eo;
        eo = J ? ef(J) : et;
        let el = Object.assign({}, this.params, {
          fromBlock: eo,
          toBlock: et
        })
          , ec = await this._fetchLogs(el)
          , ed = ec.filter(J => this.matchLog(J));
        this.addResults(ed)
      }
      async _fetchLogs(J) {
        let et = await ec(et => this.ethQuery.getLogs(J, et))();
        return et
      }
      matchLog(J) {
        if (ep(this.params.fromBlock) >= ep(J.blockNumber) || eg(this.params.toBlock) && ep(this.params.toBlock) <= ep(J.blockNumber))
          return !1;
        let et = J.address && J.address.toLowerCase();
        if (this.params.address && et && !this.params.address.includes(et))
          return !1;
        let eo = this.params.topics.every((et, eo) => {
          let el = J.topics[eo];
          if (!el)
            return !1;
          el = el.toLowerCase();
          let ec = Array.isArray(et) ? et : [et]
            , ed = ec.includes(null);
          if (ed)
            return !0;
          ec = ec.map(J => J.toLowerCase());
          let eh = ec.includes(el);
          return eh
        }
        );
        return eo
      }
    }
  },
  6417: function (J) {
    "use strict";
    let processFn = (J, et, eo, el) => function (...ec) {
      let ed = et.promiseModule;
      return new ed((ed, eh) => {
        et.multiArgs ? ec.push((...J) => {
          et.errorFirst ? J[0] ? eh(J) : (J.shift(),
            ed(J)) : ed(J)
        }
        ) : et.errorFirst ? ec.push((J, et) => {
          J ? eh(J) : ed(et)
        }
        ) : ec.push(ed);
        let ep = this === eo ? el : this;
        Reflect.apply(J, ep, ec)
      }
      )
    }
      , et = new WeakMap;
    J.exports = (J, eo) => {
      eo = {
        exclude: [/.+(?:Sync|Stream)$/],
        errorFirst: !0,
        promiseModule: Promise,
        ...eo
      };
      let el = typeof J;
      if (!(null !== J && ("object" === el || "function" === el)))
        throw TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${null === J ? "null" : el}\``);
      let filter = (J, el) => {
        let ec = et.get(J);
        if (ec || (ec = {},
          et.set(J, ec)),
          el in ec)
          return ec[el];
        let match = J => "string" == typeof J || "symbol" == typeof el ? el === J : J.test(el)
          , ed = Reflect.getOwnPropertyDescriptor(J, el)
          , eh = void 0 === ed || ed.writable || ed.configurable
          , ep = eo.include ? eo.include.some(match) : !eo.exclude.some(match)
          , ef = ep && eh;
        return ec[el] = ef,
          ef
      }
        , ec = new WeakMap
        , ed = new Proxy(J, {
          apply(J, et, el) {
            let eh = ec.get(J);
            if (eh)
              return Reflect.apply(eh, et, el);
            let ep = eo.excludeMain ? J : processFn(J, eo, ed, J);
            return ec.set(J, ep),
              Reflect.apply(ep, et, el)
          },
          get(J, et) {
            let el = J[et];
            if (!filter(J, et) || el === Function.prototype[et])
              return el;
            let eh = ec.get(el);
            if (eh)
              return eh;
            if ("function" == typeof el) {
              let et = processFn(el, eo, ed, J);
              return ec.set(el, et),
                et
            }
            return el
          }
        });
      return ed
    }
  },
  62876: function (J, et, eo) {
    let el = eo(19394).default
      , { createAsyncMiddleware: ec, createScaffoldMiddleware: ed } = eo(88625)
      , eh = eo(98406)
      , { unsafeRandomBytes: ep, incrementHexInt: ef } = eo(98112)
      , em = eo(40207);
    function normalizeBlock(J) {
      return null == J ? null : {
        hash: J.hash,
        parentHash: J.parentHash,
        sha3Uncles: J.sha3Uncles,
        miner: J.miner,
        stateRoot: J.stateRoot,
        transactionsRoot: J.transactionsRoot,
        receiptsRoot: J.receiptsRoot,
        logsBloom: J.logsBloom,
        difficulty: J.difficulty,
        number: J.number,
        gasLimit: J.gasLimit,
        gasUsed: J.gasUsed,
        nonce: J.nonce,
        mixHash: J.mixHash,
        timestamp: J.timestamp,
        extraData: J.extraData
      }
    }
    J.exports = function ({ blockTracker: J, provider: et }) {
      let eo = {}
        , eg = eh({
          blockTracker: J,
          provider: et
        })
        , ey = !1
        , eb = new el
        , ew = ed({
          eth_subscribe: ec(subscribe),
          eth_unsubscribe: ec(unsubscribe)
        });
      return ew.destroy = function () {
        for (let J in eb.removeAllListeners(),
          eo)
          eo[J].destroy(),
            delete eo[J];
        ey = !0
      }
        ,
      {
        events: eb,
        middleware: ew
      };
      async function subscribe(el, ec) {
        let ed;
        if (ey)
          throw Error("SubscriptionManager - attempting to use after destroying");
        let eh = el.params[0]
          , eb = ep(16);
        switch (eh) {
          case "newHeads":
            ed = function ({ subId: eo }) {
              let el = {
                type: eh,
                destroy: async () => {
                  J.removeListener("sync", el.update)
                }
                ,
                update: async ({ oldBlock: J, newBlock: el }) => {
                  let ec = ef(J)
                    , ed = await em({
                      provider: et,
                      fromBlock: ec,
                      toBlock: el
                    })
                    , eh = ed.map(normalizeBlock).filter(J => null !== J);
                  eh.forEach(J => {
                    _emitSubscriptionResult(eo, J)
                  }
                  )
                }
              };
              return J.on("sync", el.update),
                el
            }({
              subId: eb
            });
            break;
          case "logs":
            let ew = el.params[1]
              , e_ = await eg.newLogFilter(ew);
            ed = function ({ subId: J, filter: et }) {
              return et.on("update", et => _emitSubscriptionResult(J, et)),
              {
                type: eh,
                destroy: async () => await eg.uninstallFilter(et.idHex)
              }
            }({
              subId: eb,
              filter: e_
            });
            break;
          default:
            throw Error(`SubscriptionManager - unsupported subscription type "${eh}"`)
        }
        eo[eb] = ed,
          ec.result = eb
      }
      async function unsubscribe(J, et) {
        if (ey)
          throw Error("SubscriptionManager - attempting to use after destroying");
        let el = J.params[0]
          , ec = eo[el];
        if (!ec) {
          et.result = !1;
          return
        }
        delete eo[el],
          await ec.destroy(),
          et.result = !0
      }
      function _emitSubscriptionResult(J, et) {
        eb.emit("notification", {
          jsonrpc: "2.0",
          method: "eth_subscription",
          params: {
            subscription: J,
            result: et
          }
        })
      }
    }
  },
  25792: function (J, et, eo) {
    let el = eo(76622)
      , ec = eo(40207)
      , { incrementHexInt: ed } = eo(98112);
    J.exports = class extends el {
      constructor({ provider: J }) {
        super(),
          this.type = "tx",
          this.provider = J
      }
      async update({ oldBlock: J }) {
        let et = ed(J)
          , eo = await ec({
            provider: this.provider,
            fromBlock: et,
            toBlock: J
          })
          , el = [];
        for (let J of eo)
          el.push(...J.transactions);
        this.addResults(el)
      }
    }
  },
  75682: function (J, et, eo) {
    let el = eo(47529)
      , ec = eo(23420)();
    function EthQuery(J) {
      this.currentProvider = J
    }
    function generateFnFor(J) {
      return function () {
        var et = [].slice.call(arguments)
          , eo = et.pop();
        this.sendAsync({
          method: J,
          params: et
        }, eo)
      }
    }
    function generateFnWithDefaultBlockFor(J, et) {
      return function () {
        var eo = [].slice.call(arguments)
          , el = eo.pop();
        eo.length < J && eo.push("latest"),
          this.sendAsync({
            method: et,
            params: eo
          }, el)
      }
    }
    J.exports = EthQuery,
      EthQuery.prototype.getBalance = generateFnWithDefaultBlockFor(2, "eth_getBalance"),
      EthQuery.prototype.getCode = generateFnWithDefaultBlockFor(2, "eth_getCode"),
      EthQuery.prototype.getTransactionCount = generateFnWithDefaultBlockFor(2, "eth_getTransactionCount"),
      EthQuery.prototype.getStorageAt = generateFnWithDefaultBlockFor(3, "eth_getStorageAt"),
      EthQuery.prototype.call = generateFnWithDefaultBlockFor(2, "eth_call"),
      EthQuery.prototype.protocolVersion = generateFnFor("eth_protocolVersion"),
      EthQuery.prototype.syncing = generateFnFor("eth_syncing"),
      EthQuery.prototype.coinbase = generateFnFor("eth_coinbase"),
      EthQuery.prototype.mining = generateFnFor("eth_mining"),
      EthQuery.prototype.hashrate = generateFnFor("eth_hashrate"),
      EthQuery.prototype.gasPrice = generateFnFor("eth_gasPrice"),
      EthQuery.prototype.accounts = generateFnFor("eth_accounts"),
      EthQuery.prototype.blockNumber = generateFnFor("eth_blockNumber"),
      EthQuery.prototype.getBlockTransactionCountByHash = generateFnFor("eth_getBlockTransactionCountByHash"),
      EthQuery.prototype.getBlockTransactionCountByNumber = generateFnFor("eth_getBlockTransactionCountByNumber"),
      EthQuery.prototype.getUncleCountByBlockHash = generateFnFor("eth_getUncleCountByBlockHash"),
      EthQuery.prototype.getUncleCountByBlockNumber = generateFnFor("eth_getUncleCountByBlockNumber"),
      EthQuery.prototype.sign = generateFnFor("eth_sign"),
      EthQuery.prototype.sendTransaction = generateFnFor("eth_sendTransaction"),
      EthQuery.prototype.sendRawTransaction = generateFnFor("eth_sendRawTransaction"),
      EthQuery.prototype.estimateGas = generateFnFor("eth_estimateGas"),
      EthQuery.prototype.getBlockByHash = generateFnFor("eth_getBlockByHash"),
      EthQuery.prototype.getBlockByNumber = generateFnFor("eth_getBlockByNumber"),
      EthQuery.prototype.getTransactionByHash = generateFnFor("eth_getTransactionByHash"),
      EthQuery.prototype.getTransactionByBlockHashAndIndex = generateFnFor("eth_getTransactionByBlockHashAndIndex"),
      EthQuery.prototype.getTransactionByBlockNumberAndIndex = generateFnFor("eth_getTransactionByBlockNumberAndIndex"),
      EthQuery.prototype.getTransactionReceipt = generateFnFor("eth_getTransactionReceipt"),
      EthQuery.prototype.getUncleByBlockHashAndIndex = generateFnFor("eth_getUncleByBlockHashAndIndex"),
      EthQuery.prototype.getUncleByBlockNumberAndIndex = generateFnFor("eth_getUncleByBlockNumberAndIndex"),
      EthQuery.prototype.getCompilers = generateFnFor("eth_getCompilers"),
      EthQuery.prototype.compileLLL = generateFnFor("eth_compileLLL"),
      EthQuery.prototype.compileSolidity = generateFnFor("eth_compileSolidity"),
      EthQuery.prototype.compileSerpent = generateFnFor("eth_compileSerpent"),
      EthQuery.prototype.newFilter = generateFnFor("eth_newFilter"),
      EthQuery.prototype.newBlockFilter = generateFnFor("eth_newBlockFilter"),
      EthQuery.prototype.newPendingTransactionFilter = generateFnFor("eth_newPendingTransactionFilter"),
      EthQuery.prototype.uninstallFilter = generateFnFor("eth_uninstallFilter"),
      EthQuery.prototype.getFilterChanges = generateFnFor("eth_getFilterChanges"),
      EthQuery.prototype.getFilterLogs = generateFnFor("eth_getFilterLogs"),
      EthQuery.prototype.getLogs = generateFnFor("eth_getLogs"),
      EthQuery.prototype.getWork = generateFnFor("eth_getWork"),
      EthQuery.prototype.submitWork = generateFnFor("eth_submitWork"),
      EthQuery.prototype.submitHashrate = generateFnFor("eth_submitHashrate"),
      EthQuery.prototype.sendAsync = function (J, et) {
        this.currentProvider.sendAsync(el({
          id: ec(),
          jsonrpc: "2.0",
          params: []
        }, J), function (J, eo) {
          if (!J && eo.error && (J = Error("EthQuery - RPC Error - " + eo.error.message)),
            J)
            return et(J);
          et(null, eo.result)
        })
      }
  },
  12294: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.EthereumProviderError = et.EthereumRpcError = void 0;
    let el = eo(4445);
    let EthereumRpcError = class EthereumRpcError extends Error {
      constructor(J, et, eo) {
        if (!Number.isInteger(J))
          throw Error('"code" must be an integer.');
        if (!et || "string" != typeof et)
          throw Error('"message" must be a nonempty string.');
        super(et),
          this.code = J,
          void 0 !== eo && (this.data = eo)
      }
      serialize() {
        let J = {
          code: this.code,
          message: this.message
        };
        return void 0 !== this.data && (J.data = this.data),
          this.stack && (J.stack = this.stack),
          J
      }
      toString() {
        return el.default(this.serialize(), stringifyReplacer, 2)
      }
    }
      ;
    function stringifyReplacer(J, et) {
      if ("[Circular]" !== et)
        return et
    }
    et.EthereumRpcError = EthereumRpcError,
      et.EthereumProviderError = class extends EthereumRpcError {
        constructor(J, et, eo) {
          if (!(Number.isInteger(J) && J >= 1e3 && J <= 4999))
            throw Error('"code" must be an integer such that: 1000 <= code <= 4999');
          super(J, et, eo)
        }
      }
  },
  92662: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.errorValues = et.errorCodes = void 0,
      et.errorCodes = {
        rpc: {
          invalidInput: -32e3,
          resourceNotFound: -32001,
          resourceUnavailable: -32002,
          transactionRejected: -32003,
          methodNotSupported: -32004,
          limitExceeded: -32005,
          parse: -32700,
          invalidRequest: -32600,
          methodNotFound: -32601,
          invalidParams: -32602,
          internal: -32603
        },
        provider: {
          userRejectedRequest: 4001,
          unauthorized: 4100,
          unsupportedMethod: 4200,
          disconnected: 4900,
          chainDisconnected: 4901
        }
      },
      et.errorValues = {
        "-32700": {
          standard: "JSON RPC 2.0",
          message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
        },
        "-32600": {
          standard: "JSON RPC 2.0",
          message: "The JSON sent is not a valid Request object."
        },
        "-32601": {
          standard: "JSON RPC 2.0",
          message: "The method does not exist / is not available."
        },
        "-32602": {
          standard: "JSON RPC 2.0",
          message: "Invalid method parameter(s)."
        },
        "-32603": {
          standard: "JSON RPC 2.0",
          message: "Internal JSON-RPC error."
        },
        "-32000": {
          standard: "EIP-1474",
          message: "Invalid input."
        },
        "-32001": {
          standard: "EIP-1474",
          message: "Resource not found."
        },
        "-32002": {
          standard: "EIP-1474",
          message: "Resource unavailable."
        },
        "-32003": {
          standard: "EIP-1474",
          message: "Transaction rejected."
        },
        "-32004": {
          standard: "EIP-1474",
          message: "Method not supported."
        },
        "-32005": {
          standard: "EIP-1474",
          message: "Request limit exceeded."
        },
        4001: {
          standard: "EIP-1193",
          message: "User rejected the request."
        },
        4100: {
          standard: "EIP-1193",
          message: "The requested account and/or method has not been authorized by the user."
        },
        4200: {
          standard: "EIP-1193",
          message: "The requested method is not supported by this Ethereum provider."
        },
        4900: {
          standard: "EIP-1193",
          message: "The provider is disconnected from all chains."
        },
        4901: {
          standard: "EIP-1193",
          message: "The provider is disconnected from the specified chain."
        }
      }
  },
  68797: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.ethErrors = void 0;
    let el = eo(12294)
      , ec = eo(68753)
      , ed = eo(92662);
    function getEthJsonRpcError(J, et) {
      let [eo, ed] = parseOpts(et);
      return new el.EthereumRpcError(J, eo || ec.getMessageFromCode(J), ed)
    }
    function getEthProviderError(J, et) {
      let [eo, ed] = parseOpts(et);
      return new el.EthereumProviderError(J, eo || ec.getMessageFromCode(J), ed)
    }
    function parseOpts(J) {
      if (J) {
        if ("string" == typeof J)
          return [J];
        if ("object" == typeof J && !Array.isArray(J)) {
          let { message: et, data: eo } = J;
          if (et && "string" != typeof et)
            throw Error("Must specify string message.");
          return [et || void 0, eo]
        }
      }
      return []
    }
    et.ethErrors = {
      rpc: {
        parse: J => getEthJsonRpcError(ed.errorCodes.rpc.parse, J),
        invalidRequest: J => getEthJsonRpcError(ed.errorCodes.rpc.invalidRequest, J),
        invalidParams: J => getEthJsonRpcError(ed.errorCodes.rpc.invalidParams, J),
        methodNotFound: J => getEthJsonRpcError(ed.errorCodes.rpc.methodNotFound, J),
        internal: J => getEthJsonRpcError(ed.errorCodes.rpc.internal, J),
        server: J => {
          if (!J || "object" != typeof J || Array.isArray(J))
            throw Error("Ethereum RPC Server errors must provide single object argument.");
          let { code: et } = J;
          if (!Number.isInteger(et) || et > -32005 || et < -32099)
            throw Error('"code" must be an integer such that: -32099 <= code <= -32005');
          return getEthJsonRpcError(et, J)
        }
        ,
        invalidInput: J => getEthJsonRpcError(ed.errorCodes.rpc.invalidInput, J),
        resourceNotFound: J => getEthJsonRpcError(ed.errorCodes.rpc.resourceNotFound, J),
        resourceUnavailable: J => getEthJsonRpcError(ed.errorCodes.rpc.resourceUnavailable, J),
        transactionRejected: J => getEthJsonRpcError(ed.errorCodes.rpc.transactionRejected, J),
        methodNotSupported: J => getEthJsonRpcError(ed.errorCodes.rpc.methodNotSupported, J),
        limitExceeded: J => getEthJsonRpcError(ed.errorCodes.rpc.limitExceeded, J)
      },
      provider: {
        userRejectedRequest: J => getEthProviderError(ed.errorCodes.provider.userRejectedRequest, J),
        unauthorized: J => getEthProviderError(ed.errorCodes.provider.unauthorized, J),
        unsupportedMethod: J => getEthProviderError(ed.errorCodes.provider.unsupportedMethod, J),
        disconnected: J => getEthProviderError(ed.errorCodes.provider.disconnected, J),
        chainDisconnected: J => getEthProviderError(ed.errorCodes.provider.chainDisconnected, J),
        custom: J => {
          if (!J || "object" != typeof J || Array.isArray(J))
            throw Error("Ethereum Provider custom errors must provide single object argument.");
          let { code: et, message: eo, data: ec } = J;
          if (!eo || "string" != typeof eo)
            throw Error('"message" must be a nonempty string');
          return new el.EthereumProviderError(et, eo, ec)
        }
      }
    }
  },
  79826: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.getMessageFromCode = et.serializeError = et.EthereumProviderError = et.EthereumRpcError = et.ethErrors = et.errorCodes = void 0;
    let el = eo(12294);
    Object.defineProperty(et, "EthereumRpcError", {
      enumerable: !0,
      get: function () {
        return el.EthereumRpcError
      }
    }),
      Object.defineProperty(et, "EthereumProviderError", {
        enumerable: !0,
        get: function () {
          return el.EthereumProviderError
        }
      });
    let ec = eo(68753);
    Object.defineProperty(et, "serializeError", {
      enumerable: !0,
      get: function () {
        return ec.serializeError
      }
    }),
      Object.defineProperty(et, "getMessageFromCode", {
        enumerable: !0,
        get: function () {
          return ec.getMessageFromCode
        }
      });
    let ed = eo(68797);
    Object.defineProperty(et, "ethErrors", {
      enumerable: !0,
      get: function () {
        return ed.ethErrors
      }
    });
    let eh = eo(92662);
    Object.defineProperty(et, "errorCodes", {
      enumerable: !0,
      get: function () {
        return eh.errorCodes
      }
    })
  },
  68753: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.serializeError = et.isValidCode = et.getMessageFromCode = et.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
    let el = eo(92662)
      , ec = eo(12294)
      , ed = el.errorCodes.rpc.internal
      , eh = {
        code: ed,
        message: getMessageFromCode(ed)
      };
    function getMessageFromCode(J, eo = "Unspecified error message. This is a bug, please report it.") {
      if (Number.isInteger(J)) {
        let eo = J.toString();
        if (hasKey(el.errorValues, eo))
          return el.errorValues[eo].message;
        if (J >= -32099 && J <= -32e3)
          return et.JSON_RPC_SERVER_ERROR_MESSAGE
      }
      return eo
    }
    function isValidCode(J) {
      if (!Number.isInteger(J))
        return !1;
      let et = J.toString();
      return !!(el.errorValues[et] || J >= -32099 && J <= -32e3)
    }
    function assignOriginalError(J) {
      return J && "object" == typeof J && !Array.isArray(J) ? Object.assign({}, J) : J
    }
    function hasKey(J, et) {
      return Object.prototype.hasOwnProperty.call(J, et)
    }
    et.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.",
      et.getMessageFromCode = getMessageFromCode,
      et.isValidCode = isValidCode,
      et.serializeError = function (J, { fallbackError: et = eh, shouldIncludeStack: eo = !1 } = {}) {
        if (!et || !Number.isInteger(et.code) || "string" != typeof et.message)
          throw Error("Must provide fallback error with integer number code and string message.");
        if (J instanceof ec.EthereumRpcError)
          return J.serialize();
        let el = {};
        if (J && "object" == typeof J && !Array.isArray(J) && hasKey(J, "code") && isValidCode(J.code))
          el.code = J.code,
            J.message && "string" == typeof J.message ? (el.message = J.message,
              hasKey(J, "data") && (el.data = J.data)) : (el.message = getMessageFromCode(el.code),
                el.data = {
                  originalError: assignOriginalError(J)
                });
        else {
          el.code = et.code;
          let eo = null == J ? void 0 : J.message;
          el.message = eo && "string" == typeof eo ? eo : et.message,
            el.data = {
              originalError: assignOriginalError(J)
            }
        }
        let ed = null == J ? void 0 : J.stack;
        return eo && J && ed && "string" == typeof ed && (el.stack = ed),
          el
      }
  },
  26729: function (J) {
    "use strict";
    var et = Object.prototype.hasOwnProperty
      , eo = "~";
    function Events() { }
    function EE(J, et, eo) {
      this.fn = J,
        this.context = et,
        this.once = eo || !1
    }
    function addListener(J, et, el, ec, ed) {
      if ("function" != typeof el)
        throw TypeError("The listener must be a function");
      var eh = new EE(el, ec || J, ed)
        , ep = eo ? eo + et : et;
      return J._events[ep] ? J._events[ep].fn ? J._events[ep] = [J._events[ep], eh] : J._events[ep].push(eh) : (J._events[ep] = eh,
        J._eventsCount++),
        J
    }
    function clearEvent(J, et) {
      0 == --J._eventsCount ? J._events = new Events : delete J._events[et]
    }
    function EventEmitter() {
      this._events = new Events,
        this._eventsCount = 0
    }
    Object.create && (Events.prototype = Object.create(null),
      new Events().__proto__ || (eo = !1)),
      EventEmitter.prototype.eventNames = function () {
        var J, el, ec = [];
        if (0 === this._eventsCount)
          return ec;
        for (el in J = this._events)
          et.call(J, el) && ec.push(eo ? el.slice(1) : el);
        return Object.getOwnPropertySymbols ? ec.concat(Object.getOwnPropertySymbols(J)) : ec
      }
      ,
      EventEmitter.prototype.listeners = function (J) {
        var et = eo ? eo + J : J
          , el = this._events[et];
        if (!el)
          return [];
        if (el.fn)
          return [el.fn];
        for (var ec = 0, ed = el.length, eh = Array(ed); ec < ed; ec++)
          eh[ec] = el[ec].fn;
        return eh
      }
      ,
      EventEmitter.prototype.listenerCount = function (J) {
        var et = eo ? eo + J : J
          , el = this._events[et];
        return el ? el.fn ? 1 : el.length : 0
      }
      ,
      EventEmitter.prototype.emit = function (J, et, el, ec, ed, eh) {
        var ep = eo ? eo + J : J;
        if (!this._events[ep])
          return !1;
        var ef, em, eg = this._events[ep], ey = arguments.length;
        if (eg.fn) {
          switch (eg.once && this.removeListener(J, eg.fn, void 0, !0),
          ey) {
            case 1:
              return eg.fn.call(eg.context),
                !0;
            case 2:
              return eg.fn.call(eg.context, et),
                !0;
            case 3:
              return eg.fn.call(eg.context, et, el),
                !0;
            case 4:
              return eg.fn.call(eg.context, et, el, ec),
                !0;
            case 5:
              return eg.fn.call(eg.context, et, el, ec, ed),
                !0;
            case 6:
              return eg.fn.call(eg.context, et, el, ec, ed, eh),
                !0
          }
          for (em = 1,
            ef = Array(ey - 1); em < ey; em++)
            ef[em - 1] = arguments[em];
          eg.fn.apply(eg.context, ef)
        } else {
          var eb, ew = eg.length;
          for (em = 0; em < ew; em++)
            switch (eg[em].once && this.removeListener(J, eg[em].fn, void 0, !0),
            ey) {
              case 1:
                eg[em].fn.call(eg[em].context);
                break;
              case 2:
                eg[em].fn.call(eg[em].context, et);
                break;
              case 3:
                eg[em].fn.call(eg[em].context, et, el);
                break;
              case 4:
                eg[em].fn.call(eg[em].context, et, el, ec);
                break;
              default:
                if (!ef)
                  for (eb = 1,
                    ef = Array(ey - 1); eb < ey; eb++)
                    ef[eb - 1] = arguments[eb];
                eg[em].fn.apply(eg[em].context, ef)
            }
        }
        return !0
      }
      ,
      EventEmitter.prototype.on = function (J, et, eo) {
        return addListener(this, J, et, eo, !1)
      }
      ,
      EventEmitter.prototype.once = function (J, et, eo) {
        return addListener(this, J, et, eo, !0)
      }
      ,
      EventEmitter.prototype.removeListener = function (J, et, el, ec) {
        var ed = eo ? eo + J : J;
        if (!this._events[ed])
          return this;
        if (!et)
          return clearEvent(this, ed),
            this;
        var eh = this._events[ed];
        if (eh.fn)
          eh.fn !== et || ec && !eh.once || el && eh.context !== el || clearEvent(this, ed);
        else {
          for (var ep = 0, ef = [], em = eh.length; ep < em; ep++)
            (eh[ep].fn !== et || ec && !eh[ep].once || el && eh[ep].context !== el) && ef.push(eh[ep]);
          ef.length ? this._events[ed] = 1 === ef.length ? ef[0] : ef : clearEvent(this, ed)
        }
        return this
      }
      ,
      EventEmitter.prototype.removeAllListeners = function (J) {
        var et;
        return J ? (et = eo ? eo + J : J,
          this._events[et] && clearEvent(this, et)) : (this._events = new Events,
            this._eventsCount = 0),
          this
      }
      ,
      EventEmitter.prototype.off = EventEmitter.prototype.removeListener,
      EventEmitter.prototype.addListener = EventEmitter.prototype.on,
      EventEmitter.prefixed = eo,
      EventEmitter.EventEmitter = EventEmitter,
      J.exports = EventEmitter
  },
  17187: function (J) {
    "use strict";
    var et, eo = "object" == typeof Reflect ? Reflect : null, el = eo && "function" == typeof eo.apply ? eo.apply : function (J, et, eo) {
      return Function.prototype.apply.call(J, et, eo)
    }
      ;
    et = eo && "function" == typeof eo.ownKeys ? eo.ownKeys : Object.getOwnPropertySymbols ? function (J) {
      return Object.getOwnPropertyNames(J).concat(Object.getOwnPropertySymbols(J))
    }
      : function (J) {
        return Object.getOwnPropertyNames(J)
      }
      ;
    var ec = Number.isNaN || function (J) {
      return J != J
    }
      ;
    function EventEmitter() {
      EventEmitter.init.call(this)
    }
    J.exports = EventEmitter,
      J.exports.once = function (J, et) {
        return new Promise(function (eo, el) {
          function errorListener(eo) {
            J.removeListener(et, resolver),
              el(eo)
          }
          function resolver() {
            "function" == typeof J.removeListener && J.removeListener("error", errorListener),
              eo([].slice.call(arguments))
          }
          eventTargetAgnosticAddListener(J, et, resolver, {
            once: !0
          }),
            "error" !== et && "function" == typeof J.on && eventTargetAgnosticAddListener(J, "error", errorListener, {
              once: !0
            })
        }
        )
      }
      ,
      EventEmitter.EventEmitter = EventEmitter,
      EventEmitter.prototype._events = void 0,
      EventEmitter.prototype._eventsCount = 0,
      EventEmitter.prototype._maxListeners = void 0;
    var ed = 10;
    function checkListener(J) {
      if ("function" != typeof J)
        throw TypeError('The "listener" argument must be of type Function. Received type ' + typeof J)
    }
    function _getMaxListeners(J) {
      return void 0 === J._maxListeners ? EventEmitter.defaultMaxListeners : J._maxListeners
    }
    function _addListener(J, et, eo, el) {
      if (checkListener(eo),
        void 0 === (ed = J._events) ? (ed = J._events = Object.create(null),
          J._eventsCount = 0) : (void 0 !== ed.newListener && (J.emit("newListener", et, eo.listener ? eo.listener : eo),
            ed = J._events),
            eh = ed[et]),
        void 0 === eh)
        eh = ed[et] = eo,
          ++J._eventsCount;
      else if ("function" == typeof eh ? eh = ed[et] = el ? [eo, eh] : [eh, eo] : el ? eh.unshift(eo) : eh.push(eo),
        (ec = _getMaxListeners(J)) > 0 && eh.length > ec && !eh.warned) {
        eh.warned = !0;
        var ec, ed, eh, ep = Error("Possible EventEmitter memory leak detected. " + eh.length + " " + String(et) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        ep.name = "MaxListenersExceededWarning",
          ep.emitter = J,
          ep.type = et,
          ep.count = eh.length,
          console && console.warn && console.warn(ep)
      }
      return J
    }
    function onceWrapper() {
      if (!this.fired)
        return (this.target.removeListener(this.type, this.wrapFn),
          this.fired = !0,
          0 == arguments.length) ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
    }
    function _onceWrap(J, et, eo) {
      var el = {
        fired: !1,
        wrapFn: void 0,
        target: J,
        type: et,
        listener: eo
      }
        , ec = onceWrapper.bind(el);
      return ec.listener = eo,
        el.wrapFn = ec,
        ec
    }
    function _listeners(J, et, eo) {
      var el = J._events;
      if (void 0 === el)
        return [];
      var ec = el[et];
      return void 0 === ec ? [] : "function" == typeof ec ? eo ? [ec.listener || ec] : [ec] : eo ? function (J) {
        for (var et = Array(J.length), eo = 0; eo < et.length; ++eo)
          et[eo] = J[eo].listener || J[eo];
        return et
      }(ec) : arrayClone(ec, ec.length)
    }
    function listenerCount(J) {
      var et = this._events;
      if (void 0 !== et) {
        var eo = et[J];
        if ("function" == typeof eo)
          return 1;
        if (void 0 !== eo)
          return eo.length
      }
      return 0
    }
    function arrayClone(J, et) {
      for (var eo = Array(et), el = 0; el < et; ++el)
        eo[el] = J[el];
      return eo
    }
    function eventTargetAgnosticAddListener(J, et, eo, el) {
      if ("function" == typeof J.on)
        el.once ? J.once(et, eo) : J.on(et, eo);
      else if ("function" == typeof J.addEventListener)
        J.addEventListener(et, function wrapListener(ec) {
          el.once && J.removeEventListener(et, wrapListener),
            eo(ec)
        });
      else
        throw TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof J)
    }
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: !0,
      get: function () {
        return ed
      },
      set: function (J) {
        if ("number" != typeof J || J < 0 || ec(J))
          throw RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + J + ".");
        ed = J
      }
    }),
      EventEmitter.init = function () {
        (void 0 === this._events || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null),
          this._eventsCount = 0),
          this._maxListeners = this._maxListeners || void 0
      }
      ,
      EventEmitter.prototype.setMaxListeners = function (J) {
        if ("number" != typeof J || J < 0 || ec(J))
          throw RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + J + ".");
        return this._maxListeners = J,
          this
      }
      ,
      EventEmitter.prototype.getMaxListeners = function () {
        return _getMaxListeners(this)
      }
      ,
      EventEmitter.prototype.emit = function (J) {
        for (var et = [], eo = 1; eo < arguments.length; eo++)
          et.push(arguments[eo]);
        var ec = "error" === J
          , ed = this._events;
        if (void 0 !== ed)
          ec = ec && void 0 === ed.error;
        else if (!ec)
          return !1;
        if (ec) {
          if (et.length > 0 && (eh = et[0]),
            eh instanceof Error)
            throw eh;
          var eh, ep = Error("Unhandled error." + (eh ? " (" + eh.message + ")" : ""));
          throw ep.context = eh,
          ep
        }
        var ef = ed[J];
        if (void 0 === ef)
          return !1;
        if ("function" == typeof ef)
          el(ef, this, et);
        else
          for (var em = ef.length, eg = arrayClone(ef, em), eo = 0; eo < em; ++eo)
            el(eg[eo], this, et);
        return !0
      }
      ,
      EventEmitter.prototype.addListener = function (J, et) {
        return _addListener(this, J, et, !1)
      }
      ,
      EventEmitter.prototype.on = EventEmitter.prototype.addListener,
      EventEmitter.prototype.prependListener = function (J, et) {
        return _addListener(this, J, et, !0)
      }
      ,
      EventEmitter.prototype.once = function (J, et) {
        return checkListener(et),
          this.on(J, _onceWrap(this, J, et)),
          this
      }
      ,
      EventEmitter.prototype.prependOnceListener = function (J, et) {
        return checkListener(et),
          this.prependListener(J, _onceWrap(this, J, et)),
          this
      }
      ,
      EventEmitter.prototype.removeListener = function (J, et) {
        var eo, el, ec, ed, eh;
        if (checkListener(et),
          void 0 === (el = this._events) || void 0 === (eo = el[J]))
          return this;
        if (eo === et || eo.listener === et)
          0 == --this._eventsCount ? this._events = Object.create(null) : (delete el[J],
            el.removeListener && this.emit("removeListener", J, eo.listener || et));
        else if ("function" != typeof eo) {
          for (ec = -1,
            ed = eo.length - 1; ed >= 0; ed--)
            if (eo[ed] === et || eo[ed].listener === et) {
              eh = eo[ed].listener,
                ec = ed;
              break
            }
          if (ec < 0)
            return this;
          0 === ec ? eo.shift() : function (J, et) {
            for (; et + 1 < J.length; et++)
              J[et] = J[et + 1];
            J.pop()
          }(eo, ec),
            1 === eo.length && (el[J] = eo[0]),
            void 0 !== el.removeListener && this.emit("removeListener", J, eh || et)
        }
        return this
      }
      ,
      EventEmitter.prototype.off = EventEmitter.prototype.removeListener,
      EventEmitter.prototype.removeAllListeners = function (J) {
        var et, eo, el;
        if (void 0 === (eo = this._events))
          return this;
        if (void 0 === eo.removeListener)
          return 0 == arguments.length ? (this._events = Object.create(null),
            this._eventsCount = 0) : void 0 !== eo[J] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete eo[J]),
            this;
        if (0 == arguments.length) {
          var ec, ed = Object.keys(eo);
          for (el = 0; el < ed.length; ++el)
            "removeListener" !== (ec = ed[el]) && this.removeAllListeners(ec);
          return this.removeAllListeners("removeListener"),
            this._events = Object.create(null),
            this._eventsCount = 0,
            this
        }
        if ("function" == typeof (et = eo[J]))
          this.removeListener(J, et);
        else if (void 0 !== et)
          for (el = et.length - 1; el >= 0; el--)
            this.removeListener(J, et[el]);
        return this
      }
      ,
      EventEmitter.prototype.listeners = function (J) {
        return _listeners(this, J, !0)
      }
      ,
      EventEmitter.prototype.rawListeners = function (J) {
        return _listeners(this, J, !1)
      }
      ,
      EventEmitter.listenerCount = function (J, et) {
        return "function" == typeof J.listenerCount ? J.listenerCount(et) : listenerCount.call(J, et)
      }
      ,
      EventEmitter.prototype.listenerCount = listenerCount,
      EventEmitter.prototype.eventNames = function () {
        return this._eventsCount > 0 ? et(this._events) : []
      }
  },
  4445: function (J) {
    J.exports = stringify,
      stringify.default = stringify,
      stringify.stable = deterministicStringify,
      stringify.stableStringify = deterministicStringify;
    var et = "[...]"
      , eo = "[Circular]"
      , el = []
      , ec = [];
    function defaultOptions() {
      return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER
      }
    }
    function stringify(J, ed, eh, ep) {
      void 0 === ep && (ep = defaultOptions()),
        function decirc(J, el, ec, ed, eh, ep, ef) {
          if (ep += 1,
            "object" == typeof J && null !== J) {
            for (em = 0; em < ed.length; em++)
              if (ed[em] === J) {
                setReplace(eo, J, el, eh);
                return
              }
            if (void 0 !== ef.depthLimit && ep > ef.depthLimit || void 0 !== ef.edgesLimit && ec + 1 > ef.edgesLimit) {
              setReplace(et, J, el, eh);
              return
            }
            if (ed.push(J),
              Array.isArray(J))
              for (em = 0; em < J.length; em++)
                decirc(J[em], em, em, ed, J, ep, ef);
            else {
              var em, eg = Object.keys(J);
              for (em = 0; em < eg.length; em++) {
                var ey = eg[em];
                decirc(J[ey], ey, em, ed, J, ep, ef)
              }
            }
            ed.pop()
          }
        }(J, "", 0, [], void 0, 0, ep);
      try {
        ef = 0 === ec.length ? JSON.stringify(J, ed, eh) : JSON.stringify(J, replaceGetterValues(ed), eh)
      } catch (J) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]")
      } finally {
        for (; 0 !== el.length;) {
          var ef, em = el.pop();
          4 === em.length ? Object.defineProperty(em[0], em[1], em[3]) : em[0][em[1]] = em[2]
        }
      }
      return ef
    }
    function setReplace(J, et, eo, ed) {
      var eh = Object.getOwnPropertyDescriptor(ed, eo);
      void 0 !== eh.get ? eh.configurable ? (Object.defineProperty(ed, eo, {
        value: J
      }),
        el.push([ed, eo, et, eh])) : ec.push([et, eo, J]) : (ed[eo] = J,
          el.push([ed, eo, et]))
    }
    function compareFunction(J, et) {
      return J < et ? -1 : J > et ? 1 : 0
    }
    function deterministicStringify(J, ed, eh, ep) {
      void 0 === ep && (ep = defaultOptions());
      var ef, em = function deterministicDecirc(J, ec, ed, eh, ep, ef, em) {
        if (ef += 1,
          "object" == typeof J && null !== J) {
          for (eg = 0; eg < eh.length; eg++)
            if (eh[eg] === J) {
              setReplace(eo, J, ec, ep);
              return
            }
          try {
            if ("function" == typeof J.toJSON)
              return
          } catch (J) {
            return
          }
          if (void 0 !== em.depthLimit && ef > em.depthLimit || void 0 !== em.edgesLimit && ed + 1 > em.edgesLimit) {
            setReplace(et, J, ec, ep);
            return
          }
          if (eh.push(J),
            Array.isArray(J))
            for (eg = 0; eg < J.length; eg++)
              deterministicDecirc(J[eg], eg, eg, eh, J, ef, em);
          else {
            var eg, ey = {}, eb = Object.keys(J).sort(compareFunction);
            for (eg = 0; eg < eb.length; eg++) {
              var ew = eb[eg];
              deterministicDecirc(J[ew], ew, eg, eh, J, ef, em),
                ey[ew] = J[ew]
            }
            if (void 0 === ep)
              return ey;
            el.push([ep, ec, J]),
              ep[ec] = ey
          }
          eh.pop()
        }
      }(J, "", 0, [], void 0, 0, ep) || J;
      try {
        ef = 0 === ec.length ? JSON.stringify(em, ed, eh) : JSON.stringify(em, replaceGetterValues(ed), eh)
      } catch (J) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]")
      } finally {
        for (; 0 !== el.length;) {
          var eg = el.pop();
          4 === eg.length ? Object.defineProperty(eg[0], eg[1], eg[3]) : eg[0][eg[1]] = eg[2]
        }
      }
      return ef
    }
    function replaceGetterValues(J) {
      return J = void 0 !== J ? J : function (J, et) {
        return et
      }
        ,
        function (et, eo) {
          if (ec.length > 0)
            for (var el = 0; el < ec.length; el++) {
              var ed = ec[el];
              if (ed[1] === et && ed[0] === eo) {
                eo = ed[2],
                  ec.splice(el, 1);
                break
              }
            }
          return J.call(this, et, eo)
        }
    }
  },
  92806: function (J) {
    "use strict";
    J.exports = function (J, et) {
      for (var eo = {}, el = Object.keys(J), ec = Array.isArray(et), ed = 0; ed < el.length; ed++) {
        var eh = el[ed]
          , ep = J[eh];
        (ec ? -1 !== et.indexOf(eh) : et(eh, ep, J)) && (eo[eh] = ep)
      }
      return eo
    }
  },
  8679: function (J, et, eo) {
    "use strict";
    var el = eo(21296)
      , ec = {
        childContextTypes: !0,
        contextType: !0,
        contextTypes: !0,
        defaultProps: !0,
        displayName: !0,
        getDefaultProps: !0,
        getDerivedStateFromError: !0,
        getDerivedStateFromProps: !0,
        mixins: !0,
        propTypes: !0,
        type: !0
      }
      , ed = {
        name: !0,
        length: !0,
        prototype: !0,
        caller: !0,
        callee: !0,
        arguments: !0,
        arity: !0
      }
      , eh = {
        $$typeof: !0,
        compare: !0,
        defaultProps: !0,
        displayName: !0,
        propTypes: !0,
        type: !0
      }
      , ep = {};
    function getStatics(J) {
      return el.isMemo(J) ? eh : ep[J.$$typeof] || ec
    }
    ep[el.ForwardRef] = {
      $$typeof: !0,
      render: !0,
      defaultProps: !0,
      displayName: !0,
      propTypes: !0
    },
      ep[el.Memo] = eh;
    var ef = Object.defineProperty
      , em = Object.getOwnPropertyNames
      , eg = Object.getOwnPropertySymbols
      , ey = Object.getOwnPropertyDescriptor
      , eb = Object.getPrototypeOf
      , ew = Object.prototype;
    J.exports = function hoistNonReactStatics(J, et, eo) {
      if ("string" != typeof et) {
        if (ew) {
          var el = eb(et);
          el && el !== ew && hoistNonReactStatics(J, el, eo)
        }
        var ec = em(et);
        eg && (ec = ec.concat(eg(et)));
        for (var eh = getStatics(J), ep = getStatics(et), e_ = 0; e_ < ec.length; ++e_) {
          var ex = ec[e_];
          if (!ed[ex] && !(eo && eo[ex]) && !(ep && ep[ex]) && !(eh && eh[ex])) {
            var eE = ey(et, ex);
            try {
              ef(J, ex, eE)
            } catch (J) { }
          }
        }
      }
      return J
    }
  },
  96103: function (J, et) {
    "use strict";
    /** @license React v16.13.1
* react-is.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
    var eo = "function" == typeof Symbol && Symbol.for
      , el = eo ? Symbol.for("react.element") : 60103
      , ec = eo ? Symbol.for("react.portal") : 60106
      , ed = eo ? Symbol.for("react.fragment") : 60107
      , eh = eo ? Symbol.for("react.strict_mode") : 60108
      , ep = eo ? Symbol.for("react.profiler") : 60114
      , ef = eo ? Symbol.for("react.provider") : 60109
      , em = eo ? Symbol.for("react.context") : 60110
      , eg = eo ? Symbol.for("react.async_mode") : 60111
      , ey = eo ? Symbol.for("react.concurrent_mode") : 60111
      , eb = eo ? Symbol.for("react.forward_ref") : 60112
      , ew = eo ? Symbol.for("react.suspense") : 60113
      , e_ = eo ? Symbol.for("react.suspense_list") : 60120
      , ex = eo ? Symbol.for("react.memo") : 60115
      , eE = eo ? Symbol.for("react.lazy") : 60116
      , eC = eo ? Symbol.for("react.block") : 60121
      , eS = eo ? Symbol.for("react.fundamental") : 60117
      , ek = eo ? Symbol.for("react.responder") : 60118
      , eT = eo ? Symbol.for("react.scope") : 60119;
    function z(J) {
      if ("object" == typeof J && null !== J) {
        var et = J.$$typeof;
        switch (et) {
          case el:
            switch (J = J.type) {
              case eg:
              case ey:
              case ed:
              case ep:
              case eh:
              case ew:
                return J;
              default:
                switch (J = J && J.$$typeof) {
                  case em:
                  case eb:
                  case eE:
                  case ex:
                  case ef:
                    return J;
                  default:
                    return et
                }
            }
          case ec:
            return et
        }
      }
    }
    function A(J) {
      return z(J) === ey
    }
    et.AsyncMode = eg,
      et.ConcurrentMode = ey,
      et.ContextConsumer = em,
      et.ContextProvider = ef,
      et.Element = el,
      et.ForwardRef = eb,
      et.Fragment = ed,
      et.Lazy = eE,
      et.Memo = ex,
      et.Portal = ec,
      et.Profiler = ep,
      et.StrictMode = eh,
      et.Suspense = ew,
      et.isAsyncMode = function (J) {
        return A(J) || z(J) === eg
      }
      ,
      et.isConcurrentMode = A,
      et.isContextConsumer = function (J) {
        return z(J) === em
      }
      ,
      et.isContextProvider = function (J) {
        return z(J) === ef
      }
      ,
      et.isElement = function (J) {
        return "object" == typeof J && null !== J && J.$$typeof === el
      }
      ,
      et.isForwardRef = function (J) {
        return z(J) === eb
      }
      ,
      et.isFragment = function (J) {
        return z(J) === ed
      }
      ,
      et.isLazy = function (J) {
        return z(J) === eE
      }
      ,
      et.isMemo = function (J) {
        return z(J) === ex
      }
      ,
      et.isPortal = function (J) {
        return z(J) === ec
      }
      ,
      et.isProfiler = function (J) {
        return z(J) === ep
      }
      ,
      et.isStrictMode = function (J) {
        return z(J) === eh
      }
      ,
      et.isSuspense = function (J) {
        return z(J) === ew
      }
      ,
      et.isValidElementType = function (J) {
        return "string" == typeof J || "function" == typeof J || J === ed || J === ey || J === ep || J === eh || J === ew || J === e_ || "object" == typeof J && null !== J && (J.$$typeof === eE || J.$$typeof === ex || J.$$typeof === ef || J.$$typeof === em || J.$$typeof === eb || J.$$typeof === eS || J.$$typeof === ek || J.$$typeof === eT || J.$$typeof === eC)
      }
      ,
      et.typeOf = z
  },
  21296: function (J, et, eo) {
    "use strict";
    J.exports = eo(96103)
  },
  80645: function (J, et) {
    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
    et.read = function (J, et, eo, el, ec) {
      var ed, eh, ep = 8 * ec - el - 1, ef = (1 << ep) - 1, em = ef >> 1, eg = -7, ey = eo ? ec - 1 : 0, eb = eo ? -1 : 1, ew = J[et + ey];
      for (ey += eb,
        ed = ew & (1 << -eg) - 1,
        ew >>= -eg,
        eg += ep; eg > 0; ed = 256 * ed + J[et + ey],
        ey += eb,
        eg -= 8)
        ;
      for (eh = ed & (1 << -eg) - 1,
        ed >>= -eg,
        eg += el; eg > 0; eh = 256 * eh + J[et + ey],
        ey += eb,
        eg -= 8)
        ;
      if (0 === ed)
        ed = 1 - em;
      else {
        if (ed === ef)
          return eh ? NaN : (ew ? -1 : 1) * (1 / 0);
        eh += Math.pow(2, el),
          ed -= em
      }
      return (ew ? -1 : 1) * eh * Math.pow(2, ed - el)
    }
      ,
      et.write = function (J, et, eo, el, ec, ed) {
        var eh, ep, ef, em = 8 * ed - ec - 1, eg = (1 << em) - 1, ey = eg >> 1, eb = 23 === ec ? 5960464477539062e-23 : 0, ew = el ? 0 : ed - 1, e_ = el ? 1 : -1, ex = et < 0 || 0 === et && 1 / et < 0 ? 1 : 0;
        for (isNaN(et = Math.abs(et)) || et === 1 / 0 ? (ep = isNaN(et) ? 1 : 0,
          eh = eg) : (eh = Math.floor(Math.log(et) / Math.LN2),
            et * (ef = Math.pow(2, -eh)) < 1 && (eh--,
              ef *= 2),
            eh + ey >= 1 ? et += eb / ef : et += eb * Math.pow(2, 1 - ey),
            et * ef >= 2 && (eh++,
              ef /= 2),
            eh + ey >= eg ? (ep = 0,
              eh = eg) : eh + ey >= 1 ? (ep = (et * ef - 1) * Math.pow(2, ec),
                eh += ey) : (ep = et * Math.pow(2, ey - 1) * Math.pow(2, ec),
                  eh = 0)); ec >= 8; J[eo + ew] = 255 & ep,
                  ew += e_,
                  ep /= 256,
          ec -= 8)
          ;
        for (eh = eh << ec | ep,
          em += ec; em > 0; J[eo + ew] = 255 & eh,
          ew += e_,
          eh /= 256,
          em -= 8)
          ;
        J[eo + ew - e_] |= 128 * ex
      }
  },
  35717: function (J) {
    "function" == typeof Object.create ? J.exports = function (J, et) {
      et && (J.super_ = et,
        J.prototype = Object.create(et.prototype, {
          constructor: {
            value: J,
            enumerable: !1,
            writable: !0,
            configurable: !0
          }
        }))
    }
      : J.exports = function (J, et) {
        if (et) {
          J.super_ = et;
          var TempCtor = function () { };
          TempCtor.prototype = et.prototype,
            J.prototype = new TempCtor,
            J.prototype.constructor = J
        }
      }
  },
  17398: function (J, et, eo) {
    "use strict";
    var el = this && this.__importDefault || function (J) {
      return J && J.__esModule ? J : {
        default: J
      }
    }
      ;
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.JsonRpcEngine = void 0;
    let ec = el(eo(60759))
      , ed = eo(79826);
    let JsonRpcEngine = class JsonRpcEngine extends ec.default {
      constructor() {
        super(),
          this._middleware = []
      }
      push(J) {
        this._middleware.push(J)
      }
      handle(J, et) {
        if (et && "function" != typeof et)
          throw Error('"callback" must be a function if provided.');
        return Array.isArray(J) ? et ? this._handleBatch(J, et) : this._handleBatch(J) : et ? this._handle(J, et) : this._promiseHandle(J)
      }
      asMiddleware() {
        return async (J, et, eo, el) => {
          try {
            let [ec, ed, eh] = await JsonRpcEngine._runAllMiddleware(J, et, this._middleware);
            if (ed)
              return await JsonRpcEngine._runReturnHandlers(eh),
                el(ec);
            return eo(async J => {
              try {
                await JsonRpcEngine._runReturnHandlers(eh)
              } catch (et) {
                return J(et)
              }
              return J()
            }
            )
          } catch (J) {
            return el(J)
          }
        }
      }
      async _handleBatch(J, et) {
        try {
          let eo = await Promise.all(J.map(this._promiseHandle.bind(this)));
          if (et)
            return et(null, eo);
          return eo
        } catch (J) {
          if (et)
            return et(J);
          throw J
        }
      }
      _promiseHandle(J) {
        return new Promise(et => {
          this._handle(J, (J, eo) => {
            et(eo)
          }
          )
        }
        )
      }
      async _handle(J, et) {
        if (!J || Array.isArray(J) || "object" != typeof J) {
          let eo = new ed.EthereumRpcError(ed.errorCodes.rpc.invalidRequest, `Requests must be plain objects. Received: ${typeof J}`, {
            request: J
          });
          return et(eo, {
            id: void 0,
            jsonrpc: "2.0",
            error: eo
          })
        }
        if ("string" != typeof J.method) {
          let eo = new ed.EthereumRpcError(ed.errorCodes.rpc.invalidRequest, `Must specify a string method. Received: ${typeof J.method}`, {
            request: J
          });
          return et(eo, {
            id: J.id,
            jsonrpc: "2.0",
            error: eo
          })
        }
        let eo = Object.assign({}, J)
          , el = {
            id: eo.id,
            jsonrpc: eo.jsonrpc
          }
          , ec = null;
        try {
          await this._processRequest(eo, el)
        } catch (J) {
          ec = J
        }
        return ec && (delete el.result,
          el.error || (el.error = ed.serializeError(ec))),
          et(ec, el)
      }
      async _processRequest(J, et) {
        let [eo, el, ec] = await JsonRpcEngine._runAllMiddleware(J, et, this._middleware);
        if (JsonRpcEngine._checkForCompletion(J, et, el),
          await JsonRpcEngine._runReturnHandlers(ec),
          eo)
          throw eo
      }
      static async _runAllMiddleware(J, et, eo) {
        let el = []
          , ec = null
          , ed = !1;
        for (let eh of eo)
          if ([ec, ed] = await JsonRpcEngine._runMiddleware(J, et, eh, el),
            ed)
            break;
        return [ec, ed, el.reverse()]
      }
      static _runMiddleware(J, et, eo, el) {
        return new Promise(ec => {
          let end = J => {
            let eo = J || et.error;
            eo && (et.error = ed.serializeError(eo)),
              ec([eo, !0])
          }
            ;
          try {
            eo(J, et, eo => {
              et.error ? end(et.error) : (eo && ("function" != typeof eo && end(new ed.EthereumRpcError(ed.errorCodes.rpc.internal, `JsonRpcEngine: "next" return handlers must be functions. Received "${typeof eo}" for request:
${jsonify(J)}`, {
                request: J
              })),
                el.push(eo)),
                ec([null, !1]))
            }
              , end)
          } catch (J) {
            end(J)
          }
        }
        )
      }
      static async _runReturnHandlers(J) {
        for (let et of J)
          await new Promise((J, eo) => {
            et(et => et ? eo(et) : J())
          }
          )
      }
      static _checkForCompletion(J, et, eo) {
        if (!("result" in et) && !("error" in et))
          throw new ed.EthereumRpcError(ed.errorCodes.rpc.internal, `JsonRpcEngine: Response has no error or result for request:
${jsonify(J)}`, {
            request: J
          });
        if (!eo)
          throw new ed.EthereumRpcError(ed.errorCodes.rpc.internal, `JsonRpcEngine: Nothing ended request:
${jsonify(J)}`, {
            request: J
          })
      }
    }
      ;
    function jsonify(J) {
      return JSON.stringify(J, null, 2)
    }
    et.JsonRpcEngine = JsonRpcEngine
  },
  31841: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.createAsyncMiddleware = void 0,
      et.createAsyncMiddleware = function (J) {
        return async (et, eo, el, ec) => {
          let ed;
          let eh = new Promise(J => {
            ed = J
          }
          )
            , ep = null
            , ef = !1
            , asyncNext = async () => {
              ef = !0,
                el(J => {
                  ep = J,
                    ed()
                }
                ),
                await eh
            }
            ;
          try {
            await J(et, eo, asyncNext),
              ef ? (await eh,
                ep(null)) : ec(null)
          } catch (J) {
            ep ? ep(J) : ec(J)
          }
        }
      }
  },
  48508: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.createScaffoldMiddleware = void 0,
      et.createScaffoldMiddleware = function (J) {
        return (et, eo, el, ec) => {
          let ed = J[et.method];
          return void 0 === ed ? el() : "function" == typeof ed ? ed(et, eo, el, ec) : (eo.result = ed,
            ec())
        }
      }
  },
  33107: function (J, et) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.getUniqueId = void 0;
    let eo = Math.floor(4294967295 * Math.random());
    et.getUniqueId = function () {
      return eo = (eo + 1) % 4294967295
    }
  },
  85086: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.createIdRemapMiddleware = void 0;
    let el = eo(33107);
    et.createIdRemapMiddleware = function () {
      return (J, et, eo, ec) => {
        let ed = J.id
          , eh = el.getUniqueId();
        J.id = eh,
          et.id = eh,
          eo(eo => {
            J.id = ed,
              et.id = ed,
              eo()
          }
          )
      }
    }
  },
  88625: function (J, et, eo) {
    "use strict";
    var el = this && this.__createBinding || (Object.create ? function (J, et, eo, el) {
      void 0 === el && (el = eo),
        Object.defineProperty(J, el, {
          enumerable: !0,
          get: function () {
            return et[eo]
          }
        })
    }
      : function (J, et, eo, el) {
        void 0 === el && (el = eo),
          J[el] = et[eo]
      }
    )
      , ec = this && this.__exportStar || function (J, et) {
        for (var eo in J)
          "default" === eo || Object.prototype.hasOwnProperty.call(et, eo) || el(et, J, eo)
      }
      ;
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      ec(eo(85086), et),
      ec(eo(31841), et),
      ec(eo(48508), et),
      ec(eo(33107), et),
      ec(eo(17398), et),
      ec(eo(79962), et)
  },
  79962: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      et.mergeMiddleware = void 0;
    let el = eo(17398);
    et.mergeMiddleware = function (J) {
      let et = new el.JsonRpcEngine;
      return J.forEach(J => et.push(J)),
        et.asMiddleware()
    }
  },
  60759: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    });
    let el = eo(17187);
    function safeApply(J, et, eo) {
      try {
        Reflect.apply(J, et, eo)
      } catch (J) {
        setTimeout(() => {
          throw J
        }
        )
      }
    }
    let SafeEventEmitter = class SafeEventEmitter extends el.EventEmitter {
      emit(J, ...et) {
        let eo = "error" === J
          , el = this._events;
        if (void 0 !== el)
          eo = eo && void 0 === el.error;
        else if (!eo)
          return !1;
        if (eo) {
          let J;
          if (et.length > 0 && ([J] = et),
            J instanceof Error)
            throw J;
          let eo = Error(`Unhandled error.${J ? ` (${J.message})` : ""}`);
          throw eo.context = J,
          eo
        }
        let ec = el[J];
        if (void 0 === ec)
          return !1;
        if ("function" == typeof ec)
          safeApply(ec, this, et);
        else {
          let J = ec.length
            , eo = function (J) {
              let et = J.length
                , eo = Array(et);
              for (let el = 0; el < et; el += 1)
                eo[el] = J[el];
              return eo
            }(ec);
          for (let el = 0; el < J; el += 1)
            safeApply(eo[el], this, et)
        }
        return !0
      }
    }
      ;
    et.default = SafeEventEmitter
  },
  23420: function (J) {
    J.exports = function (J) {
      var et = (J = J || {}).max || Number.MAX_SAFE_INTEGER
        , eo = void 0 !== J.start ? J.start : Math.floor(Math.random() * et);
      return function () {
        return eo %= et,
          eo++
      }
    }
  },
  95811: function (J, et, eo) {
    J.exports = eo(26066)(eo(79653))
  },
  26066: function (J, et, eo) {
    let el = eo(37016)
      , ec = eo(5675);
    J.exports = function (J) {
      let et = el(J)
        , eo = ec(J);
      return function (J, el) {
        let ec = "string" == typeof J ? J.toLowerCase() : J;
        switch (ec) {
          case "keccak224":
            return new et(1152, 448, null, 224, el);
          case "keccak256":
            return new et(1088, 512, null, 256, el);
          case "keccak384":
            return new et(832, 768, null, 384, el);
          case "keccak512":
            return new et(576, 1024, null, 512, el);
          case "sha3-224":
            return new et(1152, 448, 6, 224, el);
          case "sha3-256":
            return new et(1088, 512, 6, 256, el);
          case "sha3-384":
            return new et(832, 768, 6, 384, el);
          case "sha3-512":
            return new et(576, 1024, 6, 512, el);
          case "shake128":
            return new eo(1344, 256, 31, el);
          case "shake256":
            return new eo(1088, 512, 31, el);
          default:
            throw Error("Invald algorithm: " + J)
        }
      }
    }
  },
  37016: function (J, et, eo) {
    var el = eo(48764).Buffer;
    let { Transform: ec } = eo(35092);
    J.exports = J => class Keccak extends ec {
      constructor(et, eo, el, ec, ed) {
        super(ed),
          this._rate = et,
          this._capacity = eo,
          this._delimitedSuffix = el,
          this._hashBitLength = ec,
          this._options = ed,
          this._state = new J,
          this._state.initialize(et, eo),
          this._finalized = !1
      }
      _transform(J, et, eo) {
        let el = null;
        try {
          this.update(J, et)
        } catch (J) {
          el = J
        }
        eo(el)
      }
      _flush(J) {
        let et = null;
        try {
          this.push(this.digest())
        } catch (J) {
          et = J
        }
        J(et)
      }
      update(J, et) {
        if (!el.isBuffer(J) && "string" != typeof J)
          throw TypeError("Data must be a string or a buffer");
        if (this._finalized)
          throw Error("Digest already called");
        return el.isBuffer(J) || (J = el.from(J, et)),
          this._state.absorb(J),
          this
      }
      digest(J) {
        if (this._finalized)
          throw Error("Digest already called");
        this._finalized = !0,
          this._delimitedSuffix && this._state.absorbLastFewBits(this._delimitedSuffix);
        let et = this._state.squeeze(this._hashBitLength / 8);
        return void 0 !== J && (et = et.toString(J)),
          this._resetState(),
          et
      }
      _resetState() {
        return this._state.initialize(this._rate, this._capacity),
          this
      }
      _clone() {
        let J = new Keccak(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);
        return this._state.copy(J._state),
          J._finalized = this._finalized,
          J
      }
    }
  },
  5675: function (J, et, eo) {
    var el = eo(48764).Buffer;
    let { Transform: ec } = eo(35092);
    J.exports = J => class Shake extends ec {
      constructor(et, eo, el, ec) {
        super(ec),
          this._rate = et,
          this._capacity = eo,
          this._delimitedSuffix = el,
          this._options = ec,
          this._state = new J,
          this._state.initialize(et, eo),
          this._finalized = !1
      }
      _transform(J, et, eo) {
        let el = null;
        try {
          this.update(J, et)
        } catch (J) {
          el = J
        }
        eo(el)
      }
      _flush() { }
      _read(J) {
        this.push(this.squeeze(J))
      }
      update(J, et) {
        if (!el.isBuffer(J) && "string" != typeof J)
          throw TypeError("Data must be a string or a buffer");
        if (this._finalized)
          throw Error("Squeeze already called");
        return el.isBuffer(J) || (J = el.from(J, et)),
          this._state.absorb(J),
          this
      }
      squeeze(J, et) {
        this._finalized || (this._finalized = !0,
          this._state.absorbLastFewBits(this._delimitedSuffix));
        let eo = this._state.squeeze(J);
        return void 0 !== et && (eo = eo.toString(et)),
          eo
      }
      _resetState() {
        return this._state.initialize(this._rate, this._capacity),
          this
      }
      _clone() {
        let J = new Shake(this._rate, this._capacity, this._delimitedSuffix, this._options);
        return this._state.copy(J._state),
          J._finalized = this._finalized,
          J
      }
    }
  },
  34040: function (J, et) {
    let eo = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
    et.p1600 = function (J) {
      for (let et = 0; et < 24; ++et) {
        let el = J[0] ^ J[10] ^ J[20] ^ J[30] ^ J[40]
          , ec = J[1] ^ J[11] ^ J[21] ^ J[31] ^ J[41]
          , ed = J[2] ^ J[12] ^ J[22] ^ J[32] ^ J[42]
          , eh = J[3] ^ J[13] ^ J[23] ^ J[33] ^ J[43]
          , ep = J[4] ^ J[14] ^ J[24] ^ J[34] ^ J[44]
          , ef = J[5] ^ J[15] ^ J[25] ^ J[35] ^ J[45]
          , em = J[6] ^ J[16] ^ J[26] ^ J[36] ^ J[46]
          , eg = J[7] ^ J[17] ^ J[27] ^ J[37] ^ J[47]
          , ey = J[8] ^ J[18] ^ J[28] ^ J[38] ^ J[48]
          , eb = J[9] ^ J[19] ^ J[29] ^ J[39] ^ J[49]
          , ew = ey ^ (ed << 1 | eh >>> 31)
          , e_ = eb ^ (eh << 1 | ed >>> 31)
          , ex = J[0] ^ ew
          , eE = J[1] ^ e_
          , eC = J[10] ^ ew
          , eS = J[11] ^ e_
          , ek = J[20] ^ ew
          , eT = J[21] ^ e_
          , eA = J[30] ^ ew
          , eP = J[31] ^ e_
          , eR = J[40] ^ ew
          , eI = J[41] ^ e_;
        ew = el ^ (ep << 1 | ef >>> 31),
          e_ = ec ^ (ef << 1 | ep >>> 31);
        let eO = J[2] ^ ew
          , eN = J[3] ^ e_
          , eM = J[12] ^ ew
          , eD = J[13] ^ e_
          , ej = J[22] ^ ew
          , eL = J[23] ^ e_
          , e$ = J[32] ^ ew
          , eB = J[33] ^ e_
          , eF = J[42] ^ ew
          , eU = J[43] ^ e_;
        ew = ed ^ (em << 1 | eg >>> 31),
          e_ = eh ^ (eg << 1 | em >>> 31);
        let ez = J[4] ^ ew
          , eH = J[5] ^ e_
          , eV = J[14] ^ ew
          , eW = J[15] ^ e_
          , eZ = J[24] ^ ew
          , eG = J[25] ^ e_
          , eY = J[34] ^ ew
          , eK = J[35] ^ e_
          , eJ = J[44] ^ ew
          , eQ = J[45] ^ e_;
        ew = ep ^ (ey << 1 | eb >>> 31),
          e_ = ef ^ (eb << 1 | ey >>> 31);
        let eX = J[6] ^ ew
          , e0 = J[7] ^ e_
          , e1 = J[16] ^ ew
          , e2 = J[17] ^ e_
          , e3 = J[26] ^ ew
          , e5 = J[27] ^ e_
          , e6 = J[36] ^ ew
          , e4 = J[37] ^ e_
          , e8 = J[46] ^ ew
          , e7 = J[47] ^ e_;
        ew = em ^ (el << 1 | ec >>> 31),
          e_ = eg ^ (ec << 1 | el >>> 31);
        let e9 = J[8] ^ ew
          , tn = J[9] ^ e_
          , to = J[18] ^ ew
          , ta = J[19] ^ e_
          , tl = J[28] ^ ew
          , tc = J[29] ^ e_
          , td = J[38] ^ ew
          , th = J[39] ^ e_
          , tp = J[48] ^ ew
          , tf = J[49] ^ e_
          , tm = eS << 4 | eC >>> 28
          , tg = eC << 4 | eS >>> 28
          , ty = ek << 3 | eT >>> 29
          , tb = eT << 3 | ek >>> 29
          , tw = eP << 9 | eA >>> 23
          , t_ = eA << 9 | eP >>> 23
          , tx = eR << 18 | eI >>> 14
          , tE = eI << 18 | eR >>> 14
          , tC = eO << 1 | eN >>> 31
          , tS = eN << 1 | eO >>> 31
          , tk = eD << 12 | eM >>> 20
          , tT = eM << 12 | eD >>> 20
          , tA = ej << 10 | eL >>> 22
          , tP = eL << 10 | ej >>> 22
          , tR = eB << 13 | e$ >>> 19
          , tI = e$ << 13 | eB >>> 19
          , tO = eF << 2 | eU >>> 30
          , tN = eU << 2 | eF >>> 30
          , tM = eH << 30 | ez >>> 2
          , tD = ez << 30 | eH >>> 2
          , tj = eV << 6 | eW >>> 26
          , tL = eW << 6 | eV >>> 26
          , t$ = eG << 11 | eZ >>> 21
          , tB = eZ << 11 | eG >>> 21
          , tF = eY << 15 | eK >>> 17
          , tU = eK << 15 | eY >>> 17
          , tz = eQ << 29 | eJ >>> 3
          , tH = eJ << 29 | eQ >>> 3
          , tV = eX << 28 | e0 >>> 4
          , tW = e0 << 28 | eX >>> 4
          , tq = e2 << 23 | e1 >>> 9
          , tZ = e1 << 23 | e2 >>> 9
          , tG = e3 << 25 | e5 >>> 7
          , tY = e5 << 25 | e3 >>> 7
          , tK = e6 << 21 | e4 >>> 11
          , tJ = e4 << 21 | e6 >>> 11
          , tQ = e7 << 24 | e8 >>> 8
          , tX = e8 << 24 | e7 >>> 8
          , t0 = e9 << 27 | tn >>> 5
          , t1 = tn << 27 | e9 >>> 5
          , t2 = to << 20 | ta >>> 12
          , t3 = ta << 20 | to >>> 12
          , t5 = tc << 7 | tl >>> 25
          , t6 = tl << 7 | tc >>> 25
          , t4 = td << 8 | th >>> 24
          , t8 = th << 8 | td >>> 24
          , t7 = tp << 14 | tf >>> 18
          , t9 = tf << 14 | tp >>> 18;
        J[0] = ex ^ ~tk & t$,
          J[1] = eE ^ ~tT & tB,
          J[10] = tV ^ ~t2 & ty,
          J[11] = tW ^ ~t3 & tb,
          J[20] = tC ^ ~tj & tG,
          J[21] = tS ^ ~tL & tY,
          J[30] = t0 ^ ~tm & tA,
          J[31] = t1 ^ ~tg & tP,
          J[40] = tM ^ ~tq & t5,
          J[41] = tD ^ ~tZ & t6,
          J[2] = tk ^ ~t$ & tK,
          J[3] = tT ^ ~tB & tJ,
          J[12] = t2 ^ ~ty & tR,
          J[13] = t3 ^ ~tb & tI,
          J[22] = tj ^ ~tG & t4,
          J[23] = tL ^ ~tY & t8,
          J[32] = tm ^ ~tA & tF,
          J[33] = tg ^ ~tP & tU,
          J[42] = tq ^ ~t5 & tw,
          J[43] = tZ ^ ~t6 & t_,
          J[4] = t$ ^ ~tK & t7,
          J[5] = tB ^ ~tJ & t9,
          J[14] = ty ^ ~tR & tz,
          J[15] = tb ^ ~tI & tH,
          J[24] = tG ^ ~t4 & tx,
          J[25] = tY ^ ~t8 & tE,
          J[34] = tA ^ ~tF & tQ,
          J[35] = tP ^ ~tU & tX,
          J[44] = t5 ^ ~tw & tO,
          J[45] = t6 ^ ~t_ & tN,
          J[6] = tK ^ ~t7 & ex,
          J[7] = tJ ^ ~t9 & eE,
          J[16] = tR ^ ~tz & tV,
          J[17] = tI ^ ~tH & tW,
          J[26] = t4 ^ ~tx & tC,
          J[27] = t8 ^ ~tE & tS,
          J[36] = tF ^ ~tQ & t0,
          J[37] = tU ^ ~tX & t1,
          J[46] = tw ^ ~tO & tM,
          J[47] = t_ ^ ~tN & tD,
          J[8] = t7 ^ ~ex & tk,
          J[9] = t9 ^ ~eE & tT,
          J[18] = tz ^ ~tV & t2,
          J[19] = tH ^ ~tW & t3,
          J[28] = tx ^ ~tC & tj,
          J[29] = tE ^ ~tS & tL,
          J[38] = tQ ^ ~t0 & tm,
          J[39] = tX ^ ~t1 & tg,
          J[48] = tO ^ ~tM & tq,
          J[49] = tN ^ ~tD & tZ,
          J[0] ^= eo[2 * et],
          J[1] ^= eo[2 * et + 1]
      }
    }
  },
  79653: function (J, et, eo) {
    var el = eo(48764).Buffer;
    let ec = eo(34040);
    function Keccak() {
      this.state = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        this.blockSize = null,
        this.count = 0,
        this.squeezing = !1
    }
    Keccak.prototype.initialize = function (J, et) {
      for (let J = 0; J < 50; ++J)
        this.state[J] = 0;
      this.blockSize = J / 8,
        this.count = 0,
        this.squeezing = !1
    }
      ,
      Keccak.prototype.absorb = function (J) {
        for (let et = 0; et < J.length; ++et)
          this.state[~~(this.count / 4)] ^= J[et] << 8 * (this.count % 4),
            this.count += 1,
            this.count === this.blockSize && (ec.p1600(this.state),
              this.count = 0)
      }
      ,
      Keccak.prototype.absorbLastFewBits = function (J) {
        this.state[~~(this.count / 4)] ^= J << 8 * (this.count % 4),
          (128 & J) != 0 && this.count === this.blockSize - 1 && ec.p1600(this.state),
          this.state[~~((this.blockSize - 1) / 4)] ^= 128 << 8 * ((this.blockSize - 1) % 4),
          ec.p1600(this.state),
          this.count = 0,
          this.squeezing = !0
      }
      ,
      Keccak.prototype.squeeze = function (J) {
        this.squeezing || this.absorbLastFewBits(1);
        let et = el.alloc(J);
        for (let eo = 0; eo < J; ++eo)
          et[eo] = this.state[~~(this.count / 4)] >>> 8 * (this.count % 4) & 255,
            this.count += 1,
            this.count === this.blockSize && (ec.p1600(this.state),
              this.count = 0);
        return et
      }
      ,
      Keccak.prototype.copy = function (J) {
        for (let et = 0; et < 50; ++et)
          J.state[et] = this.state[et];
        J.blockSize = this.blockSize,
          J.count = this.count,
          J.squeezing = this.squeezing
      }
      ,
      J.exports = Keccak
  },
  97630: function (J) {
    "use strict";
    var et = {};
    function createErrorType(J, eo, el) {
      el || (el = Error);
      var ec = function (J) {
        function NodeError(et, el, ec) {
          return J.call(this, "string" == typeof eo ? eo : eo(et, el, ec)) || this
        }
        return NodeError.prototype = Object.create(J.prototype),
          NodeError.prototype.constructor = NodeError,
          NodeError.__proto__ = J,
          NodeError
      }(el);
      ec.prototype.name = el.name,
        ec.prototype.code = J,
        et[J] = ec
    }
    function oneOf(J, et) {
      if (!Array.isArray(J))
        return "of ".concat(et, " ").concat(String(J));
      var eo = J.length;
      return (J = J.map(function (J) {
        return String(J)
      }),
        eo > 2) ? "one of ".concat(et, " ").concat(J.slice(0, eo - 1).join(", "), ", or ") + J[eo - 1] : 2 === eo ? "one of ".concat(et, " ").concat(J[0], " or ").concat(J[1]) : "of ".concat(et, " ").concat(J[0])
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function (J, et) {
      return 'The value "' + et + '" is invalid for option "' + J + '"'
    }, TypeError),
      createErrorType("ERR_INVALID_ARG_TYPE", function (J, et, eo) {
        if ("string" == typeof et && (el = "not ",
          et.substr(!ec || ec < 0 ? 0 : +ec, el.length) === el) ? (ef = "must not be",
            et = et.replace(/^not /, "")) : ef = "must be",
          ed = " argument",
          (void 0 === eh || eh > J.length) && (eh = J.length),
          J.substring(eh - ed.length, eh) === ed)
          em = "The ".concat(J, " ").concat(ef, " ").concat(oneOf(et, "type"));
        else {
          var el, ec, ed, eh, ep, ef, em, eg = ("number" != typeof ep && (ep = 0),
            ep + 1 > J.length || -1 === J.indexOf(".", ep)) ? "argument" : "property";
          em = 'The "'.concat(J, '" ').concat(eg, " ").concat(ef, " ").concat(oneOf(et, "type"))
        }
        return em + ". Received type ".concat(typeof eo)
      }, TypeError),
      createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"),
      createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function (J) {
        return "The " + J + " method is not implemented"
      }),
      createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close"),
      createErrorType("ERR_STREAM_DESTROYED", function (J) {
        return "Cannot call " + J + " after a stream was destroyed"
      }),
      createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"),
      createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"),
      createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end"),
      createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError),
      createErrorType("ERR_UNKNOWN_ENCODING", function (J) {
        return "Unknown encoding: " + J
      }, TypeError),
      createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"),
      J.exports.q = et
  },
  37735: function (J, et, eo) {
    "use strict";
    var el = eo(83454)
      , ec = Object.keys || function (J) {
        var et = [];
        for (var eo in J)
          et.push(eo);
        return et
      }
      ;
    J.exports = Duplex;
    var ed = eo(83875)
      , eh = eo(69843);
    eo(35717)(Duplex, ed);
    for (var ep = ec(eh.prototype), ef = 0; ef < ep.length; ef++) {
      var em = ep[ef];
      Duplex.prototype[em] || (Duplex.prototype[em] = eh.prototype[em])
    }
    function Duplex(J) {
      if (!(this instanceof Duplex))
        return new Duplex(J);
      ed.call(this, J),
        eh.call(this, J),
        this.allowHalfOpen = !0,
        J && (!1 === J.readable && (this.readable = !1),
          !1 === J.writable && (this.writable = !1),
          !1 === J.allowHalfOpen && (this.allowHalfOpen = !1,
            this.once("end", onend)))
    }
    function onend() {
      this._writableState.ended || el.nextTick(onEndNT, this)
    }
    function onEndNT(J) {
      J.end()
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      enumerable: !1,
      get: function () {
        return this._writableState.highWaterMark
      }
    }),
      Object.defineProperty(Duplex.prototype, "writableBuffer", {
        enumerable: !1,
        get: function () {
          return this._writableState && this._writableState.getBuffer()
        }
      }),
      Object.defineProperty(Duplex.prototype, "writableLength", {
        enumerable: !1,
        get: function () {
          return this._writableState.length
        }
      }),
      Object.defineProperty(Duplex.prototype, "destroyed", {
        enumerable: !1,
        get: function () {
          return void 0 !== this._readableState && void 0 !== this._writableState && this._readableState.destroyed && this._writableState.destroyed
        },
        set: function (J) {
          void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = J,
            this._writableState.destroyed = J)
        }
      })
  },
  36485: function (J, et, eo) {
    "use strict";
    J.exports = PassThrough;
    var el = eo(96311);
    function PassThrough(J) {
      if (!(this instanceof PassThrough))
        return new PassThrough(J);
      el.call(this, J)
    }
    eo(35717)(PassThrough, el),
      PassThrough.prototype._transform = function (J, et, eo) {
        eo(null, J)
      }
  },
  83875: function (J, et, eo) {
    "use strict";
    var el, ec, ed, eh, ep, ef = eo(83454);
    J.exports = Readable,
      Readable.ReadableState = ReadableState,
      eo(17187).EventEmitter;
    var EElistenerCount = function (J, et) {
      return J.listeners(et).length
    }
      , em = eo(89868)
      , eg = eo(48764).Buffer
      , ey = (void 0 !== eo.g ? eo.g : "undefined" != typeof window ? window : "undefined" != typeof self ? self : {}).Uint8Array || function () { }
      , eb = eo(46586);
    ec = eb && eb.debuglog ? eb.debuglog("stream") : function () { }
      ;
    var ew = eo(77983)
      , e_ = eo(73505)
      , ex = eo(65482).getHighWaterMark
      , eE = eo(97630).q
      , eC = eE.ERR_INVALID_ARG_TYPE
      , eS = eE.ERR_STREAM_PUSH_AFTER_EOF
      , ek = eE.ERR_METHOD_NOT_IMPLEMENTED
      , eT = eE.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    eo(35717)(Readable, em);
    var eA = e_.errorOrDestroy
      , eP = ["error", "close", "destroy", "pause", "resume"];
    function ReadableState(J, et, ec) {
      el = el || eo(37735),
        J = J || {},
        "boolean" != typeof ec && (ec = et instanceof el),
        this.objectMode = !!J.objectMode,
        ec && (this.objectMode = this.objectMode || !!J.readableObjectMode),
        this.highWaterMark = ex(this, J, "readableHighWaterMark", ec),
        this.buffer = new ew,
        this.length = 0,
        this.pipes = null,
        this.pipesCount = 0,
        this.flowing = null,
        this.ended = !1,
        this.endEmitted = !1,
        this.reading = !1,
        this.sync = !0,
        this.needReadable = !1,
        this.emittedReadable = !1,
        this.readableListening = !1,
        this.resumeScheduled = !1,
        this.paused = !0,
        this.emitClose = !1 !== J.emitClose,
        this.autoDestroy = !!J.autoDestroy,
        this.destroyed = !1,
        this.defaultEncoding = J.defaultEncoding || "utf8",
        this.awaitDrain = 0,
        this.readingMore = !1,
        this.decoder = null,
        this.encoding = null,
        J.encoding && (ed || (ed = eo(92809).s),
          this.decoder = new ed(J.encoding),
          this.encoding = J.encoding)
    }
    function Readable(J) {
      if (el = el || eo(37735),
        !(this instanceof Readable))
        return new Readable(J);
      var et = this instanceof el;
      this._readableState = new ReadableState(J, this, et),
        this.readable = !0,
        J && ("function" == typeof J.read && (this._read = J.read),
          "function" == typeof J.destroy && (this._destroy = J.destroy)),
        em.call(this)
    }
    function readableAddChunk(J, et, eo, el, ed) {
      ec("readableAddChunk", et);
      var eh, ep, ef, em, eb, ew = J._readableState;
      if (null === et)
        ew.reading = !1,
          function (J, et) {
            if (ec("onEofChunk"),
              !et.ended) {
              if (et.decoder) {
                var eo = et.decoder.end();
                eo && eo.length && (et.buffer.push(eo),
                  et.length += et.objectMode ? 1 : eo.length)
              }
              et.ended = !0,
                et.sync ? emitReadable(J) : (et.needReadable = !1,
                  et.emittedReadable || (et.emittedReadable = !0,
                    emitReadable_(J)))
            }
          }(J, ew);
      else {
        if (ed || (eh = ew,
          ep = et,
          eg.isBuffer(ep) || ep instanceof ey || "string" == typeof ep || void 0 === ep || eh.objectMode || (ef = new eC("chunk", ["string", "Buffer", "Uint8Array"], ep)),
          eb = ef),
          eb)
          eA(J, eb);
        else if (ew.objectMode || et && et.length > 0) {
          if ("string" == typeof et || ew.objectMode || Object.getPrototypeOf(et) === eg.prototype || (em = et,
            et = eg.from(em)),
            el)
            ew.endEmitted ? eA(J, new eT) : addChunk(J, ew, et, !0);
          else if (ew.ended)
            eA(J, new eS);
          else {
            if (ew.destroyed)
              return !1;
            ew.reading = !1,
              ew.decoder && !eo ? (et = ew.decoder.write(et),
                ew.objectMode || 0 !== et.length ? addChunk(J, ew, et, !1) : maybeReadMore(J, ew)) : addChunk(J, ew, et, !1)
          }
        } else
          el || (ew.reading = !1,
            maybeReadMore(J, ew))
      }
      return !ew.ended && (ew.length < ew.highWaterMark || 0 === ew.length)
    }
    function addChunk(J, et, eo, el) {
      et.flowing && 0 === et.length && !et.sync ? (et.awaitDrain = 0,
        J.emit("data", eo)) : (et.length += et.objectMode ? 1 : eo.length,
          el ? et.buffer.unshift(eo) : et.buffer.push(eo),
          et.needReadable && emitReadable(J)),
        maybeReadMore(J, et)
    }
    function howMuchToRead(J, et) {
      if (J <= 0 || 0 === et.length && et.ended)
        return 0;
      if (et.objectMode)
        return 1;
      if (J != J)
        return et.flowing && et.length ? et.buffer.head.data.length : et.length;
      if (J > et.highWaterMark) {
        var eo;
        et.highWaterMark = ((eo = J) >= 1073741824 ? eo = 1073741824 : (eo--,
          eo |= eo >>> 1,
          eo |= eo >>> 2,
          eo |= eo >>> 4,
          eo |= eo >>> 8,
          eo |= eo >>> 16,
          eo++),
          eo)
      }
      return J <= et.length ? J : et.ended ? et.length : (et.needReadable = !0,
        0)
    }
    function emitReadable(J) {
      var et = J._readableState;
      ec("emitReadable", et.needReadable, et.emittedReadable),
        et.needReadable = !1,
        et.emittedReadable || (ec("emitReadable", et.flowing),
          et.emittedReadable = !0,
          ef.nextTick(emitReadable_, J))
    }
    function emitReadable_(J) {
      var et = J._readableState;
      ec("emitReadable_", et.destroyed, et.length, et.ended),
        !et.destroyed && (et.length || et.ended) && (J.emit("readable"),
          et.emittedReadable = !1),
        et.needReadable = !et.flowing && !et.ended && et.length <= et.highWaterMark,
        flow(J)
    }
    function maybeReadMore(J, et) {
      et.readingMore || (et.readingMore = !0,
        ef.nextTick(maybeReadMore_, J, et))
    }
    function maybeReadMore_(J, et) {
      for (; !et.reading && !et.ended && (et.length < et.highWaterMark || et.flowing && 0 === et.length);) {
        var eo = et.length;
        if (ec("maybeReadMore read 0"),
          J.read(0),
          eo === et.length)
          break
      }
      et.readingMore = !1
    }
    function updateReadableListening(J) {
      var et = J._readableState;
      et.readableListening = J.listenerCount("readable") > 0,
        et.resumeScheduled && !et.paused ? et.flowing = !0 : J.listenerCount("data") > 0 && J.resume()
    }
    function nReadingNextTick(J) {
      ec("readable nexttick read 0"),
        J.read(0)
    }
    function resume_(J, et) {
      ec("resume", et.reading),
        et.reading || J.read(0),
        et.resumeScheduled = !1,
        J.emit("resume"),
        flow(J),
        et.flowing && !et.reading && J.read(0)
    }
    function flow(J) {
      var et = J._readableState;
      for (ec("flow", et.flowing); et.flowing && null !== J.read();)
        ;
    }
    function fromList(J, et) {
      var eo;
      return 0 === et.length ? null : (et.objectMode ? eo = et.buffer.shift() : !J || J >= et.length ? (eo = et.decoder ? et.buffer.join("") : 1 === et.buffer.length ? et.buffer.first() : et.buffer.concat(et.length),
        et.buffer.clear()) : eo = et.buffer.consume(J, et.decoder),
        eo)
    }
    function endReadable(J) {
      var et = J._readableState;
      ec("endReadable", et.endEmitted),
        et.endEmitted || (et.ended = !0,
          ef.nextTick(endReadableNT, et, J))
    }
    function endReadableNT(J, et) {
      if (ec("endReadableNT", J.endEmitted, J.length),
        !J.endEmitted && 0 === J.length && (J.endEmitted = !0,
          et.readable = !1,
          et.emit("end"),
          J.autoDestroy)) {
        var eo = et._writableState;
        (!eo || eo.autoDestroy && eo.finished) && et.destroy()
      }
    }
    function indexOf(J, et) {
      for (var eo = 0, el = J.length; eo < el; eo++)
        if (J[eo] === et)
          return eo;
      return -1
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      enumerable: !1,
      get: function () {
        return void 0 !== this._readableState && this._readableState.destroyed
      },
      set: function (J) {
        this._readableState && (this._readableState.destroyed = J)
      }
    }),
      Readable.prototype.destroy = e_.destroy,
      Readable.prototype._undestroy = e_.undestroy,
      Readable.prototype._destroy = function (J, et) {
        et(J)
      }
      ,
      Readable.prototype.push = function (J, et) {
        var eo, el = this._readableState;
        return el.objectMode ? eo = !0 : "string" == typeof J && ((et = et || el.defaultEncoding) !== el.encoding && (J = eg.from(J, et),
          et = ""),
          eo = !0),
          readableAddChunk(this, J, et, !1, eo)
      }
      ,
      Readable.prototype.unshift = function (J) {
        return readableAddChunk(this, J, null, !0, !1)
      }
      ,
      Readable.prototype.isPaused = function () {
        return !1 === this._readableState.flowing
      }
      ,
      Readable.prototype.setEncoding = function (J) {
        ed || (ed = eo(92809).s);
        var et = new ed(J);
        this._readableState.decoder = et,
          this._readableState.encoding = this._readableState.decoder.encoding;
        for (var el = this._readableState.buffer.head, ec = ""; null !== el;)
          ec += et.write(el.data),
            el = el.next;
        return this._readableState.buffer.clear(),
          "" !== ec && this._readableState.buffer.push(ec),
          this._readableState.length = ec.length,
          this
      }
      ,
      Readable.prototype.read = function (J) {
        ec("read", J),
          J = parseInt(J, 10);
        var et, eo = this._readableState, el = J;
        if (0 !== J && (eo.emittedReadable = !1),
          0 === J && eo.needReadable && ((0 !== eo.highWaterMark ? eo.length >= eo.highWaterMark : eo.length > 0) || eo.ended))
          return ec("read: emitReadable", eo.length, eo.ended),
            0 === eo.length && eo.ended ? endReadable(this) : emitReadable(this),
            null;
        if (0 === (J = howMuchToRead(J, eo)) && eo.ended)
          return 0 === eo.length && endReadable(this),
            null;
        var ed = eo.needReadable;
        return ec("need readable", ed),
          (0 === eo.length || eo.length - J < eo.highWaterMark) && ec("length less than watermark", ed = !0),
          eo.ended || eo.reading ? ec("reading or ended", ed = !1) : ed && (ec("do read"),
            eo.reading = !0,
            eo.sync = !0,
            0 === eo.length && (eo.needReadable = !0),
            this._read(eo.highWaterMark),
            eo.sync = !1,
            eo.reading || (J = howMuchToRead(el, eo))),
          null === (et = J > 0 ? fromList(J, eo) : null) ? (eo.needReadable = eo.length <= eo.highWaterMark,
            J = 0) : (eo.length -= J,
              eo.awaitDrain = 0),
          0 === eo.length && (eo.ended || (eo.needReadable = !0),
            el !== J && eo.ended && endReadable(this)),
          null !== et && this.emit("data", et),
          et
      }
      ,
      Readable.prototype._read = function (J) {
        eA(this, new ek("_read()"))
      }
      ,
      Readable.prototype.pipe = function (J, et) {
        var eo = this
          , el = this._readableState;
        switch (el.pipesCount) {
          case 0:
            el.pipes = J;
            break;
          case 1:
            el.pipes = [el.pipes, J];
            break;
          default:
            el.pipes.push(J)
        }
        el.pipesCount += 1,
          ec("pipe count=%d opts=%j", el.pipesCount, et);
        var ed = et && !1 === et.end || J === ef.stdout || J === ef.stderr ? unpipe : onend;
        function onend() {
          ec("onend"),
            J.end()
        }
        el.endEmitted ? ef.nextTick(ed) : eo.once("end", ed),
          J.on("unpipe", function onunpipe(et, ed) {
            ec("onunpipe"),
              et === eo && ed && !1 === ed.hasUnpiped && (ed.hasUnpiped = !0,
                ec("cleanup"),
                J.removeListener("close", onclose),
                J.removeListener("finish", onfinish),
                J.removeListener("drain", ondrain),
                J.removeListener("error", onerror),
                J.removeListener("unpipe", onunpipe),
                eo.removeListener("end", onend),
                eo.removeListener("end", unpipe),
                eo.removeListener("data", ondata),
                eh = !0,
                el.awaitDrain && (!J._writableState || J._writableState.needDrain) && ondrain())
          });
        var ondrain = function () {
          var J = eo._readableState;
          ec("pipeOnDrain", J.awaitDrain),
            J.awaitDrain && J.awaitDrain--,
            0 === J.awaitDrain && EElistenerCount(eo, "data") && (J.flowing = !0,
              flow(eo))
        };
        J.on("drain", ondrain);
        var eh = !1;
        function ondata(et) {
          ec("ondata");
          var ed = J.write(et);
          ec("dest.write", ed),
            !1 === ed && ((1 === el.pipesCount && el.pipes === J || el.pipesCount > 1 && -1 !== indexOf(el.pipes, J)) && !eh && (ec("false write response, pause", el.awaitDrain),
              el.awaitDrain++),
              eo.pause())
        }
        function onerror(et) {
          ec("onerror", et),
            unpipe(),
            J.removeListener("error", onerror),
            0 === EElistenerCount(J, "error") && eA(J, et)
        }
        function onclose() {
          J.removeListener("finish", onfinish),
            unpipe()
        }
        function onfinish() {
          ec("onfinish"),
            J.removeListener("close", onclose),
            unpipe()
        }
        function unpipe() {
          ec("unpipe"),
            eo.unpipe(J)
        }
        return eo.on("data", ondata),
          function (J, et, eo) {
            if ("function" == typeof J.prependListener)
              return J.prependListener(et, eo);
            J._events && J._events[et] ? Array.isArray(J._events[et]) ? J._events[et].unshift(eo) : J._events[et] = [eo, J._events[et]] : J.on(et, eo)
          }(J, "error", onerror),
          J.once("close", onclose),
          J.once("finish", onfinish),
          J.emit("pipe", eo),
          el.flowing || (ec("pipe resume"),
            eo.resume()),
          J
      }
      ,
      Readable.prototype.unpipe = function (J) {
        var et = this._readableState
          , eo = {
            hasUnpiped: !1
          };
        if (0 === et.pipesCount)
          return this;
        if (1 === et.pipesCount)
          return J && J !== et.pipes || (J || (J = et.pipes),
            et.pipes = null,
            et.pipesCount = 0,
            et.flowing = !1,
            J && J.emit("unpipe", this, eo)),
            this;
        if (!J) {
          var el = et.pipes
            , ec = et.pipesCount;
          et.pipes = null,
            et.pipesCount = 0,
            et.flowing = !1;
          for (var ed = 0; ed < ec; ed++)
            el[ed].emit("unpipe", this, {
              hasUnpiped: !1
            });
          return this
        }
        var eh = indexOf(et.pipes, J);
        return -1 === eh || (et.pipes.splice(eh, 1),
          et.pipesCount -= 1,
          1 === et.pipesCount && (et.pipes = et.pipes[0]),
          J.emit("unpipe", this, eo)),
          this
      }
      ,
      Readable.prototype.on = function (J, et) {
        var eo = em.prototype.on.call(this, J, et)
          , el = this._readableState;
        return "data" === J ? (el.readableListening = this.listenerCount("readable") > 0,
          !1 !== el.flowing && this.resume()) : "readable" !== J || el.endEmitted || el.readableListening || (el.readableListening = el.needReadable = !0,
            el.flowing = !1,
            el.emittedReadable = !1,
            ec("on readable", el.length, el.reading),
            el.length ? emitReadable(this) : el.reading || ef.nextTick(nReadingNextTick, this)),
          eo
      }
      ,
      Readable.prototype.addListener = Readable.prototype.on,
      Readable.prototype.removeListener = function (J, et) {
        var eo = em.prototype.removeListener.call(this, J, et);
        return "readable" === J && ef.nextTick(updateReadableListening, this),
          eo
      }
      ,
      Readable.prototype.removeAllListeners = function (J) {
        var et = em.prototype.removeAllListeners.apply(this, arguments);
        return ("readable" === J || void 0 === J) && ef.nextTick(updateReadableListening, this),
          et
      }
      ,
      Readable.prototype.resume = function () {
        var J = this._readableState;
        return J.flowing || (ec("resume"),
          J.flowing = !J.readableListening,
          J.resumeScheduled || (J.resumeScheduled = !0,
            ef.nextTick(resume_, this, J))),
          J.paused = !1,
          this
      }
      ,
      Readable.prototype.pause = function () {
        return ec("call pause flowing=%j", this._readableState.flowing),
          !1 !== this._readableState.flowing && (ec("pause"),
            this._readableState.flowing = !1,
            this.emit("pause")),
          this._readableState.paused = !0,
          this
      }
      ,
      Readable.prototype.wrap = function (J) {
        var et = this
          , eo = this._readableState
          , el = !1;
        for (var ed in J.on("end", function () {
          if (ec("wrapped end"),
            eo.decoder && !eo.ended) {
            var J = eo.decoder.end();
            J && J.length && et.push(J)
          }
          et.push(null)
        }),
          J.on("data", function (ed) {
            ec("wrapped data"),
              eo.decoder && (ed = eo.decoder.write(ed)),
              (!eo.objectMode || null != ed) && (eo.objectMode || ed && ed.length) && (et.push(ed) || (el = !0,
                J.pause()))
          }),
          J)
          void 0 === this[ed] && "function" == typeof J[ed] && (this[ed] = function (et) {
            return function () {
              return J[et].apply(J, arguments)
            }
          }(ed));
        for (var eh = 0; eh < eP.length; eh++)
          J.on(eP[eh], this.emit.bind(this, eP[eh]));
        return this._read = function (et) {
          ec("wrapped _read", et),
            el && (el = !1,
              J.resume())
        }
          ,
          this
      }
      ,
      "function" == typeof Symbol && (Readable.prototype[Symbol.asyncIterator] = function () {
        return void 0 === eh && (eh = eo(13471)),
          eh(this)
      }
      ),
      Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
        enumerable: !1,
        get: function () {
          return this._readableState.highWaterMark
        }
      }),
      Object.defineProperty(Readable.prototype, "readableBuffer", {
        enumerable: !1,
        get: function () {
          return this._readableState && this._readableState.buffer
        }
      }),
      Object.defineProperty(Readable.prototype, "readableFlowing", {
        enumerable: !1,
        get: function () {
          return this._readableState.flowing
        },
        set: function (J) {
          this._readableState && (this._readableState.flowing = J)
        }
      }),
      Readable._fromList = fromList,
      Object.defineProperty(Readable.prototype, "readableLength", {
        enumerable: !1,
        get: function () {
          return this._readableState.length
        }
      }),
      "function" == typeof Symbol && (Readable.from = function (J, et) {
        return void 0 === ep && (ep = eo(96435)),
          ep(Readable, J, et)
      }
      )
  },
  96311: function (J, et, eo) {
    "use strict";
    J.exports = Transform;
    var el = eo(97630).q
      , ec = el.ERR_METHOD_NOT_IMPLEMENTED
      , ed = el.ERR_MULTIPLE_CALLBACK
      , eh = el.ERR_TRANSFORM_ALREADY_TRANSFORMING
      , ep = el.ERR_TRANSFORM_WITH_LENGTH_0
      , ef = eo(37735);
    function afterTransform(J, et) {
      var eo = this._transformState;
      eo.transforming = !1;
      var el = eo.writecb;
      if (null === el)
        return this.emit("error", new ed);
      eo.writechunk = null,
        eo.writecb = null,
        null != et && this.push(et),
        el(J);
      var ec = this._readableState;
      ec.reading = !1,
        (ec.needReadable || ec.length < ec.highWaterMark) && this._read(ec.highWaterMark)
    }
    function Transform(J) {
      if (!(this instanceof Transform))
        return new Transform(J);
      ef.call(this, J),
        this._transformState = {
          afterTransform: afterTransform.bind(this),
          needTransform: !1,
          transforming: !1,
          writecb: null,
          writechunk: null,
          writeencoding: null
        },
        this._readableState.needReadable = !0,
        this._readableState.sync = !1,
        J && ("function" == typeof J.transform && (this._transform = J.transform),
          "function" == typeof J.flush && (this._flush = J.flush)),
        this.on("prefinish", prefinish)
    }
    function prefinish() {
      var J = this;
      "function" != typeof this._flush || this._readableState.destroyed ? done(this, null, null) : this._flush(function (et, eo) {
        done(J, et, eo)
      })
    }
    function done(J, et, eo) {
      if (et)
        return J.emit("error", et);
      if (null != eo && J.push(eo),
        J._writableState.length)
        throw new ep;
      if (J._transformState.transforming)
        throw new eh;
      return J.push(null)
    }
    eo(35717)(Transform, ef),
      Transform.prototype.push = function (J, et) {
        return this._transformState.needTransform = !1,
          ef.prototype.push.call(this, J, et)
      }
      ,
      Transform.prototype._transform = function (J, et, eo) {
        eo(new ec("_transform()"))
      }
      ,
      Transform.prototype._write = function (J, et, eo) {
        var el = this._transformState;
        if (el.writecb = eo,
          el.writechunk = J,
          el.writeencoding = et,
          !el.transforming) {
          var ec = this._readableState;
          (el.needTransform || ec.needReadable || ec.length < ec.highWaterMark) && this._read(ec.highWaterMark)
        }
      }
      ,
      Transform.prototype._read = function (J) {
        var et = this._transformState;
        null === et.writechunk || et.transforming ? et.needTransform = !0 : (et.transforming = !0,
          this._transform(et.writechunk, et.writeencoding, et.afterTransform))
      }
      ,
      Transform.prototype._destroy = function (J, et) {
        ef.prototype._destroy.call(this, J, function (J) {
          et(J)
        })
      }
  },
  69843: function (J, et, eo) {
    "use strict";
    var el, ec, ed = eo(83454);
    function CorkedRequest(J) {
      var et = this;
      this.next = null,
        this.entry = null,
        this.finish = function () {
          (function (J, et, eo) {
            var el = J.entry;
            for (J.entry = null; el;) {
              var ec = el.callback;
              et.pendingcb--,
                ec(void 0),
                el = el.next
            }
            et.corkedRequestsFree.next = J
          }
          )(et, J)
        }
    }
    J.exports = Writable,
      Writable.WritableState = WritableState;
    var eh = {
      deprecate: eo(94927)
    }
      , ep = eo(89868)
      , ef = eo(48764).Buffer
      , em = (void 0 !== eo.g ? eo.g : "undefined" != typeof window ? window : "undefined" != typeof self ? self : {}).Uint8Array || function () { }
      , eg = eo(73505)
      , ey = eo(65482).getHighWaterMark
      , eb = eo(97630).q
      , ew = eb.ERR_INVALID_ARG_TYPE
      , e_ = eb.ERR_METHOD_NOT_IMPLEMENTED
      , ex = eb.ERR_MULTIPLE_CALLBACK
      , eE = eb.ERR_STREAM_CANNOT_PIPE
      , eC = eb.ERR_STREAM_DESTROYED
      , eS = eb.ERR_STREAM_NULL_VALUES
      , ek = eb.ERR_STREAM_WRITE_AFTER_END
      , eT = eb.ERR_UNKNOWN_ENCODING
      , eA = eg.errorOrDestroy;
    function nop() { }
    function WritableState(J, et, ec) {
      el = el || eo(37735),
        J = J || {},
        "boolean" != typeof ec && (ec = et instanceof el),
        this.objectMode = !!J.objectMode,
        ec && (this.objectMode = this.objectMode || !!J.writableObjectMode),
        this.highWaterMark = ey(this, J, "writableHighWaterMark", ec),
        this.finalCalled = !1,
        this.needDrain = !1,
        this.ending = !1,
        this.ended = !1,
        this.finished = !1,
        this.destroyed = !1;
      var eh = !1 === J.decodeStrings;
      this.decodeStrings = !eh,
        this.defaultEncoding = J.defaultEncoding || "utf8",
        this.length = 0,
        this.writing = !1,
        this.corked = 0,
        this.sync = !0,
        this.bufferProcessing = !1,
        this.onwrite = function (J) {
          (function (J, et) {
            var eo = J._writableState
              , el = eo.sync
              , ec = eo.writecb;
            if ("function" != typeof ec)
              throw new ex;
            if (eo.writing = !1,
              eo.writecb = null,
              eo.length -= eo.writelen,
              eo.writelen = 0,
              et)
              --eo.pendingcb,
                el ? (ed.nextTick(ec, et),
                  ed.nextTick(finishMaybe, J, eo),
                  J._writableState.errorEmitted = !0,
                  eA(J, et)) : (ec(et),
                    J._writableState.errorEmitted = !0,
                    eA(J, et),
                    finishMaybe(J, eo));
            else {
              var eh = needFinish(eo) || J.destroyed;
              eh || eo.corked || eo.bufferProcessing || !eo.bufferedRequest || clearBuffer(J, eo),
                el ? ed.nextTick(afterWrite, J, eo, eh, ec) : afterWrite(J, eo, eh, ec)
            }
          }
          )(et, J)
        }
        ,
        this.writecb = null,
        this.writelen = 0,
        this.bufferedRequest = null,
        this.lastBufferedRequest = null,
        this.pendingcb = 0,
        this.prefinished = !1,
        this.errorEmitted = !1,
        this.emitClose = !1 !== J.emitClose,
        this.autoDestroy = !!J.autoDestroy,
        this.bufferedRequestCount = 0,
        this.corkedRequestsFree = new CorkedRequest(this)
    }
    function Writable(J) {
      var et = this instanceof (el = el || eo(37735));
      if (!et && !ec.call(Writable, this))
        return new Writable(J);
      this._writableState = new WritableState(J, this, et),
        this.writable = !0,
        J && ("function" == typeof J.write && (this._write = J.write),
          "function" == typeof J.writev && (this._writev = J.writev),
          "function" == typeof J.destroy && (this._destroy = J.destroy),
          "function" == typeof J.final && (this._final = J.final)),
        ep.call(this)
    }
    function doWrite(J, et, eo, el, ec, ed, eh) {
      et.writelen = el,
        et.writecb = eh,
        et.writing = !0,
        et.sync = !0,
        et.destroyed ? et.onwrite(new eC("write")) : eo ? J._writev(ec, et.onwrite) : J._write(ec, ed, et.onwrite),
        et.sync = !1
    }
    function afterWrite(J, et, eo, el) {
      eo || 0 === et.length && et.needDrain && (et.needDrain = !1,
        J.emit("drain")),
        et.pendingcb--,
        el(),
        finishMaybe(J, et)
    }
    function clearBuffer(J, et) {
      et.bufferProcessing = !0;
      var eo = et.bufferedRequest;
      if (J._writev && eo && eo.next) {
        var el = Array(et.bufferedRequestCount)
          , ec = et.corkedRequestsFree;
        ec.entry = eo;
        for (var ed = 0, eh = !0; eo;)
          el[ed] = eo,
            eo.isBuf || (eh = !1),
            eo = eo.next,
            ed += 1;
        el.allBuffers = eh,
          doWrite(J, et, !0, et.length, el, "", ec.finish),
          et.pendingcb++,
          et.lastBufferedRequest = null,
          ec.next ? (et.corkedRequestsFree = ec.next,
            ec.next = null) : et.corkedRequestsFree = new CorkedRequest(et),
          et.bufferedRequestCount = 0
      } else {
        for (; eo;) {
          var ep = eo.chunk
            , ef = eo.encoding
            , em = eo.callback
            , eg = et.objectMode ? 1 : ep.length;
          if (doWrite(J, et, !1, eg, ep, ef, em),
            eo = eo.next,
            et.bufferedRequestCount--,
            et.writing)
            break
        }
        null === eo && (et.lastBufferedRequest = null)
      }
      et.bufferedRequest = eo,
        et.bufferProcessing = !1
    }
    function needFinish(J) {
      return J.ending && 0 === J.length && null === J.bufferedRequest && !J.finished && !J.writing
    }
    function callFinal(J, et) {
      J._final(function (eo) {
        et.pendingcb--,
          eo && eA(J, eo),
          et.prefinished = !0,
          J.emit("prefinish"),
          finishMaybe(J, et)
      })
    }
    function finishMaybe(J, et) {
      var eo = needFinish(et);
      if (eo && (et.prefinished || et.finalCalled || ("function" != typeof J._final || et.destroyed ? (et.prefinished = !0,
        J.emit("prefinish")) : (et.pendingcb++,
          et.finalCalled = !0,
          ed.nextTick(callFinal, J, et))),
        0 === et.pendingcb && (et.finished = !0,
          J.emit("finish"),
          et.autoDestroy))) {
        var el = J._readableState;
        (!el || el.autoDestroy && el.endEmitted) && J.destroy()
      }
      return eo
    }
    eo(35717)(Writable, ep),
      WritableState.prototype.getBuffer = function () {
        for (var J = this.bufferedRequest, et = []; J;)
          et.push(J),
            J = J.next;
        return et
      }
      ,
      function () {
        try {
          Object.defineProperty(WritableState.prototype, "buffer", {
            get: eh.deprecate(function () {
              return this.getBuffer()
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          })
        } catch (J) { }
      }(),
      "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (ec = Function.prototype[Symbol.hasInstance],
        Object.defineProperty(Writable, Symbol.hasInstance, {
          value: function (J) {
            return !!ec.call(this, J) || this === Writable && J && J._writableState instanceof WritableState
          }
        })) : ec = function (J) {
          return J instanceof this
        }
      ,
      Writable.prototype.pipe = function () {
        eA(this, new eE)
      }
      ,
      Writable.prototype.write = function (J, et, eo) {
        var el, ec, eh, ep, eg, ey, eb, e_ = this._writableState, ex = !1, eE = !e_.objectMode && (el = J,
          ef.isBuffer(el) || el instanceof em);
        return eE && !ef.isBuffer(J) && (ec = J,
          J = ef.from(ec)),
          ("function" == typeof et && (eo = et,
            et = null),
            eE ? et = "buffer" : et || (et = e_.defaultEncoding),
            "function" != typeof eo && (eo = nop),
            e_.ending) ? (eh = eo,
              eA(this, ep = new ek),
              ed.nextTick(eh, ep)) : (eE || (eg = J,
                ey = eo,
                null === eg ? eb = new eS : "string" == typeof eg || e_.objectMode || (eb = new ew("chunk", ["string", "Buffer"], eg)),
                !eb || (eA(this, eb),
                  ed.nextTick(ey, eb),
                  0))) && (e_.pendingcb++,
                    ex = function (J, et, eo, el, ec, ed) {
                      if (!eo) {
                        var eh, ep, em = (eh = el,
                          ep = ec,
                          et.objectMode || !1 === et.decodeStrings || "string" != typeof eh || (eh = ef.from(eh, ep)),
                          eh);
                        el !== em && (eo = !0,
                          ec = "buffer",
                          el = em)
                      }
                      var eg = et.objectMode ? 1 : el.length;
                      et.length += eg;
                      var ey = et.length < et.highWaterMark;
                      if (ey || (et.needDrain = !0),
                        et.writing || et.corked) {
                        var eb = et.lastBufferedRequest;
                        et.lastBufferedRequest = {
                          chunk: el,
                          encoding: ec,
                          isBuf: eo,
                          callback: ed,
                          next: null
                        },
                          eb ? eb.next = et.lastBufferedRequest : et.bufferedRequest = et.lastBufferedRequest,
                          et.bufferedRequestCount += 1
                      } else
                        doWrite(J, et, !1, eg, el, ec, ed);
                      return ey
                    }(this, e_, eE, J, et, eo)),
          ex
      }
      ,
      Writable.prototype.cork = function () {
        this._writableState.corked++
      }
      ,
      Writable.prototype.uncork = function () {
        var J = this._writableState;
        !J.corked || (J.corked--,
          J.writing || J.corked || J.bufferProcessing || !J.bufferedRequest || clearBuffer(this, J))
      }
      ,
      Writable.prototype.setDefaultEncoding = function (J) {
        if ("string" == typeof J && (J = J.toLowerCase()),
          !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((J + "").toLowerCase()) > -1))
          throw new eT(J);
        return this._writableState.defaultEncoding = J,
          this
      }
      ,
      Object.defineProperty(Writable.prototype, "writableBuffer", {
        enumerable: !1,
        get: function () {
          return this._writableState && this._writableState.getBuffer()
        }
      }),
      Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function () {
          return this._writableState.highWaterMark
        }
      }),
      Writable.prototype._write = function (J, et, eo) {
        eo(new e_("_write()"))
      }
      ,
      Writable.prototype._writev = null,
      Writable.prototype.end = function (J, et, eo) {
        var el, ec = this._writableState;
        return "function" == typeof J ? (eo = J,
          J = null,
          et = null) : "function" == typeof et && (eo = et,
            et = null),
          null != J && this.write(J, et),
          ec.corked && (ec.corked = 1,
            this.uncork()),
          ec.ending || (el = eo,
            ec.ending = !0,
            finishMaybe(this, ec),
            el && (ec.finished ? ed.nextTick(el) : this.once("finish", el)),
            ec.ended = !0,
            this.writable = !1),
          this
      }
      ,
      Object.defineProperty(Writable.prototype, "writableLength", {
        enumerable: !1,
        get: function () {
          return this._writableState.length
        }
      }),
      Object.defineProperty(Writable.prototype, "destroyed", {
        enumerable: !1,
        get: function () {
          return void 0 !== this._writableState && this._writableState.destroyed
        },
        set: function (J) {
          this._writableState && (this._writableState.destroyed = J)
        }
      }),
      Writable.prototype.destroy = eg.destroy,
      Writable.prototype._undestroy = eg.undestroy,
      Writable.prototype._destroy = function (J, et) {
        et(J)
      }
  },
  13471: function (J, et, eo) {
    "use strict";
    var el, ec = eo(83454);
    function _defineProperty(J, et, eo) {
      var el;
      return (et = "symbol" == typeof (el = function (J, et) {
        if ("object" != typeof J || null === J)
          return J;
        var eo = J[Symbol.toPrimitive];
        if (void 0 !== eo) {
          var el = eo.call(J, et || "default");
          if ("object" != typeof el)
            return el;
          throw TypeError("@@toPrimitive must return a primitive value.")
        }
        return ("string" === et ? String : Number)(J)
      }(et, "string")) ? el : String(el)) in J ? Object.defineProperty(J, et, {
        value: eo,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : J[et] = eo,
        J
    }
    var ed = eo(48186)
      , eh = Symbol("lastResolve")
      , ep = Symbol("lastReject")
      , ef = Symbol("error")
      , em = Symbol("ended")
      , eg = Symbol("lastPromise")
      , ey = Symbol("handlePromise")
      , eb = Symbol("stream");
    function createIterResult(J, et) {
      return {
        value: J,
        done: et
      }
    }
    function readAndResolve(J) {
      var et = J[eh];
      if (null !== et) {
        var eo = J[eb].read();
        null !== eo && (J[eg] = null,
          J[eh] = null,
          J[ep] = null,
          et(createIterResult(eo, !1)))
      }
    }
    function onReadable(J) {
      ec.nextTick(readAndResolve, J)
    }
    var ew = Object.getPrototypeOf(function () { })
      , e_ = Object.setPrototypeOf((_defineProperty(el = {
        get stream() {
          return this[eb]
        },
        next: function () {
          var J, et, eo = this, el = this[ef];
          if (null !== el)
            return Promise.reject(el);
          if (this[em])
            return Promise.resolve(createIterResult(void 0, !0));
          if (this[eb].destroyed)
            return new Promise(function (J, et) {
              ec.nextTick(function () {
                eo[ef] ? et(eo[ef]) : J(createIterResult(void 0, !0))
              })
            }
            );
          var ed = this[eg];
          if (ed)
            et = new Promise((J = this,
              function (et, eo) {
                ed.then(function () {
                  if (J[em]) {
                    et(createIterResult(void 0, !0));
                    return
                  }
                  J[ey](et, eo)
                }, eo)
              }
            ));
          else {
            var eh = this[eb].read();
            if (null !== eh)
              return Promise.resolve(createIterResult(eh, !1));
            et = new Promise(this[ey])
          }
          return this[eg] = et,
            et
        }
      }, Symbol.asyncIterator, function () {
        return this
      }),
        _defineProperty(el, "return", function () {
          var J = this;
          return new Promise(function (et, eo) {
            J[eb].destroy(null, function (J) {
              if (J) {
                eo(J);
                return
              }
              et(createIterResult(void 0, !0))
            })
          }
          )
        }),
        el), ew);
    J.exports = function (J) {
      var et, eo = Object.create(e_, (_defineProperty(et = {}, eb, {
        value: J,
        writable: !0
      }),
        _defineProperty(et, eh, {
          value: null,
          writable: !0
        }),
        _defineProperty(et, ep, {
          value: null,
          writable: !0
        }),
        _defineProperty(et, ef, {
          value: null,
          writable: !0
        }),
        _defineProperty(et, em, {
          value: J._readableState.endEmitted,
          writable: !0
        }),
        _defineProperty(et, ey, {
          value: function (J, et) {
            var el = eo[eb].read();
            el ? (eo[eg] = null,
              eo[eh] = null,
              eo[ep] = null,
              J(createIterResult(el, !1))) : (eo[eh] = J,
                eo[ep] = et)
          },
          writable: !0
        }),
        et));
      return eo[eg] = null,
        ed(J, function (J) {
          if (J && "ERR_STREAM_PREMATURE_CLOSE" !== J.code) {
            var et = eo[ep];
            null !== et && (eo[eg] = null,
              eo[eh] = null,
              eo[ep] = null,
              et(J)),
              eo[ef] = J;
            return
          }
          var el = eo[eh];
          null !== el && (eo[eg] = null,
            eo[eh] = null,
            eo[ep] = null,
            el(createIterResult(void 0, !0))),
            eo[em] = !0
        }),
        J.on("readable", onReadable.bind(null, eo)),
        eo
    }
  },
  77983: function (J, et, eo) {
    "use strict";
    function ownKeys(J, et) {
      var eo = Object.keys(J);
      if (Object.getOwnPropertySymbols) {
        var el = Object.getOwnPropertySymbols(J);
        et && (el = el.filter(function (et) {
          return Object.getOwnPropertyDescriptor(J, et).enumerable
        })),
          eo.push.apply(eo, el)
      }
      return eo
    }
    function _objectSpread(J) {
      for (var et = 1; et < arguments.length; et++) {
        var eo = null != arguments[et] ? arguments[et] : {};
        et % 2 ? ownKeys(Object(eo), !0).forEach(function (et) {
          var el, ec;
          el = et,
            ec = eo[et],
            (el = _toPropertyKey(el)) in J ? Object.defineProperty(J, el, {
              value: ec,
              enumerable: !0,
              configurable: !0,
              writable: !0
            }) : J[el] = ec
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(J, Object.getOwnPropertyDescriptors(eo)) : ownKeys(Object(eo)).forEach(function (et) {
          Object.defineProperty(J, et, Object.getOwnPropertyDescriptor(eo, et))
        })
      }
      return J
    }
    function _defineProperties(J, et) {
      for (var eo = 0; eo < et.length; eo++) {
        var el = et[eo];
        el.enumerable = el.enumerable || !1,
          el.configurable = !0,
          "value" in el && (el.writable = !0),
          Object.defineProperty(J, _toPropertyKey(el.key), el)
      }
    }
    function _toPropertyKey(J) {
      var et = function (J, et) {
        if ("object" != typeof J || null === J)
          return J;
        var eo = J[Symbol.toPrimitive];
        if (void 0 !== eo) {
          var el = eo.call(J, et || "default");
          if ("object" != typeof el)
            return el;
          throw TypeError("@@toPrimitive must return a primitive value.")
        }
        return ("string" === et ? String : Number)(J)
      }(J, "string");
      return "symbol" == typeof et ? et : String(et)
    }
    var el = eo(48764).Buffer
      , ec = eo(29120).inspect
      , ed = ec && ec.custom || "inspect";
    J.exports = function () {
      var J, et;
      function BufferList() {
        !function (J, et) {
          if (!(J instanceof et))
            throw TypeError("Cannot call a class as a function")
        }(this, BufferList),
          this.head = null,
          this.tail = null,
          this.length = 0
      }
      return J = [{
        key: "push",
        value: function (J) {
          var et = {
            data: J,
            next: null
          };
          this.length > 0 ? this.tail.next = et : this.head = et,
            this.tail = et,
            ++this.length
        }
      }, {
        key: "unshift",
        value: function (J) {
          var et = {
            data: J,
            next: this.head
          };
          0 === this.length && (this.tail = et),
            this.head = et,
            ++this.length
        }
      }, {
        key: "shift",
        value: function () {
          if (0 !== this.length) {
            var J = this.head.data;
            return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next,
              --this.length,
              J
          }
        }
      }, {
        key: "clear",
        value: function () {
          this.head = this.tail = null,
            this.length = 0
        }
      }, {
        key: "join",
        value: function (J) {
          if (0 === this.length)
            return "";
          for (var et = this.head, eo = "" + et.data; et = et.next;)
            eo += J + et.data;
          return eo
        }
      }, {
        key: "concat",
        value: function (J) {
          if (0 === this.length)
            return el.alloc(0);
          for (var et, eo, ec = el.allocUnsafe(J >>> 0), ed = this.head, eh = 0; ed;)
            et = ed.data,
              eo = eh,
              el.prototype.copy.call(et, ec, eo),
              eh += ed.data.length,
              ed = ed.next;
          return ec
        }
      }, {
        key: "consume",
        value: function (J, et) {
          var eo;
          return J < this.head.data.length ? (eo = this.head.data.slice(0, J),
            this.head.data = this.head.data.slice(J)) : eo = J === this.head.data.length ? this.shift() : et ? this._getString(J) : this._getBuffer(J),
            eo
        }
      }, {
        key: "first",
        value: function () {
          return this.head.data
        }
      }, {
        key: "_getString",
        value: function (J) {
          var et = this.head
            , eo = 1
            , el = et.data;
          for (J -= el.length; et = et.next;) {
            var ec = et.data
              , ed = J > ec.length ? ec.length : J;
            if (ed === ec.length ? el += ec : el += ec.slice(0, J),
              0 == (J -= ed)) {
              ed === ec.length ? (++eo,
                et.next ? this.head = et.next : this.head = this.tail = null) : (this.head = et,
                  et.data = ec.slice(ed));
              break
            }
            ++eo
          }
          return this.length -= eo,
            el
        }
      }, {
        key: "_getBuffer",
        value: function (J) {
          var et = el.allocUnsafe(J)
            , eo = this.head
            , ec = 1;
          for (eo.data.copy(et),
            J -= eo.data.length; eo = eo.next;) {
            var ed = eo.data
              , eh = J > ed.length ? ed.length : J;
            if (ed.copy(et, et.length - J, 0, eh),
              0 == (J -= eh)) {
              eh === ed.length ? (++ec,
                eo.next ? this.head = eo.next : this.head = this.tail = null) : (this.head = eo,
                  eo.data = ed.slice(eh));
              break
            }
            ++ec
          }
          return this.length -= ec,
            et
        }
      }, {
        key: ed,
        value: function (J, et) {
          return ec(this, _objectSpread(_objectSpread({}, et), {}, {
            depth: 0,
            customInspect: !1
          }))
        }
      }],
        _defineProperties(BufferList.prototype, J),
        et && _defineProperties(BufferList, et),
        Object.defineProperty(BufferList, "prototype", {
          writable: !1
        }),
        BufferList
    }()
  },
  73505: function (J, et, eo) {
    "use strict";
    var el = eo(83454);
    function emitErrorAndCloseNT(J, et) {
      emitErrorNT(J, et),
        emitCloseNT(J)
    }
    function emitCloseNT(J) {
      (!J._writableState || J._writableState.emitClose) && (!J._readableState || J._readableState.emitClose) && J.emit("close")
    }
    function emitErrorNT(J, et) {
      J.emit("error", et)
    }
    J.exports = {
      destroy: function (J, et) {
        var eo = this
          , ec = this._readableState && this._readableState.destroyed
          , ed = this._writableState && this._writableState.destroyed;
        return ec || ed ? et ? et(J) : J && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0,
          el.nextTick(emitErrorNT, this, J)) : el.nextTick(emitErrorNT, this, J)) : (this._readableState && (this._readableState.destroyed = !0),
            this._writableState && (this._writableState.destroyed = !0),
            this._destroy(J || null, function (J) {
              !et && J ? eo._writableState ? eo._writableState.errorEmitted ? el.nextTick(emitCloseNT, eo) : (eo._writableState.errorEmitted = !0,
                el.nextTick(emitErrorAndCloseNT, eo, J)) : el.nextTick(emitErrorAndCloseNT, eo, J) : et ? (el.nextTick(emitCloseNT, eo),
                  et(J)) : el.nextTick(emitCloseNT, eo)
            })),
          this
      },
      undestroy: function () {
        this._readableState && (this._readableState.destroyed = !1,
          this._readableState.reading = !1,
          this._readableState.ended = !1,
          this._readableState.endEmitted = !1),
          this._writableState && (this._writableState.destroyed = !1,
            this._writableState.ended = !1,
            this._writableState.ending = !1,
            this._writableState.finalCalled = !1,
            this._writableState.prefinished = !1,
            this._writableState.finished = !1,
            this._writableState.errorEmitted = !1)
      },
      errorOrDestroy: function (J, et) {
        var eo = J._readableState
          , el = J._writableState;
        eo && eo.autoDestroy || el && el.autoDestroy ? J.destroy(et) : J.emit("error", et)
      }
    }
  },
  48186: function (J, et, eo) {
    "use strict";
    var el = eo(97630).q.ERR_STREAM_PREMATURE_CLOSE;
    function noop() { }
    J.exports = function eos(J, et, eo) {
      if ("function" == typeof et)
        return eos(J, null, et);
      et || (et = {}),
        ec = eo || noop,
        ed = !1,
        eo = function () {
          if (!ed) {
            ed = !0;
            for (var J = arguments.length, et = Array(J), eo = 0; eo < J; eo++)
              et[eo] = arguments[eo];
            ec.apply(this, et)
          }
        }
        ;
      var ec, ed, eh = et.readable || !1 !== et.readable && J.readable, ep = et.writable || !1 !== et.writable && J.writable, onlegacyfinish = function () {
        J.writable || onfinish()
      }, ef = J._writableState && J._writableState.finished, onfinish = function () {
        ep = !1,
          ef = !0,
          eh || eo.call(J)
      }, em = J._readableState && J._readableState.endEmitted, onend = function () {
        eh = !1,
          em = !0,
          ep || eo.call(J)
      }, onerror = function (et) {
        eo.call(J, et)
      }, onclose = function () {
        var et;
        return eh && !em ? (J._readableState && J._readableState.ended || (et = new el),
          eo.call(J, et)) : ep && !ef ? (J._writableState && J._writableState.ended || (et = new el),
            eo.call(J, et)) : void 0
      }, onrequest = function () {
        J.req.on("finish", onfinish)
      };
      return J.setHeader && "function" == typeof J.abort ? (J.on("complete", onfinish),
        J.on("abort", onclose),
        J.req ? onrequest() : J.on("request", onrequest)) : ep && !J._writableState && (J.on("end", onlegacyfinish),
          J.on("close", onlegacyfinish)),
        J.on("end", onend),
        J.on("finish", onfinish),
        !1 !== et.error && J.on("error", onerror),
        J.on("close", onclose),
        function () {
          J.removeListener("complete", onfinish),
            J.removeListener("abort", onclose),
            J.removeListener("request", onrequest),
            J.req && J.req.removeListener("finish", onfinish),
            J.removeListener("end", onlegacyfinish),
            J.removeListener("close", onlegacyfinish),
            J.removeListener("finish", onfinish),
            J.removeListener("end", onend),
            J.removeListener("error", onerror),
            J.removeListener("close", onclose)
        }
    }
  },
  96435: function (J) {
    J.exports = function () {
      throw Error("Readable.from is not available in the browser")
    }
  },
  79619: function (J, et, eo) {
    "use strict";
    var el, ec = eo(97630).q, ed = ec.ERR_MISSING_ARGS, eh = ec.ERR_STREAM_DESTROYED;
    function noop(J) {
      if (J)
        throw J
    }
    function call(J) {
      J()
    }
    function pipe(J, et) {
      return J.pipe(et)
    }
    J.exports = function () {
      for (var J, et, ec = arguments.length, ep = Array(ec), ef = 0; ef < ec; ef++)
        ep[ef] = arguments[ef];
      var em = (J = ep).length && "function" == typeof J[J.length - 1] ? J.pop() : noop;
      if (Array.isArray(ep[0]) && (ep = ep[0]),
        ep.length < 2)
        throw new ed("streams");
      var eg = ep.map(function (J, ec) {
        var ed, ef, ey, eb, ew, e_ = ec < ep.length - 1;
        return ef = ed = function (J) {
          et || (et = J),
            J && eg.forEach(call),
            e_ || (eg.forEach(call),
              em(et))
        }
          ,
          ey = !1,
          ed = function () {
            ey || (ey = !0,
              ef.apply(void 0, arguments))
          }
          ,
          eb = !1,
          J.on("close", function () {
            eb = !0
          }),
          void 0 === el && (el = eo(48186)),
          el(J, {
            readable: e_,
            writable: ec > 0
          }, function (J) {
            if (J)
              return ed(J);
            eb = !0,
              ed()
          }),
          ew = !1,
          function (et) {
            if (!eb && !ew) {
              if (ew = !0,
                J.setHeader && "function" == typeof J.abort)
                return J.abort();
              if ("function" == typeof J.destroy)
                return J.destroy();
              ed(et || new eh("pipe"))
            }
          }
      });
      return ep.reduce(pipe)
    }
  },
  65482: function (J, et, eo) {
    "use strict";
    var el = eo(97630).q.ERR_INVALID_OPT_VALUE;
    J.exports = {
      getHighWaterMark: function (J, et, eo, ec) {
        var ed = null != et.highWaterMark ? et.highWaterMark : ec ? et[eo] : null;
        if (null != ed) {
          if (!(isFinite(ed) && Math.floor(ed) === ed) || ed < 0) {
            var eh = ec ? eo : "highWaterMark";
            throw new el(eh, ed)
          }
          return Math.floor(ed)
        }
        return J.objectMode ? 16 : 16384
      }
    }
  },
  89868: function (J, et, eo) {
    J.exports = eo(17187).EventEmitter
  },
  35092: function (J, et, eo) {
    (et = J.exports = eo(83875)).Stream = et,
      et.Readable = et,
      et.Writable = eo(69843),
      et.Duplex = eo(37735),
      et.Transform = eo(96311),
      et.PassThrough = eo(36485),
      et.finished = eo(48186),
      et.pipeline = eo(79619)
  },
  3646: function (J, et, eo) {
    /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
    var el = eo(48764)
      , ec = el.Buffer;
    function copyProps(J, et) {
      for (var eo in J)
        et[eo] = J[eo]
    }
    function SafeBuffer(J, et, eo) {
      return ec(J, et, eo)
    }
    ec.from && ec.alloc && ec.allocUnsafe && ec.allocUnsafeSlow ? J.exports = el : (copyProps(el, et),
      et.Buffer = SafeBuffer),
      SafeBuffer.prototype = Object.create(ec.prototype),
      copyProps(ec, SafeBuffer),
      SafeBuffer.from = function (J, et, eo) {
        if ("number" == typeof J)
          throw TypeError("Argument must not be a number");
        return ec(J, et, eo)
      }
      ,
      SafeBuffer.alloc = function (J, et, eo) {
        if ("number" != typeof J)
          throw TypeError("Argument must be a number");
        var el = ec(J);
        return void 0 !== et ? "string" == typeof eo ? el.fill(et, eo) : el.fill(et) : el.fill(0),
          el
      }
      ,
      SafeBuffer.allocUnsafe = function (J) {
        if ("number" != typeof J)
          throw TypeError("Argument must be a number");
        return ec(J)
      }
      ,
      SafeBuffer.allocUnsafeSlow = function (J) {
        if ("number" != typeof J)
          throw TypeError("Argument must be a number");
        return el.SlowBuffer(J)
      }
  },
  92809: function (J, et, eo) {
    "use strict";
    var el = eo(3646).Buffer
      , ec = el.isEncoding || function (J) {
        switch ((J = "" + J) && J.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return !0;
          default:
            return !1
        }
      }
      ;
    function StringDecoder(J) {
      var et;
      switch (this.encoding = function (J) {
        var et = function (J) {
          var et;
          if (!J)
            return "utf8";
          for (; ;)
            switch (J) {
              case "utf8":
              case "utf-8":
                return "utf8";
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return "utf16le";
              case "latin1":
              case "binary":
                return "latin1";
              case "base64":
              case "ascii":
              case "hex":
                return J;
              default:
                if (et)
                  return;
                J = ("" + J).toLowerCase(),
                  et = !0
            }
        }(J);
        if ("string" != typeof et && (el.isEncoding === ec || !ec(J)))
          throw Error("Unknown encoding: " + J);
        return et || J
      }(J),
      this.encoding) {
        case "utf16le":
          this.text = utf16Text,
            this.end = utf16End,
            et = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast,
            et = 4;
          break;
        case "base64":
          this.text = base64Text,
            this.end = base64End,
            et = 3;
          break;
        default:
          this.write = simpleWrite,
            this.end = simpleEnd;
          return
      }
      this.lastNeed = 0,
        this.lastTotal = 0,
        this.lastChar = el.allocUnsafe(et)
    }
    function utf8CheckByte(J) {
      return J <= 127 ? 0 : J >> 5 == 6 ? 2 : J >> 4 == 14 ? 3 : J >> 3 == 30 ? 4 : J >> 6 == 2 ? -1 : -2
    }
    function utf8FillLast(J) {
      var et = this.lastTotal - this.lastNeed
        , eo = function (J, et, eo) {
          if ((192 & et[0]) != 128)
            return J.lastNeed = 0,
              "�";
          if (J.lastNeed > 1 && et.length > 1) {
            if ((192 & et[1]) != 128)
              return J.lastNeed = 1,
                "�";
            if (J.lastNeed > 2 && et.length > 2 && (192 & et[2]) != 128)
              return J.lastNeed = 2,
                "�"
          }
        }(this, J, 0);
      return void 0 !== eo ? eo : this.lastNeed <= J.length ? (J.copy(this.lastChar, et, 0, this.lastNeed),
        this.lastChar.toString(this.encoding, 0, this.lastTotal)) : void (J.copy(this.lastChar, et, 0, J.length),
          this.lastNeed -= J.length)
    }
    function utf16Text(J, et) {
      if ((J.length - et) % 2 == 0) {
        var eo = J.toString("utf16le", et);
        if (eo) {
          var el = eo.charCodeAt(eo.length - 1);
          if (el >= 55296 && el <= 56319)
            return this.lastNeed = 2,
              this.lastTotal = 4,
              this.lastChar[0] = J[J.length - 2],
              this.lastChar[1] = J[J.length - 1],
              eo.slice(0, -1)
        }
        return eo
      }
      return this.lastNeed = 1,
        this.lastTotal = 2,
        this.lastChar[0] = J[J.length - 1],
        J.toString("utf16le", et, J.length - 1)
    }
    function utf16End(J) {
      var et = J && J.length ? this.write(J) : "";
      if (this.lastNeed) {
        var eo = this.lastTotal - this.lastNeed;
        return et + this.lastChar.toString("utf16le", 0, eo)
      }
      return et
    }
    function base64Text(J, et) {
      var eo = (J.length - et) % 3;
      return 0 === eo ? J.toString("base64", et) : (this.lastNeed = 3 - eo,
        this.lastTotal = 3,
        1 === eo ? this.lastChar[0] = J[J.length - 1] : (this.lastChar[0] = J[J.length - 2],
          this.lastChar[1] = J[J.length - 1]),
        J.toString("base64", et, J.length - eo))
    }
    function base64End(J) {
      var et = J && J.length ? this.write(J) : "";
      return this.lastNeed ? et + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : et
    }
    function simpleWrite(J) {
      return J.toString(this.encoding)
    }
    function simpleEnd(J) {
      return J && J.length ? this.write(J) : ""
    }
    et.s = StringDecoder,
      StringDecoder.prototype.write = function (J) {
        var et, eo;
        if (0 === J.length)
          return "";
        if (this.lastNeed) {
          if (void 0 === (et = this.fillLast(J)))
            return "";
          eo = this.lastNeed,
            this.lastNeed = 0
        } else
          eo = 0;
        return eo < J.length ? et ? et + this.text(J, eo) : this.text(J, eo) : et || ""
      }
      ,
      StringDecoder.prototype.end = function (J) {
        var et = J && J.length ? this.write(J) : "";
        return this.lastNeed ? et + "�" : et
      }
      ,
      StringDecoder.prototype.text = function (J, et) {
        var eo = function (J, et, eo) {
          var el = et.length - 1;
          if (el < eo)
            return 0;
          var ec = utf8CheckByte(et[el]);
          return ec >= 0 ? (ec > 0 && (J.lastNeed = ec - 1),
            ec) : --el < eo || -2 === ec ? 0 : (ec = utf8CheckByte(et[el])) >= 0 ? (ec > 0 && (J.lastNeed = ec - 2),
              ec) : --el < eo || -2 === ec ? 0 : (ec = utf8CheckByte(et[el])) >= 0 ? (ec > 0 && (2 === ec ? ec = 0 : J.lastNeed = ec - 3),
                ec) : 0
        }(this, J, et);
        if (!this.lastNeed)
          return J.toString("utf8", et);
        this.lastTotal = eo;
        var el = J.length - (eo - this.lastNeed);
        return J.copy(this.lastChar, 0, el),
          J.toString("utf8", et, el)
      }
      ,
      StringDecoder.prototype.fillLast = function (J) {
        if (this.lastNeed <= J.length)
          return J.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed),
            this.lastChar.toString(this.encoding, 0, this.lastTotal);
        J.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, J.length),
          this.lastNeed -= J.length
      }
  },
  72307: function (J, et, eo) {
    J = eo.nmd(J);
    var el, ec, ed, eh = "__lodash_hash_undefined__", ep = "[object Arguments]", ef = "[object Array]", em = "[object Boolean]", eg = "[object Date]", ey = "[object Error]", eb = "[object Function]", ew = "[object Map]", e_ = "[object Number]", ex = "[object Object]", eE = "[object Promise]", eC = "[object RegExp]", eS = "[object Set]", ek = "[object String]", eT = "[object WeakMap]", eA = "[object ArrayBuffer]", eP = "[object DataView]", eR = /^\[object .+?Constructor\]$/, eI = /^(?:0|[1-9]\d*)$/, eO = {};
    eO["[object Float32Array]"] = eO["[object Float64Array]"] = eO["[object Int8Array]"] = eO["[object Int16Array]"] = eO["[object Int32Array]"] = eO["[object Uint8Array]"] = eO["[object Uint8ClampedArray]"] = eO["[object Uint16Array]"] = eO["[object Uint32Array]"] = !0,
      eO[ep] = eO[ef] = eO[eA] = eO[em] = eO[eP] = eO[eg] = eO[ey] = eO[eb] = eO[ew] = eO[e_] = eO[ex] = eO[eC] = eO[eS] = eO[ek] = eO[eT] = !1;
    var eN = "object" == typeof eo.g && eo.g && eo.g.Object === Object && eo.g
      , eM = "object" == typeof self && self && self.Object === Object && self
      , eD = eN || eM || Function("return this")()
      , ej = et && !et.nodeType && et
      , eL = ej && J && !J.nodeType && J
      , e$ = eL && eL.exports === ej
      , eB = e$ && eN.process
      , eF = function () {
        try {
          return eB && eB.binding && eB.binding("util")
        } catch (J) { }
      }()
      , eU = eF && eF.isTypedArray;
    function mapToArray(J) {
      var et = -1
        , eo = Array(J.size);
      return J.forEach(function (J, el) {
        eo[++et] = [el, J]
      }),
        eo
    }
    function setToArray(J) {
      var et = -1
        , eo = Array(J.size);
      return J.forEach(function (J) {
        eo[++et] = J
      }),
        eo
    }
    var ez = Array.prototype
      , eH = Function.prototype
      , eV = Object.prototype
      , eW = eD["__core-js_shared__"]
      , eZ = eH.toString
      , eG = eV.hasOwnProperty
      , eY = (el = /[^.]+$/.exec(eW && eW.keys && eW.keys.IE_PROTO || "")) ? "Symbol(src)_1." + el : ""
      , eK = eV.toString
      , eJ = RegExp("^" + eZ.call(eG).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$")
      , eQ = e$ ? eD.Buffer : void 0
      , eX = eD.Symbol
      , e0 = eD.Uint8Array
      , e1 = eV.propertyIsEnumerable
      , e2 = ez.splice
      , e3 = eX ? eX.toStringTag : void 0
      , e5 = Object.getOwnPropertySymbols
      , e6 = eQ ? eQ.isBuffer : void 0
      , e4 = (ec = Object.keys,
        ed = Object,
        function (J) {
          return ec(ed(J))
        }
      )
      , e8 = getNative(eD, "DataView")
      , e7 = getNative(eD, "Map")
      , e9 = getNative(eD, "Promise")
      , tn = getNative(eD, "Set")
      , to = getNative(eD, "WeakMap")
      , ta = getNative(Object, "create")
      , tl = toSource(e8)
      , tc = toSource(e7)
      , td = toSource(e9)
      , th = toSource(tn)
      , tp = toSource(to)
      , tf = eX ? eX.prototype : void 0
      , tm = tf ? tf.valueOf : void 0;
    function Hash(J) {
      var et = -1
        , eo = null == J ? 0 : J.length;
      for (this.clear(); ++et < eo;) {
        var el = J[et];
        this.set(el[0], el[1])
      }
    }
    function ListCache(J) {
      var et = -1
        , eo = null == J ? 0 : J.length;
      for (this.clear(); ++et < eo;) {
        var el = J[et];
        this.set(el[0], el[1])
      }
    }
    function MapCache(J) {
      var et = -1
        , eo = null == J ? 0 : J.length;
      for (this.clear(); ++et < eo;) {
        var el = J[et];
        this.set(el[0], el[1])
      }
    }
    function SetCache(J) {
      var et = -1
        , eo = null == J ? 0 : J.length;
      for (this.__data__ = new MapCache; ++et < eo;)
        this.add(J[et])
    }
    function Stack(J) {
      var et = this.__data__ = new ListCache(J);
      this.size = et.size
    }
    function assocIndexOf(J, et) {
      for (var eo = J.length; eo--;)
        if (eq(J[eo][0], et))
          return eo;
      return -1
    }
    function baseGetTag(J) {
      return null == J ? void 0 === J ? "[object Undefined]" : "[object Null]" : e3 && e3 in Object(J) ? function (J) {
        var et = eG.call(J, e3)
          , eo = J[e3];
        try {
          J[e3] = void 0;
          var el = !0
        } catch (J) { }
        var ec = eK.call(J);
        return el && (et ? J[e3] = eo : delete J[e3]),
          ec
      }(J) : eK.call(J)
    }
    function baseIsArguments(J) {
      return isObjectLike(J) && baseGetTag(J) == ep
    }
    function equalArrays(J, et, eo, el, ec, ed) {
      var eh = 1 & eo
        , ep = J.length
        , ef = et.length;
      if (ep != ef && !(eh && ef > ep))
        return !1;
      var em = ed.get(J);
      if (em && ed.get(et))
        return em == et;
      var eg = -1
        , ey = !0
        , eb = 2 & eo ? new SetCache : void 0;
      for (ed.set(J, et),
        ed.set(et, J); ++eg < ep;) {
        var ew = J[eg]
          , e_ = et[eg];
        if (el)
          var ex = eh ? el(e_, ew, eg, et, J, ed) : el(ew, e_, eg, J, et, ed);
        if (void 0 !== ex) {
          if (ex)
            continue;
          ey = !1;
          break
        }
        if (eb) {
          if (!function (J, et) {
            for (var eo = -1, el = null == J ? 0 : J.length; ++eo < el;)
              if (et(J[eo], eo, J))
                return !0;
            return !1
          }(et, function (J, et) {
            if (!eb.has(et) && (ew === J || ec(ew, J, eo, el, ed)))
              return eb.push(et)
          })) {
            ey = !1;
            break
          }
        } else if (!(ew === e_ || ec(ew, e_, eo, el, ed))) {
          ey = !1;
          break
        }
      }
      return ed.delete(J),
        ed.delete(et),
        ey
    }
    function getAllKeys(J) {
      var et;
      return et = function (J) {
        return null != J && isLength(J.length) && !isFunction(J) ? function (J, et) {
          var eo, el = tw(J), ec = !el && tb(J), ed = !el && !ec && t_(J), eh = !el && !ec && !ed && tx(J), ep = el || ec || ed || eh, ef = ep ? function (J, et) {
            for (var eo = -1, el = Array(J); ++eo < J;)
              el[eo] = et(eo);
            return el
          }(J.length, String) : [], em = ef.length;
          for (var eg in J)
            eG.call(J, eg) && !(ep && ("length" == eg || ed && ("offset" == eg || "parent" == eg) || eh && ("buffer" == eg || "byteLength" == eg || "byteOffset" == eg) || (eo = null == (eo = em) ? 9007199254740991 : eo) && ("number" == typeof eg || eI.test(eg)) && eg > -1 && eg % 1 == 0 && eg < eo)) && ef.push(eg);
          return ef
        }(J) : function (J) {
          if (et = J && J.constructor,
            J !== ("function" == typeof et && et.prototype || eV))
            return e4(J);
          var et, eo = [];
          for (var el in Object(J))
            eG.call(J, el) && "constructor" != el && eo.push(el);
          return eo
        }(J)
      }(J),
        tw(J) ? et : function (J, et) {
          for (var eo = -1, el = et.length, ec = J.length; ++eo < el;)
            J[ec + eo] = et[eo];
          return J
        }(et, tg(J))
    }
    function getMapData(J, et) {
      var eo, el = J.__data__;
      return ("string" == (eo = typeof et) || "number" == eo || "symbol" == eo || "boolean" == eo ? "__proto__" !== et : null === et) ? el["string" == typeof et ? "string" : "hash"] : el.map
    }
    function getNative(J, et) {
      var eo = null == J ? void 0 : J[et];
      return !(!isObject(eo) || eY && eY in eo) && (isFunction(eo) ? eJ : eR).test(toSource(eo)) ? eo : void 0
    }
    Hash.prototype.clear = function () {
      this.__data__ = ta ? ta(null) : {},
        this.size = 0
    }
      ,
      Hash.prototype.delete = function (J) {
        var et = this.has(J) && delete this.__data__[J];
        return this.size -= et ? 1 : 0,
          et
      }
      ,
      Hash.prototype.get = function (J) {
        var et = this.__data__;
        if (ta) {
          var eo = et[J];
          return eo === eh ? void 0 : eo
        }
        return eG.call(et, J) ? et[J] : void 0
      }
      ,
      Hash.prototype.has = function (J) {
        var et = this.__data__;
        return ta ? void 0 !== et[J] : eG.call(et, J)
      }
      ,
      Hash.prototype.set = function (J, et) {
        var eo = this.__data__;
        return this.size += this.has(J) ? 0 : 1,
          eo[J] = ta && void 0 === et ? eh : et,
          this
      }
      ,
      ListCache.prototype.clear = function () {
        this.__data__ = [],
          this.size = 0
      }
      ,
      ListCache.prototype.delete = function (J) {
        var et = this.__data__
          , eo = assocIndexOf(et, J);
        return !(eo < 0) && (eo == et.length - 1 ? et.pop() : e2.call(et, eo, 1),
          --this.size,
          !0)
      }
      ,
      ListCache.prototype.get = function (J) {
        var et = this.__data__
          , eo = assocIndexOf(et, J);
        return eo < 0 ? void 0 : et[eo][1]
      }
      ,
      ListCache.prototype.has = function (J) {
        return assocIndexOf(this.__data__, J) > -1
      }
      ,
      ListCache.prototype.set = function (J, et) {
        var eo = this.__data__
          , el = assocIndexOf(eo, J);
        return el < 0 ? (++this.size,
          eo.push([J, et])) : eo[el][1] = et,
          this
      }
      ,
      MapCache.prototype.clear = function () {
        this.size = 0,
          this.__data__ = {
            hash: new Hash,
            map: new (e7 || ListCache),
            string: new Hash
          }
      }
      ,
      MapCache.prototype.delete = function (J) {
        var et = getMapData(this, J).delete(J);
        return this.size -= et ? 1 : 0,
          et
      }
      ,
      MapCache.prototype.get = function (J) {
        return getMapData(this, J).get(J)
      }
      ,
      MapCache.prototype.has = function (J) {
        return getMapData(this, J).has(J)
      }
      ,
      MapCache.prototype.set = function (J, et) {
        var eo = getMapData(this, J)
          , el = eo.size;
        return eo.set(J, et),
          this.size += eo.size == el ? 0 : 1,
          this
      }
      ,
      SetCache.prototype.add = SetCache.prototype.push = function (J) {
        return this.__data__.set(J, eh),
          this
      }
      ,
      SetCache.prototype.has = function (J) {
        return this.__data__.has(J)
      }
      ,
      Stack.prototype.clear = function () {
        this.__data__ = new ListCache,
          this.size = 0
      }
      ,
      Stack.prototype.delete = function (J) {
        var et = this.__data__
          , eo = et.delete(J);
        return this.size = et.size,
          eo
      }
      ,
      Stack.prototype.get = function (J) {
        return this.__data__.get(J)
      }
      ,
      Stack.prototype.has = function (J) {
        return this.__data__.has(J)
      }
      ,
      Stack.prototype.set = function (J, et) {
        var eo = this.__data__;
        if (eo instanceof ListCache) {
          var el = eo.__data__;
          if (!e7 || el.length < 199)
            return el.push([J, et]),
              this.size = ++eo.size,
              this;
          eo = this.__data__ = new MapCache(el)
        }
        return eo.set(J, et),
          this.size = eo.size,
          this
      }
      ;
    var tg = e5 ? function (J) {
      return null == J ? [] : function (J, et) {
        for (var eo = -1, el = null == J ? 0 : J.length, ec = 0, ed = []; ++eo < el;) {
          var eh = J[eo];
          et(eh, eo, J) && (ed[ec++] = eh)
        }
        return ed
      }(e5(J = Object(J)), function (et) {
        return e1.call(J, et)
      })
    }
      : function () {
        return []
      }
      , ty = baseGetTag;
    function toSource(J) {
      if (null != J) {
        try {
          return eZ.call(J)
        } catch (J) { }
        try {
          return J + ""
        } catch (J) { }
      }
      return ""
    }
    function eq(J, et) {
      return J === et || J != J && et != et
    }
    (e8 && ty(new e8(new ArrayBuffer(1))) != eP || e7 && ty(new e7) != ew || e9 && ty(e9.resolve()) != eE || tn && ty(new tn) != eS || to && ty(new to) != eT) && (ty = function (J) {
      var et = baseGetTag(J)
        , eo = et == ex ? J.constructor : void 0
        , el = eo ? toSource(eo) : "";
      if (el)
        switch (el) {
          case tl:
            return eP;
          case tc:
            return ew;
          case td:
            return eE;
          case th:
            return eS;
          case tp:
            return eT
        }
      return et
    }
    );
    var tb = baseIsArguments(function () {
      return arguments
    }()) ? baseIsArguments : function (J) {
      return isObjectLike(J) && eG.call(J, "callee") && !e1.call(J, "callee")
    }
      , tw = Array.isArray
      , t_ = e6 || function () {
        return !1
      }
      ;
    function isFunction(J) {
      if (!isObject(J))
        return !1;
      var et = baseGetTag(J);
      return et == eb || "[object GeneratorFunction]" == et || "[object AsyncFunction]" == et || "[object Proxy]" == et
    }
    function isLength(J) {
      return "number" == typeof J && J > -1 && J % 1 == 0 && J <= 9007199254740991
    }
    function isObject(J) {
      var et = typeof J;
      return null != J && ("object" == et || "function" == et)
    }
    function isObjectLike(J) {
      return null != J && "object" == typeof J
    }
    var tx = eU ? function (J) {
      return eU(J)
    }
      : function (J) {
        return isObjectLike(J) && isLength(J.length) && !!eO[baseGetTag(J)]
      }
      ;
    J.exports = function (J, et) {
      return function baseIsEqual(J, et, eo, el, ec) {
        return J === et || (null != J && null != et && (isObjectLike(J) || isObjectLike(et)) ? function (J, et, eo, el, ec, ed) {
          var eh = tw(J)
            , eb = tw(et)
            , eE = eh ? ef : ty(J)
            , eT = eb ? ef : ty(et);
          eE = eE == ep ? ex : eE,
            eT = eT == ep ? ex : eT;
          var eR = eE == ex
            , eI = eT == ex
            , eO = eE == eT;
          if (eO && t_(J)) {
            if (!t_(et))
              return !1;
            eh = !0,
              eR = !1
          }
          if (eO && !eR)
            return ed || (ed = new Stack),
              eh || tx(J) ? equalArrays(J, et, eo, el, ec, ed) : function (J, et, eo, el, ec, ed, eh) {
                switch (eo) {
                  case eP:
                    if (J.byteLength != et.byteLength || J.byteOffset != et.byteOffset)
                      break;
                    J = J.buffer,
                      et = et.buffer;
                  case eA:
                    if (J.byteLength != et.byteLength || !ed(new e0(J), new e0(et)))
                      break;
                    return !0;
                  case em:
                  case eg:
                  case e_:
                    return eq(+J, +et);
                  case ey:
                    return J.name == et.name && J.message == et.message;
                  case eC:
                  case ek:
                    return J == et + "";
                  case ew:
                    var ep = mapToArray;
                  case eS:
                    var ef = 1 & el;
                    if (ep || (ep = setToArray),
                      J.size != et.size && !ef)
                      break;
                    var eb = eh.get(J);
                    if (eb)
                      return eb == et;
                    el |= 2,
                      eh.set(J, et);
                    var ex = equalArrays(ep(J), ep(et), el, ec, ed, eh);
                    return eh.delete(J),
                      ex;
                  case "[object Symbol]":
                    if (tm)
                      return tm.call(J) == tm.call(et)
                }
                return !1
              }(J, et, eE, eo, el, ec, ed);
          if (!(1 & eo)) {
            var eN = eR && eG.call(J, "__wrapped__")
              , eM = eI && eG.call(et, "__wrapped__");
            if (eN || eM) {
              var eD = eN ? J.value() : J
                , ej = eM ? et.value() : et;
              return ed || (ed = new Stack),
                ec(eD, ej, eo, el, ed)
            }
          }
          return !!eO && (ed || (ed = new Stack),
            function (J, et, eo, el, ec, ed) {
              var eh = 1 & eo
                , ep = getAllKeys(J)
                , ef = ep.length;
              if (ef != getAllKeys(et).length && !eh)
                return !1;
              for (var em = ef; em--;) {
                var eg = ep[em];
                if (!(eh ? eg in et : eG.call(et, eg)))
                  return !1
              }
              var ey = ed.get(J);
              if (ey && ed.get(et))
                return ey == et;
              var eb = !0;
              ed.set(J, et),
                ed.set(et, J);
              for (var ew = eh; ++em < ef;) {
                var e_ = J[eg = ep[em]]
                  , ex = et[eg];
                if (el)
                  var eE = eh ? el(ex, e_, eg, et, J, ed) : el(e_, ex, eg, J, et, ed);
                if (!(void 0 === eE ? e_ === ex || ec(e_, ex, eo, el, ed) : eE)) {
                  eb = !1;
                  break
                }
                ew || (ew = "constructor" == eg)
              }
              if (eb && !ew) {
                var eC = J.constructor
                  , eS = et.constructor;
                eC != eS && "constructor" in J && "constructor" in et && !("function" == typeof eC && eC instanceof eC && "function" == typeof eS && eS instanceof eS) && (eb = !1)
              }
              return ed.delete(J),
                ed.delete(et),
                eb
            }(J, et, eo, el, ec, ed))
        }(J, et, eo, el, baseIsEqual, ec) : J != J && et != et)
      }(J, et)
    }
  },
  30381: function (J, et, eo) {
    (J = eo.nmd(J)).exports = function () {
      "use strict";
      function hooks() {
        return ey.apply(null, arguments)
      }
      function isArray(J) {
        return J instanceof Array || "[object Array]" === Object.prototype.toString.call(J)
      }
      function isObject(J) {
        return null != J && "[object Object]" === Object.prototype.toString.call(J)
      }
      function hasOwnProp(J, et) {
        return Object.prototype.hasOwnProperty.call(J, et)
      }
      function isObjectEmpty(J) {
        var et;
        if (Object.getOwnPropertyNames)
          return 0 === Object.getOwnPropertyNames(J).length;
        for (et in J)
          if (hasOwnProp(J, et))
            return !1;
        return !0
      }
      function isUndefined(J) {
        return void 0 === J
      }
      function isNumber(J) {
        return "number" == typeof J || "[object Number]" === Object.prototype.toString.call(J)
      }
      function isDate(J) {
        return J instanceof Date || "[object Date]" === Object.prototype.toString.call(J)
      }
      function map(J, et) {
        var eo, el = [], ec = J.length;
        for (eo = 0; eo < ec; ++eo)
          el.push(et(J[eo], eo));
        return el
      }
      function extend(J, et) {
        for (var eo in et)
          hasOwnProp(et, eo) && (J[eo] = et[eo]);
        return hasOwnProp(et, "toString") && (J.toString = et.toString),
          hasOwnProp(et, "valueOf") && (J.valueOf = et.valueOf),
          J
      }
      function createUTC(J, et, eo, el) {
        return createLocalOrUTC(J, et, eo, el, !0).utc()
      }
      function getParsingFlags(J) {
        return null == J._pf && (J._pf = {
          empty: !1,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: !1,
          invalidEra: null,
          invalidMonth: null,
          invalidFormat: !1,
          userInvalidated: !1,
          iso: !1,
          parsedDateParts: [],
          era: null,
          meridiem: null,
          rfc2822: !1,
          weekdayMismatch: !1
        }),
          J._pf
      }
      function isValid(J) {
        var et = null
          , eo = !1
          , el = J._d && !isNaN(J._d.getTime());
        return (el && (et = getParsingFlags(J),
          eo = eb.call(et.parsedDateParts, function (J) {
            return null != J
          }),
          el = et.overflow < 0 && !et.empty && !et.invalidEra && !et.invalidMonth && !et.invalidWeekday && !et.weekdayMismatch && !et.nullInput && !et.invalidFormat && !et.userInvalidated && (!et.meridiem || et.meridiem && eo),
          J._strict && (el = el && 0 === et.charsLeftOver && 0 === et.unusedTokens.length && void 0 === et.bigHour)),
          null != Object.isFrozen && Object.isFrozen(J)) ? el : (J._isValid = el,
            J._isValid)
      }
      function createInvalid(J) {
        var et = createUTC(NaN);
        return null != J ? extend(getParsingFlags(et), J) : getParsingFlags(et).userInvalidated = !0,
          et
      }
      eb = Array.prototype.some ? Array.prototype.some : function (J) {
        var et, eo = Object(this), el = eo.length >>> 0;
        for (et = 0; et < el; et++)
          if (et in eo && J.call(this, eo[et], et, eo))
            return !0;
        return !1
      }
        ;
      var et, eo, el = hooks.momentProperties = [], ec = !1;
      function copyConfig(J, et) {
        var eo, ec, ed, eh = el.length;
        if (isUndefined(et._isAMomentObject) || (J._isAMomentObject = et._isAMomentObject),
          isUndefined(et._i) || (J._i = et._i),
          isUndefined(et._f) || (J._f = et._f),
          isUndefined(et._l) || (J._l = et._l),
          isUndefined(et._strict) || (J._strict = et._strict),
          isUndefined(et._tzm) || (J._tzm = et._tzm),
          isUndefined(et._isUTC) || (J._isUTC = et._isUTC),
          isUndefined(et._offset) || (J._offset = et._offset),
          isUndefined(et._pf) || (J._pf = getParsingFlags(et)),
          isUndefined(et._locale) || (J._locale = et._locale),
          eh > 0)
          for (eo = 0; eo < eh; eo++)
            isUndefined(ed = et[ec = el[eo]]) || (J[ec] = ed);
        return J
      }
      function Moment(J) {
        copyConfig(this, J),
          this._d = new Date(null != J._d ? J._d.getTime() : NaN),
          this.isValid() || (this._d = new Date(NaN)),
          !1 === ec && (ec = !0,
            hooks.updateOffset(this),
            ec = !1)
      }
      function isMoment(J) {
        return J instanceof Moment || null != J && null != J._isAMomentObject
      }
      function warn(J) {
        !1 === hooks.suppressDeprecationWarnings && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + J)
      }
      function deprecate(J, et) {
        var eo = !0;
        return extend(function () {
          if (null != hooks.deprecationHandler && hooks.deprecationHandler(null, J),
            eo) {
            var el, ec, ed, eh = [], ep = arguments.length;
            for (ec = 0; ec < ep; ec++) {
              if (el = "",
                "object" == typeof arguments[ec]) {
                for (ed in el += "\n[" + ec + "] ",
                  arguments[0])
                  hasOwnProp(arguments[0], ed) && (el += ed + ": " + arguments[0][ed] + ", ");
                el = el.slice(0, -2)
              } else
                el = arguments[ec];
              eh.push(el)
            }
            warn(J + "\nArguments: " + Array.prototype.slice.call(eh).join("") + "\n" + Error().stack),
              eo = !1
          }
          return et.apply(this, arguments)
        }, et)
      }
      var ed = {};
      function deprecateSimple(J, et) {
        null != hooks.deprecationHandler && hooks.deprecationHandler(J, et),
          ed[J] || (warn(et),
            ed[J] = !0)
      }
      function isFunction(J) {
        return "undefined" != typeof Function && J instanceof Function || "[object Function]" === Object.prototype.toString.call(J)
      }
      function mergeConfigs(J, et) {
        var eo, el = extend({}, J);
        for (eo in et)
          hasOwnProp(et, eo) && (isObject(J[eo]) && isObject(et[eo]) ? (el[eo] = {},
            extend(el[eo], J[eo]),
            extend(el[eo], et[eo])) : null != et[eo] ? el[eo] = et[eo] : delete el[eo]);
        for (eo in J)
          hasOwnProp(J, eo) && !hasOwnProp(et, eo) && isObject(J[eo]) && (el[eo] = extend({}, el[eo]));
        return el
      }
      function Locale(J) {
        null != J && this.set(J)
      }
      function zeroFill(J, et, eo) {
        var el = "" + Math.abs(J);
        return (J >= 0 ? eo ? "+" : "" : "-") + Math.pow(10, Math.max(0, et - el.length)).toString().substr(1) + el
      }
      hooks.suppressDeprecationWarnings = !1,
        hooks.deprecationHandler = null,
        ew = Object.keys ? Object.keys : function (J) {
          var et, eo = [];
          for (et in J)
            hasOwnProp(J, et) && eo.push(et);
          return eo
        }
        ;
      var eh = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g
        , ep = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g
        , ef = {}
        , em = {};
      function addFormatToken(J, et, eo, el) {
        var ec = el;
        "string" == typeof el && (ec = function () {
          return this[el]()
        }
        ),
          J && (em[J] = ec),
          et && (em[et[0]] = function () {
            return zeroFill(ec.apply(this, arguments), et[1], et[2])
          }
          ),
          eo && (em[eo] = function () {
            return this.localeData().ordinal(ec.apply(this, arguments), J)
          }
          )
      }
      function formatMoment(J, et) {
        return J.isValid() ? (ef[et = expandFormat(et, J.localeData())] = ef[et] || function (J) {
          var et, eo, el, ec = J.match(eh);
          for (eo = 0,
            el = ec.length; eo < el; eo++)
            em[ec[eo]] ? ec[eo] = em[ec[eo]] : ec[eo] = (et = ec[eo]).match(/\[[\s\S]/) ? et.replace(/^\[|\]$/g, "") : et.replace(/\\/g, "");
          return function (et) {
            var eo, ed = "";
            for (eo = 0; eo < el; eo++)
              ed += isFunction(ec[eo]) ? ec[eo].call(et, J) : ec[eo];
            return ed
          }
        }(et),
          ef[et](J)) : J.localeData().invalidDate()
      }
      function expandFormat(J, et) {
        var eo = 5;
        function replaceLongDateFormatTokens(J) {
          return et.longDateFormat(J) || J
        }
        for (ep.lastIndex = 0; eo >= 0 && ep.test(J);)
          J = J.replace(ep, replaceLongDateFormatTokens),
            ep.lastIndex = 0,
            eo -= 1;
        return J
      }
      var eg = {
        D: "date",
        dates: "date",
        date: "date",
        d: "day",
        days: "day",
        day: "day",
        e: "weekday",
        weekdays: "weekday",
        weekday: "weekday",
        E: "isoWeekday",
        isoweekdays: "isoWeekday",
        isoweekday: "isoWeekday",
        DDD: "dayOfYear",
        dayofyears: "dayOfYear",
        dayofyear: "dayOfYear",
        h: "hour",
        hours: "hour",
        hour: "hour",
        ms: "millisecond",
        milliseconds: "millisecond",
        millisecond: "millisecond",
        m: "minute",
        minutes: "minute",
        minute: "minute",
        M: "month",
        months: "month",
        month: "month",
        Q: "quarter",
        quarters: "quarter",
        quarter: "quarter",
        s: "second",
        seconds: "second",
        second: "second",
        gg: "weekYear",
        weekyears: "weekYear",
        weekyear: "weekYear",
        GG: "isoWeekYear",
        isoweekyears: "isoWeekYear",
        isoweekyear: "isoWeekYear",
        w: "week",
        weeks: "week",
        week: "week",
        W: "isoWeek",
        isoweeks: "isoWeek",
        isoweek: "isoWeek",
        y: "year",
        years: "year",
        year: "year"
      };
      function normalizeUnits(J) {
        return "string" == typeof J ? eg[J] || eg[J.toLowerCase()] : void 0
      }
      function normalizeObjectUnits(J) {
        var et, eo, el = {};
        for (eo in J)
          hasOwnProp(J, eo) && (et = normalizeUnits(eo)) && (el[et] = J[eo]);
        return el
      }
      var ey, eb, ew, e_, ex = {
        date: 9,
        day: 11,
        weekday: 11,
        isoWeekday: 11,
        dayOfYear: 4,
        hour: 13,
        millisecond: 16,
        minute: 14,
        month: 8,
        quarter: 7,
        second: 15,
        weekYear: 1,
        isoWeekYear: 1,
        week: 5,
        isoWeek: 5,
        year: 1
      }, eE = /\d/, eC = /\d\d/, eS = /\d{3}/, ek = /\d{4}/, eT = /[+-]?\d{6}/, eA = /\d\d?/, eP = /\d\d\d\d?/, eR = /\d\d\d\d\d\d?/, eI = /\d{1,3}/, eO = /\d{1,4}/, eN = /[+-]?\d{1,6}/, eM = /\d+/, eD = /[+-]?\d+/, ej = /Z|[+-]\d\d:?\d\d/gi, eL = /Z|[+-]\d\d(?::?\d\d)?/gi, e$ = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, eB = /^[1-9]\d?/, eF = /^([1-9]\d|\d)/;
      function addRegexToken(J, et, eo) {
        e_[J] = isFunction(et) ? et : function (J, el) {
          return J && eo ? eo : et
        }
      }
      function regexEscape(J) {
        return J.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
      }
      function absFloor(J) {
        return J < 0 ? Math.ceil(J) || 0 : Math.floor(J)
      }
      function toInt(J) {
        var et = +J
          , eo = 0;
        return 0 !== et && isFinite(et) && (eo = absFloor(et)),
          eo
      }
      e_ = {};
      var eU = {};
      function addParseToken(J, et) {
        var eo, el, ec = et;
        for ("string" == typeof J && (J = [J]),
          isNumber(et) && (ec = function (J, eo) {
            eo[et] = toInt(J)
          }
          ),
          el = J.length,
          eo = 0; eo < el; eo++)
          eU[J[eo]] = ec
      }
      function addWeekParseToken(J, et) {
        addParseToken(J, function (J, eo, el, ec) {
          el._w = el._w || {},
            et(J, el._w, el, ec)
        })
      }
      function isLeapYear(J) {
        return J % 4 == 0 && J % 100 != 0 || J % 400 == 0
      }
      function daysInYear(J) {
        return isLeapYear(J) ? 366 : 365
      }
      addFormatToken("Y", 0, 0, function () {
        var J = this.year();
        return J <= 9999 ? zeroFill(J, 4) : "+" + J
      }),
        addFormatToken(0, ["YY", 2], 0, function () {
          return this.year() % 100
        }),
        addFormatToken(0, ["YYYY", 4], 0, "year"),
        addFormatToken(0, ["YYYYY", 5], 0, "year"),
        addFormatToken(0, ["YYYYYY", 6, !0], 0, "year"),
        addRegexToken("Y", eD),
        addRegexToken("YY", eA, eC),
        addRegexToken("YYYY", eO, ek),
        addRegexToken("YYYYY", eN, eT),
        addRegexToken("YYYYYY", eN, eT),
        addParseToken(["YYYYY", "YYYYYY"], 0),
        addParseToken("YYYY", function (J, et) {
          et[0] = 2 === J.length ? hooks.parseTwoDigitYear(J) : toInt(J)
        }),
        addParseToken("YY", function (J, et) {
          et[0] = hooks.parseTwoDigitYear(J)
        }),
        addParseToken("Y", function (J, et) {
          et[0] = parseInt(J, 10)
        }),
        hooks.parseTwoDigitYear = function (J) {
          return toInt(J) + (toInt(J) > 68 ? 1900 : 2e3)
        }
        ;
      var ez = makeGetSet("FullYear", !0);
      function makeGetSet(J, et) {
        return function (eo) {
          return null != eo ? (set$1(this, J, eo),
            hooks.updateOffset(this, et),
            this) : get(this, J)
        }
      }
      function get(J, et) {
        if (!J.isValid())
          return NaN;
        var eo = J._d
          , el = J._isUTC;
        switch (et) {
          case "Milliseconds":
            return el ? eo.getUTCMilliseconds() : eo.getMilliseconds();
          case "Seconds":
            return el ? eo.getUTCSeconds() : eo.getSeconds();
          case "Minutes":
            return el ? eo.getUTCMinutes() : eo.getMinutes();
          case "Hours":
            return el ? eo.getUTCHours() : eo.getHours();
          case "Date":
            return el ? eo.getUTCDate() : eo.getDate();
          case "Day":
            return el ? eo.getUTCDay() : eo.getDay();
          case "Month":
            return el ? eo.getUTCMonth() : eo.getMonth();
          case "FullYear":
            return el ? eo.getUTCFullYear() : eo.getFullYear();
          default:
            return NaN
        }
      }
      function set$1(J, et, eo) {
        var el, ec, ed, eh;
        if (!(!J.isValid() || isNaN(eo))) {
          switch (el = J._d,
          ec = J._isUTC,
          et) {
            case "Milliseconds":
              return void (ec ? el.setUTCMilliseconds(eo) : el.setMilliseconds(eo));
            case "Seconds":
              return void (ec ? el.setUTCSeconds(eo) : el.setSeconds(eo));
            case "Minutes":
              return void (ec ? el.setUTCMinutes(eo) : el.setMinutes(eo));
            case "Hours":
              return void (ec ? el.setUTCHours(eo) : el.setHours(eo));
            case "Date":
              return void (ec ? el.setUTCDate(eo) : el.setDate(eo));
            case "FullYear":
              break;
            default:
              return
          }
          ed = J.month(),
            eh = 29 !== (eh = J.date()) || 1 !== ed || isLeapYear(eo) ? eh : 28,
            ec ? el.setUTCFullYear(eo, ed, eh) : el.setFullYear(eo, ed, eh)
        }
      }
      function daysInMonth(J, et) {
        if (isNaN(J) || isNaN(et))
          return NaN;
        var eo = (et % 12 + 12) % 12;
        return J += (et - eo) / 12,
          1 === eo ? isLeapYear(J) ? 29 : 28 : 31 - eo % 7 % 2
      }
      eZ = Array.prototype.indexOf ? Array.prototype.indexOf : function (J) {
        var et;
        for (et = 0; et < this.length; ++et)
          if (this[et] === J)
            return et;
        return -1
      }
        ,
        addFormatToken("M", ["MM", 2], "Mo", function () {
          return this.month() + 1
        }),
        addFormatToken("MMM", 0, 0, function (J) {
          return this.localeData().monthsShort(this, J)
        }),
        addFormatToken("MMMM", 0, 0, function (J) {
          return this.localeData().months(this, J)
        }),
        addRegexToken("M", eA, eB),
        addRegexToken("MM", eA, eC),
        addRegexToken("MMM", function (J, et) {
          return et.monthsShortRegex(J)
        }),
        addRegexToken("MMMM", function (J, et) {
          return et.monthsRegex(J)
        }),
        addParseToken(["M", "MM"], function (J, et) {
          et[1] = toInt(J) - 1
        }),
        addParseToken(["MMM", "MMMM"], function (J, et, eo, el) {
          var ec = eo._locale.monthsParse(J, el, eo._strict);
          null != ec ? et[1] = ec : getParsingFlags(eo).invalidMonth = J
        });
      var eH = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_")
        , eV = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
      function handleStrictParse(J, et, eo) {
        var el, ec, ed, eh = J.toLocaleLowerCase();
        if (!this._monthsParse)
          for (el = 0,
            this._monthsParse = [],
            this._longMonthsParse = [],
            this._shortMonthsParse = []; el < 12; ++el)
            ed = createUTC([2e3, el]),
              this._shortMonthsParse[el] = this.monthsShort(ed, "").toLocaleLowerCase(),
              this._longMonthsParse[el] = this.months(ed, "").toLocaleLowerCase();
        return eo ? "MMM" === et ? -1 !== (ec = eZ.call(this._shortMonthsParse, eh)) ? ec : null : -1 !== (ec = eZ.call(this._longMonthsParse, eh)) ? ec : null : "MMM" === et ? -1 !== (ec = eZ.call(this._shortMonthsParse, eh)) ? ec : -1 !== (ec = eZ.call(this._longMonthsParse, eh)) ? ec : null : -1 !== (ec = eZ.call(this._longMonthsParse, eh)) ? ec : -1 !== (ec = eZ.call(this._shortMonthsParse, eh)) ? ec : null
      }
      function setMonth(J, et) {
        if (!J.isValid())
          return J;
        if ("string" == typeof et) {
          if (/^\d+$/.test(et))
            et = toInt(et);
          else if (!isNumber(et = J.localeData().monthsParse(et)))
            return J
        }
        var eo = et
          , el = J.date();
        return el = el < 29 ? el : Math.min(el, daysInMonth(J.year(), eo)),
          J._isUTC ? J._d.setUTCMonth(eo, el) : J._d.setMonth(eo, el),
          J
      }
      function getSetMonth(J) {
        return null != J ? (setMonth(this, J),
          hooks.updateOffset(this, !0),
          this) : get(this, "Month")
      }
      function computeMonthsParse() {
        function cmpLenRev(J, et) {
          return et.length - J.length
        }
        var J, et, eo, el, ec = [], ed = [], eh = [];
        for (J = 0; J < 12; J++)
          et = createUTC([2e3, J]),
            eo = regexEscape(this.monthsShort(et, "")),
            el = regexEscape(this.months(et, "")),
            ec.push(eo),
            ed.push(el),
            eh.push(el),
            eh.push(eo);
        ec.sort(cmpLenRev),
          ed.sort(cmpLenRev),
          eh.sort(cmpLenRev),
          this._monthsRegex = RegExp("^(" + eh.join("|") + ")", "i"),
          this._monthsShortRegex = this._monthsRegex,
          this._monthsStrictRegex = RegExp("^(" + ed.join("|") + ")", "i"),
          this._monthsShortStrictRegex = RegExp("^(" + ec.join("|") + ")", "i")
      }
      function createDate(J, et, eo, el, ec, ed, eh) {
        var ep;
        return J < 100 && J >= 0 ? isFinite((ep = new Date(J + 400, et, eo, el, ec, ed, eh)).getFullYear()) && ep.setFullYear(J) : ep = new Date(J, et, eo, el, ec, ed, eh),
          ep
      }
      function createUTCDate(J) {
        var et, eo;
        return J < 100 && J >= 0 ? (eo = Array.prototype.slice.call(arguments),
          eo[0] = J + 400,
          isFinite((et = new Date(Date.UTC.apply(null, eo))).getUTCFullYear()) && et.setUTCFullYear(J)) : et = new Date(Date.UTC.apply(null, arguments)),
          et
      }
      function firstWeekOffset(J, et, eo) {
        var el = 7 + et - eo;
        return -((7 + createUTCDate(J, 0, el).getUTCDay() - et) % 7) + el - 1
      }
      function dayOfYearFromWeeks(J, et, eo, el, ec) {
        var ed, eh, ep = 1 + 7 * (et - 1) + (7 + eo - el) % 7 + firstWeekOffset(J, el, ec);
        return ep <= 0 ? eh = daysInYear(ed = J - 1) + ep : ep > daysInYear(J) ? (ed = J + 1,
          eh = ep - daysInYear(J)) : (ed = J,
            eh = ep),
        {
          year: ed,
          dayOfYear: eh
        }
      }
      function weekOfYear(J, et, eo) {
        var el, ec, ed = firstWeekOffset(J.year(), et, eo), eh = Math.floor((J.dayOfYear() - ed - 1) / 7) + 1;
        return eh < 1 ? el = eh + weeksInYear(ec = J.year() - 1, et, eo) : eh > weeksInYear(J.year(), et, eo) ? (el = eh - weeksInYear(J.year(), et, eo),
          ec = J.year() + 1) : (ec = J.year(),
            el = eh),
        {
          week: el,
          year: ec
        }
      }
      function weeksInYear(J, et, eo) {
        var el = firstWeekOffset(J, et, eo)
          , ec = firstWeekOffset(J + 1, et, eo);
        return (daysInYear(J) - el + ec) / 7
      }
      function shiftWeekdays(J, et) {
        return J.slice(et, 7).concat(J.slice(0, et))
      }
      addFormatToken("w", ["ww", 2], "wo", "week"),
        addFormatToken("W", ["WW", 2], "Wo", "isoWeek"),
        addRegexToken("w", eA, eB),
        addRegexToken("ww", eA, eC),
        addRegexToken("W", eA, eB),
        addRegexToken("WW", eA, eC),
        addWeekParseToken(["w", "ww", "W", "WW"], function (J, et, eo, el) {
          et[el.substr(0, 1)] = toInt(J)
        }),
        addFormatToken("d", 0, "do", "day"),
        addFormatToken("dd", 0, 0, function (J) {
          return this.localeData().weekdaysMin(this, J)
        }),
        addFormatToken("ddd", 0, 0, function (J) {
          return this.localeData().weekdaysShort(this, J)
        }),
        addFormatToken("dddd", 0, 0, function (J) {
          return this.localeData().weekdays(this, J)
        }),
        addFormatToken("e", 0, 0, "weekday"),
        addFormatToken("E", 0, 0, "isoWeekday"),
        addRegexToken("d", eA),
        addRegexToken("e", eA),
        addRegexToken("E", eA),
        addRegexToken("dd", function (J, et) {
          return et.weekdaysMinRegex(J)
        }),
        addRegexToken("ddd", function (J, et) {
          return et.weekdaysShortRegex(J)
        }),
        addRegexToken("dddd", function (J, et) {
          return et.weekdaysRegex(J)
        }),
        addWeekParseToken(["dd", "ddd", "dddd"], function (J, et, eo, el) {
          var ec = eo._locale.weekdaysParse(J, el, eo._strict);
          null != ec ? et.d = ec : getParsingFlags(eo).invalidWeekday = J
        }),
        addWeekParseToken(["d", "e", "E"], function (J, et, eo, el) {
          et[el] = toInt(J)
        });
      var eW = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");
      function handleStrictParse$1(J, et, eo) {
        var el, ec, ed, eh = J.toLocaleLowerCase();
        if (!this._weekdaysParse)
          for (el = 0,
            this._weekdaysParse = [],
            this._shortWeekdaysParse = [],
            this._minWeekdaysParse = []; el < 7; ++el)
            ed = createUTC([2e3, 1]).day(el),
              this._minWeekdaysParse[el] = this.weekdaysMin(ed, "").toLocaleLowerCase(),
              this._shortWeekdaysParse[el] = this.weekdaysShort(ed, "").toLocaleLowerCase(),
              this._weekdaysParse[el] = this.weekdays(ed, "").toLocaleLowerCase();
        return eo ? "dddd" === et ? -1 !== (ec = eZ.call(this._weekdaysParse, eh)) ? ec : null : "ddd" === et ? -1 !== (ec = eZ.call(this._shortWeekdaysParse, eh)) ? ec : null : -1 !== (ec = eZ.call(this._minWeekdaysParse, eh)) ? ec : null : "dddd" === et ? -1 !== (ec = eZ.call(this._weekdaysParse, eh)) || -1 !== (ec = eZ.call(this._shortWeekdaysParse, eh)) ? ec : -1 !== (ec = eZ.call(this._minWeekdaysParse, eh)) ? ec : null : "ddd" === et ? -1 !== (ec = eZ.call(this._shortWeekdaysParse, eh)) || -1 !== (ec = eZ.call(this._weekdaysParse, eh)) ? ec : -1 !== (ec = eZ.call(this._minWeekdaysParse, eh)) ? ec : null : -1 !== (ec = eZ.call(this._minWeekdaysParse, eh)) || -1 !== (ec = eZ.call(this._weekdaysParse, eh)) ? ec : -1 !== (ec = eZ.call(this._shortWeekdaysParse, eh)) ? ec : null
      }
      function computeWeekdaysParse() {
        function cmpLenRev(J, et) {
          return et.length - J.length
        }
        var J, et, eo, el, ec, ed = [], eh = [], ep = [], ef = [];
        for (J = 0; J < 7; J++)
          et = createUTC([2e3, 1]).day(J),
            eo = regexEscape(this.weekdaysMin(et, "")),
            el = regexEscape(this.weekdaysShort(et, "")),
            ec = regexEscape(this.weekdays(et, "")),
            ed.push(eo),
            eh.push(el),
            ep.push(ec),
            ef.push(eo),
            ef.push(el),
            ef.push(ec);
        ed.sort(cmpLenRev),
          eh.sort(cmpLenRev),
          ep.sort(cmpLenRev),
          ef.sort(cmpLenRev),
          this._weekdaysRegex = RegExp("^(" + ef.join("|") + ")", "i"),
          this._weekdaysShortRegex = this._weekdaysRegex,
          this._weekdaysMinRegex = this._weekdaysRegex,
          this._weekdaysStrictRegex = RegExp("^(" + ep.join("|") + ")", "i"),
          this._weekdaysShortStrictRegex = RegExp("^(" + eh.join("|") + ")", "i"),
          this._weekdaysMinStrictRegex = RegExp("^(" + ed.join("|") + ")", "i")
      }
      function hFormat() {
        return this.hours() % 12 || 12
      }
      function meridiem(J, et) {
        addFormatToken(J, 0, 0, function () {
          return this.localeData().meridiem(this.hours(), this.minutes(), et)
        })
      }
      function matchMeridiem(J, et) {
        return et._meridiemParse
      }
      addFormatToken("H", ["HH", 2], 0, "hour"),
        addFormatToken("h", ["hh", 2], 0, hFormat),
        addFormatToken("k", ["kk", 2], 0, function () {
          return this.hours() || 24
        }),
        addFormatToken("hmm", 0, 0, function () {
          return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2)
        }),
        addFormatToken("hmmss", 0, 0, function () {
          return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2)
        }),
        addFormatToken("Hmm", 0, 0, function () {
          return "" + this.hours() + zeroFill(this.minutes(), 2)
        }),
        addFormatToken("Hmmss", 0, 0, function () {
          return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2)
        }),
        meridiem("a", !0),
        meridiem("A", !1),
        addRegexToken("a", matchMeridiem),
        addRegexToken("A", matchMeridiem),
        addRegexToken("H", eA, eF),
        addRegexToken("h", eA, eB),
        addRegexToken("k", eA, eB),
        addRegexToken("HH", eA, eC),
        addRegexToken("hh", eA, eC),
        addRegexToken("kk", eA, eC),
        addRegexToken("hmm", eP),
        addRegexToken("hmmss", eR),
        addRegexToken("Hmm", eP),
        addRegexToken("Hmmss", eR),
        addParseToken(["H", "HH"], 3),
        addParseToken(["k", "kk"], function (J, et, eo) {
          var el = toInt(J);
          et[3] = 24 === el ? 0 : el
        }),
        addParseToken(["a", "A"], function (J, et, eo) {
          eo._isPm = eo._locale.isPM(J),
            eo._meridiem = J
        }),
        addParseToken(["h", "hh"], function (J, et, eo) {
          et[3] = toInt(J),
            getParsingFlags(eo).bigHour = !0
        }),
        addParseToken("hmm", function (J, et, eo) {
          var el = J.length - 2;
          et[3] = toInt(J.substr(0, el)),
            et[4] = toInt(J.substr(el)),
            getParsingFlags(eo).bigHour = !0
        }),
        addParseToken("hmmss", function (J, et, eo) {
          var el = J.length - 4
            , ec = J.length - 2;
          et[3] = toInt(J.substr(0, el)),
            et[4] = toInt(J.substr(el, 2)),
            et[5] = toInt(J.substr(ec)),
            getParsingFlags(eo).bigHour = !0
        }),
        addParseToken("Hmm", function (J, et, eo) {
          var el = J.length - 2;
          et[3] = toInt(J.substr(0, el)),
            et[4] = toInt(J.substr(el))
        }),
        addParseToken("Hmmss", function (J, et, eo) {
          var el = J.length - 4
            , ec = J.length - 2;
          et[3] = toInt(J.substr(0, el)),
            et[4] = toInt(J.substr(el, 2)),
            et[5] = toInt(J.substr(ec))
        });
      var eZ, eG, eY = makeGetSet("Hours", !0), eK = {
        calendar: {
          sameDay: "[Today at] LT",
          nextDay: "[Tomorrow at] LT",
          nextWeek: "dddd [at] LT",
          lastDay: "[Yesterday at] LT",
          lastWeek: "[Last] dddd [at] LT",
          sameElse: "L"
        },
        longDateFormat: {
          LTS: "h:mm:ss A",
          LT: "h:mm A",
          L: "MM/DD/YYYY",
          LL: "MMMM D, YYYY",
          LLL: "MMMM D, YYYY h:mm A",
          LLLL: "dddd, MMMM D, YYYY h:mm A"
        },
        invalidDate: "Invalid date",
        ordinal: "%d",
        dayOfMonthOrdinalParse: /\d{1,2}/,
        relativeTime: {
          future: "in %s",
          past: "%s ago",
          s: "a few seconds",
          ss: "%d seconds",
          m: "a minute",
          mm: "%d minutes",
          h: "an hour",
          hh: "%d hours",
          d: "a day",
          dd: "%d days",
          w: "a week",
          ww: "%d weeks",
          M: "a month",
          MM: "%d months",
          y: "a year",
          yy: "%d years"
        },
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        monthsShort: eH,
        week: {
          dow: 0,
          doy: 6
        },
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        weekdaysShort: eW,
        meridiemParse: /[ap]\.?m?\.?/i
      }, eJ = {}, eQ = {};
      function normalizeLocale(J) {
        return J ? J.toLowerCase().replace("_", "-") : J
      }
      function loadLocale(et) {
        var eo = null;
        if (void 0 === eJ[et] && J && J.exports && et && et.match("^[^/\\\\]*$"))
          try {
            eo = eG._abbr,
              function () {
                var J = Error("Cannot find module 'undefined'");
                throw J.code = "MODULE_NOT_FOUND",
                J
              }(),
              getSetGlobalLocale(eo)
          } catch (J) {
            eJ[et] = null
          }
        return eJ[et]
      }
      function getSetGlobalLocale(J, et) {
        var eo;
        return J && ((eo = isUndefined(et) ? getLocale(J) : defineLocale(J, et)) ? eG = eo : "undefined" != typeof console && console.warn && console.warn("Locale " + J + " not found. Did you forget to load it?")),
          eG._abbr
      }
      function defineLocale(J, et) {
        if (null === et)
          return delete eJ[J],
            null;
        var eo, el = eK;
        if (et.abbr = J,
          null != eJ[J])
          deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."),
            el = eJ[J]._config;
        else if (null != et.parentLocale) {
          if (null != eJ[et.parentLocale])
            el = eJ[et.parentLocale]._config;
          else {
            if (null == (eo = loadLocale(et.parentLocale)))
              return eQ[et.parentLocale] || (eQ[et.parentLocale] = []),
                eQ[et.parentLocale].push({
                  name: J,
                  config: et
                }),
                null;
            el = eo._config
          }
        }
        return eJ[J] = new Locale(mergeConfigs(el, et)),
          eQ[J] && eQ[J].forEach(function (J) {
            defineLocale(J.name, J.config)
          }),
          getSetGlobalLocale(J),
          eJ[J]
      }
      function getLocale(J) {
        var et;
        if (J && J._locale && J._locale._abbr && (J = J._locale._abbr),
          !J)
          return eG;
        if (!isArray(J)) {
          if (et = loadLocale(J))
            return et;
          J = [J]
        }
        return function (J) {
          for (var et, eo, el, ec, ed = 0; ed < J.length;) {
            for (et = (ec = normalizeLocale(J[ed]).split("-")).length,
              eo = (eo = normalizeLocale(J[ed + 1])) ? eo.split("-") : null; et > 0;) {
              if (el = loadLocale(ec.slice(0, et).join("-")))
                return el;
              if (eo && eo.length >= et && function (J, et) {
                var eo, el = Math.min(J.length, et.length);
                for (eo = 0; eo < el; eo += 1)
                  if (J[eo] !== et[eo])
                    return eo;
                return el
              }(ec, eo) >= et - 1)
                break;
              et--
            }
            ed++
          }
          return eG
        }(J)
      }
      function checkOverflow(J) {
        var et, eo = J._a;
        return eo && -2 === getParsingFlags(J).overflow && (et = eo[1] < 0 || eo[1] > 11 ? 1 : eo[2] < 1 || eo[2] > daysInMonth(eo[0], eo[1]) ? 2 : eo[3] < 0 || eo[3] > 24 || 24 === eo[3] && (0 !== eo[4] || 0 !== eo[5] || 0 !== eo[6]) ? 3 : eo[4] < 0 || eo[4] > 59 ? 4 : eo[5] < 0 || eo[5] > 59 ? 5 : eo[6] < 0 || eo[6] > 999 ? 6 : -1,
          getParsingFlags(J)._overflowDayOfYear && (et < 0 || et > 2) && (et = 2),
          getParsingFlags(J)._overflowWeeks && -1 === et && (et = 7),
          getParsingFlags(J)._overflowWeekday && -1 === et && (et = 8),
          getParsingFlags(J).overflow = et),
          J
      }
      var eX = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/
        , e0 = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/
        , e1 = /Z|[+-]\d\d(?::?\d\d)?/
        , e2 = [["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/], ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/], ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/], ["GGGG-[W]WW", /\d{4}-W\d\d/, !1], ["YYYY-DDD", /\d{4}-\d{3}/], ["YYYY-MM", /\d{4}-\d\d/, !1], ["YYYYYYMMDD", /[+-]\d{10}/], ["YYYYMMDD", /\d{8}/], ["GGGG[W]WWE", /\d{4}W\d{3}/], ["GGGG[W]WW", /\d{4}W\d{2}/, !1], ["YYYYDDD", /\d{7}/], ["YYYYMM", /\d{6}/, !1], ["YYYY", /\d{4}/, !1]]
        , e3 = [["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/], ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/], ["HH:mm:ss", /\d\d:\d\d:\d\d/], ["HH:mm", /\d\d:\d\d/], ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/], ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/], ["HHmmss", /\d\d\d\d\d\d/], ["HHmm", /\d\d\d\d/], ["HH", /\d\d/]]
        , e5 = /^\/?Date\((-?\d+)/i
        , e6 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/
        , e4 = {
          UT: 0,
          GMT: 0,
          EDT: -240,
          EST: -300,
          CDT: -300,
          CST: -360,
          MDT: -360,
          MST: -420,
          PDT: -420,
          PST: -480
        };
      function configFromISO(J) {
        var et, eo, el, ec, ed, eh, ep = J._i, ef = eX.exec(ep) || e0.exec(ep), em = e2.length, eg = e3.length;
        if (ef) {
          for (et = 0,
            getParsingFlags(J).iso = !0,
            eo = em; et < eo; et++)
            if (e2[et][1].exec(ef[1])) {
              ec = e2[et][0],
                el = !1 !== e2[et][2];
              break
            }
          if (null == ec) {
            J._isValid = !1;
            return
          }
          if (ef[3]) {
            for (et = 0,
              eo = eg; et < eo; et++)
              if (e3[et][1].exec(ef[3])) {
                ed = (ef[2] || " ") + e3[et][0];
                break
              }
            if (null == ed) {
              J._isValid = !1;
              return
            }
          }
          if (!el && null != ed) {
            J._isValid = !1;
            return
          }
          if (ef[4]) {
            if (e1.exec(ef[4]))
              eh = "Z";
            else {
              J._isValid = !1;
              return
            }
          }
          J._f = ec + (ed || "") + (eh || ""),
            configFromStringAndFormat(J)
        } else
          J._isValid = !1
      }
      function configFromRFC2822(J) {
        var et, eo, el, ec, ed, eh, ep, ef, em, eg = e6.exec(J._i.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, ""));
        if (eg) {
          if (eo = eg[4],
            el = eg[3],
            ec = eg[2],
            ed = eg[5],
            eh = eg[6],
            ep = eg[7],
            ef = [(et = parseInt(eo, 10)) <= 49 ? 2e3 + et : et <= 999 ? 1900 + et : et, eH.indexOf(el), parseInt(ec, 10), parseInt(ed, 10), parseInt(eh, 10)],
            ep && ef.push(parseInt(ep, 10)),
            (em = eg[1]) && eW.indexOf(em) !== new Date(ef[0], ef[1], ef[2]).getDay() && (getParsingFlags(J).weekdayMismatch = !0,
              J._isValid = !1,
              1))
            return;
          J._a = ef,
            J._tzm = function (J, et, eo) {
              if (J)
                return e4[J];
              if (et)
                return 0;
              var el = parseInt(eo, 10)
                , ec = el % 100;
              return 60 * ((el - ec) / 100) + ec
            }(eg[8], eg[9], eg[10]),
            J._d = createUTCDate.apply(null, J._a),
            J._d.setUTCMinutes(J._d.getUTCMinutes() - J._tzm),
            getParsingFlags(J).rfc2822 = !0
        } else
          J._isValid = !1
      }
      function defaults(J, et, eo) {
        return null != J ? J : null != et ? et : eo
      }
      function configFromArray(J) {
        var et, eo, el, ec, ed, eh, ep, ef, em, eg, ey, eb, ew, e_, ex, eE = [];
        if (!J._d) {
          for (eg = new Date(hooks.now()),
            ew = J._useUTC ? [eg.getUTCFullYear(), eg.getUTCMonth(), eg.getUTCDate()] : [eg.getFullYear(), eg.getMonth(), eg.getDate()],
            J._w && null == J._a[2] && null == J._a[1] && (null != (et = J._w).GG || null != et.W || null != et.E ? (ed = 1,
              eh = 4,
              eo = defaults(et.GG, J._a[0], weekOfYear(createLocal(), 1, 4).year),
              el = defaults(et.W, 1),
              ((ec = defaults(et.E, 1)) < 1 || ec > 7) && (ef = !0)) : (ed = J._locale._week.dow,
                eh = J._locale._week.doy,
                em = weekOfYear(createLocal(), ed, eh),
                eo = defaults(et.gg, J._a[0], em.year),
                el = defaults(et.w, em.week),
                null != et.d ? ((ec = et.d) < 0 || ec > 6) && (ef = !0) : null != et.e ? (ec = et.e + ed,
                  (et.e < 0 || et.e > 6) && (ef = !0)) : ec = ed),
              el < 1 || el > weeksInYear(eo, ed, eh) ? getParsingFlags(J)._overflowWeeks = !0 : null != ef ? getParsingFlags(J)._overflowWeekday = !0 : (ep = dayOfYearFromWeeks(eo, el, ec, ed, eh),
                J._a[0] = ep.year,
                J._dayOfYear = ep.dayOfYear)),
            null != J._dayOfYear && (ex = defaults(J._a[0], ew[0]),
              (J._dayOfYear > daysInYear(ex) || 0 === J._dayOfYear) && (getParsingFlags(J)._overflowDayOfYear = !0),
              eb = createUTCDate(ex, 0, J._dayOfYear),
              J._a[1] = eb.getUTCMonth(),
              J._a[2] = eb.getUTCDate()),
            ey = 0; ey < 3 && null == J._a[ey]; ++ey)
            J._a[ey] = eE[ey] = ew[ey];
          for (; ey < 7; ey++)
            J._a[ey] = eE[ey] = null == J._a[ey] ? 2 === ey ? 1 : 0 : J._a[ey];
          24 === J._a[3] && 0 === J._a[4] && 0 === J._a[5] && 0 === J._a[6] && (J._nextDay = !0,
            J._a[3] = 0),
            J._d = (J._useUTC ? createUTCDate : createDate).apply(null, eE),
            e_ = J._useUTC ? J._d.getUTCDay() : J._d.getDay(),
            null != J._tzm && J._d.setUTCMinutes(J._d.getUTCMinutes() - J._tzm),
            J._nextDay && (J._a[3] = 24),
            J._w && void 0 !== J._w.d && J._w.d !== e_ && (getParsingFlags(J).weekdayMismatch = !0)
        }
      }
      function configFromStringAndFormat(J) {
        if (J._f === hooks.ISO_8601) {
          configFromISO(J);
          return
        }
        if (J._f === hooks.RFC_2822) {
          configFromRFC2822(J);
          return
        }
        J._a = [],
          getParsingFlags(J).empty = !0;
        var et, eo, el, ec, ed, ep, ef, eg, ey, eb, ew, ex = "" + J._i, eE = ex.length, eC = 0;
        for (ed = 0,
          ew = (ef = expandFormat(J._f, J._locale).match(eh) || []).length; ed < ew; ed++)
          (eg = ef[ed],
            (ep = (ex.match(hasOwnProp(e_, eg) ? e_[eg](J._strict, J._locale) : new RegExp(regexEscape(eg.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (J, et, eo, el, ec) {
              return et || eo || el || ec
            })))) || [])[0]) && ((ey = ex.substr(0, ex.indexOf(ep))).length > 0 && getParsingFlags(J).unusedInput.push(ey),
              ex = ex.slice(ex.indexOf(ep) + ep.length),
              eC += ep.length),
            em[eg]) ? (ep ? getParsingFlags(J).empty = !1 : getParsingFlags(J).unusedTokens.push(eg),
              null != ep && hasOwnProp(eU, eg) && eU[eg](ep, J._a, J, eg)) : J._strict && !ep && getParsingFlags(J).unusedTokens.push(eg);
        getParsingFlags(J).charsLeftOver = eE - eC,
          ex.length > 0 && getParsingFlags(J).unusedInput.push(ex),
          J._a[3] <= 12 && !0 === getParsingFlags(J).bigHour && J._a[3] > 0 && (getParsingFlags(J).bigHour = void 0),
          getParsingFlags(J).parsedDateParts = J._a.slice(0),
          getParsingFlags(J).meridiem = J._meridiem,
          J._a[3] = (et = J._locale,
            eo = J._a[3],
            null == (el = J._meridiem) ? eo : null != et.meridiemHour ? et.meridiemHour(eo, el) : (null != et.isPM && ((ec = et.isPM(el)) && eo < 12 && (eo += 12),
              ec || 12 !== eo || (eo = 0)),
              eo)),
          null !== (eb = getParsingFlags(J).era) && (J._a[0] = J._locale.erasConvertYear(eb, J._a[0])),
          configFromArray(J),
          checkOverflow(J)
      }
      function prepareConfig(J) {
        var et, eo = J._i, el = J._f;
        return (J._locale = J._locale || getLocale(J._l),
          null === eo || void 0 === el && "" === eo) ? createInvalid({
            nullInput: !0
          }) : ("string" == typeof eo && (J._i = eo = J._locale.preparse(eo)),
            isMoment(eo)) ? new Moment(checkOverflow(eo)) : (isDate(eo) ? J._d = eo : isArray(el) ? function (J) {
              var et, eo, el, ec, ed, eh, ep = !1, ef = J._f.length;
              if (0 === ef) {
                getParsingFlags(J).invalidFormat = !0,
                  J._d = new Date(NaN);
                return
              }
              for (ec = 0; ec < ef; ec++)
                ed = 0,
                  eh = !1,
                  et = copyConfig({}, J),
                  null != J._useUTC && (et._useUTC = J._useUTC),
                  et._f = J._f[ec],
                  configFromStringAndFormat(et),
                  isValid(et) && (eh = !0),
                  ed += getParsingFlags(et).charsLeftOver + 10 * getParsingFlags(et).unusedTokens.length,
                  getParsingFlags(et).score = ed,
                  ep ? ed < el && (el = ed,
                    eo = et) : (null == el || ed < el || eh) && (el = ed,
                      eo = et,
                      eh && (ep = !0));
              extend(J, eo || et)
            }(J) : el ? configFromStringAndFormat(J) : isUndefined(et = J._i) ? J._d = new Date(hooks.now()) : isDate(et) ? J._d = new Date(et.valueOf()) : "string" == typeof et ? function (J) {
              var et = e5.exec(J._i);
              if (null !== et) {
                J._d = new Date(+et[1]);
                return
              }
              configFromISO(J),
                !1 === J._isValid && (delete J._isValid,
                  configFromRFC2822(J),
                  !1 === J._isValid && (delete J._isValid,
                    J._strict ? J._isValid = !1 : hooks.createFromInputFallback(J)))
            }(J) : isArray(et) ? (J._a = map(et.slice(0), function (J) {
              return parseInt(J, 10)
            }),
              configFromArray(J)) : isObject(et) ? function (J) {
                if (!J._d) {
                  var et = normalizeObjectUnits(J._i)
                    , eo = void 0 === et.day ? et.date : et.day;
                  J._a = map([et.year, et.month, eo, et.hour, et.minute, et.second, et.millisecond], function (J) {
                    return J && parseInt(J, 10)
                  }),
                    configFromArray(J)
                }
              }(J) : isNumber(et) ? J._d = new Date(et) : hooks.createFromInputFallback(J),
              isValid(J) || (J._d = null),
              J)
      }
      function createLocalOrUTC(J, et, eo, el, ec) {
        var ed, eh = {};
        return (!0 === et || !1 === et) && (el = et,
          et = void 0),
          (!0 === eo || !1 === eo) && (el = eo,
            eo = void 0),
          (isObject(J) && isObjectEmpty(J) || isArray(J) && 0 === J.length) && (J = void 0),
          eh._isAMomentObject = !0,
          eh._useUTC = eh._isUTC = ec,
          eh._l = eo,
          eh._i = J,
          eh._f = et,
          eh._strict = el,
          (ed = new Moment(checkOverflow(prepareConfig(eh))))._nextDay && (ed.add(1, "d"),
            ed._nextDay = void 0),
          ed
      }
      function createLocal(J, et, eo, el) {
        return createLocalOrUTC(J, et, eo, el, !1)
      }
      hooks.createFromInputFallback = deprecate("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function (J) {
        J._d = new Date(J._i + (J._useUTC ? " UTC" : ""))
      }),
        hooks.ISO_8601 = function () { }
        ,
        hooks.RFC_2822 = function () { }
        ;
      var e8 = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function () {
        var J = createLocal.apply(null, arguments);
        return this.isValid() && J.isValid() ? J < this ? this : J : createInvalid()
      })
        , e7 = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function () {
          var J = createLocal.apply(null, arguments);
          return this.isValid() && J.isValid() ? J > this ? this : J : createInvalid()
        });
      function pickBy(J, et) {
        var eo, el;
        if (1 === et.length && isArray(et[0]) && (et = et[0]),
          !et.length)
          return createLocal();
        for (el = 1,
          eo = et[0]; el < et.length; ++el)
          (!et[el].isValid() || et[el][J](eo)) && (eo = et[el]);
        return eo
      }
      var e9 = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];
      function Duration(J) {
        var et = normalizeObjectUnits(J)
          , eo = et.year || 0
          , el = et.quarter || 0
          , ec = et.month || 0
          , ed = et.week || et.isoWeek || 0
          , eh = et.day || 0
          , ep = et.hour || 0
          , ef = et.minute || 0
          , em = et.second || 0
          , eg = et.millisecond || 0;
        this._isValid = function (J) {
          var et, eo, el = !1, ec = e9.length;
          for (et in J)
            if (hasOwnProp(J, et) && !(-1 !== eZ.call(e9, et) && (null == J[et] || !isNaN(J[et]))))
              return !1;
          for (eo = 0; eo < ec; ++eo)
            if (J[e9[eo]]) {
              if (el)
                return !1;
              parseFloat(J[e9[eo]]) !== toInt(J[e9[eo]]) && (el = !0)
            }
          return !0
        }(et),
          this._milliseconds = +eg + 1e3 * em + 6e4 * ef + 36e5 * ep,
          this._days = +eh + 7 * ed,
          this._months = +ec + 3 * el + 12 * eo,
          this._data = {},
          this._locale = getLocale(),
          this._bubble()
      }
      function isDuration(J) {
        return J instanceof Duration
      }
      function absRound(J) {
        return J < 0 ? -1 * Math.round(-1 * J) : Math.round(J)
      }
      function offset(J, et) {
        addFormatToken(J, 0, 0, function () {
          var J = this.utcOffset()
            , eo = "+";
          return J < 0 && (J = -J,
            eo = "-"),
            eo + zeroFill(~~(J / 60), 2) + et + zeroFill(~~J % 60, 2)
        })
      }
      offset("Z", ":"),
        offset("ZZ", ""),
        addRegexToken("Z", eL),
        addRegexToken("ZZ", eL),
        addParseToken(["Z", "ZZ"], function (J, et, eo) {
          eo._useUTC = !0,
            eo._tzm = offsetFromString(eL, J)
        });
      var tn = /([\+\-]|\d\d)/gi;
      function offsetFromString(J, et) {
        var eo, el, ec = (et || "").match(J);
        return null === ec ? null : 0 === (el = +(60 * (eo = ((ec[ec.length - 1] || []) + "").match(tn) || ["-", 0, 0])[1]) + toInt(eo[2])) ? 0 : "+" === eo[0] ? el : -el
      }
      function cloneWithOffset(J, et) {
        var eo, el;
        return et._isUTC ? (eo = et.clone(),
          el = (isMoment(J) || isDate(J) ? J.valueOf() : createLocal(J).valueOf()) - eo.valueOf(),
          eo._d.setTime(eo._d.valueOf() + el),
          hooks.updateOffset(eo, !1),
          eo) : createLocal(J).local()
      }
      function getDateOffset(J) {
        return -Math.round(J._d.getTimezoneOffset())
      }
      function isUtc() {
        return !!this.isValid() && this._isUTC && 0 === this._offset
      }
      hooks.updateOffset = function () { }
        ;
      var to = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/
        , ta = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
      function createDuration(J, et) {
        var eo, el, ec, ed, eh, ep, ef = J, em = null;
        return isDuration(J) ? ef = {
          ms: J._milliseconds,
          d: J._days,
          M: J._months
        } : isNumber(J) || !isNaN(+J) ? (ef = {},
          et ? ef[et] = +J : ef.milliseconds = +J) : (em = to.exec(J)) ? (ed = "-" === em[1] ? -1 : 1,
            ef = {
              y: 0,
              d: toInt(em[2]) * ed,
              h: toInt(em[3]) * ed,
              m: toInt(em[4]) * ed,
              s: toInt(em[5]) * ed,
              ms: toInt(absRound(1e3 * em[6])) * ed
            }) : (em = ta.exec(J)) ? (ed = "-" === em[1] ? -1 : 1,
              ef = {
                y: parseIso(em[2], ed),
                M: parseIso(em[3], ed),
                w: parseIso(em[4], ed),
                d: parseIso(em[5], ed),
                h: parseIso(em[6], ed),
                m: parseIso(em[7], ed),
                s: parseIso(em[8], ed)
              }) : null == ef ? ef = {} : "object" == typeof ef && ("from" in ef || "to" in ef) && (eo = createLocal(ef.from),
                el = createLocal(ef.to),
                ep = eo.isValid() && el.isValid() ? (el = cloneWithOffset(el, eo),
                  eo.isBefore(el) ? ec = positiveMomentsDifference(eo, el) : ((ec = positiveMomentsDifference(el, eo)).milliseconds = -ec.milliseconds,
                    ec.months = -ec.months),
                  ec) : {
                  milliseconds: 0,
                  months: 0
                },
                (ef = {}).ms = ep.milliseconds,
                ef.M = ep.months),
          eh = new Duration(ef),
          isDuration(J) && hasOwnProp(J, "_locale") && (eh._locale = J._locale),
          isDuration(J) && hasOwnProp(J, "_isValid") && (eh._isValid = J._isValid),
          eh
      }
      function parseIso(J, et) {
        var eo = J && parseFloat(J.replace(",", "."));
        return (isNaN(eo) ? 0 : eo) * et
      }
      function positiveMomentsDifference(J, et) {
        var eo = {};
        return eo.months = et.month() - J.month() + (et.year() - J.year()) * 12,
          J.clone().add(eo.months, "M").isAfter(et) && --eo.months,
          eo.milliseconds = +et - +J.clone().add(eo.months, "M"),
          eo
      }
      function createAdder(J, et) {
        return function (eo, el) {
          var ec;
          return null === el || isNaN(+el) || (deprecateSimple(et, "moment()." + et + "(period, number) is deprecated. Please use moment()." + et + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."),
            ec = eo,
            eo = el,
            el = ec),
            addSubtract(this, createDuration(eo, el), J),
            this
        }
      }
      function addSubtract(J, et, eo, el) {
        var ec = et._milliseconds
          , ed = absRound(et._days)
          , eh = absRound(et._months);
        J.isValid() && (el = null == el || el,
          eh && setMonth(J, get(J, "Month") + eh * eo),
          ed && set$1(J, "Date", get(J, "Date") + ed * eo),
          ec && J._d.setTime(J._d.valueOf() + ec * eo),
          el && hooks.updateOffset(J, ed || eh))
      }
      createDuration.fn = Duration.prototype,
        createDuration.invalid = function () {
          return createDuration(NaN)
        }
        ;
      var tl = createAdder(1, "add")
        , tc = createAdder(-1, "subtract");
      function isString(J) {
        return "string" == typeof J || J instanceof String
      }
      function monthDiff(J, et) {
        if (J.date() < et.date())
          return -monthDiff(et, J);
        var eo, el = (et.year() - J.year()) * 12 + (et.month() - J.month()), ec = J.clone().add(el, "months");
        return eo = et - ec < 0 ? (et - ec) / (ec - J.clone().add(el - 1, "months")) : (et - ec) / (J.clone().add(el + 1, "months") - ec),
          -(el + eo) || 0
      }
      function locale(J) {
        var et;
        return void 0 === J ? this._locale._abbr : (null != (et = getLocale(J)) && (this._locale = et),
          this)
      }
      hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ",
        hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
      var td = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function (J) {
        return void 0 === J ? this.localeData() : this.locale(J)
      });
      function localeData() {
        return this._locale
      }
      function localStartOfDate(J, et, eo) {
        return J < 100 && J >= 0 ? new Date(J + 400, et, eo) - 126227808e5 : new Date(J, et, eo).valueOf()
      }
      function utcStartOfDate(J, et, eo) {
        return J < 100 && J >= 0 ? Date.UTC(J + 400, et, eo) - 126227808e5 : Date.UTC(J, et, eo)
      }
      function matchEraAbbr(J, et) {
        return et.erasAbbrRegex(J)
      }
      function computeErasParse() {
        var J, et, eo, el, ec, ed = [], eh = [], ep = [], ef = [], em = this.eras();
        for (J = 0,
          et = em.length; J < et; ++J)
          eo = regexEscape(em[J].name),
            el = regexEscape(em[J].abbr),
            ec = regexEscape(em[J].narrow),
            eh.push(eo),
            ed.push(el),
            ep.push(ec),
            ef.push(eo),
            ef.push(el),
            ef.push(ec);
        this._erasRegex = RegExp("^(" + ef.join("|") + ")", "i"),
          this._erasNameRegex = RegExp("^(" + eh.join("|") + ")", "i"),
          this._erasAbbrRegex = RegExp("^(" + ed.join("|") + ")", "i"),
          this._erasNarrowRegex = RegExp("^(" + ep.join("|") + ")", "i")
      }
      function addWeekYearFormatToken(J, et) {
        addFormatToken(0, [J, J.length], 0, et)
      }
      function getSetWeekYearHelper(J, et, eo, el, ec) {
        var ed;
        return null == J ? weekOfYear(this, el, ec).year : (et > (ed = weeksInYear(J, el, ec)) && (et = ed),
          setWeekAll.call(this, J, et, eo, el, ec))
      }
      function setWeekAll(J, et, eo, el, ec) {
        var ed = dayOfYearFromWeeks(J, et, eo, el, ec)
          , eh = createUTCDate(ed.year, 0, ed.dayOfYear);
        return this.year(eh.getUTCFullYear()),
          this.month(eh.getUTCMonth()),
          this.date(eh.getUTCDate()),
          this
      }
      addFormatToken("N", 0, 0, "eraAbbr"),
        addFormatToken("NN", 0, 0, "eraAbbr"),
        addFormatToken("NNN", 0, 0, "eraAbbr"),
        addFormatToken("NNNN", 0, 0, "eraName"),
        addFormatToken("NNNNN", 0, 0, "eraNarrow"),
        addFormatToken("y", ["y", 1], "yo", "eraYear"),
        addFormatToken("y", ["yy", 2], 0, "eraYear"),
        addFormatToken("y", ["yyy", 3], 0, "eraYear"),
        addFormatToken("y", ["yyyy", 4], 0, "eraYear"),
        addRegexToken("N", matchEraAbbr),
        addRegexToken("NN", matchEraAbbr),
        addRegexToken("NNN", matchEraAbbr),
        addRegexToken("NNNN", function (J, et) {
          return et.erasNameRegex(J)
        }),
        addRegexToken("NNNNN", function (J, et) {
          return et.erasNarrowRegex(J)
        }),
        addParseToken(["N", "NN", "NNN", "NNNN", "NNNNN"], function (J, et, eo, el) {
          var ec = eo._locale.erasParse(J, el, eo._strict);
          ec ? getParsingFlags(eo).era = ec : getParsingFlags(eo).invalidEra = J
        }),
        addRegexToken("y", eM),
        addRegexToken("yy", eM),
        addRegexToken("yyy", eM),
        addRegexToken("yyyy", eM),
        addRegexToken("yo", function (J, et) {
          return et._eraYearOrdinalRegex || eM
        }),
        addParseToken(["y", "yy", "yyy", "yyyy"], 0),
        addParseToken(["yo"], function (J, et, eo, el) {
          var ec;
          eo._locale._eraYearOrdinalRegex && (ec = J.match(eo._locale._eraYearOrdinalRegex)),
            eo._locale.eraYearOrdinalParse ? et[0] = eo._locale.eraYearOrdinalParse(J, ec) : et[0] = parseInt(J, 10)
        }),
        addFormatToken(0, ["gg", 2], 0, function () {
          return this.weekYear() % 100
        }),
        addFormatToken(0, ["GG", 2], 0, function () {
          return this.isoWeekYear() % 100
        }),
        addWeekYearFormatToken("gggg", "weekYear"),
        addWeekYearFormatToken("ggggg", "weekYear"),
        addWeekYearFormatToken("GGGG", "isoWeekYear"),
        addWeekYearFormatToken("GGGGG", "isoWeekYear"),
        addRegexToken("G", eD),
        addRegexToken("g", eD),
        addRegexToken("GG", eA, eC),
        addRegexToken("gg", eA, eC),
        addRegexToken("GGGG", eO, ek),
        addRegexToken("gggg", eO, ek),
        addRegexToken("GGGGG", eN, eT),
        addRegexToken("ggggg", eN, eT),
        addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function (J, et, eo, el) {
          et[el.substr(0, 2)] = toInt(J)
        }),
        addWeekParseToken(["gg", "GG"], function (J, et, eo, el) {
          et[el] = hooks.parseTwoDigitYear(J)
        }),
        addFormatToken("Q", 0, "Qo", "quarter"),
        addRegexToken("Q", eE),
        addParseToken("Q", function (J, et) {
          et[1] = (toInt(J) - 1) * 3
        }),
        addFormatToken("D", ["DD", 2], "Do", "date"),
        addRegexToken("D", eA, eB),
        addRegexToken("DD", eA, eC),
        addRegexToken("Do", function (J, et) {
          return J ? et._dayOfMonthOrdinalParse || et._ordinalParse : et._dayOfMonthOrdinalParseLenient
        }),
        addParseToken(["D", "DD"], 2),
        addParseToken("Do", function (J, et) {
          et[2] = toInt(J.match(eA)[0])
        });
      var th = makeGetSet("Date", !0);
      addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear"),
        addRegexToken("DDD", eI),
        addRegexToken("DDDD", eS),
        addParseToken(["DDD", "DDDD"], function (J, et, eo) {
          eo._dayOfYear = toInt(J)
        }),
        addFormatToken("m", ["mm", 2], 0, "minute"),
        addRegexToken("m", eA, eF),
        addRegexToken("mm", eA, eC),
        addParseToken(["m", "mm"], 4);
      var tp = makeGetSet("Minutes", !1);
      addFormatToken("s", ["ss", 2], 0, "second"),
        addRegexToken("s", eA, eF),
        addRegexToken("ss", eA, eC),
        addParseToken(["s", "ss"], 5);
      var tf = makeGetSet("Seconds", !1);
      for (addFormatToken("S", 0, 0, function () {
        return ~~(this.millisecond() / 100)
      }),
        addFormatToken(0, ["SS", 2], 0, function () {
          return ~~(this.millisecond() / 10)
        }),
        addFormatToken(0, ["SSS", 3], 0, "millisecond"),
        addFormatToken(0, ["SSSS", 4], 0, function () {
          return 10 * this.millisecond()
        }),
        addFormatToken(0, ["SSSSS", 5], 0, function () {
          return 100 * this.millisecond()
        }),
        addFormatToken(0, ["SSSSSS", 6], 0, function () {
          return 1e3 * this.millisecond()
        }),
        addFormatToken(0, ["SSSSSSS", 7], 0, function () {
          return 1e4 * this.millisecond()
        }),
        addFormatToken(0, ["SSSSSSSS", 8], 0, function () {
          return 1e5 * this.millisecond()
        }),
        addFormatToken(0, ["SSSSSSSSS", 9], 0, function () {
          return 1e6 * this.millisecond()
        }),
        addRegexToken("S", eI, eE),
        addRegexToken("SS", eI, eC),
        addRegexToken("SSS", eI, eS),
        et = "SSSS"; et.length <= 9; et += "S")
        addRegexToken(et, eM);
      function parseMs(J, et) {
        et[6] = toInt(("0." + J) * 1e3)
      }
      for (et = "S"; et.length <= 9; et += "S")
        addParseToken(et, parseMs);
      eo = makeGetSet("Milliseconds", !1),
        addFormatToken("z", 0, 0, "zoneAbbr"),
        addFormatToken("zz", 0, 0, "zoneName");
      var tm = Moment.prototype;
      function preParsePostFormat(J) {
        return J
      }
      tm.add = tl,
        tm.calendar = function (J, et) {
          if (1 == arguments.length) {
            if (arguments[0]) {
              var eo, el, ec;
              (eo = arguments[0],
                isMoment(eo) || isDate(eo) || isString(eo) || isNumber(eo) || (el = isArray(eo),
                  ec = !1,
                  el && (ec = 0 === eo.filter(function (J) {
                    return !isNumber(J) && isString(eo)
                  }).length),
                  el && ec) || function (J) {
                    var et, eo, el = isObject(J) && !isObjectEmpty(J), ec = !1, ed = ["years", "year", "y", "months", "month", "M", "days", "day", "d", "dates", "date", "D", "hours", "hour", "h", "minutes", "minute", "m", "seconds", "second", "s", "milliseconds", "millisecond", "ms"], eh = ed.length;
                    for (et = 0; et < eh; et += 1)
                      eo = ed[et],
                        ec = ec || hasOwnProp(J, eo);
                    return el && ec
                  }(eo) || null == eo) ? (J = arguments[0],
                    et = void 0) : function (J) {
                      var et, eo, el = isObject(J) && !isObjectEmpty(J), ec = !1, ed = ["sameDay", "nextDay", "lastDay", "nextWeek", "lastWeek", "sameElse"];
                      for (et = 0; et < ed.length; et += 1)
                        eo = ed[et],
                          ec = ec || hasOwnProp(J, eo);
                      return el && ec
                    }(arguments[0]) && (et = arguments[0],
                      J = void 0)
            } else
              J = void 0,
                et = void 0
          }
          var ed = J || createLocal()
            , eh = cloneWithOffset(ed, this).startOf("day")
            , ep = hooks.calendarFormat(this, eh) || "sameElse"
            , ef = et && (isFunction(et[ep]) ? et[ep].call(this, ed) : et[ep]);
          return this.format(ef || this.localeData().calendar(ep, this, createLocal(ed)))
        }
        ,
        tm.clone = function () {
          return new Moment(this)
        }
        ,
        tm.diff = function (J, et, eo) {
          var el, ec, ed;
          if (!this.isValid() || !(el = cloneWithOffset(J, this)).isValid())
            return NaN;
          switch (ec = (el.utcOffset() - this.utcOffset()) * 6e4,
          et = normalizeUnits(et)) {
            case "year":
              ed = monthDiff(this, el) / 12;
              break;
            case "month":
              ed = monthDiff(this, el);
              break;
            case "quarter":
              ed = monthDiff(this, el) / 3;
              break;
            case "second":
              ed = (this - el) / 1e3;
              break;
            case "minute":
              ed = (this - el) / 6e4;
              break;
            case "hour":
              ed = (this - el) / 36e5;
              break;
            case "day":
              ed = (this - el - ec) / 864e5;
              break;
            case "week":
              ed = (this - el - ec) / 6048e5;
              break;
            default:
              ed = this - el
          }
          return eo ? ed : absFloor(ed)
        }
        ,
        tm.endOf = function (J) {
          var et, eo;
          if (void 0 === (J = normalizeUnits(J)) || "millisecond" === J || !this.isValid())
            return this;
          switch (eo = this._isUTC ? utcStartOfDate : localStartOfDate,
          J) {
            case "year":
              et = eo(this.year() + 1, 0, 1) - 1;
              break;
            case "quarter":
              et = eo(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
              break;
            case "month":
              et = eo(this.year(), this.month() + 1, 1) - 1;
              break;
            case "week":
              et = eo(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
              break;
            case "isoWeek":
              et = eo(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
              break;
            case "day":
            case "date":
              et = eo(this.year(), this.month(), this.date() + 1) - 1;
              break;
            case "hour":
              et = this._d.valueOf(),
                et += 36e5 - ((et + (this._isUTC ? 0 : 6e4 * this.utcOffset())) % 36e5 + 36e5) % 36e5 - 1;
              break;
            case "minute":
              et = this._d.valueOf(),
                et += 6e4 - (et % 6e4 + 6e4) % 6e4 - 1;
              break;
            case "second":
              et = this._d.valueOf(),
                et += 1e3 - (et % 1e3 + 1e3) % 1e3 - 1
          }
          return this._d.setTime(et),
            hooks.updateOffset(this, !0),
            this
        }
        ,
        tm.format = function (J) {
          J || (J = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat);
          var et = formatMoment(this, J);
          return this.localeData().postformat(et)
        }
        ,
        tm.from = function (J, et) {
          return this.isValid() && (isMoment(J) && J.isValid() || createLocal(J).isValid()) ? createDuration({
            to: this,
            from: J
          }).locale(this.locale()).humanize(!et) : this.localeData().invalidDate()
        }
        ,
        tm.fromNow = function (J) {
          return this.from(createLocal(), J)
        }
        ,
        tm.to = function (J, et) {
          return this.isValid() && (isMoment(J) && J.isValid() || createLocal(J).isValid()) ? createDuration({
            from: this,
            to: J
          }).locale(this.locale()).humanize(!et) : this.localeData().invalidDate()
        }
        ,
        tm.toNow = function (J) {
          return this.to(createLocal(), J)
        }
        ,
        tm.get = function (J) {
          return isFunction(this[J = normalizeUnits(J)]) ? this[J]() : this
        }
        ,
        tm.invalidAt = function () {
          return getParsingFlags(this).overflow
        }
        ,
        tm.isAfter = function (J, et) {
          var eo = isMoment(J) ? J : createLocal(J);
          return !!(this.isValid() && eo.isValid()) && ("millisecond" === (et = normalizeUnits(et) || "millisecond") ? this.valueOf() > eo.valueOf() : eo.valueOf() < this.clone().startOf(et).valueOf())
        }
        ,
        tm.isBefore = function (J, et) {
          var eo = isMoment(J) ? J : createLocal(J);
          return !!(this.isValid() && eo.isValid()) && ("millisecond" === (et = normalizeUnits(et) || "millisecond") ? this.valueOf() < eo.valueOf() : this.clone().endOf(et).valueOf() < eo.valueOf())
        }
        ,
        tm.isBetween = function (J, et, eo, el) {
          var ec = isMoment(J) ? J : createLocal(J)
            , ed = isMoment(et) ? et : createLocal(et);
          return !!(this.isValid() && ec.isValid() && ed.isValid()) && ("(" === (el = el || "()")[0] ? this.isAfter(ec, eo) : !this.isBefore(ec, eo)) && (")" === el[1] ? this.isBefore(ed, eo) : !this.isAfter(ed, eo))
        }
        ,
        tm.isSame = function (J, et) {
          var eo, el = isMoment(J) ? J : createLocal(J);
          return !!(this.isValid() && el.isValid()) && ("millisecond" === (et = normalizeUnits(et) || "millisecond") ? this.valueOf() === el.valueOf() : (eo = el.valueOf(),
            this.clone().startOf(et).valueOf() <= eo && eo <= this.clone().endOf(et).valueOf()))
        }
        ,
        tm.isSameOrAfter = function (J, et) {
          return this.isSame(J, et) || this.isAfter(J, et)
        }
        ,
        tm.isSameOrBefore = function (J, et) {
          return this.isSame(J, et) || this.isBefore(J, et)
        }
        ,
        tm.isValid = function () {
          return isValid(this)
        }
        ,
        tm.lang = td,
        tm.locale = locale,
        tm.localeData = localeData,
        tm.max = e7,
        tm.min = e8,
        tm.parsingFlags = function () {
          return extend({}, getParsingFlags(this))
        }
        ,
        tm.set = function (J, et) {
          if ("object" == typeof J) {
            var eo, el = function (J) {
              var et, eo = [];
              for (et in J)
                hasOwnProp(J, et) && eo.push({
                  unit: et,
                  priority: ex[et]
                });
              return eo.sort(function (J, et) {
                return J.priority - et.priority
              }),
                eo
            }(J = normalizeObjectUnits(J)), ec = el.length;
            for (eo = 0; eo < ec; eo++)
              this[el[eo].unit](J[el[eo].unit])
          } else if (isFunction(this[J = normalizeUnits(J)]))
            return this[J](et);
          return this
        }
        ,
        tm.startOf = function (J) {
          var et, eo;
          if (void 0 === (J = normalizeUnits(J)) || "millisecond" === J || !this.isValid())
            return this;
          switch (eo = this._isUTC ? utcStartOfDate : localStartOfDate,
          J) {
            case "year":
              et = eo(this.year(), 0, 1);
              break;
            case "quarter":
              et = eo(this.year(), this.month() - this.month() % 3, 1);
              break;
            case "month":
              et = eo(this.year(), this.month(), 1);
              break;
            case "week":
              et = eo(this.year(), this.month(), this.date() - this.weekday());
              break;
            case "isoWeek":
              et = eo(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
              break;
            case "day":
            case "date":
              et = eo(this.year(), this.month(), this.date());
              break;
            case "hour":
              et = this._d.valueOf(),
                et -= ((et + (this._isUTC ? 0 : 6e4 * this.utcOffset())) % 36e5 + 36e5) % 36e5;
              break;
            case "minute":
              et = this._d.valueOf(),
                et -= (et % 6e4 + 6e4) % 6e4;
              break;
            case "second":
              et = this._d.valueOf(),
                et -= (et % 1e3 + 1e3) % 1e3
          }
          return this._d.setTime(et),
            hooks.updateOffset(this, !0),
            this
        }
        ,
        tm.subtract = tc,
        tm.toArray = function () {
          return [this.year(), this.month(), this.date(), this.hour(), this.minute(), this.second(), this.millisecond()]
        }
        ,
        tm.toObject = function () {
          return {
            years: this.year(),
            months: this.month(),
            date: this.date(),
            hours: this.hours(),
            minutes: this.minutes(),
            seconds: this.seconds(),
            milliseconds: this.milliseconds()
          }
        }
        ,
        tm.toDate = function () {
          return new Date(this.valueOf())
        }
        ,
        tm.toISOString = function (J) {
          if (!this.isValid())
            return null;
          var et = !0 !== J
            , eo = et ? this.clone().utc() : this;
          return 0 > eo.year() || eo.year() > 9999 ? formatMoment(eo, et ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ") : isFunction(Date.prototype.toISOString) ? et ? this.toDate().toISOString() : new Date(this.valueOf() + 6e4 * this.utcOffset()).toISOString().replace("Z", formatMoment(eo, "Z")) : formatMoment(eo, et ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ")
        }
        ,
        tm.inspect = function () {
          if (!this.isValid())
            return "moment.invalid(/* " + this._i + " */)";
          var J, et, eo, el = "moment", ec = "";
          return this.isLocal() || (el = 0 === this.utcOffset() ? "moment.utc" : "moment.parseZone",
            ec = "Z"),
            J = "[" + el + '("]',
            et = 0 <= this.year() && 9999 >= this.year() ? "YYYY" : "YYYYYY",
            eo = ec + '[")]',
            this.format(J + et + "-MM-DD[T]HH:mm:ss.SSS" + eo)
        }
        ,
        "undefined" != typeof Symbol && null != Symbol.for && (tm[Symbol.for("nodejs.util.inspect.custom")] = function () {
          return "Moment<" + this.format() + ">"
        }
        ),
        tm.toJSON = function () {
          return this.isValid() ? this.toISOString() : null
        }
        ,
        tm.toString = function () {
          return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")
        }
        ,
        tm.unix = function () {
          return Math.floor(this.valueOf() / 1e3)
        }
        ,
        tm.valueOf = function () {
          return this._d.valueOf() - 6e4 * (this._offset || 0)
        }
        ,
        tm.creationData = function () {
          return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
          }
        }
        ,
        tm.eraName = function () {
          var J, et, eo, el = this.localeData().eras();
          for (J = 0,
            et = el.length; J < et; ++J)
            if (eo = this.clone().startOf("day").valueOf(),
              el[J].since <= eo && eo <= el[J].until || el[J].until <= eo && eo <= el[J].since)
              return el[J].name;
          return ""
        }
        ,
        tm.eraNarrow = function () {
          var J, et, eo, el = this.localeData().eras();
          for (J = 0,
            et = el.length; J < et; ++J)
            if (eo = this.clone().startOf("day").valueOf(),
              el[J].since <= eo && eo <= el[J].until || el[J].until <= eo && eo <= el[J].since)
              return el[J].narrow;
          return ""
        }
        ,
        tm.eraAbbr = function () {
          var J, et, eo, el = this.localeData().eras();
          for (J = 0,
            et = el.length; J < et; ++J)
            if (eo = this.clone().startOf("day").valueOf(),
              el[J].since <= eo && eo <= el[J].until || el[J].until <= eo && eo <= el[J].since)
              return el[J].abbr;
          return ""
        }
        ,
        tm.eraYear = function () {
          var J, et, eo, el, ec = this.localeData().eras();
          for (J = 0,
            et = ec.length; J < et; ++J)
            if (eo = ec[J].since <= ec[J].until ? 1 : -1,
              el = this.clone().startOf("day").valueOf(),
              ec[J].since <= el && el <= ec[J].until || ec[J].until <= el && el <= ec[J].since)
              return (this.year() - hooks(ec[J].since).year()) * eo + ec[J].offset;
          return this.year()
        }
        ,
        tm.year = ez,
        tm.isLeapYear = function () {
          return isLeapYear(this.year())
        }
        ,
        tm.weekYear = function (J) {
          return getSetWeekYearHelper.call(this, J, this.week(), this.weekday() + this.localeData()._week.dow, this.localeData()._week.dow, this.localeData()._week.doy)
        }
        ,
        tm.isoWeekYear = function (J) {
          return getSetWeekYearHelper.call(this, J, this.isoWeek(), this.isoWeekday(), 1, 4)
        }
        ,
        tm.quarter = tm.quarters = function (J) {
          return null == J ? Math.ceil((this.month() + 1) / 3) : this.month((J - 1) * 3 + this.month() % 3)
        }
        ,
        tm.month = getSetMonth,
        tm.daysInMonth = function () {
          return daysInMonth(this.year(), this.month())
        }
        ,
        tm.week = tm.weeks = function (J) {
          var et = this.localeData().week(this);
          return null == J ? et : this.add((J - et) * 7, "d")
        }
        ,
        tm.isoWeek = tm.isoWeeks = function (J) {
          var et = weekOfYear(this, 1, 4).week;
          return null == J ? et : this.add((J - et) * 7, "d")
        }
        ,
        tm.weeksInYear = function () {
          var J = this.localeData()._week;
          return weeksInYear(this.year(), J.dow, J.doy)
        }
        ,
        tm.weeksInWeekYear = function () {
          var J = this.localeData()._week;
          return weeksInYear(this.weekYear(), J.dow, J.doy)
        }
        ,
        tm.isoWeeksInYear = function () {
          return weeksInYear(this.year(), 1, 4)
        }
        ,
        tm.isoWeeksInISOWeekYear = function () {
          return weeksInYear(this.isoWeekYear(), 1, 4)
        }
        ,
        tm.date = th,
        tm.day = tm.days = function (J) {
          if (!this.isValid())
            return null != J ? this : NaN;
          var et, eo, el = get(this, "Day");
          return null == J ? el : (et = J,
            eo = this.localeData(),
            J = "string" != typeof et ? et : isNaN(et) ? "number" == typeof (et = eo.weekdaysParse(et)) ? et : null : parseInt(et, 10),
            this.add(J - el, "d"))
        }
        ,
        tm.weekday = function (J) {
          if (!this.isValid())
            return null != J ? this : NaN;
          var et = (this.day() + 7 - this.localeData()._week.dow) % 7;
          return null == J ? et : this.add(J - et, "d")
        }
        ,
        tm.isoWeekday = function (J) {
          if (!this.isValid())
            return null != J ? this : NaN;
          if (null == J)
            return this.day() || 7;
          var et, eo = (et = this.localeData(),
            "string" == typeof J ? et.weekdaysParse(J) % 7 || 7 : isNaN(J) ? null : J);
          return this.day(this.day() % 7 ? eo : eo - 7)
        }
        ,
        tm.dayOfYear = function (J) {
          var et = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
          return null == J ? et : this.add(J - et, "d")
        }
        ,
        tm.hour = tm.hours = eY,
        tm.minute = tm.minutes = tp,
        tm.second = tm.seconds = tf,
        tm.millisecond = tm.milliseconds = eo,
        tm.utcOffset = function (J, et, eo) {
          var el, ec = this._offset || 0;
          if (!this.isValid())
            return null != J ? this : NaN;
          if (null == J)
            return this._isUTC ? ec : getDateOffset(this);
          if ("string" == typeof J) {
            if (null === (J = offsetFromString(eL, J)))
              return this
          } else
            16 > Math.abs(J) && !eo && (J *= 60);
          return !this._isUTC && et && (el = getDateOffset(this)),
            this._offset = J,
            this._isUTC = !0,
            null != el && this.add(el, "m"),
            ec === J || (!et || this._changeInProgress ? addSubtract(this, createDuration(J - ec, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0,
              hooks.updateOffset(this, !0),
              this._changeInProgress = null)),
            this
        }
        ,
        tm.utc = function (J) {
          return this.utcOffset(0, J)
        }
        ,
        tm.local = function (J) {
          return this._isUTC && (this.utcOffset(0, J),
            this._isUTC = !1,
            J && this.subtract(getDateOffset(this), "m")),
            this
        }
        ,
        tm.parseZone = function () {
          if (null != this._tzm)
            this.utcOffset(this._tzm, !1, !0);
          else if ("string" == typeof this._i) {
            var J = offsetFromString(ej, this._i);
            null != J ? this.utcOffset(J) : this.utcOffset(0, !0)
          }
          return this
        }
        ,
        tm.hasAlignedHourOffset = function (J) {
          return !!this.isValid() && (J = J ? createLocal(J).utcOffset() : 0,
            (this.utcOffset() - J) % 60 == 0)
        }
        ,
        tm.isDST = function () {
          return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset()
        }
        ,
        tm.isLocal = function () {
          return !!this.isValid() && !this._isUTC
        }
        ,
        tm.isUtcOffset = function () {
          return !!this.isValid() && this._isUTC
        }
        ,
        tm.isUtc = isUtc,
        tm.isUTC = isUtc,
        tm.zoneAbbr = function () {
          return this._isUTC ? "UTC" : ""
        }
        ,
        tm.zoneName = function () {
          return this._isUTC ? "Coordinated Universal Time" : ""
        }
        ,
        tm.dates = deprecate("dates accessor is deprecated. Use date instead.", th),
        tm.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth),
        tm.years = deprecate("years accessor is deprecated. Use year instead", ez),
        tm.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", function (J, et) {
          return null != J ? ("string" != typeof J && (J = -J),
            this.utcOffset(J, et),
            this) : -this.utcOffset()
        }),
        tm.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", function () {
          if (!isUndefined(this._isDSTShifted))
            return this._isDSTShifted;
          var J, et = {};
          return copyConfig(et, this),
            (et = prepareConfig(et))._a ? (J = et._isUTC ? createUTC(et._a) : createLocal(et._a),
              this._isDSTShifted = this.isValid() && function (J, et, eo) {
                var el, ec = Math.min(J.length, et.length), ed = Math.abs(J.length - et.length), eh = 0;
                for (el = 0; el < ec; el++)
                  (eo && J[el] !== et[el] || !eo && toInt(J[el]) !== toInt(et[el])) && eh++;
                return eh + ed
              }(et._a, J.toArray()) > 0) : this._isDSTShifted = !1,
            this._isDSTShifted
        });
      var tg = Locale.prototype;
      function get$1(J, et, eo, el) {
        var ec = getLocale()
          , ed = createUTC().set(el, et);
        return ec[eo](ed, J)
      }
      function listMonthsImpl(J, et, eo) {
        if (isNumber(J) && (et = J,
          J = void 0),
          J = J || "",
          null != et)
          return get$1(J, et, eo, "month");
        var el, ec = [];
        for (el = 0; el < 12; el++)
          ec[el] = get$1(J, el, eo, "month");
        return ec
      }
      function listWeekdaysImpl(J, et, eo, el) {
        "boolean" == typeof J || (eo = et = J,
          J = !1),
          isNumber(et) && (eo = et,
            et = void 0),
          et = et || "";
        var ec, ed = getLocale(), eh = J ? ed._week.dow : 0, ep = [];
        if (null != eo)
          return get$1(et, (eo + eh) % 7, el, "day");
        for (ec = 0; ec < 7; ec++)
          ep[ec] = get$1(et, (ec + eh) % 7, el, "day");
        return ep
      }
      tg.calendar = function (J, et, eo) {
        var el = this._calendar[J] || this._calendar.sameElse;
        return isFunction(el) ? el.call(et, eo) : el
      }
        ,
        tg.longDateFormat = function (J) {
          var et = this._longDateFormat[J]
            , eo = this._longDateFormat[J.toUpperCase()];
          return et || !eo ? et : (this._longDateFormat[J] = eo.match(eh).map(function (J) {
            return "MMMM" === J || "MM" === J || "DD" === J || "dddd" === J ? J.slice(1) : J
          }).join(""),
            this._longDateFormat[J])
        }
        ,
        tg.invalidDate = function () {
          return this._invalidDate
        }
        ,
        tg.ordinal = function (J) {
          return this._ordinal.replace("%d", J)
        }
        ,
        tg.preparse = preParsePostFormat,
        tg.postformat = preParsePostFormat,
        tg.relativeTime = function (J, et, eo, el) {
          var ec = this._relativeTime[eo];
          return isFunction(ec) ? ec(J, et, eo, el) : ec.replace(/%d/i, J)
        }
        ,
        tg.pastFuture = function (J, et) {
          var eo = this._relativeTime[J > 0 ? "future" : "past"];
          return isFunction(eo) ? eo(et) : eo.replace(/%s/i, et)
        }
        ,
        tg.set = function (J) {
          var et, eo;
          for (eo in J)
            hasOwnProp(J, eo) && (isFunction(et = J[eo]) ? this[eo] = et : this["_" + eo] = et);
          this._config = J,
            this._dayOfMonthOrdinalParseLenient = RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source)
        }
        ,
        tg.eras = function (J, et) {
          var eo, el, ec, ed = this._eras || getLocale("en")._eras;
          for (eo = 0,
            el = ed.length; eo < el; ++eo)
            switch ("string" == typeof ed[eo].since && (ec = hooks(ed[eo].since).startOf("day"),
              ed[eo].since = ec.valueOf()),
            typeof ed[eo].until) {
              case "undefined":
                ed[eo].until = Infinity;
                break;
              case "string":
                ec = hooks(ed[eo].until).startOf("day").valueOf(),
                  ed[eo].until = ec.valueOf()
            }
          return ed
        }
        ,
        tg.erasParse = function (J, et, eo) {
          var el, ec, ed, eh, ep, ef = this.eras();
          for (el = 0,
            J = J.toUpperCase(),
            ec = ef.length; el < ec; ++el)
            if (ed = ef[el].name.toUpperCase(),
              eh = ef[el].abbr.toUpperCase(),
              ep = ef[el].narrow.toUpperCase(),
              eo)
              switch (et) {
                case "N":
                case "NN":
                case "NNN":
                  if (eh === J)
                    return ef[el];
                  break;
                case "NNNN":
                  if (ed === J)
                    return ef[el];
                  break;
                case "NNNNN":
                  if (ep === J)
                    return ef[el]
              }
            else if ([ed, eh, ep].indexOf(J) >= 0)
              return ef[el]
        }
        ,
        tg.erasConvertYear = function (J, et) {
          var eo = J.since <= J.until ? 1 : -1;
          return void 0 === et ? hooks(J.since).year() : hooks(J.since).year() + (et - J.offset) * eo
        }
        ,
        tg.erasAbbrRegex = function (J) {
          return hasOwnProp(this, "_erasAbbrRegex") || computeErasParse.call(this),
            J ? this._erasAbbrRegex : this._erasRegex
        }
        ,
        tg.erasNameRegex = function (J) {
          return hasOwnProp(this, "_erasNameRegex") || computeErasParse.call(this),
            J ? this._erasNameRegex : this._erasRegex
        }
        ,
        tg.erasNarrowRegex = function (J) {
          return hasOwnProp(this, "_erasNarrowRegex") || computeErasParse.call(this),
            J ? this._erasNarrowRegex : this._erasRegex
        }
        ,
        tg.months = function (J, et) {
          return J ? isArray(this._months) ? this._months[J.month()] : this._months[(this._months.isFormat || eV).test(et) ? "format" : "standalone"][J.month()] : isArray(this._months) ? this._months : this._months.standalone
        }
        ,
        tg.monthsShort = function (J, et) {
          return J ? isArray(this._monthsShort) ? this._monthsShort[J.month()] : this._monthsShort[eV.test(et) ? "format" : "standalone"][J.month()] : isArray(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone
        }
        ,
        tg.monthsParse = function (J, et, eo) {
          var el, ec, ed;
          if (this._monthsParseExact)
            return handleStrictParse.call(this, J, et, eo);
          for (this._monthsParse || (this._monthsParse = [],
            this._longMonthsParse = [],
            this._shortMonthsParse = []),
            el = 0; el < 12; el++)
            if (ec = createUTC([2e3, el]),
              eo && !this._longMonthsParse[el] && (this._longMonthsParse[el] = RegExp("^" + this.months(ec, "").replace(".", "") + "$", "i"),
                this._shortMonthsParse[el] = RegExp("^" + this.monthsShort(ec, "").replace(".", "") + "$", "i")),
              eo || this._monthsParse[el] || (ed = "^" + this.months(ec, "") + "|^" + this.monthsShort(ec, ""),
                this._monthsParse[el] = RegExp(ed.replace(".", ""), "i")),
              eo && "MMMM" === et && this._longMonthsParse[el].test(J) || eo && "MMM" === et && this._shortMonthsParse[el].test(J) || !eo && this._monthsParse[el].test(J))
              return el
        }
        ,
        tg.monthsRegex = function (J) {
          return this._monthsParseExact ? (hasOwnProp(this, "_monthsRegex") || computeMonthsParse.call(this),
            J) ? this._monthsStrictRegex : this._monthsRegex : (hasOwnProp(this, "_monthsRegex") || (this._monthsRegex = e$),
              this._monthsStrictRegex && J ? this._monthsStrictRegex : this._monthsRegex)
        }
        ,
        tg.monthsShortRegex = function (J) {
          return this._monthsParseExact ? (hasOwnProp(this, "_monthsRegex") || computeMonthsParse.call(this),
            J) ? this._monthsShortStrictRegex : this._monthsShortRegex : (hasOwnProp(this, "_monthsShortRegex") || (this._monthsShortRegex = e$),
              this._monthsShortStrictRegex && J ? this._monthsShortStrictRegex : this._monthsShortRegex)
        }
        ,
        tg.week = function (J) {
          return weekOfYear(J, this._week.dow, this._week.doy).week
        }
        ,
        tg.firstDayOfYear = function () {
          return this._week.doy
        }
        ,
        tg.firstDayOfWeek = function () {
          return this._week.dow
        }
        ,
        tg.weekdays = function (J, et) {
          var eo = isArray(this._weekdays) ? this._weekdays : this._weekdays[J && !0 !== J && this._weekdays.isFormat.test(et) ? "format" : "standalone"];
          return !0 === J ? shiftWeekdays(eo, this._week.dow) : J ? eo[J.day()] : eo
        }
        ,
        tg.weekdaysMin = function (J) {
          return !0 === J ? shiftWeekdays(this._weekdaysMin, this._week.dow) : J ? this._weekdaysMin[J.day()] : this._weekdaysMin
        }
        ,
        tg.weekdaysShort = function (J) {
          return !0 === J ? shiftWeekdays(this._weekdaysShort, this._week.dow) : J ? this._weekdaysShort[J.day()] : this._weekdaysShort
        }
        ,
        tg.weekdaysParse = function (J, et, eo) {
          var el, ec, ed;
          if (this._weekdaysParseExact)
            return handleStrictParse$1.call(this, J, et, eo);
          for (this._weekdaysParse || (this._weekdaysParse = [],
            this._minWeekdaysParse = [],
            this._shortWeekdaysParse = [],
            this._fullWeekdaysParse = []),
            el = 0; el < 7; el++) {
            if (ec = createUTC([2e3, 1]).day(el),
              eo && !this._fullWeekdaysParse[el] && (this._fullWeekdaysParse[el] = RegExp("^" + this.weekdays(ec, "").replace(".", "\\.?") + "$", "i"),
                this._shortWeekdaysParse[el] = RegExp("^" + this.weekdaysShort(ec, "").replace(".", "\\.?") + "$", "i"),
                this._minWeekdaysParse[el] = RegExp("^" + this.weekdaysMin(ec, "").replace(".", "\\.?") + "$", "i")),
              this._weekdaysParse[el] || (ed = "^" + this.weekdays(ec, "") + "|^" + this.weekdaysShort(ec, "") + "|^" + this.weekdaysMin(ec, ""),
                this._weekdaysParse[el] = RegExp(ed.replace(".", ""), "i")),
              eo && "dddd" === et && this._fullWeekdaysParse[el].test(J) || eo && "ddd" === et && this._shortWeekdaysParse[el].test(J))
              return el;
            if (eo && "dd" === et && this._minWeekdaysParse[el].test(J))
              return el;
            if (!eo && this._weekdaysParse[el].test(J))
              return el
          }
        }
        ,
        tg.weekdaysRegex = function (J) {
          return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this),
            J) ? this._weekdaysStrictRegex : this._weekdaysRegex : (hasOwnProp(this, "_weekdaysRegex") || (this._weekdaysRegex = e$),
              this._weekdaysStrictRegex && J ? this._weekdaysStrictRegex : this._weekdaysRegex)
        }
        ,
        tg.weekdaysShortRegex = function (J) {
          return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this),
            J) ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex : (hasOwnProp(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = e$),
              this._weekdaysShortStrictRegex && J ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex)
        }
        ,
        tg.weekdaysMinRegex = function (J) {
          return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this),
            J) ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex : (hasOwnProp(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = e$),
              this._weekdaysMinStrictRegex && J ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex)
        }
        ,
        tg.isPM = function (J) {
          return "p" === (J + "").toLowerCase().charAt(0)
        }
        ,
        tg.meridiem = function (J, et, eo) {
          return J > 11 ? eo ? "pm" : "PM" : eo ? "am" : "AM"
        }
        ,
        getSetGlobalLocale("en", {
          eras: [{
            since: "0001-01-01",
            until: Infinity,
            offset: 1,
            name: "Anno Domini",
            narrow: "AD",
            abbr: "AD"
          }, {
            since: "0000-12-31",
            until: -1 / 0,
            offset: 1,
            name: "Before Christ",
            narrow: "BC",
            abbr: "BC"
          }],
          dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
          ordinal: function (J) {
            var et = J % 10
              , eo = 1 === toInt(J % 100 / 10) ? "th" : 1 === et ? "st" : 2 === et ? "nd" : 3 === et ? "rd" : "th";
            return J + eo
          }
        }),
        hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale),
        hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
      var ty = Math.abs;
      function addSubtract$1(J, et, eo, el) {
        var ec = createDuration(et, eo);
        return J._milliseconds += el * ec._milliseconds,
          J._days += el * ec._days,
          J._months += el * ec._months,
          J._bubble()
      }
      function absCeil(J) {
        return J < 0 ? Math.floor(J) : Math.ceil(J)
      }
      function daysToMonths(J) {
        return 4800 * J / 146097
      }
      function monthsToDays(J) {
        return 146097 * J / 4800
      }
      function makeAs(J) {
        return function () {
          return this.as(J)
        }
      }
      var tb = makeAs("ms")
        , tw = makeAs("s")
        , t_ = makeAs("m")
        , tx = makeAs("h")
        , tE = makeAs("d")
        , tC = makeAs("w")
        , tS = makeAs("M")
        , tk = makeAs("Q")
        , tT = makeAs("y");
      function makeGetter(J) {
        return function () {
          return this.isValid() ? this._data[J] : NaN
        }
      }
      var tA = makeGetter("milliseconds")
        , tP = makeGetter("seconds")
        , tR = makeGetter("minutes")
        , tI = makeGetter("hours")
        , tO = makeGetter("days")
        , tN = makeGetter("months")
        , tM = makeGetter("years")
        , tD = Math.round
        , tj = {
          ss: 44,
          s: 45,
          m: 45,
          h: 22,
          d: 26,
          w: null,
          M: 11
        };
      function substituteTimeAgo(J, et, eo, el, ec) {
        return ec.relativeTime(et || 1, !!eo, J, el)
      }
      var tL = Math.abs;
      function sign(J) {
        return (J > 0) - (J < 0) || +J
      }
      function toISOString$1() {
        if (!this.isValid())
          return this.localeData().invalidDate();
        var J, et, eo, el, ec, ed, eh, ep, ef = tL(this._milliseconds) / 1e3, em = tL(this._days), eg = tL(this._months), ey = this.asSeconds();
        return ey ? (J = absFloor(ef / 60),
          et = absFloor(J / 60),
          ef %= 60,
          J %= 60,
          eo = absFloor(eg / 12),
          eg %= 12,
          el = ef ? ef.toFixed(3).replace(/\.?0+$/, "") : "",
          ec = ey < 0 ? "-" : "",
          ed = sign(this._months) !== sign(ey) ? "-" : "",
          eh = sign(this._days) !== sign(ey) ? "-" : "",
          ep = sign(this._milliseconds) !== sign(ey) ? "-" : "",
          ec + "P" + (eo ? ed + eo + "Y" : "") + (eg ? ed + eg + "M" : "") + (em ? eh + em + "D" : "") + (et || J || ef ? "T" : "") + (et ? ep + et + "H" : "") + (J ? ep + J + "M" : "") + (ef ? ep + el + "S" : "")) : "P0D"
      }
      var t$ = Duration.prototype;
      return t$.isValid = function () {
        return this._isValid
      }
        ,
        t$.abs = function () {
          var J = this._data;
          return this._milliseconds = ty(this._milliseconds),
            this._days = ty(this._days),
            this._months = ty(this._months),
            J.milliseconds = ty(J.milliseconds),
            J.seconds = ty(J.seconds),
            J.minutes = ty(J.minutes),
            J.hours = ty(J.hours),
            J.months = ty(J.months),
            J.years = ty(J.years),
            this
        }
        ,
        t$.add = function (J, et) {
          return addSubtract$1(this, J, et, 1)
        }
        ,
        t$.subtract = function (J, et) {
          return addSubtract$1(this, J, et, -1)
        }
        ,
        t$.as = function (J) {
          if (!this.isValid())
            return NaN;
          var et, eo, el = this._milliseconds;
          if ("month" === (J = normalizeUnits(J)) || "quarter" === J || "year" === J)
            switch (et = this._days + el / 864e5,
            eo = this._months + daysToMonths(et),
            J) {
              case "month":
                return eo;
              case "quarter":
                return eo / 3;
              case "year":
                return eo / 12
            }
          else
            switch (et = this._days + Math.round(monthsToDays(this._months)),
            J) {
              case "week":
                return et / 7 + el / 6048e5;
              case "day":
                return et + el / 864e5;
              case "hour":
                return 24 * et + el / 36e5;
              case "minute":
                return 1440 * et + el / 6e4;
              case "second":
                return 86400 * et + el / 1e3;
              case "millisecond":
                return Math.floor(864e5 * et) + el;
              default:
                throw Error("Unknown unit " + J)
            }
        }
        ,
        t$.asMilliseconds = tb,
        t$.asSeconds = tw,
        t$.asMinutes = t_,
        t$.asHours = tx,
        t$.asDays = tE,
        t$.asWeeks = tC,
        t$.asMonths = tS,
        t$.asQuarters = tk,
        t$.asYears = tT,
        t$.valueOf = tb,
        t$._bubble = function () {
          var J, et, eo, el, ec, ed = this._milliseconds, eh = this._days, ep = this._months, ef = this._data;
          return ed >= 0 && eh >= 0 && ep >= 0 || ed <= 0 && eh <= 0 && ep <= 0 || (ed += 864e5 * absCeil(monthsToDays(ep) + eh),
            eh = 0,
            ep = 0),
            ef.milliseconds = ed % 1e3,
            J = absFloor(ed / 1e3),
            ef.seconds = J % 60,
            et = absFloor(J / 60),
            ef.minutes = et % 60,
            eo = absFloor(et / 60),
            ef.hours = eo % 24,
            eh += absFloor(eo / 24),
            ep += ec = absFloor(daysToMonths(eh)),
            eh -= absCeil(monthsToDays(ec)),
            el = absFloor(ep / 12),
            ep %= 12,
            ef.days = eh,
            ef.months = ep,
            ef.years = el,
            this
        }
        ,
        t$.clone = function () {
          return createDuration(this)
        }
        ,
        t$.get = function (J) {
          return J = normalizeUnits(J),
            this.isValid() ? this[J + "s"]() : NaN
        }
        ,
        t$.milliseconds = tA,
        t$.seconds = tP,
        t$.minutes = tR,
        t$.hours = tI,
        t$.days = tO,
        t$.weeks = function () {
          return absFloor(this.days() / 7)
        }
        ,
        t$.months = tN,
        t$.years = tM,
        t$.humanize = function (J, et) {
          if (!this.isValid())
            return this.localeData().invalidDate();
          var eo, el, ec, ed, eh, ep, ef, em, eg, ey, eb, ew, e_, ex = !1, eE = tj;
          return "object" == typeof J && (et = J,
            J = !1),
            "boolean" == typeof J && (ex = J),
            "object" == typeof et && (eE = Object.assign({}, tj, et),
              null != et.s && null == et.ss && (eE.ss = et.s - 1)),
            ew = this.localeData(),
            eo = !ex,
            el = eE,
            ec = createDuration(this).abs(),
            ed = tD(ec.as("s")),
            eh = tD(ec.as("m")),
            ep = tD(ec.as("h")),
            ef = tD(ec.as("d")),
            em = tD(ec.as("M")),
            eg = tD(ec.as("w")),
            ey = tD(ec.as("y")),
            eb = ed <= el.ss && ["s", ed] || ed < el.s && ["ss", ed] || eh <= 1 && ["m"] || eh < el.m && ["mm", eh] || ep <= 1 && ["h"] || ep < el.h && ["hh", ep] || ef <= 1 && ["d"] || ef < el.d && ["dd", ef],
            null != el.w && (eb = eb || eg <= 1 && ["w"] || eg < el.w && ["ww", eg]),
            (eb = eb || em <= 1 && ["M"] || em < el.M && ["MM", em] || ey <= 1 && ["y"] || ["yy", ey])[2] = eo,
            eb[3] = +this > 0,
            eb[4] = ew,
            e_ = substituteTimeAgo.apply(null, eb),
            ex && (e_ = ew.pastFuture(+this, e_)),
            ew.postformat(e_)
        }
        ,
        t$.toISOString = toISOString$1,
        t$.toString = toISOString$1,
        t$.toJSON = toISOString$1,
        t$.locale = locale,
        t$.localeData = localeData,
        t$.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1),
        t$.lang = td,
        addFormatToken("X", 0, 0, "unix"),
        addFormatToken("x", 0, 0, "valueOf"),
        addRegexToken("x", eD),
        addRegexToken("X", /[+-]?\d+(\.\d{1,3})?/),
        addParseToken("X", function (J, et, eo) {
          eo._d = new Date(1e3 * parseFloat(J))
        }),
        addParseToken("x", function (J, et, eo) {
          eo._d = new Date(toInt(J))
        }),
        hooks.version = "2.30.1",
        ey = createLocal,
        hooks.fn = tm,
        hooks.min = function () {
          var J = [].slice.call(arguments, 0);
          return pickBy("isBefore", J)
        }
        ,
        hooks.max = function () {
          var J = [].slice.call(arguments, 0);
          return pickBy("isAfter", J)
        }
        ,
        hooks.now = function () {
          return Date.now ? Date.now() : +new Date
        }
        ,
        hooks.utc = createUTC,
        hooks.unix = function (J) {
          return createLocal(1e3 * J)
        }
        ,
        hooks.months = function (J, et) {
          return listMonthsImpl(J, et, "months")
        }
        ,
        hooks.isDate = isDate,
        hooks.locale = getSetGlobalLocale,
        hooks.invalid = createInvalid,
        hooks.duration = createDuration,
        hooks.isMoment = isMoment,
        hooks.weekdays = function (J, et, eo) {
          return listWeekdaysImpl(J, et, eo, "weekdays")
        }
        ,
        hooks.parseZone = function () {
          return createLocal.apply(null, arguments).parseZone()
        }
        ,
        hooks.localeData = getLocale,
        hooks.isDuration = isDuration,
        hooks.monthsShort = function (J, et) {
          return listMonthsImpl(J, et, "monthsShort")
        }
        ,
        hooks.weekdaysMin = function (J, et, eo) {
          return listWeekdaysImpl(J, et, eo, "weekdaysMin")
        }
        ,
        hooks.defineLocale = defineLocale,
        hooks.updateLocale = function (J, et) {
          if (null != et) {
            var eo, el, ec = eK;
            null != eJ[J] && null != eJ[J].parentLocale ? eJ[J].set(mergeConfigs(eJ[J]._config, et)) : (null != (el = loadLocale(J)) && (ec = el._config),
              et = mergeConfigs(ec, et),
              null == el && (et.abbr = J),
              (eo = new Locale(et)).parentLocale = eJ[J],
              eJ[J] = eo),
              getSetGlobalLocale(J)
          } else
            null != eJ[J] && (null != eJ[J].parentLocale ? (eJ[J] = eJ[J].parentLocale,
              J === getSetGlobalLocale() && getSetGlobalLocale(J)) : null != eJ[J] && delete eJ[J]);
          return eJ[J]
        }
        ,
        hooks.locales = function () {
          return ew(eJ)
        }
        ,
        hooks.weekdaysShort = function (J, et, eo) {
          return listWeekdaysImpl(J, et, eo, "weekdaysShort")
        }
        ,
        hooks.normalizeUnits = normalizeUnits,
        hooks.relativeTimeRounding = function (J) {
          return void 0 === J ? tD : "function" == typeof J && (tD = J,
            !0)
        }
        ,
        hooks.relativeTimeThreshold = function (J, et) {
          return void 0 !== tj[J] && (void 0 === et ? tj[J] : (tj[J] = et,
            "s" === J && (tj.ss = et - 1),
            !0))
        }
        ,
        hooks.calendarFormat = function (J, et) {
          var eo = J.diff(et, "days", !0);
          return eo < -6 ? "sameElse" : eo < -1 ? "lastWeek" : eo < 0 ? "lastDay" : eo < 1 ? "sameDay" : eo < 2 ? "nextDay" : eo < 7 ? "nextWeek" : "sameElse"
        }
        ,
        hooks.prototype = tm,
        hooks.HTML5_FMT = {
          DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
          DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
          DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
          DATE: "YYYY-MM-DD",
          TIME: "HH:mm",
          TIME_SECONDS: "HH:mm:ss",
          TIME_MS: "HH:mm:ss.SSS",
          WEEK: "GGGG-[W]WW",
          MONTH: "YYYY-MM"
        },
        hooks
    }()
  },
  57824: function (J) {
    function plural(J, et, eo, el) {
      return Math.round(J / eo) + " " + el + (et >= 1.5 * eo ? "s" : "")
    }
    J.exports = function (J, et) {
      et = et || {};
      var eo, el, ec = typeof J;
      if ("string" === ec && J.length > 0)
        return function (J) {
          if (!((J = String(J)).length > 100)) {
            var et = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(J);
            if (et) {
              var eo = parseFloat(et[1]);
              switch ((et[2] || "ms").toLowerCase()) {
                case "years":
                case "year":
                case "yrs":
                case "yr":
                case "y":
                  return 315576e5 * eo;
                case "weeks":
                case "week":
                case "w":
                  return 6048e5 * eo;
                case "days":
                case "day":
                case "d":
                  return 864e5 * eo;
                case "hours":
                case "hour":
                case "hrs":
                case "hr":
                case "h":
                  return 36e5 * eo;
                case "minutes":
                case "minute":
                case "mins":
                case "min":
                case "m":
                  return 6e4 * eo;
                case "seconds":
                case "second":
                case "secs":
                case "sec":
                case "s":
                  return 1e3 * eo;
                case "milliseconds":
                case "millisecond":
                case "msecs":
                case "msec":
                case "ms":
                  return eo;
                default:
                  return
              }
            }
          }
        }(J);
      if ("number" === ec && isFinite(J))
        return et.long ? (eo = Math.abs(J)) >= 864e5 ? plural(J, eo, 864e5, "day") : eo >= 36e5 ? plural(J, eo, 36e5, "hour") : eo >= 6e4 ? plural(J, eo, 6e4, "minute") : eo >= 1e3 ? plural(J, eo, 1e3, "second") : J + " ms" : (el = Math.abs(J)) >= 864e5 ? Math.round(J / 864e5) + "d" : el >= 36e5 ? Math.round(J / 36e5) + "h" : el >= 6e4 ? Math.round(J / 6e4) + "m" : el >= 1e3 ? Math.round(J / 1e3) + "s" : J + "ms";
      throw Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(J))
    }
  },
  63144: function (J) {
    "use strict";
    let et = self.fetch.bind(self);
    J.exports = et,
      J.exports.default = J.exports
  },
  83454: function (J, et, eo) {
    "use strict";
    var el, ec;
    J.exports = (null == (el = eo.g.process) ? void 0 : el.env) && "object" == typeof (null == (ec = eo.g.process) ? void 0 : ec.env) ? eo.g.process : eo(77663)
  },
  91118: function (J, et, eo) {
    (window.__NEXT_P = window.__NEXT_P || []).push(["/_app", function () {
      return eo(43572)
    }
    ])
  },
  56377: function (J, et, eo) {
    "use strict";
    eo.r(et),
      eo.d(et, {
        default: function () {
          return el
        }
      });
    var el = [{
      inputs: [],
      name: "AlreadyPurchaseExtendedCap",
      type: "error"
    }, {
      inputs: [],
      name: "AlreadyPurchaseHardCap",
      type: "error"
    }, {
      inputs: [],
      name: "AlreadyPurchaseSoftLaunch",
      type: "error"
    }, {
      inputs: [],
      name: "AlreadySwept",
      type: "error"
    }, {
      inputs: [],
      name: "InvalidAmount",
      type: "error"
    }, {
      inputs: [],
      name: "InvalidExtendedCapAmount",
      type: "error"
    }, {
      inputs: [],
      name: "InvalidHardCapAmount",
      type: "error"
    }, {
      inputs: [],
      name: "InvalidLength",
      type: "error"
    }, {
      inputs: [],
      name: "InvalidPbs",
      type: "error"
    }, {
      inputs: [],
      name: "InvalidPrice",
      type: "error"
    }, {
      inputs: [],
      name: "InvalidPurchaseCap",
      type: "error"
    }, {
      inputs: [],
      name: "InvalidSaleCap",
      type: "error"
    }, {
      inputs: [],
      name: "InvalidSignature",
      type: "error"
    }, {
      inputs: [],
      name: "InvalidSoftLaunchAmount",
      type: "error"
    }, {
      inputs: [],
      name: "InvalidTimeStamps",
      type: "error"
    }, {
      inputs: [],
      name: "NativePaymentToken",
      type: "error"
    }, {
      inputs: [{
        internalType: "address",
        name: "",
        type: "address"
      }],
      name: "NotOperator",
      type: "error"
    }, {
      inputs: [],
      name: "NotSweepTime",
      type: "error"
    }, {
      inputs: [],
      name: "NothingToClaim",
      type: "error"
    }, {
      inputs: [{
        internalType: "address",
        name: "",
        type: "address"
      }],
      name: "OnlyOperator",
      type: "error"
    }, {
      inputs: [{
        internalType: "address",
        name: "",
        type: "address"
      }],
      name: "OperatorAdded",
      type: "error"
    }, {
      inputs: [],
      name: "PermitFailed",
      type: "error"
    }, {
      inputs: [],
      name: "SaleEnded",
      type: "error"
    }, {
      inputs: [],
      name: "SaleNotEnded",
      type: "error"
    }, {
      inputs: [],
      name: "SaleNotStarted",
      type: "error"
    }, {
      inputs: [],
      name: "SaleStarted",
      type: "error"
    }, {
      inputs: [],
      name: "SoldOut",
      type: "error"
    }, {
      inputs: [],
      name: "SoldOutOrEnded",
      type: "error"
    }, {
      inputs: [],
      name: "ZeroAddress",
      type: "error"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !1,
        internalType: "uint256",
        name: "claimTime",
        type: "uint256"
      }],
      name: "ClaimTimeChanged",
      type: "event"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !0,
        internalType: "address",
        name: "sender",
        type: "address"
      }, {
        indexed: !1,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }],
      name: "Claimed",
      type: "event"
    }, {
      anonymous: !1,
      inputs: [],
      name: "EIP712DomainChanged",
      type: "event"
    }, {
      anonymous: !1,
      inputs: [{
        components: [{
          internalType: "uint256",
          name: "cap",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "startTime",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "endTime",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "price",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "extendedStep",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "extendPrice",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "minPay",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "maxPay",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "maxPayIncreaseTime",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "increasedMaxPay",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "initialReleasePbs",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "vestingPeriod",
          type: "uint256"
        }],
        indexed: !1,
        internalType: "struct IMobySale.HardCapConfig",
        name: "config",
        type: "tuple"
      }],
      name: "HardCapConfigChanged",
      type: "event"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !1,
        internalType: "uint8",
        name: "version",
        type: "uint8"
      }],
      name: "Initialized",
      type: "event"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !0,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      }, {
        indexed: !0,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }],
      name: "OwnershipTransferred",
      type: "event"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !1,
        internalType: "address",
        name: "account",
        type: "address"
      }],
      name: "Paused",
      type: "event"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !0,
        internalType: "address",
        name: "sender",
        type: "address"
      }, {
        indexed: !1,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }],
      name: "Purchased",
      type: "event"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !0,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }, {
        indexed: !0,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      }, {
        indexed: !0,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }],
      name: "RoleAdminChanged",
      type: "event"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !0,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }, {
        indexed: !0,
        internalType: "address",
        name: "account",
        type: "address"
      }, {
        indexed: !0,
        internalType: "address",
        name: "sender",
        type: "address"
      }],
      name: "RoleGranted",
      type: "event"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !0,
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }, {
        indexed: !0,
        internalType: "address",
        name: "account",
        type: "address"
      }, {
        indexed: !0,
        internalType: "address",
        name: "sender",
        type: "address"
      }],
      name: "RoleRevoked",
      type: "event"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !1,
        internalType: "address",
        name: "saleToken",
        type: "address"
      }],
      name: "SaleTokenChanged",
      type: "event"
    }, {
      anonymous: !1,
      inputs: [{
        components: [{
          internalType: "uint256",
          name: "cap",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "startTime",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "endTime",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "price",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "minPay",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "maxPay",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "initialReleasePbs",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "vestingPeriod",
          type: "uint256"
        }],
        indexed: !1,
        internalType: "struct IMobySale.SoftLaunchConfig",
        name: "config",
        type: "tuple"
      }],
      name: "SoftLaunchConfigChanged",
      type: "event"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !0,
        internalType: "address",
        name: "receiver",
        type: "address"
      }, {
        indexed: !1,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }],
      name: "Swept",
      type: "event"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !1,
        internalType: "address",
        name: "account",
        type: "address"
      }],
      name: "Unpaused",
      type: "event"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !1,
        internalType: "address",
        name: "verifier",
        type: "address"
      }],
      name: "VerifierChanged",
      type: "event"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !0,
        internalType: "address",
        name: "account",
        type: "address"
      }, {
        indexed: !1,
        internalType: "uint256",
        name: "allocation",
        type: "uint256"
      }],
      name: "Whitelisted",
      type: "event"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !0,
        internalType: "address",
        name: "receiver",
        type: "address"
      }, {
        indexed: !1,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }],
      name: "Withdrawn",
      type: "event"
    }, {
      inputs: [],
      name: "BASIS_POINTS",
      outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [],
      name: "DEFAULT_ADMIN_ROLE",
      outputs: [{
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [],
      name: "MINIMUM_CLAIM_PERIOD",
      outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [],
      name: "OPERATOR_ROLE",
      outputs: [{
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [],
      name: "PRICE_PRECISION",
      outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [{
        internalType: "address",
        name: "account",
        type: "address"
      }],
      name: "addOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }, {
      inputs: [],
      name: "claim",
      outputs: [{
        internalType: "uint256",
        name: "claimAmount",
        type: "uint256"
      }],
      stateMutability: "nonpayable",
      type: "function"
    }, {
      inputs: [],
      name: "claimTime",
      outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [],
      name: "eip712Domain",
      outputs: [{
        internalType: "bytes1",
        name: "fields",
        type: "bytes1"
      }, {
        internalType: "string",
        name: "name",
        type: "string"
      }, {
        internalType: "string",
        name: "version",
        type: "string"
      }, {
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      }, {
        internalType: "address",
        name: "verifyingContract",
        type: "address"
      }, {
        internalType: "bytes32",
        name: "salt",
        type: "bytes32"
      }, {
        internalType: "uint256[]",
        name: "extensions",
        type: "uint256[]"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [{
        internalType: "address",
        name: "account",
        type: "address"
      }],
      name: "getClaimAmount",
      outputs: [{
        internalType: "uint256",
        name: "claimAmount",
        type: "uint256"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [],
      name: "getHardCapMaxPay",
      outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [{
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }, {
        internalType: "address",
        name: "user",
        type: "address"
      }],
      name: "getPurchaseAmount",
      outputs: [{
        internalType: "uint256",
        name: "paymentTokenAmount",
        type: "uint256"
      }, {
        internalType: "uint256",
        name: "softLaunchAmount",
        type: "uint256"
      }, {
        internalType: "uint256",
        name: "hardCapAmount",
        type: "uint256"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [{
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }],
      name: "getRoleAdmin",
      outputs: [{
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [{
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }, {
        internalType: "address",
        name: "account",
        type: "address"
      }],
      name: "grantRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }, {
      inputs: [],
      name: "hardCapConfig",
      outputs: [{
        internalType: "uint256",
        name: "cap",
        type: "uint256"
      }, {
        internalType: "uint256",
        name: "startTime",
        type: "uint256"
      }, {
        internalType: "uint256",
        name: "endTime",
        type: "uint256"
      }, {
        internalType: "uint256",
        name: "price",
        type: "uint256"
      }, {
        internalType: "uint256",
        name: "extendedStep",
        type: "uint256"
      }, {
        internalType: "uint256",
        name: "extendPrice",
        type: "uint256"
      }, {
        internalType: "uint256",
        name: "minPay",
        type: "uint256"
      }, {
        internalType: "uint256",
        name: "maxPay",
        type: "uint256"
      }, {
        internalType: "uint256",
        name: "maxPayIncreaseTime",
        type: "uint256"
      }, {
        internalType: "uint256",
        name: "increasedMaxPay",
        type: "uint256"
      }, {
        internalType: "uint256",
        name: "initialReleasePbs",
        type: "uint256"
      }, {
        internalType: "uint256",
        name: "vestingPeriod",
        type: "uint256"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [],
      name: "hardcapPaymentTokenPaid",
      outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [{
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }, {
        internalType: "address",
        name: "account",
        type: "address"
      }],
      name: "hasRole",
      outputs: [{
        internalType: "bool",
        name: "",
        type: "bool"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [{
        internalType: "address",
        name: "initialOwner",
        type: "address"
      }, {
        internalType: "address",
        name: "_saleToken",
        type: "address"
      }, {
        internalType: "address",
        name: "_paymentToken",
        type: "address"
      }, {
        internalType: "address",
        name: "_verifier",
        type: "address"
      }, {
        components: [{
          internalType: "uint256",
          name: "cap",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "startTime",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "endTime",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "price",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "minPay",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "maxPay",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "initialReleasePbs",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "vestingPeriod",
          type: "uint256"
        }],
        internalType: "struct IMobySale.SoftLaunchConfig",
        name: "_softLaunchConfig",
        type: "tuple"
      }, {
        components: [{
          internalType: "uint256",
          name: "cap",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "startTime",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "endTime",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "price",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "extendedStep",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "extendPrice",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "minPay",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "maxPay",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "maxPayIncreaseTime",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "increasedMaxPay",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "initialReleasePbs",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "vestingPeriod",
          type: "uint256"
        }],
        internalType: "struct IMobySale.HardCapConfig",
        name: "_hardCapConfig",
        type: "tuple"
      }, {
        internalType: "uint256",
        name: "_claimTime",
        type: "uint256"
      }, {
        internalType: "string",
        name: "domainName",
        type: "string"
      }, {
        internalType: "string",
        name: "signatureVersion",
        type: "string"
      }],
      name: "initialize",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }, {
      inputs: [],
      name: "isSwept",
      outputs: [{
        internalType: "bool",
        name: "",
        type: "bool"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [{
        internalType: "address",
        name: "account",
        type: "address"
      }],
      name: "nonces",
      outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [],
      name: "owner",
      outputs: [{
        internalType: "address",
        name: "",
        type: "address"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [],
      name: "pause",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }, {
      inputs: [],
      name: "paused",
      outputs: [{
        internalType: "bool",
        name: "",
        type: "bool"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [],
      name: "paymentToken",
      outputs: [{
        internalType: "contract IERC20Upgradeable",
        name: "",
        type: "address"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [{
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }, {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }],
      name: "purchase",
      outputs: [],
      stateMutability: "payable",
      type: "function"
    }, {
      inputs: [{
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }, {
        components: [{
          internalType: "uint256",
          name: "nonce",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "deadline",
          type: "uint256"
        }, {
          internalType: "uint8",
          name: "v",
          type: "uint8"
        }, {
          internalType: "bytes32",
          name: "r",
          type: "bytes32"
        }, {
          internalType: "bytes32",
          name: "s",
          type: "bytes32"
        }],
        internalType: "struct IMobySale.PermitRequest",
        name: "permit",
        type: "tuple"
      }, {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }],
      name: "purchaseWithPermit",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }, {
      inputs: [{
        internalType: "address",
        name: "",
        type: "address"
      }],
      name: "purchasers",
      outputs: [{
        internalType: "address",
        name: "account",
        type: "address"
      }, {
        internalType: "uint256",
        name: "softLaunchAmount",
        type: "uint256"
      }, {
        internalType: "uint256",
        name: "hardCapAmount",
        type: "uint256"
      }, {
        internalType: "uint256",
        name: "lastTimeClaimed",
        type: "uint256"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [{
        internalType: "address",
        name: "account",
        type: "address"
      }],
      name: "removeOperator",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }, {
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }, {
      inputs: [{
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }, {
        internalType: "address",
        name: "account",
        type: "address"
      }],
      name: "renounceRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }, {
      inputs: [{
        internalType: "bytes32",
        name: "role",
        type: "bytes32"
      }, {
        internalType: "address",
        name: "account",
        type: "address"
      }],
      name: "revokeRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }, {
      inputs: [],
      name: "saleToken",
      outputs: [{
        internalType: "contract IERC20Upgradeable",
        name: "",
        type: "address"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [{
        internalType: "uint256",
        name: "_claimTime",
        type: "uint256"
      }],
      name: "setClaimTime",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }, {
      inputs: [{
        components: [{
          internalType: "uint256",
          name: "cap",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "startTime",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "endTime",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "price",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "extendedStep",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "extendPrice",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "minPay",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "maxPay",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "maxPayIncreaseTime",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "increasedMaxPay",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "initialReleasePbs",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "vestingPeriod",
          type: "uint256"
        }],
        internalType: "struct IMobySale.HardCapConfig",
        name: "_hardCapConfig",
        type: "tuple"
      }],
      name: "setHardCapConfig",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }, {
      inputs: [{
        internalType: "address",
        name: "_saleToken",
        type: "address"
      }],
      name: "setSaleToken",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }, {
      inputs: [{
        components: [{
          internalType: "uint256",
          name: "cap",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "startTime",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "endTime",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "price",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "minPay",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "maxPay",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "initialReleasePbs",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "vestingPeriod",
          type: "uint256"
        }],
        internalType: "struct IMobySale.SoftLaunchConfig",
        name: "_softLaunchConfig",
        type: "tuple"
      }],
      name: "setSoftLaunchConfig",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }, {
      inputs: [{
        internalType: "address[]",
        name: "_addresses",
        type: "address[]"
      }, {
        internalType: "uint256[]",
        name: "_allocations",
        type: "uint256[]"
      }],
      name: "setSoftLaunchWhitelistAllocation",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }, {
      inputs: [{
        internalType: "address",
        name: "_verifier",
        type: "address"
      }],
      name: "setVerifier",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }, {
      inputs: [],
      name: "softLaunchConfig",
      outputs: [{
        internalType: "uint256",
        name: "cap",
        type: "uint256"
      }, {
        internalType: "uint256",
        name: "startTime",
        type: "uint256"
      }, {
        internalType: "uint256",
        name: "endTime",
        type: "uint256"
      }, {
        internalType: "uint256",
        name: "price",
        type: "uint256"
      }, {
        internalType: "uint256",
        name: "minPay",
        type: "uint256"
      }, {
        internalType: "uint256",
        name: "maxPay",
        type: "uint256"
      }, {
        internalType: "uint256",
        name: "initialReleasePbs",
        type: "uint256"
      }, {
        internalType: "uint256",
        name: "vestingPeriod",
        type: "uint256"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [{
        internalType: "address",
        name: "",
        type: "address"
      }],
      name: "softLaunchWhitelistAllocations",
      outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [{
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }],
      name: "supportsInterface",
      outputs: [{
        internalType: "bool",
        name: "",
        type: "bool"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [{
        internalType: "address",
        name: "to",
        type: "address"
      }],
      name: "sweep",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }, {
      inputs: [],
      name: "sweepTime",
      outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [],
      name: "totalPaymentTokenPaid",
      outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [],
      name: "totalPurchasedAmount",
      outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [],
      name: "totalSoftCapPurchasedAmount",
      outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [{
        internalType: "address",
        name: "newOwner",
        type: "address"
      }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }, {
      inputs: [],
      name: "unpause",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }, {
      inputs: [],
      name: "verifier",
      outputs: [{
        internalType: "address",
        name: "",
        type: "address"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [{
        internalType: "address",
        name: "_user",
        type: "address"
      }, {
        internalType: "uint256",
        name: "_nonce",
        type: "uint256"
      }, {
        internalType: "bytes",
        name: "_signature",
        type: "bytes"
      }],
      name: "verifyPurchaseRequest",
      outputs: [{
        internalType: "bool",
        name: "",
        type: "bool"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [{
        internalType: "address",
        name: "to",
        type: "address"
      }, {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }],
      name: "withdraw",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }]
  },
  95676: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      V: function () {
        return getAbi
      },
      C: function () {
        return getContractAddress
      }
    });
    var el = eo(56377)
      , ec = [{
        inputs: [],
        name: "AlreadyClaimed",
        type: "error"
      }, {
        inputs: [],
        name: "DuplicateUnstakeRequest",
        type: "error"
      }, {
        inputs: [],
        name: "InsufficientStakedAmount",
        type: "error"
      }, {
        inputs: [],
        name: "InvalidAmount",
        type: "error"
      }, {
        inputs: [],
        name: "NotClaimTime",
        type: "error"
      }, {
        inputs: [],
        name: "NotEmergencyWithdraw",
        type: "error"
      }, {
        inputs: [],
        name: "NotRequestOwner",
        type: "error"
      }, {
        inputs: [],
        name: "ZeroAddress",
        type: "error"
      }, {
        anonymous: !1,
        inputs: [{
          indexed: !0,
          internalType: "address",
          name: "user",
          type: "address"
        }, {
          indexed: !0,
          internalType: "bytes32",
          name: "unstakeRequestId",
          type: "bytes32"
        }, {
          indexed: !1,
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }],
        name: "Claimed",
        type: "event"
      }, {
        anonymous: !1,
        inputs: [{
          indexed: !0,
          internalType: "address",
          name: "user",
          type: "address"
        }, {
          indexed: !1,
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }],
        name: "EmergencyWithdrawn",
        type: "event"
      }, {
        anonymous: !1,
        inputs: [{
          indexed: !1,
          internalType: "uint8",
          name: "version",
          type: "uint8"
        }],
        name: "Initialized",
        type: "event"
      }, {
        anonymous: !1,
        inputs: [{
          indexed: !0,
          internalType: "address",
          name: "previousOwner",
          type: "address"
        }, {
          indexed: !0,
          internalType: "address",
          name: "newOwner",
          type: "address"
        }],
        name: "OwnershipTransferred",
        type: "event"
      }, {
        anonymous: !1,
        inputs: [{
          indexed: !1,
          internalType: "address",
          name: "account",
          type: "address"
        }],
        name: "Paused",
        type: "event"
      }, {
        anonymous: !1,
        inputs: [{
          indexed: !1,
          internalType: "bool",
          name: "emergencyWithdraw",
          type: "bool"
        }],
        name: "SetIsEmergencyWithdraw",
        type: "event"
      }, {
        anonymous: !1,
        inputs: [{
          indexed: !0,
          internalType: "address",
          name: "user",
          type: "address"
        }, {
          indexed: !1,
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }],
        name: "Staked",
        type: "event"
      }, {
        anonymous: !1,
        inputs: [{
          indexed: !1,
          internalType: "address",
          name: "account",
          type: "address"
        }],
        name: "Unpaused",
        type: "event"
      }, {
        anonymous: !1,
        inputs: [{
          indexed: !0,
          internalType: "address",
          name: "user",
          type: "address"
        }, {
          indexed: !0,
          internalType: "bytes32",
          name: "unstakeRequestId",
          type: "bytes32"
        }, {
          indexed: !1,
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }, {
          indexed: !1,
          internalType: "uint256",
          name: "claimTime",
          type: "uint256"
        }],
        name: "Unstake",
        type: "event"
      }, {
        anonymous: !1,
        inputs: [{
          indexed: !1,
          internalType: "uint256",
          name: "oldUnstakeLockTime",
          type: "uint256"
        }, {
          indexed: !1,
          internalType: "uint256",
          name: "newUnstakeLockTime",
          type: "uint256"
        }],
        name: "UnstakeLockTimeChanged",
        type: "event"
      }, {
        inputs: [{
          internalType: "bytes32",
          name: "unstakeRequestId",
          type: "bytes32"
        }],
        name: "claim",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }, {
        inputs: [{
          internalType: "bytes32[]",
          name: "unstakeRequestIds",
          type: "bytes32[]"
        }],
        name: "claimMultiple",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }, {
        inputs: [],
        name: "emergencyWithdraw",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }, {
        inputs: [{
          internalType: "address",
          name: "_user",
          type: "address"
        }],
        name: "getUserUnstakeRequests",
        outputs: [{
          internalType: "bytes32[]",
          name: "",
          type: "bytes32[]"
        }],
        stateMutability: "view",
        type: "function"
      }, {
        inputs: [{
          internalType: "address",
          name: "_stakeToken",
          type: "address"
        }, {
          internalType: "uint256",
          name: "_unstakeLockTime",
          type: "uint256"
        }, {
          internalType: "address",
          name: "_owner",
          type: "address"
        }],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }, {
        inputs: [],
        name: "isEmergencyWithdraw",
        outputs: [{
          internalType: "bool",
          name: "",
          type: "bool"
        }],
        stateMutability: "view",
        type: "function"
      }, {
        inputs: [],
        name: "owner",
        outputs: [{
          internalType: "address",
          name: "",
          type: "address"
        }],
        stateMutability: "view",
        type: "function"
      }, {
        inputs: [],
        name: "pause",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }, {
        inputs: [],
        name: "paused",
        outputs: [{
          internalType: "bool",
          name: "",
          type: "bool"
        }],
        stateMutability: "view",
        type: "function"
      }, {
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }, {
        inputs: [{
          internalType: "bool",
          name: "_value",
          type: "bool"
        }],
        name: "setIsEmergencyWithdraw",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }, {
        inputs: [{
          internalType: "uint256",
          name: "_unstakeLockTime",
          type: "uint256"
        }],
        name: "setUnstakeLockTime",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }, {
        inputs: [{
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }],
        name: "stake",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }, {
        inputs: [],
        name: "stakeToken",
        outputs: [{
          internalType: "contract IERC20Upgradeable",
          name: "",
          type: "address"
        }],
        stateMutability: "view",
        type: "function"
      }, {
        inputs: [{
          internalType: "address",
          name: "",
          type: "address"
        }],
        name: "stakedAmount",
        outputs: [{
          internalType: "uint256",
          name: "",
          type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
      }, {
        inputs: [],
        name: "totalStaked",
        outputs: [{
          internalType: "uint256",
          name: "",
          type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
      }, {
        inputs: [{
          internalType: "address",
          name: "newOwner",
          type: "address"
        }],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }, {
        inputs: [],
        name: "unpause",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }, {
        inputs: [{
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }],
        name: "unstake",
        outputs: [{
          internalType: "bytes32",
          name: "unstakeRequestId",
          type: "bytes32"
        }],
        stateMutability: "nonpayable",
        type: "function"
      }, {
        inputs: [],
        name: "unstakeLockTime",
        outputs: [{
          internalType: "uint256",
          name: "",
          type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
      }, {
        inputs: [{
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }],
        name: "unstakeRequests",
        outputs: [{
          internalType: "address",
          name: "owner",
          type: "address"
        }, {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "claimTime",
          type: "uint256"
        }, {
          internalType: "bool",
          name: "claimed",
          type: "bool"
        }],
        stateMutability: "view",
        type: "function"
      }]
      , ed = [{
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor"
      }, {
        inputs: [{
          internalType: "address",
          name: "spender",
          type: "address"
        }, {
          internalType: "uint256",
          name: "allowance",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "needed",
          type: "uint256"
        }],
        name: "ERC20InsufficientAllowance",
        type: "error"
      }, {
        inputs: [{
          internalType: "address",
          name: "sender",
          type: "address"
        }, {
          internalType: "uint256",
          name: "balance",
          type: "uint256"
        }, {
          internalType: "uint256",
          name: "needed",
          type: "uint256"
        }],
        name: "ERC20InsufficientBalance",
        type: "error"
      }, {
        inputs: [{
          internalType: "address",
          name: "approver",
          type: "address"
        }],
        name: "ERC20InvalidApprover",
        type: "error"
      }, {
        inputs: [{
          internalType: "address",
          name: "receiver",
          type: "address"
        }],
        name: "ERC20InvalidReceiver",
        type: "error"
      }, {
        inputs: [{
          internalType: "address",
          name: "sender",
          type: "address"
        }],
        name: "ERC20InvalidSender",
        type: "error"
      }, {
        inputs: [{
          internalType: "address",
          name: "spender",
          type: "address"
        }],
        name: "ERC20InvalidSpender",
        type: "error"
      }, {
        anonymous: !1,
        inputs: [{
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address"
        }, {
          indexed: !0,
          internalType: "address",
          name: "spender",
          type: "address"
        }, {
          indexed: !1,
          internalType: "uint256",
          name: "value",
          type: "uint256"
        }],
        name: "Approval",
        type: "event"
      }, {
        anonymous: !1,
        inputs: [{
          indexed: !0,
          internalType: "address",
          name: "from",
          type: "address"
        }, {
          indexed: !0,
          internalType: "address",
          name: "to",
          type: "address"
        }, {
          indexed: !1,
          internalType: "uint256",
          name: "value",
          type: "uint256"
        }],
        name: "Transfer",
        type: "event"
      }, {
        inputs: [{
          internalType: "address",
          name: "owner",
          type: "address"
        }, {
          internalType: "address",
          name: "spender",
          type: "address"
        }],
        name: "allowance",
        outputs: [{
          internalType: "uint256",
          name: "",
          type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
      }, {
        inputs: [{
          internalType: "address",
          name: "spender",
          type: "address"
        }, {
          internalType: "uint256",
          name: "value",
          type: "uint256"
        }],
        name: "approve",
        outputs: [{
          internalType: "bool",
          name: "",
          type: "bool"
        }],
        stateMutability: "nonpayable",
        type: "function"
      }, {
        inputs: [{
          internalType: "address",
          name: "account",
          type: "address"
        }],
        name: "balanceOf",
        outputs: [{
          internalType: "uint256",
          name: "",
          type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
      }, {
        inputs: [],
        name: "decimals",
        outputs: [{
          internalType: "uint8",
          name: "",
          type: "uint8"
        }],
        stateMutability: "view",
        type: "function"
      }, {
        inputs: [],
        name: "name",
        outputs: [{
          internalType: "string",
          name: "",
          type: "string"
        }],
        stateMutability: "view",
        type: "function"
      }, {
        inputs: [],
        name: "symbol",
        outputs: [{
          internalType: "string",
          name: "",
          type: "string"
        }],
        stateMutability: "view",
        type: "function"
      }, {
        inputs: [],
        name: "totalSupply",
        outputs: [{
          internalType: "uint256",
          name: "",
          type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
      }, {
        inputs: [{
          internalType: "address",
          name: "to",
          type: "address"
        }, {
          internalType: "uint256",
          name: "value",
          type: "uint256"
        }],
        name: "transfer",
        outputs: [{
          internalType: "bool",
          name: "",
          type: "bool"
        }],
        stateMutability: "nonpayable",
        type: "function"
      }, {
        inputs: [{
          internalType: "address",
          name: "from",
          type: "address"
        }, {
          internalType: "address",
          name: "to",
          type: "address"
        }, {
          internalType: "uint256",
          name: "value",
          type: "uint256"
        }],
        name: "transferFrom",
        outputs: [{
          internalType: "bool",
          name: "",
          type: "bool"
        }],
        stateMutability: "nonpayable",
        type: "function"
      }];
    function getAbi(J) {
      if ("moby-sale" === J)
        ;
      else if ("moby-staking" === J)
        return ec;
      else if ("moby-token" === J)
        return ed;
      return el.default
    }
    function getContractAddress(J) {
      if ("moby-sale" === J)
        ;
      else if ("moby-staking" === J)
        return "0x4b6f83bed0AA7278Cf01b2A62ec28Af3b48Ac699";
      else if ("moby-token" === J)
        return "0x40a7dF3dF8b56147B781353D379cB960120211D7";
      return "0x628245ecedb180e4ccbe31a3c05e19b6bcbd1f8e"
    }
  },
  49288: function (J, et, eo) {
    "use strict";
    function getBlockExplorers(J) {
      switch (J) {
        case 1:
        default:
          return "https://etherscan.io";
        case 195:
          return "https://www.okx.com/explorer/x1-test";
        case 11155111:
          return "https://sepolia.etherscan.io";
        case 5:
          return "https://goerli.etherscan.io"
      }
    }
    eo.d(et, {
      Z: function () {
        return getBlockExplorers
      }
    })
  },
  15871: function (J, et, eo) {
    "use strict";
    let { default: el } = eo(56377);
    et.Z = function (J, et) {
      var eo;
      let ec = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : el
        , ed = null == ec ? void 0 : ec.find(et => (null == et ? void 0 : et.name) === J)
        , eh = null == ed ? void 0 : ed.outputs
        , ep = null == eh ? void 0 : null === (eo = eh.map) || void 0 === eo ? void 0 : eo.call(eh, (J, et) => null == J ? void 0 : J.name);
      if (!(null == ep ? void 0 : ep[0]) || "object" != typeof et)
        return et;
      if ((null == ep ? void 0 : ep.length) > 0) {
        let J = ep.reduce((J, eo, el) => (J[eo] = null == et ? void 0 : et[el],
          J), {});
        return J
      }
    }
  },
  34183: function (J, et, eo) {
    "use strict";
    var el = eo(31686);
    et.Z = function (J) {
      if ((null == J ? void 0 : J.abi) && (null == J ? void 0 : J.message)) {
        var et, eo, ec;
        let ed = null == J ? void 0 : J.message
          , eh = null == J ? void 0 : null === (et = J.abi) || void 0 === et ? void 0 : et.filter((J, et) => (null == J ? void 0 : J.type) === "error");
        for (let J = 0; J < (null == eh ? void 0 : eh.length); J++)
          if (ed.includes(null === (eo = eh[J]) || void 0 === eo ? void 0 : eo.name))
            return (0,
              el.Mq)(null === (ec = eh[J]) || void 0 === ec ? void 0 : ec.name)
      }
      return (null == J ? void 0 : J.shortMessage) ? (null == J ? void 0 : J.shortMessage) === "Connector not connected." ? "Wallet not connected" : null == J ? void 0 : J.shortMessage : (null == J ? void 0 : J.details) ? null == J ? void 0 : J.details : (null == J ? void 0 : J.message) ? null == J ? void 0 : J.message : "Somthing went wrong with our system. Please try again!"
    }
  },
  36635: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      Z: function () {
        return validateHash
      }
    });
    var el = eo(33639)
      , ec = eo(95946)
      , ed = eo(6073);
    let eh = {
      "0x0": "reverted",
      "0x1": "success"
    };
    function formatTransactionReceipt(J) {
      return {
        ...J,
        blockNumber: J.blockNumber ? BigInt(J.blockNumber) : null,
        contractAddress: J.contractAddress ? J.contractAddress : null,
        cumulativeGasUsed: J.cumulativeGasUsed ? BigInt(J.cumulativeGasUsed) : null,
        effectiveGasPrice: J.effectiveGasPrice ? BigInt(J.effectiveGasPrice) : null,
        gasUsed: J.gasUsed ? BigInt(J.gasUsed) : null,
        logs: J.logs ? J.logs.map(J => (function (J, { args: et, eventName: eo } = {}) {
          return {
            ...J,
            blockHash: J.blockHash ? J.blockHash : null,
            blockNumber: J.blockNumber ? BigInt(J.blockNumber) : null,
            logIndex: J.logIndex ? Number(J.logIndex) : null,
            transactionHash: J.transactionHash ? J.transactionHash : null,
            transactionIndex: J.transactionIndex ? Number(J.transactionIndex) : null,
            ...eo ? {
              args: et,
              eventName: eo
            } : {}
          }
        }
        )(J)) : null,
        to: J.to ? J.to : null,
        transactionIndex: J.transactionIndex ? (0,
          ec.ly)(J.transactionIndex) : null,
        status: J.status ? eh[J.status] : null,
        type: J.type ? ed.c8[J.type] || J.type : null
      }
    }
    async function getTransactionReceipt(J, { hash: et }) {
      let eo = await J.request({
        method: "eth_getTransactionReceipt",
        params: [et]
      });
      if (!eo)
        throw new el.Yb({
          hash: et
        });
      let ec = J.chain?.formatters?.transactionReceipt?.format || formatTransactionReceipt;
      return ec(eo)
    }
    var ep = eo(81946);
    async function getTransactionReceipt_getTransactionReceipt(J, et) {
      let { chainId: eo, ...el } = et
        , ec = J.getClient({
          chainId: eo
        })
        , ed = (0,
          ep.s)(ec, getTransactionReceipt, "getTransactionReceipt");
      return ed(el)
    }
    var ef = eo(43572);
    function validateHash(J, et) {
      let { tx: eo } = J
        , { onSuccess: el = () => { }
          , onError: ec = () => { }
          , onCommon: ed = () => { }
        } = et
        , eh = Number(1e3);
      "string" == typeof eo && eo.length >= 60 ? function callValidate() {
        getTransactionReceipt_getTransactionReceipt(ef.wagmiConfig, {
          hash: eo
        }).then(J => {
          if ((null == J ? void 0 : J.status) === "success")
            try {
              el()
            } catch (J) {
              ec()
            }
          else
            ec();
          ed()
        }
        ).catch(J => {
          setTimeout(callValidate, eh)
        }
        )
      }() : (ec(),
        ed())
    }
  },
  43186: function (J, et, eo) {
    "use strict";
    var el = eo(85893)
      , ec = eo(25675)
      , ed = eo.n(ec);
    eo(67294);
    var eh = eo(88039)
      , ep = eo(86394);
    et.Z = J => {
      let { children: et, className: eo, classNameRoot: ec, onClick: ef = () => { }
        , iconLeft: em, iconRight: eg, loading: ey, disabled: eb, primary: ew, ...e_ } = J;
      return (0,
        el.jsxs)(eh.zx, {
          variant: "raised",
          className: (0,
            ep.cn)("relative", {
              "flat-border": ew
            }, ec),
          onClick: ef,
          disabled: eb || ey,
          primary: ew,
          ...e_,
          children: [(0,
            el.jsxs)("div", {
              className: (0,
                ep.cn)("text-[14px] flex items-center gap-[2px] px-[6px] py-[6px]", eo, {
                  "opacity-0 select-none pointer-events-none": ey
                }),
              children: [em && (0,
                el.jsx)(ed(), {
                  src: em,
                  className: (0,
                    ep.cn)("object-contain object-center", {
                      "opacity-40 drop-shadow-[1px_1px_0_white]": eb
                    }),
                  width: 12,
                  height: 12,
                  alt: "icon-left"
                }), et, eg && (0,
                  el.jsx)(ed(), {
                    src: eg,
                    className: (0,
                      ep.cn)("object-contain object-center", {
                        "opacity-40 drop-shadow-[1px_1px_0_white]": eb
                      }),
                    width: 12,
                    height: 12,
                    alt: "icon-right"
                  })]
            }), ey && (0,
              el.jsx)("div", {
                className: "absolute top-0 left-0 right-0 bottom-0 w-full h-full flex items-center justify-center",
                children: (0,
                  el.jsx)(eh.t3, {
                    size: 20
                  })
              })]
        })
    }
  },
  77177: function (J, et, eo) {
    "use strict";
    var el = eo(85893);
    eo(67294);
    var ec = eo(86394);
    et.Z = J => {
      let { className: et, children: eo } = J;
      return (0,
        el.jsx)("div", {
          className: (0,
            ec.cn)("border border-solid border-b-[#fff] border-r-[#fff] border-l-[#808080] border-t-[#808080] bg-white shadow-frame-inside", et),
          children: eo
        })
    }
  },
  16919: function (J, et, eo) {
    "use strict";
    var el = eo(85893)
      , ec = eo(25675)
      , ed = eo.n(ec);
    eo(67294);
    var eh = eo(44194)
      , ep = eo(86394);
    et.Z = J => {
      let { icon: et, text: eo, id: ec, width: ef = 136, onDoubleClick: em = () => { }
        , isHint: eg = !1 } = J
        , { openWindow: ey } = (0,
          eh.Z)();
      return (0,
        el.jsxs)("button", {
          type: "button",
          className: (0,
            ep.cn)("flex flex-col items-center winicon bg-transparent", {
              "opacity-60 !cursor-default !pointer-events-none hin-winicon": eg
            }),
          style: {
            width: ef
          },
          onDoubleClick: () => {
            eg || (ec && ey(ec),
              em())
          }
          ,
          onTouchStart: () => {
            eg || (ec && ey(ec),
              em())
          }
          ,
          children: [(0,
            el.jsx)(ed(), {
              src: et || "/imgs/svgs/disc-drive.svg",
              width: 48,
              height: 48,
              alt: "win-icon",
              className: "winicon-img"
            }), (0,
              el.jsx)("p", {
                className: "mt-[6px] text-[14px] text-center leading-[16px] tracking-[2%] winicon-text font-[400]",
                children: eo
              })]
        })
    }
  },
  84465: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      n: function () {
        return ed
      }
    });
    var el = eo(85893)
      , ec = eo(67294);
    let ed = (0,
      ec.createContext)();
    et.Z = J => {
      let { children: et } = J
        , [eo, eh] = (0,
          ec.useState)({})
        , [ep, ef] = (0,
          ec.useState)({});
      return (0,
        el.jsx)(ed.Provider, {
          value: {
            manageFolder: eo,
            setManageFolder: eh,
            currentFolder: ep,
            setCurrentFolder: ef
          },
          children: et
        })
    }
  },
  45651: function (J, et, eo) {
    "use strict";
    let el, ec;
    eo.d(et, {
      X: function () {
        return ik
      },
      Z: function () {
        return ManageWindowContext_ManageWindowProvider
      }
    });
    var ed, eh, ep, ef, em, eg, ey, eb, ew = eo(85893), e_ = eo(75374), ex = eo(67294), eE = eo.t(ex, 2), eC = eo(99711), eS = eo(25675), ek = eo.n(eS), eT = eo(88039), eA = eo(86394), eP = eo(44194), common_WindowApplication = J => {
      let { children: et, title: eo, id: el, height: ec = "auto", ...ed } = J
        , eh = (0,
          ex.useRef)()
        , ep = (0,
          ex.useRef)()
        , [ef, em] = (0,
          ex.useState)(!1)
        , { listApp: eg, getData: ey, closeWindow: eb, minimizeWindow: e_, focusWindow: eE, fullscreenWindow: eC, focus: eS } = (0,
          eP.Z)()
        , { icon: eR } = [...eg].filter(J => J.id === el)[0]
        , { open: eI, minimize: eO, fullscreen: eN } = ey(el);
      return ((0,
        ex.useEffect)(() => {
          em(!0)
        }
          , []),
        (0,
          ex.useEffect)(() => {
            let J = !1;
            function mousedown() {
              J = !0
            }
            function mouseup() {
              J = !1
            }
            function mousemove(et) {
              let eo, el, ec;
              if (J) {
                null == et.pageX && null != et.clientX && (el = (eo = et.target && et.target.ownerDocument || document).documentElement,
                  ec = eo.body,
                  et.pageX = et.clientX + (el && el.scrollLeft || ec && ec.scrollLeft || 0) - (el && el.clientLeft || ec && ec.clientLeft || 0),
                  et.pageY = et.clientY + (el && el.scrollTop || ec && ec.scrollTop || 0) - (el && el.clientTop || ec && ec.clientTop || 0));
                let J = (0,
                  eA.Lj)(ep.current.style.left) + et.movementX
                  , ed = (0,
                    eA.Lj)(ep.current.style.top) + et.movementY;
                ep.current.style.left = "".concat(J, "px"),
                  ep.current.style.top = "".concat(ed, "px")
              }
            }
            return (null == eh ? void 0 : eh.current) && !eN && (eh.current.addEventListener("mousedown", mousedown),
              eh.current.addEventListener("mouseup", mouseup),
              document.addEventListener("mousemove", mousemove)),
              () => {
                eh.current && (eh.current.removeEventListener("mousedown", mousedown),
                  eh.current.removeEventListener("mouseup", mouseup),
                  document.removeEventListener("mousemove", mousemove))
              }
          }
            , [ef, eI, eN]),
        eI && ef) ? (0,
          ew.jsx)("div", {
            ref: ep,
            className: (0,
              eA.cn)("absolute z-50 w-max h-max -translate-x-[50%] -translate-y-[50%]", {
                "z-[100]": eS === el,
                "!top-0 !left-0 !translate-x-0 !translate-y-0": eN,
                "scale-0 !-top-[100%] !-left-[100%]": eO
              }),
            style: {
              left: window.innerWidth / 2,
              top: window.innerHeight / 2
            },
            onClick: () => {
              eO || eE(el)
            }
            ,
            children: (0,
              ew.jsxs)(eT.Rz, {
                className: (0,
                  eA.cn)("min-w-[448px] w-max  !flex flex-col", {
                    "!w-screen !h-screen !top-0 !left-0": eN,
                    "!max-h-[96vh] !max-w-[96vw]": !eN
                  }),
                style: {
                  height: ec
                },
                ...ed,
                children: [(0,
                  ew.jsx)(eT.ib, {
                    className: (0,
                      eA.cn)("!h-max cursor-move select-none", {
                        "cursor-default": eN
                      }),
                    ref: eh,
                    active: eS === el,
                    children: (0,
                      ew.jsxs)("div", {
                        className: "flex items-center gap-[8px] text-[12px] tracking-[0.24px] font-[400] w-full pl-[8px] pr-[2px] py-[4px]",
                        children: [(0,
                          ew.jsx)(ek(), {
                            src: eR,
                            alt: "",
                            width: 19,
                            height: 15,
                            className: "w-[19px] h-auto"
                          }), (0,
                            ew.jsx)("span", {
                              className: "text-white flex-1",
                              children: eo
                            }), (0,
                              ew.jsxs)("div", {
                                className: "flex items-center",
                                children: [(0,
                                  ew.jsx)(eT.zx, {
                                    className: "!px-0 !py-0 !w-[24px] !h-[24px]",
                                    square: !0,
                                    onClick: J => {
                                      J.preventDefault(),
                                        J.stopPropagation(),
                                        e_(el)
                                    }
                                    ,
                                    children: (0,
                                      ew.jsx)(ek(), {
                                        src: "/imgs/svgs/minimize.svg",
                                        alt: "",
                                        width: 12,
                                        height: 12,
                                        className: "w-[12px] h-[12px]"
                                      })
                                  }), (0,
                                    ew.jsx)(eT.zx, {
                                      className: "!px-0 !py-0 !w-[24px] !h-[24px]",
                                      square: !0,
                                      onClick: () => {
                                        eC(el)
                                      }
                                      ,
                                      children: (0,
                                        ew.jsx)(ek(), {
                                          src: "/imgs/svgs/maximize.svg",
                                          alt: "",
                                          width: 12,
                                          height: 12,
                                          className: "w-[12px] h-[12px]"
                                        })
                                    }), (0,
                                      ew.jsx)(eT.zx, {
                                        className: "!px-0 !py-0 !w-[24px] !h-[24px]",
                                        square: !0,
                                        onClick: () => {
                                          eb(el)
                                        }
                                        ,
                                        children: (0,
                                          ew.jsx)(ek(), {
                                            src: "/imgs/svgs/close.svg",
                                            alt: "",
                                            width: 12,
                                            height: 12,
                                            className: "w-[12px] h-[12px]"
                                          })
                                      })]
                              })]
                      })
                  }), (0,
                    ew.jsx)(eT.GH, {
                      className: "!p-0 flex-1 flex overflow-hidden",
                      children: et
                    })]
              })
          }) : (0,
            ew.jsx)(ew.Fragment, {})
    }
      , eR = eo(84465), FolderContext_useFolder = J => {
        var et;
        let { manageFolder: eo, setManageFolder: el } = (0,
          ex.useContext)(eR.n)
          , ec = null !== (et = null == eo ? void 0 : eo[J]) && void 0 !== et ? et : {
            currentFolderID: "",
            list: []
          };
        return {
          setFolderList: function (et, ed) {
            if (el) {
              let eh = {
                ...ec,
                currentFolderID: ed,
                list: et
              };
              el({
                ...null != eo ? eo : {},
                [J]: eh
              })
            }
          },
          window: ec
        }
      }
      , FolderContext_useRouterFolder = J => {
        var et;
        let { manageFolder: eo, setManageFolder: el } = (0,
          ex.useContext)(eR.n)
          , { window: ec } = FolderContext_useFolder(J)
          , [ed, eh] = (0,
            ex.useState)("C:\\")
          , getCurrentFolderID = J => {
            var et;
            let eo = null == J ? void 0 : null === (et = J.split) || void 0 === et ? void 0 : et.call(J, "/")
              , el = "";
            if ((null == eo ? void 0 : eo.length) > 0)
              for (let J = (null == eo ? void 0 : eo.length) - 1; J >= 0; J -= 1) {
                eo[J] && (el = eo[J]);
                break
              }
            return el
          }
          , findParentElements = function (J, et) {
            let eo = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : []
              , el = J.find(J => J.id === et);
            return el && (eo.push(el),
              el.parent) ? findParentElements(J, el.parent, eo) : eo
          }
          , getPathname = J => {
            let et = getCurrentFolderID(J)
              , eo = findParentElements(null == ec ? void 0 : ec.list, et, [])
              , el = "C:";
            if ((null == eo ? void 0 : eo.length) > 0)
              for (let J = (null == eo ? void 0 : eo.length) - 1; J >= 0; J -= 1) {
                var ed, eh;
                (null === (ed = eo[J]) || void 0 === ed ? void 0 : ed.name) && (el += "\\".concat(null === (eh = eo[J]) || void 0 === eh ? void 0 : eh.name))
              }
            return el
          }
          , push = et => {
            let ed = getCurrentFolderID(et)
              , eh = getPathname(et);
            el({
              ...null != eo ? eo : {},
              [J]: {
                ...ec,
                currentFolderID: ed,
                pathname: eh
              }
            })
          }
          ;
        return (0,
          ex.useEffect)(() => {
            eh(getPathname(null == ec ? void 0 : ec.currentFolderID))
          }
            , [null == ec ? void 0 : ec.currentFolderID, null == ec ? void 0 : null === (et = ec.list) || void 0 === et ? void 0 : et.length]),
        {
          push,
          pathname: ed,
          currentFolderID: null == ec ? void 0 : ec.currentFolderID,
          back: () => {
            var J, et;
            let eo = null == ec ? void 0 : null === (et = ec.list) || void 0 === et ? void 0 : null === (J = et.find) || void 0 === J ? void 0 : J.call(et, J => (null == J ? void 0 : J.id) === (null == ec ? void 0 : ec.currentFolderID));
            (null == eo ? void 0 : eo.parent) && push(null == eo ? void 0 : eo.parent)
          }
        }
      }
      , FolderContext_FolderWrap = J => {
        let { windowID: et, list: eo = [], initFolderID: el = "" } = J
          , { setFolderList: ec } = FolderContext_useFolder(et)
          , { currentFolderID: ed } = FolderContext_useRouterFolder(et)
          , [eh, ep] = (0,
            ex.useState)();
        return (0,
          ex.useEffect)(() => {
            ec(eo, el)
          }
            , [null == eo ? void 0 : eo.length]),
          (0,
            ex.useEffect)(() => {
              if (ed)
                ep(ed);
              else if (el)
                ep(el);
              else {
                let J = eo.find(J => (null == J ? void 0 : J.parent) === "");
                ep(null == J ? void 0 : J.id)
              }
            }
              , [ed]),
          (0,
            ew.jsx)(ew.Fragment, {
              children: null == eo ? void 0 : eo.map((J, eo) => (0,
                ew.jsx)(ex.Fragment, {
                  children: (null == J ? void 0 : J.id) === eh && ex.cloneElement((null == J ? void 0 : J.component) || (0,
                    ew.jsx)("div", {}), {
                    ...J,
                    component: void 0,
                    windowID: et
                  })
                }, eo))
            })
      }
      , eI = eo(16919), Folder_DashboardAlphaChest = J => {
        let { windowID: et } = J
          , { push: eo } = FolderContext_useRouterFolder(et);
        return (0,
          ew.jsxs)("div", {
            children: [(0,
              ew.jsxs)(eT.RQ, {
                variant: "field",
                className: " px-[16px] py-[20px] min-h-[351px]",
                children: [(0,
                  ew.jsx)("h6", {
                    className: "text-[20px]",
                    children: "Choose a project"
                  }), (0,
                    ew.jsx)("div", {
                      className: "grid grid-cols-5 gap-[8px] mt-[16px]",
                      children: (0,
                        ew.jsx)(eI.Z, {
                          icon: "/imgs/beoble.png",
                          text: "Beoble",
                          width: 80,
                          onDoubleClick: () => {
                            eo("/beoble")
                          }
                        }, "beoble")
                    })]
              }), (0,
                ew.jsxs)("div", {
                  className: "w-full flex items-center",
                  children: [(0,
                    ew.jsx)(eT.RQ, {
                      variant: "well",
                      className: "flex-1 self-stretch p-[4px] pb-[2px]",
                      children: "1 project(s)"
                    }), (0,
                      ew.jsx)(eT.RQ, {
                        variant: "well",
                        className: "flex-1 self-stretch !flex justify-end items-end",
                        children: (0,
                          ew.jsx)(ek(), {
                            src: "/imgs/svgs/size-grip.svg",
                            width: 13,
                            height: 13,
                            className: "object-contain",
                            alt: "Size grip"
                          })
                      })]
                })]
          })
      }
      , eO = eo(43186), eN = eo(31686), AlphaChest_UserTickets = () => {
        let { openWindow: J, focusWindow: et } = (0,
          eP.Z)()
          , { address: eo } = (0,
            eC.m)();
        return (0,
          ew.jsx)("div", {
            className: "mx-[7px] my-[2px] flex items-center gap-[4px]",
            children: (0,
              ew.jsx)("div", {
                className: "w-full border-solid border-2 border-l-[#808080] border-t-[#808080] border-r-[#FFF] border-b-[#FFF]",
                children: (0,
                  ew.jsxs)("div", {
                    className: "p-[10px] text-[12px] leading-[18px] border-solid border-2 border-l-[#FFF] border-t-[#FFF] border-r-[#808080] border-b-[#808080]",
                    children: [(0,
                      ew.jsx)("p", {
                        className: "text-[#808080]",
                        children: "Your wallet address"
                      }), (0,
                        ew.jsx)("p", {
                          className: "text-black",
                          children: (0,
                            eN.sC)(eo)
                        })]
                  })
              })
          })
      }
      , eM = eo(96110), eD = eo(30381), ej = eo.n(eD), eL = eo(44537), e$ = eo(83055);
    function _objectWithoutPropertiesLoose(J, et) {
      if (null == J)
        return {};
      var eo, el, ec = {}, ed = Object.keys(J);
      for (el = 0; el < ed.length; el++)
        eo = ed[el],
          et.indexOf(eo) >= 0 || (ec[eo] = J[eo]);
      return ec
    }
    function extends_extends() {
      return (extends_extends = Object.assign ? Object.assign.bind() : function (J) {
        for (var et = 1; et < arguments.length; et++) {
          var eo = arguments[et];
          for (var el in eo)
            Object.prototype.hasOwnProperty.call(eo, el) && (J[el] = eo[el])
        }
        return J
      }
      ).apply(this, arguments)
    }
    var eB = eo(87462)
      , eF = eo(71068)
      , eU = function () {
        function StyleSheet(J) {
          var et = this;
          this._insertTag = function (J) {
            var eo;
            eo = 0 === et.tags.length ? et.insertionPoint ? et.insertionPoint.nextSibling : et.prepend ? et.container.firstChild : et.before : et.tags[et.tags.length - 1].nextSibling,
              et.container.insertBefore(J, eo),
              et.tags.push(J)
          }
            ,
            this.isSpeedy = void 0 === J.speedy || J.speedy,
            this.tags = [],
            this.ctr = 0,
            this.nonce = J.nonce,
            this.key = J.key,
            this.container = J.container,
            this.prepend = J.prepend,
            this.insertionPoint = J.insertionPoint,
            this.before = null
        }
        var J = StyleSheet.prototype;
        return J.hydrate = function (J) {
          J.forEach(this._insertTag)
        }
          ,
          J.insert = function (J) {
            if (this.ctr % (this.isSpeedy ? 65e3 : 1) == 0) {
              var et;
              this._insertTag(((et = document.createElement("style")).setAttribute("data-emotion", this.key),
                void 0 !== this.nonce && et.setAttribute("nonce", this.nonce),
                et.appendChild(document.createTextNode("")),
                et.setAttribute("data-s", ""),
                et))
            }
            var eo = this.tags[this.tags.length - 1];
            if (this.isSpeedy) {
              var el = function (J) {
                if (J.sheet)
                  return J.sheet;
                for (var et = 0; et < document.styleSheets.length; et++)
                  if (document.styleSheets[et].ownerNode === J)
                    return document.styleSheets[et]
              }(eo);
              try {
                el.insertRule(J, el.cssRules.length)
              } catch (J) { }
            } else
              eo.appendChild(document.createTextNode(J));
            this.ctr++
          }
          ,
          J.flush = function () {
            this.tags.forEach(function (J) {
              return J.parentNode && J.parentNode.removeChild(J)
            }),
              this.tags = [],
              this.ctr = 0
          }
          ,
          StyleSheet
      }()
      , ez = Math.abs
      , eH = String.fromCharCode
      , eV = Object.assign;
    function Utility_replace(J, et, eo) {
      return J.replace(et, eo)
    }
    function indexof(J, et) {
      return J.indexOf(et)
    }
    function Utility_charat(J, et) {
      return 0 | J.charCodeAt(et)
    }
    function Utility_substr(J, et, eo) {
      return J.slice(et, eo)
    }
    function Utility_strlen(J) {
      return J.length
    }
    function Utility_append(J, et) {
      return et.push(J),
        J
    }
    var eW = 1
      , eZ = 1
      , eG = 0
      , eY = 0
      , eK = 0
      , eJ = "";
    function node(J, et, eo, el, ec, ed, eh) {
      return {
        value: J,
        root: et,
        parent: eo,
        type: el,
        props: ec,
        children: ed,
        line: eW,
        column: eZ,
        length: eh,
        return: ""
      }
    }
    function Tokenizer_copy(J, et) {
      return eV(node("", null, null, "", null, null, 0), J, {
        length: -J.length
      }, et)
    }
    function next() {
      return eK = eY < eG ? Utility_charat(eJ, eY++) : 0,
        eZ++,
        10 === eK && (eZ = 1,
          eW++),
        eK
    }
    function peek() {
      return Utility_charat(eJ, eY)
    }
    function token(J) {
      switch (J) {
        case 0:
        case 9:
        case 10:
        case 13:
        case 32:
          return 5;
        case 33:
        case 43:
        case 44:
        case 47:
        case 62:
        case 64:
        case 126:
        case 59:
        case 123:
        case 125:
          return 4;
        case 58:
          return 3;
        case 34:
        case 39:
        case 40:
        case 91:
          return 2;
        case 41:
        case 93:
          return 1
      }
      return 0
    }
    function alloc(J) {
      return eW = eZ = 1,
        eG = Utility_strlen(eJ = J),
        eY = 0,
        []
    }
    function delimit(J) {
      var et, eo;
      return (et = eY - 1,
        eo = function delimiter(J) {
          for (; next();)
            switch (eK) {
              case J:
                return eY;
              case 34:
              case 39:
                34 !== J && 39 !== J && delimiter(eK);
                break;
              case 40:
                41 === J && delimiter(J);
                break;
              case 92:
                next()
            }
          return eY
        }(91 === J ? J + 2 : 40 === J ? J + 1 : J),
        Utility_substr(eJ, et, eo)).trim()
    }
    var eQ = "-ms-"
      , eX = "-moz-"
      , e0 = "-webkit-"
      , e1 = "comm"
      , e2 = "rule"
      , e3 = "decl"
      , e5 = "@keyframes";
    function Serializer_serialize(J, et) {
      for (var eo = "", el = J.length, ec = 0; ec < el; ec++)
        eo += et(J[ec], ec, J, et) || "";
      return eo
    }
    function stringify(J, et, eo, el) {
      switch (J.type) {
        case "@layer":
          if (J.children.length)
            break;
        case "@import":
        case e3:
          return J.return = J.return || J.value;
        case e1:
          return "";
        case e5:
          return J.return = J.value + "{" + Serializer_serialize(J.children, el) + "}";
        case e2:
          J.value = J.props.join(",")
      }
      return Utility_strlen(eo = Serializer_serialize(J.children, el)) ? J.return = J.value + "{" + eo + "}" : ""
    }
    function ruleset(J, et, eo, el, ec, ed, eh, ep, ef, em, eg) {
      for (var ey = ec - 1, eb = 0 === ec ? ed : [""], ew = eb.length, e_ = 0, ex = 0, eE = 0; e_ < el; ++e_)
        for (var eC = 0, eS = Utility_substr(J, ey + 1, ey = ez(ex = eh[e_])), ek = J; eC < ew; ++eC)
          (ek = (ex > 0 ? eb[eC] + " " + eS : Utility_replace(eS, /&\f/g, eb[eC])).trim()) && (ef[eE++] = ek);
      return node(J, et, eo, 0 === ec ? e2 : ep, ef, em, eg)
    }
    function declaration(J, et, eo, el) {
      return node(J, et, eo, e3, Utility_substr(J, 0, el), Utility_substr(J, el + 1, -1), el)
    }
    var identifierWithPointTracking = function (J, et, eo) {
      for (var el = 0, ec = 0; el = ec,
        ec = peek(),
        38 === el && 12 === ec && (et[eo] = 1),
        !token(ec);)
        next();
      return Utility_substr(eJ, J, eY)
    }
      , toRules = function (J, et) {
        var eo = -1
          , el = 44;
        do
          switch (token(el)) {
            case 0:
              38 === el && 12 === peek() && (et[eo] = 1),
                J[eo] += identifierWithPointTracking(eY - 1, et, eo);
              break;
            case 2:
              J[eo] += delimit(el);
              break;
            case 4:
              if (44 === el) {
                J[++eo] = 58 === peek() ? "&\f" : "",
                  et[eo] = J[eo].length;
                break
              }
            default:
              J[eo] += eH(el)
          }
        while (el = next());
        return J
      }
      , getRules = function (J, et) {
        var eo;
        return eo = toRules(alloc(J), et),
          eJ = "",
          eo
      }
      , e6 = new WeakMap
      , compat = function (J) {
        if ("rule" === J.type && J.parent && !(J.length < 1)) {
          for (var et = J.value, eo = J.parent, el = J.column === eo.column && J.line === eo.line; "rule" !== eo.type;)
            if (!(eo = eo.parent))
              return;
          if ((1 !== J.props.length || 58 === et.charCodeAt(0) || e6.get(eo)) && !el) {
            e6.set(J, !0);
            for (var ec = [], ed = getRules(et, ec), eh = eo.props, ep = 0, ef = 0; ep < ed.length; ep++)
              for (var em = 0; em < eh.length; em++,
                ef++)
                J.props[ef] = ec[ep] ? ed[ep].replace(/&\f/g, eh[em]) : eh[em] + " " + ed[ep]
          }
        }
      }
      , removeLabel = function (J) {
        if ("decl" === J.type) {
          var et = J.value;
          108 === et.charCodeAt(0) && 98 === et.charCodeAt(2) && (J.return = "",
            J.value = "")
        }
      }
      , e4 = [function (J, et, eo, el) {
        if (J.length > -1 && !J.return)
          switch (J.type) {
            case e3:
              J.return = function emotion_cache_browser_esm_prefix(J, et) {
                switch (45 ^ Utility_charat(J, 0) ? (((et << 2 ^ Utility_charat(J, 0)) << 2 ^ Utility_charat(J, 1)) << 2 ^ Utility_charat(J, 2)) << 2 ^ Utility_charat(J, 3) : 0) {
                  case 5103:
                    return e0 + "print-" + J + J;
                  case 5737:
                  case 4201:
                  case 3177:
                  case 3433:
                  case 1641:
                  case 4457:
                  case 2921:
                  case 5572:
                  case 6356:
                  case 5844:
                  case 3191:
                  case 6645:
                  case 3005:
                  case 6391:
                  case 5879:
                  case 5623:
                  case 6135:
                  case 4599:
                  case 4855:
                  case 4215:
                  case 6389:
                  case 5109:
                  case 5365:
                  case 5621:
                  case 3829:
                    return e0 + J + J;
                  case 5349:
                  case 4246:
                  case 4810:
                  case 6968:
                  case 2756:
                    return e0 + J + eX + J + eQ + J + J;
                  case 6828:
                  case 4268:
                    return e0 + J + eQ + J + J;
                  case 6165:
                    return e0 + J + eQ + "flex-" + J + J;
                  case 5187:
                    return e0 + J + Utility_replace(J, /(\w+).+(:[^]+)/, e0 + "box-$1$2" + eQ + "flex-$1$2") + J;
                  case 5443:
                    return e0 + J + eQ + "flex-item-" + Utility_replace(J, /flex-|-self/, "") + J;
                  case 4675:
                    return e0 + J + eQ + "flex-line-pack" + Utility_replace(J, /align-content|flex-|-self/, "") + J;
                  case 5548:
                    return e0 + J + eQ + Utility_replace(J, "shrink", "negative") + J;
                  case 5292:
                    return e0 + J + eQ + Utility_replace(J, "basis", "preferred-size") + J;
                  case 6060:
                    return e0 + "box-" + Utility_replace(J, "-grow", "") + e0 + J + eQ + Utility_replace(J, "grow", "positive") + J;
                  case 4554:
                    return e0 + Utility_replace(J, /([^-])(transform)/g, "$1" + e0 + "$2") + J;
                  case 6187:
                    return Utility_replace(Utility_replace(Utility_replace(J, /(zoom-|grab)/, e0 + "$1"), /(image-set)/, e0 + "$1"), J, "") + J;
                  case 5495:
                  case 3959:
                    return Utility_replace(J, /(image-set\([^]*)/, e0 + "$1$`$1");
                  case 4968:
                    return Utility_replace(Utility_replace(J, /(.+:)(flex-)?(.*)/, e0 + "box-pack:$3" + eQ + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + e0 + J + J;
                  case 4095:
                  case 3583:
                  case 4068:
                  case 2532:
                    return Utility_replace(J, /(.+)-inline(.+)/, e0 + "$1$2") + J;
                  case 8116:
                  case 7059:
                  case 5753:
                  case 5535:
                  case 5445:
                  case 5701:
                  case 4933:
                  case 4677:
                  case 5533:
                  case 5789:
                  case 5021:
                  case 4765:
                    if (Utility_strlen(J) - 1 - et > 6)
                      switch (Utility_charat(J, et + 1)) {
                        case 109:
                          if (45 !== Utility_charat(J, et + 4))
                            break;
                        case 102:
                          return Utility_replace(J, /(.+:)(.+)-([^]+)/, "$1" + e0 + "$2-$3$1" + eX + (108 == Utility_charat(J, et + 3) ? "$3" : "$2-$3")) + J;
                        case 115:
                          return ~indexof(J, "stretch") ? emotion_cache_browser_esm_prefix(Utility_replace(J, "stretch", "fill-available"), et) + J : J
                      }
                    break;
                  case 4949:
                    if (115 !== Utility_charat(J, et + 1))
                      break;
                  case 6444:
                    switch (Utility_charat(J, Utility_strlen(J) - 3 - (~indexof(J, "!important") && 10))) {
                      case 107:
                        return Utility_replace(J, ":", ":" + e0) + J;
                      case 101:
                        return Utility_replace(J, /(.+:)([^;!]+)(;|!.+)?/, "$1" + e0 + (45 === Utility_charat(J, 14) ? "inline-" : "") + "box$3$1" + e0 + "$2$3$1" + eQ + "$2box$3") + J
                    }
                    break;
                  case 5936:
                    switch (Utility_charat(J, et + 11)) {
                      case 114:
                        return e0 + J + eQ + Utility_replace(J, /[svh]\w+-[tblr]{2}/, "tb") + J;
                      case 108:
                        return e0 + J + eQ + Utility_replace(J, /[svh]\w+-[tblr]{2}/, "tb-rl") + J;
                      case 45:
                        return e0 + J + eQ + Utility_replace(J, /[svh]\w+-[tblr]{2}/, "lr") + J
                    }
                    return e0 + J + eQ + J + J
                }
                return J
              }(J.value, J.length);
              break;
            case e5:
              return Serializer_serialize([Tokenizer_copy(J, {
                value: Utility_replace(J.value, "@", "@" + e0)
              })], el);
            case e2:
              if (J.length)
                return J.props.map(function (et) {
                  var eo;
                  switch (eo = et,
                  (eo = /(::plac\w+|:read-\w+)/.exec(eo)) ? eo[0] : eo) {
                    case ":read-only":
                    case ":read-write":
                      return Serializer_serialize([Tokenizer_copy(J, {
                        props: [Utility_replace(et, /:(read-\w+)/, ":" + eX + "$1")]
                      })], el);
                    case "::placeholder":
                      return Serializer_serialize([Tokenizer_copy(J, {
                        props: [Utility_replace(et, /:(plac\w+)/, ":" + e0 + "input-$1")]
                      }), Tokenizer_copy(J, {
                        props: [Utility_replace(et, /:(plac\w+)/, ":" + eX + "$1")]
                      }), Tokenizer_copy(J, {
                        props: [Utility_replace(et, /:(plac\w+)/, eQ + "input-$1")]
                      })], el)
                  }
                  return ""
                }).join("")
          }
      }
      ]
      , e8 = !!eE.useInsertionEffect && eE.useInsertionEffect
      , e7 = e8 || function (J) {
        return J()
      }
      ;
    e8 || ex.useLayoutEffect;
    var e9 = ex.createContext("undefined" != typeof HTMLElement ? function (J) {
      var et, eo, el, ec, ed, eh = J.key;
      if ("css" === eh) {
        var ep = document.querySelectorAll("style[data-emotion]:not([data-s])");
        Array.prototype.forEach.call(ep, function (J) {
          -1 !== J.getAttribute("data-emotion").indexOf(" ") && (document.head.appendChild(J),
            J.setAttribute("data-s", ""))
        })
      }
      var ef = J.stylisPlugins || e4
        , em = {}
        , eg = [];
      ec = J.container || document.head,
        Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="' + eh + ' "]'), function (J) {
          for (var et = J.getAttribute("data-emotion").split(" "), eo = 1; eo < et.length; eo++)
            em[et[eo]] = !0;
          eg.push(J)
        });
      var ey = (eo = (et = [compat, removeLabel].concat(ef, [stringify, (el = function (J) {
        ed.insert(J)
      }
        ,
        function (J) {
          !J.root && (J = J.return) && el(J)
        }
      )])).length,
        function (J, el, ec, ed) {
          for (var eh = "", ep = 0; ep < eo; ep++)
            eh += et[ep](J, el, ec, ed) || "";
          return eh
        }
      )
        , stylis = function (J) {
          var et, eo;
          return Serializer_serialize((eo = function parse(J, et, eo, el, ec, ed, eh, ep, ef) {
            for (var em, eg = 0, ey = 0, eb = eh, ew = 0, e_ = 0, ex = 0, eE = 1, eC = 1, eS = 1, ek = 0, eT = "", eA = ec, eP = ed, eR = el, eI = eT; eC;)
              switch (ex = ek,
              ek = next()) {
                case 40:
                  if (108 != ex && 58 == Utility_charat(eI, eb - 1)) {
                    -1 != indexof(eI += Utility_replace(delimit(ek), "&", "&\f"), "&\f") && (eS = -1);
                    break
                  }
                case 34:
                case 39:
                case 91:
                  eI += delimit(ek);
                  break;
                case 9:
                case 10:
                case 13:
                case 32:
                  eI += function (J) {
                    for (; eK = peek();)
                      if (eK < 33)
                        next();
                      else
                        break;
                    return token(J) > 2 || token(eK) > 3 ? "" : " "
                  }(ex);
                  break;
                case 92:
                  eI += function (J, et) {
                    for (var eo; --et && next() && !(eK < 48) && !(eK > 102) && (!(eK > 57) || !(eK < 65)) && (!(eK > 70) || !(eK < 97));)
                      ;
                    return eo = eY + (et < 6 && 32 == peek() && 32 == next()),
                      Utility_substr(eJ, J, eo)
                  }(eY - 1, 7);
                  continue;
                case 47:
                  switch (peek()) {
                    case 42:
                    case 47:
                      Utility_append(node(em = function (J, et) {
                        for (; next();)
                          if (J + eK === 57)
                            break;
                          else if (J + eK === 84 && 47 === peek())
                            break;
                        return "/*" + Utility_substr(eJ, et, eY - 1) + "*" + eH(47 === J ? J : next())
                      }(next(), eY), et, eo, e1, eH(eK), Utility_substr(em, 2, -2), 0), ef);
                      break;
                    default:
                      eI += "/"
                  }
                  break;
                case 123 * eE:
                  ep[eg++] = Utility_strlen(eI) * eS;
                case 125 * eE:
                case 59:
                case 0:
                  switch (ek) {
                    case 0:
                    case 125:
                      eC = 0;
                    case 59 + ey:
                      -1 == eS && (eI = Utility_replace(eI, /\f/g, "")),
                        e_ > 0 && Utility_strlen(eI) - eb && Utility_append(e_ > 32 ? declaration(eI + ";", el, eo, eb - 1) : declaration(Utility_replace(eI, " ", "") + ";", el, eo, eb - 2), ef);
                      break;
                    case 59:
                      eI += ";";
                    default:
                      if (Utility_append(eR = ruleset(eI, et, eo, eg, ey, ec, ep, eT, eA = [], eP = [], eb), ed),
                        123 === ek) {
                        if (0 === ey)
                          parse(eI, et, eR, eR, eA, ed, eb, ep, eP);
                        else
                          switch (99 === ew && 110 === Utility_charat(eI, 3) ? 100 : ew) {
                            case 100:
                            case 108:
                            case 109:
                            case 115:
                              parse(J, eR, eR, el && Utility_append(ruleset(J, eR, eR, 0, 0, ec, ep, eT, ec, eA = [], eb), eP), ec, eP, eb, ep, el ? eA : eP);
                              break;
                            default:
                              parse(eI, eR, eR, eR, [""], eP, 0, ep, eP)
                          }
                      }
                  }
                  eg = ey = e_ = 0,
                    eE = eS = 1,
                    eT = eI = "",
                    eb = eh;
                  break;
                case 58:
                  eb = 1 + Utility_strlen(eI),
                    e_ = ex;
                default:
                  if (eE < 1) {
                    if (123 == ek)
                      --eE;
                    else if (125 == ek && 0 == eE++ && 125 == (eK = eY > 0 ? Utility_charat(eJ, --eY) : 0,
                      eZ--,
                      10 === eK && (eZ = 1,
                        eW--),
                      eK))
                      continue
                  }
                  switch (eI += eH(ek),
                  ek * eE) {
                    case 38:
                      eS = ey > 0 ? 1 : (eI += "\f",
                        -1);
                      break;
                    case 44:
                      ep[eg++] = (Utility_strlen(eI) - 1) * eS,
                        eS = 1;
                      break;
                    case 64:
                      45 === peek() && (eI += delimit(next())),
                        ew = peek(),
                        ey = eb = Utility_strlen(eT = eI += function (J) {
                          for (; !token(peek());)
                            next();
                          return Utility_substr(eJ, J, eY)
                        }(eY)),
                        ek++;
                      break;
                    case 45:
                      45 === ex && 2 == Utility_strlen(eI) && (eE = 0)
                  }
              }
            return ed
          }("", null, null, null, [""], et = alloc(et = J), 0, [0], et),
            eJ = "",
            eo), ey)
        }
        , eb = {
          key: eh,
          sheet: new eU({
            key: eh,
            container: ec,
            nonce: J.nonce,
            speedy: J.speedy,
            prepend: J.prepend,
            insertionPoint: J.insertionPoint
          }),
          nonce: J.nonce,
          inserted: em,
          registered: {},
          insert: function (J, et, eo, el) {
            ed = eo,
              stylis(J ? J + "{" + et.styles + "}" : et.styles),
              el && (eb.inserted[et.name] = !0)
          }
        };
      return eb.sheet.hydrate(eg),
        eb
    }({
      key: "css"
    }) : null);
    e9.Provider;
    var tn = ex.createContext({})
      , emotion_utils_browser_esm_registerStyles = function (J, et, eo) {
        var el = J.key + "-" + et.name;
        !1 === eo && void 0 === J.registered[el] && (J.registered[el] = et.styles)
      }
      , emotion_utils_browser_esm_insertStyles = function (J, et, eo) {
        emotion_utils_browser_esm_registerStyles(J, et, eo);
        var el = J.key + "-" + et.name;
        if (void 0 === J.inserted[et.name]) {
          var ec = et;
          do
            J.insert(et === ec ? "." + el : "", ec, J.sheet, !0),
              ec = ec.next;
          while (void 0 !== ec)
        }
      }
      , to = {
        animationIterationCount: 1,
        aspectRatio: 1,
        borderImageOutset: 1,
        borderImageSlice: 1,
        borderImageWidth: 1,
        boxFlex: 1,
        boxFlexGroup: 1,
        boxOrdinalGroup: 1,
        columnCount: 1,
        columns: 1,
        flex: 1,
        flexGrow: 1,
        flexPositive: 1,
        flexShrink: 1,
        flexNegative: 1,
        flexOrder: 1,
        gridRow: 1,
        gridRowEnd: 1,
        gridRowSpan: 1,
        gridRowStart: 1,
        gridColumn: 1,
        gridColumnEnd: 1,
        gridColumnSpan: 1,
        gridColumnStart: 1,
        msGridRow: 1,
        msGridRowSpan: 1,
        msGridColumn: 1,
        msGridColumnSpan: 1,
        fontWeight: 1,
        lineHeight: 1,
        opacity: 1,
        order: 1,
        orphans: 1,
        tabSize: 1,
        widows: 1,
        zIndex: 1,
        zoom: 1,
        WebkitLineClamp: 1,
        fillOpacity: 1,
        floodOpacity: 1,
        stopOpacity: 1,
        strokeDasharray: 1,
        strokeDashoffset: 1,
        strokeMiterlimit: 1,
        strokeOpacity: 1,
        strokeWidth: 1
      }
      , ta = eo(45042)
      , tl = /[A-Z]|^ms/g
      , tc = /_EMO_([^_]+?)_([^]*?)_EMO_/g
      , emotion_serialize_browser_esm_isCustomProperty = function (J) {
        return 45 === J.charCodeAt(1)
      }
      , emotion_serialize_browser_esm_isProcessableValue = function (J) {
        return null != J && "boolean" != typeof J
      }
      , td = (0,
        ta.Z)(function (J) {
          return emotion_serialize_browser_esm_isCustomProperty(J) ? J : J.replace(tl, "-$&").toLowerCase()
        })
      , emotion_serialize_browser_esm_processStyleValue = function (J, et) {
        switch (J) {
          case "animation":
          case "animationName":
            if ("string" == typeof et)
              return et.replace(tc, function (J, et, eo) {
                return ey = {
                  name: et,
                  styles: eo,
                  next: ey
                },
                  et
              })
        }
        return 1 === to[J] || emotion_serialize_browser_esm_isCustomProperty(J) || "number" != typeof et || 0 === et ? et : et + "px"
      };
    function emotion_serialize_browser_esm_handleInterpolation(J, et, eo) {
      if (null == eo)
        return "";
      if (void 0 !== eo.__emotion_styles)
        return eo;
      switch (typeof eo) {
        case "boolean":
          return "";
        case "object":
          if (1 === eo.anim)
            return ey = {
              name: eo.name,
              styles: eo.styles,
              next: ey
            },
              eo.name;
          if (void 0 !== eo.styles) {
            var el = eo.next;
            if (void 0 !== el)
              for (; void 0 !== el;)
                ey = {
                  name: el.name,
                  styles: el.styles,
                  next: ey
                },
                  el = el.next;
            return eo.styles + ";"
          }
          return function (J, et, eo) {
            var el = "";
            if (Array.isArray(eo))
              for (var ec = 0; ec < eo.length; ec++)
                el += emotion_serialize_browser_esm_handleInterpolation(J, et, eo[ec]) + ";";
            else
              for (var ed in eo) {
                var eh = eo[ed];
                if ("object" != typeof eh)
                  null != et && void 0 !== et[eh] ? el += ed + "{" + et[eh] + "}" : emotion_serialize_browser_esm_isProcessableValue(eh) && (el += td(ed) + ":" + emotion_serialize_browser_esm_processStyleValue(ed, eh) + ";");
                else if (Array.isArray(eh) && "string" == typeof eh[0] && (null == et || void 0 === et[eh[0]]))
                  for (var ep = 0; ep < eh.length; ep++)
                    emotion_serialize_browser_esm_isProcessableValue(eh[ep]) && (el += td(ed) + ":" + emotion_serialize_browser_esm_processStyleValue(ed, eh[ep]) + ";");
                else {
                  var ef = emotion_serialize_browser_esm_handleInterpolation(J, et, eh);
                  switch (ed) {
                    case "animation":
                    case "animationName":
                      el += td(ed) + ":" + ef + ";";
                      break;
                    default:
                      el += ed + "{" + ef + "}"
                  }
                }
              }
            return el
          }(J, et, eo);
        case "function":
          if (void 0 !== J) {
            var ec = ey
              , ed = eo(J);
            return ey = ec,
              emotion_serialize_browser_esm_handleInterpolation(J, et, ed)
          }
      }
      if (null == et)
        return eo;
      var eh = et[eo];
      return void 0 !== eh ? eh : eo
    }
    var th = /label:\s*([^\s;\n{]+)\s*(;|$)/g
      , dist_emotion_serialize_browser_esm_serializeStyles = function (J, et, eo) {
        if (1 === J.length && "object" == typeof J[0] && null !== J[0] && void 0 !== J[0].styles)
          return J[0];
        var el, ec = !0, ed = "";
        ey = void 0;
        var eh = J[0];
        null == eh || void 0 === eh.raw ? (ec = !1,
          ed += emotion_serialize_browser_esm_handleInterpolation(eo, et, eh)) : ed += eh[0];
        for (var ep = 1; ep < J.length; ep++)
          ed += emotion_serialize_browser_esm_handleInterpolation(eo, et, J[ep]),
            ec && (ed += eh[ep]);
        th.lastIndex = 0;
        for (var ef = ""; null !== (el = th.exec(ed));)
          ef += "-" + el[1];
        return {
          name: function (J) {
            for (var et, eo = 0, el = 0, ec = J.length; ec >= 4; ++el,
              ec -= 4)
              et = (65535 & (et = 255 & J.charCodeAt(el) | (255 & J.charCodeAt(++el)) << 8 | (255 & J.charCodeAt(++el)) << 16 | (255 & J.charCodeAt(++el)) << 24)) * 1540483477 + ((et >>> 16) * 59797 << 16),
                et ^= et >>> 24,
                eo = (65535 & et) * 1540483477 + ((et >>> 16) * 59797 << 16) ^ (65535 & eo) * 1540483477 + ((eo >>> 16) * 59797 << 16);
            switch (ec) {
              case 3:
                eo ^= (255 & J.charCodeAt(el + 2)) << 16;
              case 2:
                eo ^= (255 & J.charCodeAt(el + 1)) << 8;
              case 1:
                eo ^= 255 & J.charCodeAt(el),
                  eo = (65535 & eo) * 1540483477 + ((eo >>> 16) * 59797 << 16)
            }
            return eo ^= eo >>> 13,
              (((eo = (65535 & eo) * 1540483477 + ((eo >>> 16) * 59797 << 16)) ^ eo >>> 15) >>> 0).toString(36)
          }(ed) + ef,
          styles: ed,
          next: ey
        }
      }
      , tp = eF.Z
      , testOmitPropsOnComponent = function (J) {
        return "theme" !== J
      }
      , getDefaultShouldForwardProp = function (J) {
        return "string" == typeof J && J.charCodeAt(0) > 96 ? tp : testOmitPropsOnComponent
      }
      , composeShouldForwardProps = function (J, et, eo) {
        var el;
        if (et) {
          var ec = et.shouldForwardProp;
          el = J.__emotion_forwardProp && ec ? function (et) {
            return J.__emotion_forwardProp(et) && ec(et)
          }
            : ec
        }
        return "function" != typeof el && eo && (el = J.__emotion_forwardProp),
          el
      }
      , emotion_styled_base_browser_esm_Insertion = function (J) {
        var et = J.cache
          , eo = J.serialized
          , el = J.isStringTag;
        return emotion_utils_browser_esm_registerStyles(et, eo, el),
          e7(function () {
            return emotion_utils_browser_esm_insertStyles(et, eo, el)
          }),
          null
      }
      , tf = (function createStyled(J, et) {
        var eo, el, ec = J.__emotion_real === J, ed = ec && J.__emotion_base || J;
        void 0 !== et && (eo = et.label,
          el = et.target);
        var eh = composeShouldForwardProps(J, et, ec)
          , ep = eh || getDefaultShouldForwardProp(ed)
          , ef = !ep("as");
        return function () {
          var em, eg = arguments, ey = ec && void 0 !== J.__emotion_styles ? J.__emotion_styles.slice(0) : [];
          if (void 0 !== eo && ey.push("label:" + eo + ";"),
            null == eg[0] || void 0 === eg[0].raw)
            ey.push.apply(ey, eg);
          else {
            ey.push(eg[0][0]);
            for (var eb = eg.length, ew = 1; ew < eb; ew++)
              ey.push(eg[ew], eg[0][ew])
          }
          var e_ = (em = function (J, et, eo) {
            var ec, em, eg, eb = ef && J.as || ed, ew = "", e_ = [], eE = J;
            if (null == J.theme) {
              for (var eC in eE = {},
                J)
                eE[eC] = J[eC];
              eE.theme = ex.useContext(tn)
            }
            "string" == typeof J.className ? (ec = et.registered,
              em = J.className,
              eg = "",
              em.split(" ").forEach(function (J) {
                void 0 !== ec[J] ? e_.push(ec[J] + ";") : eg += J + " "
              }),
              ew = eg) : null != J.className && (ew = J.className + " ");
            var eS = dist_emotion_serialize_browser_esm_serializeStyles(ey.concat(e_), et.registered, eE);
            ew += et.key + "-" + eS.name,
              void 0 !== el && (ew += " " + el);
            var ek = ef && void 0 === eh ? getDefaultShouldForwardProp(eb) : ep
              , eT = {};
            for (var eA in J)
              (!ef || "as" !== eA) && ek(eA) && (eT[eA] = J[eA]);
            return eT.className = ew,
              eT.ref = eo,
              ex.createElement(ex.Fragment, null, ex.createElement(emotion_styled_base_browser_esm_Insertion, {
                cache: et,
                serialized: eS,
                isStringTag: "string" == typeof eb
              }), ex.createElement(eb, eT))
          }
            ,
            (0,
              ex.forwardRef)(function (J, et) {
                return em(J, (0,
                  ex.useContext)(e9), et)
              }));
          return e_.displayName = void 0 !== eo ? eo : "Styled(" + ("string" == typeof ed ? ed : ed.displayName || ed.name || "Component") + ")",
            e_.defaultProps = J.defaultProps,
            e_.__emotion_real = e_,
            e_.__emotion_base = ed,
            e_.__emotion_styles = ey,
            e_.__emotion_forwardProp = eh,
            Object.defineProperty(e_, "toString", {
              value: function () {
                return "." + el
              }
            }),
            e_.withComponent = function (J, eo) {
              return createStyled(J, (0,
                eB.Z)({}, et, eo, {
                  shouldForwardProp: composeShouldForwardProps(e_, eo, !0)
                })).apply(void 0, ey)
            }
            ,
            e_
        }
      }
      ).bind();
    ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"].forEach(function (J) {
      tf[J] = tf(J)
    });
    let internal_processStyles = (J, et) => {
      Array.isArray(J.__emotion_styles) && (J.__emotion_styles = et(J.__emotion_styles))
    }
      ;
    function esm_extends_extends() {
      return (esm_extends_extends = Object.assign ? Object.assign.bind() : function (J) {
        for (var et = 1; et < arguments.length; et++) {
          var eo = arguments[et];
          for (var el in eo)
            Object.prototype.hasOwnProperty.call(eo, el) && (J[el] = eo[el])
        }
        return J
      }
      ).apply(this, arguments)
    }
    function isPlainObject(J) {
      if ("object" != typeof J || null === J)
        return !1;
      let et = Object.getPrototypeOf(J);
      return (null === et || et === Object.prototype || null === Object.getPrototypeOf(et)) && !(Symbol.toStringTag in J) && !(Symbol.iterator in J)
    }
    function deepmerge_deepmerge(J, et, eo = {
      clone: !0
    }) {
      let el = eo.clone ? esm_extends_extends({}, J) : J;
      return isPlainObject(J) && isPlainObject(et) && Object.keys(et).forEach(ec => {
        "__proto__" !== ec && (isPlainObject(et[ec]) && ec in J && isPlainObject(J[ec]) ? el[ec] = deepmerge_deepmerge(J[ec], et[ec], eo) : eo.clone ? el[ec] = isPlainObject(et[ec]) ? function deepClone(J) {
          if (!isPlainObject(J))
            return J;
          let et = {};
          return Object.keys(J).forEach(eo => {
            et[eo] = deepClone(J[eo])
          }
          ),
            et
        }(et[ec]) : et[ec] : el[ec] = et[ec])
      }
      ),
        el
    }
    let tm = ["values", "unit", "step"]
      , sortBreakpointsValues = J => {
        let et = Object.keys(J).map(et => ({
          key: et,
          val: J[et]
        })) || [];
        return et.sort((J, et) => J.val - et.val),
          et.reduce((J, et) => extends_extends({}, J, {
            [et.key]: et.val
          }), {})
      }
      ;
    var tg = {
      borderRadius: 4
    };
    let ty = {
      xs: 0,
      sm: 600,
      md: 900,
      lg: 1200,
      xl: 1536
    }
      , tb = {
        keys: ["xs", "sm", "md", "lg", "xl"],
        up: J => `@media (min-width:${ty[J]}px)`
      };
    function handleBreakpoints(J, et, eo) {
      let el = J.theme || {};
      if (Array.isArray(et)) {
        let J = el.breakpoints || tb;
        return et.reduce((el, ec, ed) => (el[J.up(J.keys[ed])] = eo(et[ed]),
          el), {})
      }
      if ("object" == typeof et) {
        let J = el.breakpoints || tb;
        return Object.keys(et).reduce((el, ec) => {
          if (-1 !== Object.keys(J.values || ty).indexOf(ec)) {
            let ed = J.up(ec);
            el[ed] = eo(et[ec], ec)
          } else
            el[ec] = et[ec];
          return el
        }
          , {})
      }
      let ec = eo(et);
      return ec
    }
    function formatMuiErrorMessage(J) {
      let et = "https://mui.com/production-error/?code=" + J;
      for (let J = 1; J < arguments.length; J += 1)
        et += "&args[]=" + encodeURIComponent(arguments[J]);
      return "Minified MUI error #" + J + "; visit " + et + " for the full message."
    }
    function capitalize(J) {
      if ("string" != typeof J)
        throw Error(formatMuiErrorMessage(7));
      return J.charAt(0).toUpperCase() + J.slice(1)
    }
    function getPath(J, et, eo = !0) {
      if (!et || "string" != typeof et)
        return null;
      if (J && J.vars && eo) {
        let eo = `vars.${et}`.split(".").reduce((J, et) => J && J[et] ? J[et] : null, J);
        if (null != eo)
          return eo
      }
      return et.split(".").reduce((J, et) => J && null != J[et] ? J[et] : null, J)
    }
    function getStyleValue(J, et, eo, el = eo) {
      let ec;
      return ec = "function" == typeof J ? J(eo) : Array.isArray(J) ? J[eo] || el : getPath(J, eo) || el,
        et && (ec = et(ec, el, J)),
        ec
    }
    var esm_style = function (J) {
      let { prop: et, cssProperty: eo = J.prop, themeKey: el, transform: ec } = J
        , fn = J => {
          if (null == J[et])
            return null;
          let ed = J[et]
            , eh = J.theme
            , ep = getPath(eh, el) || {};
          return handleBreakpoints(J, ed, J => {
            let el = getStyleValue(ep, ec, J);
            return (J === el && "string" == typeof J && (el = getStyleValue(ep, ec, `${et}${"default" === J ? "" : capitalize(J)}`, J)),
              !1 === eo) ? el : {
              [eo]: el
            }
          }
          )
        }
        ;
      return fn.propTypes = {},
        fn.filterProps = [et],
        fn
    }
      , esm_merge = function (J, et) {
        return et ? deepmerge_deepmerge(J, et, {
          clone: !1
        }) : J
      };
    let tw = {
      m: "margin",
      p: "padding"
    }
      , t_ = {
        t: "Top",
        r: "Right",
        b: "Bottom",
        l: "Left",
        x: ["Left", "Right"],
        y: ["Top", "Bottom"]
      }
      , tx = {
        marginX: "mx",
        marginY: "my",
        paddingX: "px",
        paddingY: "py"
      }
      , tE = function (J) {
        let et = {};
        return eo => (void 0 === et[eo] && (et[eo] = J(eo)),
          et[eo])
      }(J => {
        if (J.length > 2) {
          if (!tx[J])
            return [J];
          J = tx[J]
        }
        let [et, eo] = J.split("")
          , el = tw[et]
          , ec = t_[eo] || "";
        return Array.isArray(ec) ? ec.map(J => el + J) : [el + ec]
      }
      )
      , tC = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"]
      , tS = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"]
      , tk = [...tC, ...tS];
    function createUnaryUnit(J, et, eo, el) {
      var ec;
      let ed = null != (ec = getPath(J, et, !1)) ? ec : eo;
      return "number" == typeof ed ? J => "string" == typeof J ? J : ed * J : Array.isArray(ed) ? J => "string" == typeof J ? J : ed[J] : "function" == typeof ed ? ed : () => void 0
    }
    function createUnarySpacing(J) {
      return createUnaryUnit(J, "spacing", 8, "spacing")
    }
    function getValue(J, et) {
      if ("string" == typeof et || null == et)
        return et;
      let eo = Math.abs(et)
        , el = J(eo);
      return et >= 0 ? el : "number" == typeof el ? -el : `-${el}`
    }
    function spacing_style(J, et) {
      let eo = createUnarySpacing(J.theme);
      return Object.keys(J).map(el => (function (J, et, eo, el) {
        if (-1 === et.indexOf(eo))
          return null;
        let ec = tE(eo)
          , ed = J[eo];
        return handleBreakpoints(J, ed, J => ec.reduce((et, eo) => (et[eo] = getValue(el, J),
          et), {}))
      }
      )(J, et, el, eo)).reduce(esm_merge, {})
    }
    function margin(J) {
      return spacing_style(J, tC)
    }
    function padding(J) {
      return spacing_style(J, tS)
    }
    function spacing(J) {
      return spacing_style(J, tk)
    }
    margin.propTypes = {},
      margin.filterProps = tC,
      padding.propTypes = {},
      padding.filterProps = tS,
      spacing.propTypes = {},
      spacing.filterProps = tk;
    var esm_compose = function (...J) {
      let et = J.reduce((J, et) => (et.filterProps.forEach(eo => {
        J[eo] = et
      }
      ),
        J), {})
        , fn = J => Object.keys(J).reduce((eo, el) => et[el] ? esm_merge(eo, et[el](J)) : eo, {});
      return fn.propTypes = {},
        fn.filterProps = J.reduce((J, et) => J.concat(et.filterProps), []),
        fn
    };
    function borderTransform(J) {
      return "number" != typeof J ? J : `${J}px solid`
    }
    function createBorderStyle(J, et) {
      return esm_style({
        prop: J,
        themeKey: "borders",
        transform: et
      })
    }
    let tT = createBorderStyle("border", borderTransform)
      , tA = createBorderStyle("borderTop", borderTransform)
      , tP = createBorderStyle("borderRight", borderTransform)
      , tR = createBorderStyle("borderBottom", borderTransform)
      , tI = createBorderStyle("borderLeft", borderTransform)
      , tO = createBorderStyle("borderColor")
      , tN = createBorderStyle("borderTopColor")
      , tM = createBorderStyle("borderRightColor")
      , tD = createBorderStyle("borderBottomColor")
      , tj = createBorderStyle("borderLeftColor")
      , tL = createBorderStyle("outline", borderTransform)
      , t$ = createBorderStyle("outlineColor")
      , borderRadius = J => {
        if (void 0 !== J.borderRadius && null !== J.borderRadius) {
          let et = createUnaryUnit(J.theme, "shape.borderRadius", 4, "borderRadius");
          return handleBreakpoints(J, J.borderRadius, J => ({
            borderRadius: getValue(et, J)
          }))
        }
        return null
      }
      ;
    borderRadius.propTypes = {},
      borderRadius.filterProps = ["borderRadius"],
      esm_compose(tT, tA, tP, tR, tI, tO, tN, tM, tD, tj, borderRadius, tL, t$);
    let gap = J => {
      if (void 0 !== J.gap && null !== J.gap) {
        let et = createUnaryUnit(J.theme, "spacing", 8, "gap");
        return handleBreakpoints(J, J.gap, J => ({
          gap: getValue(et, J)
        }))
      }
      return null
    }
      ;
    gap.propTypes = {},
      gap.filterProps = ["gap"];
    let columnGap = J => {
      if (void 0 !== J.columnGap && null !== J.columnGap) {
        let et = createUnaryUnit(J.theme, "spacing", 8, "columnGap");
        return handleBreakpoints(J, J.columnGap, J => ({
          columnGap: getValue(et, J)
        }))
      }
      return null
    }
      ;
    columnGap.propTypes = {},
      columnGap.filterProps = ["columnGap"];
    let rowGap = J => {
      if (void 0 !== J.rowGap && null !== J.rowGap) {
        let et = createUnaryUnit(J.theme, "spacing", 8, "rowGap");
        return handleBreakpoints(J, J.rowGap, J => ({
          rowGap: getValue(et, J)
        }))
      }
      return null
    }
      ;
    rowGap.propTypes = {},
      rowGap.filterProps = ["rowGap"];
    let tB = esm_style({
      prop: "gridColumn"
    })
      , tF = esm_style({
        prop: "gridRow"
      })
      , tU = esm_style({
        prop: "gridAutoFlow"
      })
      , tz = esm_style({
        prop: "gridAutoColumns"
      })
      , tH = esm_style({
        prop: "gridAutoRows"
      })
      , tV = esm_style({
        prop: "gridTemplateColumns"
      })
      , tW = esm_style({
        prop: "gridTemplateRows"
      })
      , tq = esm_style({
        prop: "gridTemplateAreas"
      })
      , tZ = esm_style({
        prop: "gridArea"
      });
    function paletteTransform(J, et) {
      return "grey" === et ? et : J
    }
    esm_compose(gap, columnGap, rowGap, tB, tF, tU, tz, tH, tV, tW, tq, tZ);
    let tG = esm_style({
      prop: "color",
      themeKey: "palette",
      transform: paletteTransform
    })
      , tY = esm_style({
        prop: "bgcolor",
        cssProperty: "backgroundColor",
        themeKey: "palette",
        transform: paletteTransform
      })
      , tK = esm_style({
        prop: "backgroundColor",
        themeKey: "palette",
        transform: paletteTransform
      });
    function sizingTransform(J) {
      return J <= 1 && 0 !== J ? `${100 * J}%` : J
    }
    esm_compose(tG, tY, tK);
    let tJ = esm_style({
      prop: "width",
      transform: sizingTransform
    })
      , maxWidth = J => void 0 !== J.maxWidth && null !== J.maxWidth ? handleBreakpoints(J, J.maxWidth, et => {
        var eo, el;
        let ec = (null == (eo = J.theme) || null == (eo = eo.breakpoints) || null == (eo = eo.values) ? void 0 : eo[et]) || ty[et];
        return ec ? (null == (el = J.theme) || null == (el = el.breakpoints) ? void 0 : el.unit) !== "px" ? {
          maxWidth: `${ec}${J.theme.breakpoints.unit}`
        } : {
          maxWidth: ec
        } : {
          maxWidth: sizingTransform(et)
        }
      }
      ) : null;
    maxWidth.filterProps = ["maxWidth"];
    let tQ = esm_style({
      prop: "minWidth",
      transform: sizingTransform
    })
      , tX = esm_style({
        prop: "height",
        transform: sizingTransform
      })
      , t0 = esm_style({
        prop: "maxHeight",
        transform: sizingTransform
      })
      , t1 = esm_style({
        prop: "minHeight",
        transform: sizingTransform
      });
    esm_style({
      prop: "size",
      cssProperty: "width",
      transform: sizingTransform
    }),
      esm_style({
        prop: "size",
        cssProperty: "height",
        transform: sizingTransform
      });
    let t2 = esm_style({
      prop: "boxSizing"
    });
    esm_compose(tJ, maxWidth, tQ, tX, t0, t1, t2);
    var t3 = {
      border: {
        themeKey: "borders",
        transform: borderTransform
      },
      borderTop: {
        themeKey: "borders",
        transform: borderTransform
      },
      borderRight: {
        themeKey: "borders",
        transform: borderTransform
      },
      borderBottom: {
        themeKey: "borders",
        transform: borderTransform
      },
      borderLeft: {
        themeKey: "borders",
        transform: borderTransform
      },
      borderColor: {
        themeKey: "palette"
      },
      borderTopColor: {
        themeKey: "palette"
      },
      borderRightColor: {
        themeKey: "palette"
      },
      borderBottomColor: {
        themeKey: "palette"
      },
      borderLeftColor: {
        themeKey: "palette"
      },
      outline: {
        themeKey: "borders",
        transform: borderTransform
      },
      outlineColor: {
        themeKey: "palette"
      },
      borderRadius: {
        themeKey: "shape.borderRadius",
        style: borderRadius
      },
      color: {
        themeKey: "palette",
        transform: paletteTransform
      },
      bgcolor: {
        themeKey: "palette",
        cssProperty: "backgroundColor",
        transform: paletteTransform
      },
      backgroundColor: {
        themeKey: "palette",
        transform: paletteTransform
      },
      p: {
        style: padding
      },
      pt: {
        style: padding
      },
      pr: {
        style: padding
      },
      pb: {
        style: padding
      },
      pl: {
        style: padding
      },
      px: {
        style: padding
      },
      py: {
        style: padding
      },
      padding: {
        style: padding
      },
      paddingTop: {
        style: padding
      },
      paddingRight: {
        style: padding
      },
      paddingBottom: {
        style: padding
      },
      paddingLeft: {
        style: padding
      },
      paddingX: {
        style: padding
      },
      paddingY: {
        style: padding
      },
      paddingInline: {
        style: padding
      },
      paddingInlineStart: {
        style: padding
      },
      paddingInlineEnd: {
        style: padding
      },
      paddingBlock: {
        style: padding
      },
      paddingBlockStart: {
        style: padding
      },
      paddingBlockEnd: {
        style: padding
      },
      m: {
        style: margin
      },
      mt: {
        style: margin
      },
      mr: {
        style: margin
      },
      mb: {
        style: margin
      },
      ml: {
        style: margin
      },
      mx: {
        style: margin
      },
      my: {
        style: margin
      },
      margin: {
        style: margin
      },
      marginTop: {
        style: margin
      },
      marginRight: {
        style: margin
      },
      marginBottom: {
        style: margin
      },
      marginLeft: {
        style: margin
      },
      marginX: {
        style: margin
      },
      marginY: {
        style: margin
      },
      marginInline: {
        style: margin
      },
      marginInlineStart: {
        style: margin
      },
      marginInlineEnd: {
        style: margin
      },
      marginBlock: {
        style: margin
      },
      marginBlockStart: {
        style: margin
      },
      marginBlockEnd: {
        style: margin
      },
      displayPrint: {
        cssProperty: !1,
        transform: J => ({
          "@media print": {
            display: J
          }
        })
      },
      display: {},
      overflow: {},
      textOverflow: {},
      visibility: {},
      whiteSpace: {},
      flexBasis: {},
      flexDirection: {},
      flexWrap: {},
      justifyContent: {},
      alignItems: {},
      alignContent: {},
      order: {},
      flex: {},
      flexGrow: {},
      flexShrink: {},
      alignSelf: {},
      justifyItems: {},
      justifySelf: {},
      gap: {
        style: gap
      },
      rowGap: {
        style: rowGap
      },
      columnGap: {
        style: columnGap
      },
      gridColumn: {},
      gridRow: {},
      gridAutoFlow: {},
      gridAutoColumns: {},
      gridAutoRows: {},
      gridTemplateColumns: {},
      gridTemplateRows: {},
      gridTemplateAreas: {},
      gridArea: {},
      position: {},
      zIndex: {
        themeKey: "zIndex"
      },
      top: {},
      right: {},
      bottom: {},
      left: {},
      boxShadow: {
        themeKey: "shadows"
      },
      width: {
        transform: sizingTransform
      },
      maxWidth: {
        style: maxWidth
      },
      minWidth: {
        transform: sizingTransform
      },
      height: {
        transform: sizingTransform
      },
      maxHeight: {
        transform: sizingTransform
      },
      minHeight: {
        transform: sizingTransform
      },
      boxSizing: {},
      fontFamily: {
        themeKey: "typography"
      },
      fontSize: {
        themeKey: "typography"
      },
      fontStyle: {
        themeKey: "typography"
      },
      fontWeight: {
        themeKey: "typography"
      },
      letterSpacing: {},
      textTransform: {},
      lineHeight: {},
      textAlign: {},
      typography: {
        cssProperty: !1,
        themeKey: "typography"
      }
    };
    let t5 = function () {
      function getThemeValue(J, et, eo, el) {
        let ec = {
          [J]: et,
          theme: eo
        }
          , ed = el[J];
        if (!ed)
          return {
            [J]: et
          };
        let { cssProperty: eh = J, themeKey: ep, transform: ef, style: em } = ed;
        if (null == et)
          return null;
        if ("typography" === ep && "inherit" === et)
          return {
            [J]: et
          };
        let eg = getPath(eo, ep) || {};
        return em ? em(ec) : handleBreakpoints(ec, et, et => {
          let eo = getStyleValue(eg, ef, et);
          return (et === eo && "string" == typeof et && (eo = getStyleValue(eg, ef, `${J}${"default" === et ? "" : capitalize(et)}`, et)),
            !1 === eh) ? eo : {
            [eh]: eo
          }
        }
        )
      }
      return function styleFunctionSx(J) {
        var et;
        let { sx: eo, theme: el = {} } = J || {};
        if (!eo)
          return null;
        let ec = null != (et = el.unstable_sxConfig) ? et : t3;
        function traverse(J) {
          var et;
          let eo = J;
          if ("function" == typeof J)
            eo = J(el);
          else if ("object" != typeof J)
            return J;
          if (!eo)
            return null;
          let ed = function (J = {}) {
            var et;
            let eo = null == (et = J.keys) ? void 0 : et.reduce((et, eo) => {
              let el = J.up(eo);
              return et[el] = {},
                et
            }
              , {});
            return eo || {}
          }(el.breakpoints)
            , eh = Object.keys(ed)
            , ep = ed;
          return Object.keys(eo).forEach(J => {
            var et;
            let ed = "function" == typeof (et = eo[J]) ? et(el) : et;
            if (null != ed) {
              if ("object" == typeof ed) {
                if (ec[J])
                  ep = esm_merge(ep, getThemeValue(J, ed, el, ec));
                else {
                  let et = handleBreakpoints({
                    theme: el
                  }, ed, et => ({
                    [J]: et
                  }));
                  (function (...J) {
                    let et = J.reduce((J, et) => J.concat(Object.keys(et)), [])
                      , eo = new Set(et);
                    return J.every(J => eo.size === Object.keys(J).length)
                  }
                  )(et, ed) ? ep[J] = styleFunctionSx({
                    sx: ed,
                    theme: el
                  }) : ep = esm_merge(ep, et)
                }
              } else
                ep = esm_merge(ep, getThemeValue(J, ed, el, ec))
            }
          }
          ),
            et = ep,
            eh.reduce((J, et) => {
              let eo = J[et]
                , el = !eo || 0 === Object.keys(eo).length;
              return el && delete J[et],
                J
            }
              , et)
        }
        return Array.isArray(eo) ? eo.map(traverse) : traverse(eo)
      }
    }();
    t5.filterProps = ["sx"];
    let t6 = ["breakpoints", "palette", "spacing", "shape"];
    var createTheme_createTheme = function (J = {}, ...et) {
      let { breakpoints: eo = {}, palette: el = {}, spacing: ec, shape: ed = {} } = J
        , eh = _objectWithoutPropertiesLoose(J, t6)
        , ep = function (J) {
          let { values: et = {
            xs: 0,
            sm: 600,
            md: 900,
            lg: 1200,
            xl: 1536
          }, unit: eo = "px", step: el = 5 } = J
            , ec = _objectWithoutPropertiesLoose(J, tm)
            , ed = sortBreakpointsValues(et)
            , eh = Object.keys(ed);
          function up(J) {
            let el = "number" == typeof et[J] ? et[J] : J;
            return `@media (min-width:${el}${eo})`
          }
          function down(J) {
            let ec = "number" == typeof et[J] ? et[J] : J;
            return `@media (max-width:${ec - el / 100}${eo})`
          }
          function between(J, ec) {
            let ed = eh.indexOf(ec);
            return `@media (min-width:${"number" == typeof et[J] ? et[J] : J}${eo}) and (max-width:${(-1 !== ed && "number" == typeof et[eh[ed]] ? et[eh[ed]] : ec) - el / 100}${eo})`
          }
          return extends_extends({
            keys: eh,
            values: ed,
            up,
            down,
            between,
            only: function (J) {
              return eh.indexOf(J) + 1 < eh.length ? between(J, eh[eh.indexOf(J) + 1]) : up(J)
            },
            not: function (J) {
              let et = eh.indexOf(J);
              return 0 === et ? up(eh[1]) : et === eh.length - 1 ? down(eh[et]) : between(J, eh[eh.indexOf(J) + 1]).replace("@media", "@media not all and")
            },
            unit: eo
          }, ec)
        }(eo)
        , ef = function (J = 8) {
          if (J.mui)
            return J;
          let et = createUnarySpacing({
            spacing: J
          })
            , spacing = (...J) => {
              let eo = 0 === J.length ? [1] : J;
              return eo.map(J => {
                let eo = et(J);
                return "number" == typeof eo ? `${eo}px` : eo
              }
              ).join(" ")
            }
            ;
          return spacing.mui = !0,
            spacing
        }(ec)
        , em = deepmerge_deepmerge({
          breakpoints: ep,
          direction: "ltr",
          components: {},
          palette: extends_extends({
            mode: "light"
          }, el),
          spacing: ef,
          shape: extends_extends({}, tg, ed)
        }, eh);
      return (em = et.reduce((J, et) => deepmerge_deepmerge(J, et), em)).unstable_sxConfig = extends_extends({}, t3, null == eh ? void 0 : eh.unstable_sxConfig),
        em.unstable_sx = function (J) {
          return t5({
            sx: J,
            theme: this
          })
        }
        ,
        em
    };
    let t4 = ["variant"];
    function isEmpty(J) {
      return 0 === J.length
    }
    function propsToClassKey(J) {
      let { variant: et } = J
        , eo = _objectWithoutPropertiesLoose(J, t4)
        , el = et || "";
      return Object.keys(eo).sort().forEach(et => {
        "color" === et ? el += isEmpty(el) ? J[et] : capitalize(J[et]) : el += `${isEmpty(el) ? et : capitalize(et)}${capitalize(J[et].toString())}`
      }
      ),
        el
    }
    let t8 = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"]
      , getStyleOverrides = (J, et) => et.components && et.components[J] && et.components[J].styleOverrides ? et.components[J].styleOverrides : null
      , transformVariants = J => {
        let et = 0
          , eo = {};
        return J && J.forEach(J => {
          let el = "";
          "function" == typeof J.props ? (el = `callback${et}`,
            et += 1) : el = propsToClassKey(J.props),
            eo[el] = J.style
        }
        ),
          eo
      }
      , getVariantStyles = (J, et) => {
        let eo = [];
        return et && et.components && et.components[J] && et.components[J].variants && (eo = et.components[J].variants),
          transformVariants(eo)
      }
      , variantsResolver = (J, et, eo) => {
        let { ownerState: el = {} } = J
          , ec = []
          , ed = 0;
        return eo && eo.forEach(eo => {
          let eh = !0;
          if ("function" == typeof eo.props) {
            let et = extends_extends({}, J, el);
            eh = eo.props(et)
          } else
            Object.keys(eo.props).forEach(et => {
              el[et] !== eo.props[et] && J[et] !== eo.props[et] && (eh = !1)
            }
            );
          eh && ("function" == typeof eo.props ? ec.push(et[`callback${ed}`]) : ec.push(et[propsToClassKey(eo.props)])),
            "function" == typeof eo.props && (ed += 1)
        }
        ),
          ec
      }
      , themeVariantsResolver = (J, et, eo, el) => {
        var ec;
        let ed = null == eo || null == (ec = eo.components) || null == (ec = ec[el]) ? void 0 : ec.variants;
        return variantsResolver(J, et, ed)
      }
      ;
    function createStyled_shouldForwardProp(J) {
      return "ownerState" !== J && "theme" !== J && "sx" !== J && "as" !== J
    }
    let t7 = createTheme_createTheme()
      , lowercaseFirstLetter = J => J ? J.charAt(0).toLowerCase() + J.slice(1) : J;
    function resolveTheme({ defaultTheme: J, theme: et, themeId: eo }) {
      return 0 === Object.keys(et).length ? J : et[eo] || et
    }
    let muiStyledFunctionResolver = ({ styledArg: J, props: et, defaultTheme: eo, themeId: el }) => {
      let ec;
      let ed = J(extends_extends({}, et, {
        theme: resolveTheme(extends_extends({}, et, {
          defaultTheme: eo,
          themeId: el
        }))
      }));
      if (ed && ed.variants && (ec = ed.variants,
        delete ed.variants),
        ec) {
        let J = variantsResolver(et, transformVariants(ec), ec);
        return [ed, ...J]
      }
      return ed
    }
      ;
    function helpers_esm_extends_extends() {
      return (helpers_esm_extends_extends = Object.assign ? Object.assign.bind() : function (J) {
        for (var et = 1; et < arguments.length; et++) {
          var eo = arguments[et];
          for (var el in eo)
            Object.prototype.hasOwnProperty.call(eo, el) && (J[el] = eo[el])
        }
        return J
      }
      ).apply(this, arguments)
    }
    function objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(J, et) {
      if (null == J)
        return {};
      var eo, el, ec = {}, ed = Object.keys(J);
      for (el = 0; el < ed.length; el++)
        eo = ed[el],
          et.indexOf(eo) >= 0 || (ec[eo] = J[eo]);
      return ec
    }
    function clampWrapper(J, et = 0, eo = 1) {
      return function (J, et = Number.MIN_SAFE_INTEGER, eo = Number.MAX_SAFE_INTEGER) {
        return Math.max(et, Math.min(J, eo))
      }(J, et, eo)
    }
    function decomposeColor(J) {
      let et;
      if (J.type)
        return J;
      if ("#" === J.charAt(0))
        return decomposeColor(function (J) {
          J = J.slice(1);
          let et = RegExp(`.{1,${J.length >= 6 ? 2 : 1}}`, "g")
            , eo = J.match(et);
          return eo && 1 === eo[0].length && (eo = eo.map(J => J + J)),
            eo ? `rgb${4 === eo.length ? "a" : ""}(${eo.map((J, et) => et < 3 ? parseInt(J, 16) : Math.round(parseInt(J, 16) / 255 * 1e3) / 1e3).join(", ")})` : ""
        }(J));
      let eo = J.indexOf("(")
        , el = J.substring(0, eo);
      if (-1 === ["rgb", "rgba", "hsl", "hsla", "color"].indexOf(el))
        throw Error(formatMuiErrorMessage(9, J));
      let ec = J.substring(eo + 1, J.length - 1);
      if ("color" === el) {
        if (et = (ec = ec.split(" ")).shift(),
          4 === ec.length && "/" === ec[3].charAt(0) && (ec[3] = ec[3].slice(1)),
          -1 === ["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(et))
          throw Error(formatMuiErrorMessage(10, et))
      } else
        ec = ec.split(",");
      return {
        type: el,
        values: ec = ec.map(J => parseFloat(J)),
        colorSpace: et
      }
    }
    function recomposeColor(J) {
      let { type: et, colorSpace: eo } = J
        , { values: el } = J;
      return -1 !== et.indexOf("rgb") ? el = el.map((J, et) => et < 3 ? parseInt(J, 10) : J) : -1 !== et.indexOf("hsl") && (el[1] = `${el[1]}%`,
        el[2] = `${el[2]}%`),
        el = -1 !== et.indexOf("color") ? `${eo} ${el.join(" ")}` : `${el.join(", ")}`,
        `${et}(${el})`
    }
    function getLuminance(J) {
      let et = "hsl" === (J = decomposeColor(J)).type || "hsla" === J.type ? decomposeColor(function (J) {
        J = decomposeColor(J);
        let { values: et } = J
          , eo = et[0]
          , el = et[1] / 100
          , ec = et[2] / 100
          , ed = el * Math.min(ec, 1 - ec)
          , f = (J, et = (J + eo / 30) % 12) => ec - ed * Math.max(Math.min(et - 3, 9 - et, 1), -1)
          , eh = "rgb"
          , ep = [Math.round(255 * f(0)), Math.round(255 * f(8)), Math.round(255 * f(4))];
        return "hsla" === J.type && (eh += "a",
          ep.push(et[3])),
          recomposeColor({
            type: eh,
            values: ep
          })
      }(J)).values : J.values;
      return Number((.2126 * (et = et.map(et => ("color" !== J.type && (et /= 255),
        et <= .03928 ? et / 12.92 : ((et + .055) / 1.055) ** 2.4)))[0] + .7152 * et[1] + .0722 * et[2]).toFixed(3))
    }
    function alpha(J, et) {
      return J = decomposeColor(J),
        et = clampWrapper(et),
        ("rgb" === J.type || "hsl" === J.type) && (J.type += "a"),
        "color" === J.type ? J.values[3] = `/${et}` : J.values[3] = et,
        recomposeColor(J)
    }
    var t9 = {
      black: "#000",
      white: "#fff"
    }
      , ro = {
        50: "#fafafa",
        100: "#f5f5f5",
        200: "#eeeeee",
        300: "#e0e0e0",
        400: "#bdbdbd",
        500: "#9e9e9e",
        600: "#757575",
        700: "#616161",
        800: "#424242",
        900: "#212121",
        A100: "#f5f5f5",
        A200: "#eeeeee",
        A400: "#bdbdbd",
        A700: "#616161"
      }
      , ra = {
        50: "#f3e5f5",
        100: "#e1bee7",
        200: "#ce93d8",
        300: "#ba68c8",
        400: "#ab47bc",
        500: "#9c27b0",
        600: "#8e24aa",
        700: "#7b1fa2",
        800: "#6a1b9a",
        900: "#4a148c",
        A100: "#ea80fc",
        A200: "#e040fb",
        A400: "#d500f9",
        A700: "#aa00ff"
      }
      , rl = {
        50: "#ffebee",
        100: "#ffcdd2",
        200: "#ef9a9a",
        300: "#e57373",
        400: "#ef5350",
        500: "#f44336",
        600: "#e53935",
        700: "#d32f2f",
        800: "#c62828",
        900: "#b71c1c",
        A100: "#ff8a80",
        A200: "#ff5252",
        A400: "#ff1744",
        A700: "#d50000"
      }
      , rc = {
        50: "#fff3e0",
        100: "#ffe0b2",
        200: "#ffcc80",
        300: "#ffb74d",
        400: "#ffa726",
        500: "#ff9800",
        600: "#fb8c00",
        700: "#f57c00",
        800: "#ef6c00",
        900: "#e65100",
        A100: "#ffd180",
        A200: "#ffab40",
        A400: "#ff9100",
        A700: "#ff6d00"
      }
      , rd = {
        50: "#e3f2fd",
        100: "#bbdefb",
        200: "#90caf9",
        300: "#64b5f6",
        400: "#42a5f5",
        500: "#2196f3",
        600: "#1e88e5",
        700: "#1976d2",
        800: "#1565c0",
        900: "#0d47a1",
        A100: "#82b1ff",
        A200: "#448aff",
        A400: "#2979ff",
        A700: "#2962ff"
      }
      , rh = {
        50: "#e1f5fe",
        100: "#b3e5fc",
        200: "#81d4fa",
        300: "#4fc3f7",
        400: "#29b6f6",
        500: "#03a9f4",
        600: "#039be5",
        700: "#0288d1",
        800: "#0277bd",
        900: "#01579b",
        A100: "#80d8ff",
        A200: "#40c4ff",
        A400: "#00b0ff",
        A700: "#0091ea"
      }
      , rp = {
        50: "#e8f5e9",
        100: "#c8e6c9",
        200: "#a5d6a7",
        300: "#81c784",
        400: "#66bb6a",
        500: "#4caf50",
        600: "#43a047",
        700: "#388e3c",
        800: "#2e7d32",
        900: "#1b5e20",
        A100: "#b9f6ca",
        A200: "#69f0ae",
        A400: "#00e676",
        A700: "#00c853"
      };
    let rm = ["mode", "contrastThreshold", "tonalOffset"]
      , rg = {
        text: {
          primary: "rgba(0, 0, 0, 0.87)",
          secondary: "rgba(0, 0, 0, 0.6)",
          disabled: "rgba(0, 0, 0, 0.38)"
        },
        divider: "rgba(0, 0, 0, 0.12)",
        background: {
          paper: t9.white,
          default: t9.white
        },
        action: {
          active: "rgba(0, 0, 0, 0.54)",
          hover: "rgba(0, 0, 0, 0.04)",
          hoverOpacity: .04,
          selected: "rgba(0, 0, 0, 0.08)",
          selectedOpacity: .08,
          disabled: "rgba(0, 0, 0, 0.26)",
          disabledBackground: "rgba(0, 0, 0, 0.12)",
          disabledOpacity: .38,
          focus: "rgba(0, 0, 0, 0.12)",
          focusOpacity: .12,
          activatedOpacity: .12
        }
      }
      , ry = {
        text: {
          primary: t9.white,
          secondary: "rgba(255, 255, 255, 0.7)",
          disabled: "rgba(255, 255, 255, 0.5)",
          icon: "rgba(255, 255, 255, 0.5)"
        },
        divider: "rgba(255, 255, 255, 0.12)",
        background: {
          paper: "#121212",
          default: "#121212"
        },
        action: {
          active: t9.white,
          hover: "rgba(255, 255, 255, 0.08)",
          hoverOpacity: .08,
          selected: "rgba(255, 255, 255, 0.16)",
          selectedOpacity: .16,
          disabled: "rgba(255, 255, 255, 0.3)",
          disabledBackground: "rgba(255, 255, 255, 0.12)",
          disabledOpacity: .38,
          focus: "rgba(255, 255, 255, 0.12)",
          focusOpacity: .12,
          activatedOpacity: .24
        }
      };
    function addLightOrDark(J, et, eo, el) {
      let ec = el.light || el
        , ed = el.dark || 1.5 * el;
      J[et] || (J.hasOwnProperty(eo) ? J[et] = J[eo] : "light" === et ? J.light = function (J, et) {
        if (J = decomposeColor(J),
          et = clampWrapper(et),
          -1 !== J.type.indexOf("hsl"))
          J.values[2] += (100 - J.values[2]) * et;
        else if (-1 !== J.type.indexOf("rgb"))
          for (let eo = 0; eo < 3; eo += 1)
            J.values[eo] += (255 - J.values[eo]) * et;
        else if (-1 !== J.type.indexOf("color"))
          for (let eo = 0; eo < 3; eo += 1)
            J.values[eo] += (1 - J.values[eo]) * et;
        return recomposeColor(J)
      }(J.main, ec) : "dark" === et && (J.dark = function (J, et) {
        if (J = decomposeColor(J),
          et = clampWrapper(et),
          -1 !== J.type.indexOf("hsl"))
          J.values[2] *= 1 - et;
        else if (-1 !== J.type.indexOf("rgb") || -1 !== J.type.indexOf("color"))
          for (let eo = 0; eo < 3; eo += 1)
            J.values[eo] *= 1 - et;
        return recomposeColor(J)
      }(J.main, ed)))
    }
    let rb = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"]
      , rw = {
        textTransform: "uppercase"
      }
      , r_ = '"Roboto", "Helvetica", "Arial", sans-serif';
    function createShadow(...J) {
      return `${J[0]}px ${J[1]}px ${J[2]}px ${J[3]}px rgba(0,0,0,0.2),${J[4]}px ${J[5]}px ${J[6]}px ${J[7]}px rgba(0,0,0,0.14),${J[8]}px ${J[9]}px ${J[10]}px ${J[11]}px rgba(0,0,0,0.12)`
    }
    let rx = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)]
      , rE = ["duration", "easing", "delay"]
      , rC = {
        easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
        easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
        easeIn: "cubic-bezier(0.4, 0, 1, 1)",
        sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
      }
      , rS = {
        shortest: 150,
        shorter: 200,
        short: 250,
        standard: 300,
        complex: 375,
        enteringScreen: 225,
        leavingScreen: 195
      };
    function formatMs(J) {
      return `${Math.round(J)}ms`
    }
    function getAutoHeightDuration(J) {
      if (!J)
        return 0;
      let et = J / 36;
      return Math.round((4 + 15 * et ** .25 + et / 5) * 10)
    }
    var rk = {
      mobileStepper: 1e3,
      fab: 1050,
      speedDial: 1050,
      appBar: 1100,
      drawer: 1200,
      modal: 1300,
      snackbar: 1400,
      tooltip: 1500
    };
    let rT = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"]
      , rA = function (J = {}) {
        var et;
        let { mixins: eo = {}, palette: el = {}, transitions: ec = {}, typography: ed = {} } = J
          , eh = objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(J, rT);
        if (J.vars)
          throw Error(formatMuiErrorMessage(18));
        let ep = function (J) {
          let { mode: et = "light", contrastThreshold: eo = 3, tonalOffset: el = .2 } = J
            , ec = objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(J, rm)
            , ed = J.primary || function (J = "light") {
              return "dark" === J ? {
                main: rd[200],
                light: rd[50],
                dark: rd[400]
              } : {
                main: rd[700],
                light: rd[400],
                dark: rd[800]
              }
            }(et)
            , eh = J.secondary || function (J = "light") {
              return "dark" === J ? {
                main: ra[200],
                light: ra[50],
                dark: ra[400]
              } : {
                main: ra[500],
                light: ra[300],
                dark: ra[700]
              }
            }(et)
            , ep = J.error || function (J = "light") {
              return "dark" === J ? {
                main: rl[500],
                light: rl[300],
                dark: rl[700]
              } : {
                main: rl[700],
                light: rl[400],
                dark: rl[800]
              }
            }(et)
            , ef = J.info || function (J = "light") {
              return "dark" === J ? {
                main: rh[400],
                light: rh[300],
                dark: rh[700]
              } : {
                main: rh[700],
                light: rh[500],
                dark: rh[900]
              }
            }(et)
            , em = J.success || function (J = "light") {
              return "dark" === J ? {
                main: rp[400],
                light: rp[300],
                dark: rp[700]
              } : {
                main: rp[800],
                light: rp[500],
                dark: rp[900]
              }
            }(et)
            , eg = J.warning || function (J = "light") {
              return "dark" === J ? {
                main: rc[400],
                light: rc[300],
                dark: rc[700]
              } : {
                main: "#ed6c02",
                light: rc[500],
                dark: rc[900]
              }
            }(et);
          function getContrastText(J) {
            let et = function (J, et) {
              let eo = getLuminance(J)
                , el = getLuminance(et);
              return (Math.max(eo, el) + .05) / (Math.min(eo, el) + .05)
            }(J, ry.text.primary) >= eo ? ry.text.primary : rg.text.primary;
            return et
          }
          let augmentColor = ({ color: J, name: et, mainShade: eo = 500, lightShade: ec = 300, darkShade: ed = 700 }) => {
            if (!(J = helpers_esm_extends_extends({}, J)).main && J[eo] && (J.main = J[eo]),
              !J.hasOwnProperty("main"))
              throw Error(formatMuiErrorMessage(11, et ? ` (${et})` : "", eo));
            if ("string" != typeof J.main)
              throw Error(formatMuiErrorMessage(12, et ? ` (${et})` : "", JSON.stringify(J.main)));
            return addLightOrDark(J, "light", ec, el),
              addLightOrDark(J, "dark", ed, el),
              J.contrastText || (J.contrastText = getContrastText(J.main)),
              J
          }
            , ey = deepmerge_deepmerge(helpers_esm_extends_extends({
              common: helpers_esm_extends_extends({}, t9),
              mode: et,
              primary: augmentColor({
                color: ed,
                name: "primary"
              }),
              secondary: augmentColor({
                color: eh,
                name: "secondary",
                mainShade: "A400",
                lightShade: "A200",
                darkShade: "A700"
              }),
              error: augmentColor({
                color: ep,
                name: "error"
              }),
              warning: augmentColor({
                color: eg,
                name: "warning"
              }),
              info: augmentColor({
                color: ef,
                name: "info"
              }),
              success: augmentColor({
                color: em,
                name: "success"
              }),
              grey: ro,
              contrastThreshold: eo,
              getContrastText,
              augmentColor,
              tonalOffset: el
            }, {
              dark: ry,
              light: rg
            }[et]), ec);
          return ey
        }(el)
          , ef = createTheme_createTheme(J)
          , em = deepmerge_deepmerge(ef, {
            mixins: (et = ef.breakpoints,
              helpers_esm_extends_extends({
                toolbar: {
                  minHeight: 56,
                  [et.up("xs")]: {
                    "@media (orientation: landscape)": {
                      minHeight: 48
                    }
                  },
                  [et.up("sm")]: {
                    minHeight: 64
                  }
                }
              }, eo)),
            palette: ep,
            shadows: rx.slice(),
            typography: function (J, et) {
              let eo = "function" == typeof et ? et(J) : et
                , { fontFamily: el = r_, fontSize: ec = 14, fontWeightLight: ed = 300, fontWeightRegular: eh = 400, fontWeightMedium: ep = 500, fontWeightBold: ef = 700, htmlFontSize: em = 16, allVariants: eg, pxToRem: ey } = eo
                , eb = objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(eo, rb)
                , ew = ec / 14
                , e_ = ey || (J => `${J / em * ew}rem`)
                , buildVariant = (J, et, eo, ec, ed) => helpers_esm_extends_extends({
                  fontFamily: el,
                  fontWeight: J,
                  fontSize: e_(et),
                  lineHeight: eo
                }, el === r_ ? {
                  letterSpacing: `${Math.round(1e5 * (ec / et)) / 1e5}em`
                } : {}, ed, eg)
                , ex = {
                  h1: buildVariant(ed, 96, 1.167, -1.5),
                  h2: buildVariant(ed, 60, 1.2, -.5),
                  h3: buildVariant(eh, 48, 1.167, 0),
                  h4: buildVariant(eh, 34, 1.235, .25),
                  h5: buildVariant(eh, 24, 1.334, 0),
                  h6: buildVariant(ep, 20, 1.6, .15),
                  subtitle1: buildVariant(eh, 16, 1.75, .15),
                  subtitle2: buildVariant(ep, 14, 1.57, .1),
                  body1: buildVariant(eh, 16, 1.5, .15),
                  body2: buildVariant(eh, 14, 1.43, .15),
                  button: buildVariant(ep, 14, 1.75, .4, rw),
                  caption: buildVariant(eh, 12, 1.66, .4),
                  overline: buildVariant(eh, 12, 2.66, 1, rw),
                  inherit: {
                    fontFamily: "inherit",
                    fontWeight: "inherit",
                    fontSize: "inherit",
                    lineHeight: "inherit",
                    letterSpacing: "inherit"
                  }
                };
              return deepmerge_deepmerge(helpers_esm_extends_extends({
                htmlFontSize: em,
                pxToRem: e_,
                fontFamily: el,
                fontSize: ec,
                fontWeightLight: ed,
                fontWeightRegular: eh,
                fontWeightMedium: ep,
                fontWeightBold: ef
              }, ex), eb, {
                clone: !1
              })
            }(ep, ed),
            transitions: function (J) {
              let et = helpers_esm_extends_extends({}, rC, J.easing)
                , eo = helpers_esm_extends_extends({}, rS, J.duration);
              return helpers_esm_extends_extends({
                getAutoHeightDuration,
                create: (J = ["all"], el = {}) => {
                  let { duration: ec = eo.standard, easing: ed = et.easeInOut, delay: eh = 0 } = el;
                  return objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(el, rE),
                    (Array.isArray(J) ? J : [J]).map(J => `${J} ${"string" == typeof ec ? ec : formatMs(ec)} ${ed} ${"string" == typeof eh ? eh : formatMs(eh)}`).join(",")
                }
              }, J, {
                easing: et,
                duration: eo
              })
            }(ec),
            zIndex: helpers_esm_extends_extends({}, rk),
            applyDarkStyles(J) {
              if (this.vars) {
                let et = this.getColorSchemeSelector("dark").replace(/(\[[^\]]+\])/, ":where($1)");
                return {
                  [et]: J
                }
              }
              return "dark" === this.palette.mode ? J : {}
            }
          });
        return (em = [].reduce((J, et) => deepmerge_deepmerge(J, et), em = deepmerge_deepmerge(em, eh))).unstable_sxConfig = helpers_esm_extends_extends({}, t3, null == eh ? void 0 : eh.unstable_sxConfig),
          em.unstable_sx = function (J) {
            return t5({
              sx: J,
              theme: this
            })
          }
          ,
          em
      }();
    var rP = "$$material";
    let rR = function (J = {}) {
      let { themeId: et, defaultTheme: eo = t7, rootShouldForwardProp: el = createStyled_shouldForwardProp, slotShouldForwardProp: ec = createStyled_shouldForwardProp } = J
        , systemSx = J => t5(extends_extends({}, J, {
          theme: resolveTheme(extends_extends({}, J, {
            defaultTheme: eo,
            themeId: et
          }))
        }));
      return systemSx.__mui_systemSx = !0,
        (J, ed = {}) => {
          var eh;
          let ep;
          internal_processStyles(J, J => J.filter(J => !(null != J && J.__mui_systemSx)));
          let { name: ef, slot: em, skipVariantsResolver: eg, skipSx: ey, overridesResolver: eb = (eh = lowercaseFirstLetter(em)) ? (J, et) => et[eh] : null } = ed
            , ew = _objectWithoutPropertiesLoose(ed, t8)
            , e_ = void 0 !== eg ? eg : em && "Root" !== em && "root" !== em || !1
            , ex = ey || !1
            , eE = createStyled_shouldForwardProp;
          "Root" === em || "root" === em ? eE = el : em ? eE = ec : "string" == typeof J && J.charCodeAt(0) > 96 && (eE = void 0);
          let eC = function (J, et) {
            let eo = tf(J, et);
            return eo
          }(J, extends_extends({
            shouldForwardProp: eE,
            label: ep
          }, ew))
            , muiStyledResolver = (el, ...ec) => {
              let ed = ec ? ec.map(J => {
                if ("function" == typeof J && J.__emotion_real !== J)
                  return el => muiStyledFunctionResolver({
                    styledArg: J,
                    props: el,
                    defaultTheme: eo,
                    themeId: et
                  });
                if (isPlainObject(J)) {
                  let et, eo = J;
                  return J && J.variants && (et = J.variants,
                    delete eo.variants,
                    eo = eo => {
                      let el = J
                        , ec = variantsResolver(eo, transformVariants(et), et);
                      return ec.forEach(J => {
                        el = deepmerge_deepmerge(el, J)
                      }
                      ),
                        el
                    }
                  ),
                    eo
                }
                return J
              }
              ) : []
                , eh = el;
              if (isPlainObject(el)) {
                let J;
                el && el.variants && (J = el.variants,
                  delete eh.variants,
                  eh = et => {
                    let eo = el
                      , ec = variantsResolver(et, transformVariants(J), J);
                    return ec.forEach(J => {
                      eo = deepmerge_deepmerge(eo, J)
                    }
                    ),
                      eo
                  }
                )
              } else
                "function" == typeof el && el.__emotion_real !== el && (eh = J => muiStyledFunctionResolver({
                  styledArg: el,
                  props: J,
                  defaultTheme: eo,
                  themeId: et
                }));
              ef && eb && ed.push(J => {
                let el = resolveTheme(extends_extends({}, J, {
                  defaultTheme: eo,
                  themeId: et
                }))
                  , ec = getStyleOverrides(ef, el);
                if (ec) {
                  let et = {};
                  return Object.entries(ec).forEach(([eo, ec]) => {
                    et[eo] = "function" == typeof ec ? ec(extends_extends({}, J, {
                      theme: el
                    })) : ec
                  }
                  ),
                    eb(J, et)
                }
                return null
              }
              ),
                ef && !e_ && ed.push(J => {
                  let el = resolveTheme(extends_extends({}, J, {
                    defaultTheme: eo,
                    themeId: et
                  }));
                  return themeVariantsResolver(J, getVariantStyles(ef, el), el, ef)
                }
                ),
                ex || ed.push(systemSx);
              let ep = ed.length - ec.length;
              if (Array.isArray(el) && ep > 0) {
                let J = Array(ep).fill("");
                (eh = [...el, ...J]).raw = [...el.raw, ...J]
              }
              let em = eC(eh, ...ed);
              return J.muiName && (em.muiName = J.muiName),
                em
            }
            ;
          return eC.withConfig && (muiStyledResolver.withConfig = eC.withConfig),
            muiStyledResolver
        }
    }({
      themeId: rP,
      defaultTheme: rA,
      rootShouldForwardProp: J => createStyled_shouldForwardProp(J) && "classes" !== J
    });
    var dist_clsx = function () {
      for (var J, et, eo = 0, el = "", ec = arguments.length; eo < ec; eo++)
        (J = arguments[eo]) && (et = function r(J) {
          var et, eo, el = "";
          if ("string" == typeof J || "number" == typeof J)
            el += J;
          else if ("object" == typeof J) {
            if (Array.isArray(J)) {
              var ec = J.length;
              for (et = 0; et < ec; et++)
                J[et] && (eo = r(J[et])) && (el && (el += " "),
                  el += eo)
            } else
              for (eo in J)
                J[eo] && (el && (el += " "),
                  el += eo)
          }
          return el
        }(J)) && (el && (el += " "),
          el += et);
      return el
    };
    function composeClasses(J, et, eo) {
      let el = {};
      return Object.keys(J).forEach(ec => {
        el[ec] = J[ec].reduce((J, el) => {
          if (el) {
            let ec = et(el);
            "" !== ec && J.push(ec),
              eo && eo[el] && J.push(eo[el])
          }
          return J
        }
          , []).join(" ")
      }
      ),
        el
    }
    function runtime_helpers_esm_extends_extends() {
      return (runtime_helpers_esm_extends_extends = Object.assign ? Object.assign.bind() : function (J) {
        for (var et = 1; et < arguments.length; et++) {
          var eo = arguments[et];
          for (var el in eo)
            Object.prototype.hasOwnProperty.call(eo, el) && (J[el] = eo[el])
        }
        return J
      }
      ).apply(this, arguments)
    }
    function appendOwnerState(J, et, eo) {
      return void 0 === J || "string" == typeof J ? et : runtime_helpers_esm_extends_extends({}, et, {
        ownerState: runtime_helpers_esm_extends_extends({}, et.ownerState, eo)
      })
    }
    var useThemeWithoutDefault = function (J = null) {
      let et = ex.useContext(tn);
      return et && 0 !== Object.keys(et).length ? et : J
    };
    let rI = createTheme_createTheme();
    var esm_useTheme = function (J = rI) {
      return useThemeWithoutDefault(J)
    };
    function styles_useTheme_useTheme() {
      let J = esm_useTheme(rA);
      return J[rP] || J
    }
    function useThemeProps_useThemeProps({ props: J, name: et }) {
      return function ({ props: J, name: et, defaultTheme: eo, themeId: el }) {
        let ec = esm_useTheme(eo);
        el && (ec = ec[el] || ec);
        let ed = function (J) {
          let { theme: et, name: eo, props: el } = J;
          return et && et.components && et.components[eo] && et.components[eo].defaultProps ? function resolveProps(J, et) {
            let eo = esm_extends_extends({}, et);
            return Object.keys(J).forEach(el => {
              if (el.toString().match(/^(components|slots)$/))
                eo[el] = esm_extends_extends({}, J[el], eo[el]);
              else if (el.toString().match(/^(componentsProps|slotProps)$/)) {
                let ec = J[el] || {}
                  , ed = et[el];
                eo[el] = {},
                  ed && Object.keys(ed) ? ec && Object.keys(ec) ? (eo[el] = esm_extends_extends({}, ed),
                    Object.keys(ec).forEach(J => {
                      eo[el][J] = resolveProps(ec[J], ed[J])
                    }
                    )) : eo[el] = ed : eo[el] = ec
              } else
                void 0 === eo[el] && (eo[el] = J[el])
            }
            ),
              eo
          }(et.components[eo].defaultProps, el) : el
        }({
          theme: ec,
          name: et,
          props: J
        });
        return ed
      }({
        props: J,
        name: et,
        defaultTheme: rA,
        themeId: rP
      })
    }
    function _setPrototypeOf(J, et) {
      return (_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (J, et) {
        return J.__proto__ = et,
          J
      }
      )(J, et)
    }
    var rO = eo(73935)
      , rN = {
        disabled: !1
      }
      , rM = ex.createContext(null)
      , rD = "unmounted"
      , rj = "exited"
      , rL = "entering"
      , r$ = "entered"
      , rB = "exiting"
      , rF = function (J) {
        function Transition(et, eo) {
          el = J.call(this, et, eo) || this;
          var el, ec, ed = eo && !eo.isMounting ? et.enter : et.appear;
          return el.appearStatus = null,
            et.in ? ed ? (ec = rj,
              el.appearStatus = rL) : ec = r$ : ec = et.unmountOnExit || et.mountOnEnter ? rD : rj,
            el.state = {
              status: ec
            },
            el.nextCallback = null,
            el
        }
        Transition.prototype = Object.create(J.prototype),
          Transition.prototype.constructor = Transition,
          _setPrototypeOf(Transition, J),
          Transition.getDerivedStateFromProps = function (J, et) {
            return J.in && et.status === rD ? {
              status: rj
            } : null
          }
          ;
        var et = Transition.prototype;
        return et.componentDidMount = function () {
          this.updateStatus(!0, this.appearStatus)
        }
          ,
          et.componentDidUpdate = function (J) {
            var et = null;
            if (J !== this.props) {
              var eo = this.state.status;
              this.props.in ? eo !== rL && eo !== r$ && (et = rL) : (eo === rL || eo === r$) && (et = rB)
            }
            this.updateStatus(!1, et)
          }
          ,
          et.componentWillUnmount = function () {
            this.cancelNextCallback()
          }
          ,
          et.getTimeouts = function () {
            var J, et, eo, el = this.props.timeout;
            return J = et = eo = el,
              null != el && "number" != typeof el && (J = el.exit,
                et = el.enter,
                eo = void 0 !== el.appear ? el.appear : et),
            {
              exit: J,
              enter: et,
              appear: eo
            }
          }
          ,
          et.updateStatus = function (J, et) {
            if (void 0 === J && (J = !1),
              null !== et) {
              if (this.cancelNextCallback(),
                et === rL) {
                if (this.props.unmountOnExit || this.props.mountOnEnter) {
                  var eo = this.props.nodeRef ? this.props.nodeRef.current : rO.findDOMNode(this);
                  eo && eo.scrollTop
                }
                this.performEnter(J)
              } else
                this.performExit()
            } else
              this.props.unmountOnExit && this.state.status === rj && this.setState({
                status: rD
              })
          }
          ,
          et.performEnter = function (J) {
            var et = this
              , eo = this.props.enter
              , el = this.context ? this.context.isMounting : J
              , ec = this.props.nodeRef ? [el] : [rO.findDOMNode(this), el]
              , ed = ec[0]
              , eh = ec[1]
              , ep = this.getTimeouts()
              , ef = el ? ep.appear : ep.enter;
            if (!J && !eo || rN.disabled) {
              this.safeSetState({
                status: r$
              }, function () {
                et.props.onEntered(ed)
              });
              return
            }
            this.props.onEnter(ed, eh),
              this.safeSetState({
                status: rL
              }, function () {
                et.props.onEntering(ed, eh),
                  et.onTransitionEnd(ef, function () {
                    et.safeSetState({
                      status: r$
                    }, function () {
                      et.props.onEntered(ed, eh)
                    })
                  })
              })
          }
          ,
          et.performExit = function () {
            var J = this
              , et = this.props.exit
              , eo = this.getTimeouts()
              , el = this.props.nodeRef ? void 0 : rO.findDOMNode(this);
            if (!et || rN.disabled) {
              this.safeSetState({
                status: rj
              }, function () {
                J.props.onExited(el)
              });
              return
            }
            this.props.onExit(el),
              this.safeSetState({
                status: rB
              }, function () {
                J.props.onExiting(el),
                  J.onTransitionEnd(eo.exit, function () {
                    J.safeSetState({
                      status: rj
                    }, function () {
                      J.props.onExited(el)
                    })
                  })
              })
          }
          ,
          et.cancelNextCallback = function () {
            null !== this.nextCallback && (this.nextCallback.cancel(),
              this.nextCallback = null)
          }
          ,
          et.safeSetState = function (J, et) {
            et = this.setNextCallback(et),
              this.setState(J, et)
          }
          ,
          et.setNextCallback = function (J) {
            var et = this
              , eo = !0;
            return this.nextCallback = function (el) {
              eo && (eo = !1,
                et.nextCallback = null,
                J(el))
            }
              ,
              this.nextCallback.cancel = function () {
                eo = !1
              }
              ,
              this.nextCallback
          }
          ,
          et.onTransitionEnd = function (J, et) {
            this.setNextCallback(et);
            var eo = this.props.nodeRef ? this.props.nodeRef.current : rO.findDOMNode(this)
              , el = null == J && !this.props.addEndListener;
            if (!eo || el) {
              setTimeout(this.nextCallback, 0);
              return
            }
            if (this.props.addEndListener) {
              var ec = this.props.nodeRef ? [this.nextCallback] : [eo, this.nextCallback]
                , ed = ec[0]
                , eh = ec[1];
              this.props.addEndListener(ed, eh)
            }
            null != J && setTimeout(this.nextCallback, J)
          }
          ,
          et.render = function () {
            var J = this.state.status;
            if (J === rD)
              return null;
            var et = this.props
              , eo = et.children
              , el = (et.in,
                et.mountOnEnter,
                et.unmountOnExit,
                et.appear,
                et.enter,
                et.exit,
                et.timeout,
                et.addEndListener,
                et.onEnter,
                et.onEntering,
                et.onEntered,
                et.onExit,
                et.onExiting,
                et.onExited,
                et.nodeRef,
                function (J, et) {
                  if (null == J)
                    return {};
                  var eo, el, ec = {}, ed = Object.keys(J);
                  for (el = 0; el < ed.length; el++)
                    et.indexOf(eo = ed[el]) >= 0 || (ec[eo] = J[eo]);
                  return ec
                }(et, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]));
            return ex.createElement(rM.Provider, {
              value: null
            }, "function" == typeof eo ? eo(J, el) : ex.cloneElement(ex.Children.only(eo), el))
          }
          ,
          Transition
      }(ex.Component);
    function noop() { }
    rF.contextType = rM,
      rF.propTypes = {},
      rF.defaultProps = {
        in: !1,
        mountOnEnter: !1,
        unmountOnExit: !1,
        appear: !1,
        enter: !0,
        exit: !0,
        onEnter: noop,
        onEntering: noop,
        onEntered: noop,
        onExit: noop,
        onExiting: noop,
        onExited: noop
      },
      rF.UNMOUNTED = rD,
      rF.EXITED = rj,
      rF.ENTERING = rL,
      rF.ENTERED = r$,
      rF.EXITING = rB;
    let reflow = J => J.scrollTop;
    function getTransitionProps(J, et) {
      var eo, el;
      let { timeout: ec, easing: ed, style: eh = {} } = J;
      return {
        duration: null != (eo = eh.transitionDuration) ? eo : "number" == typeof ec ? ec : ec[et.mode] || 0,
        easing: null != (el = eh.transitionTimingFunction) ? el : "object" == typeof ed ? ed[et.mode] : ed,
        delay: eh.transitionDelay
      }
    }
    function setRef(J, et) {
      "function" == typeof J ? J(et) : J && (J.current = et)
    }
    function useForkRef(...J) {
      return ex.useMemo(() => J.every(J => null == J) ? null : et => {
        J.forEach(J => {
          setRef(J, et)
        }
        )
      }
        , J)
    }
    let rU = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
    function getScale(J) {
      return `scale(${J}, ${J ** 2})`
    }
    let rz = {
      entering: {
        opacity: 1,
        transform: getScale(1)
      },
      entered: {
        opacity: 1,
        transform: "none"
      }
    }
      , rH = "undefined" != typeof navigator && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent)
      , rV = ex.forwardRef(function (J, et) {
        let { addEndListener: eo, appear: el = !0, children: ec, easing: ed, in: eh, onEnter: ep, onEntered: ef, onEntering: em, onExit: eg, onExited: ey, onExiting: eb, style: e_, timeout: eE = "auto", TransitionComponent: eC = rF } = J
          , eS = objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(J, rU)
          , ek = ex.useRef()
          , eT = ex.useRef()
          , eA = styles_useTheme_useTheme()
          , eP = ex.useRef(null)
          , eR = useForkRef(eP, ec.ref, et)
          , normalizedTransitionCallback = J => et => {
            if (J) {
              let eo = eP.current;
              void 0 === et ? J(eo) : J(eo, et)
            }
          }
          , eI = normalizedTransitionCallback(em)
          , eO = normalizedTransitionCallback((J, et) => {
            let eo;
            reflow(J);
            let { duration: el, delay: ec, easing: eh } = getTransitionProps({
              style: e_,
              timeout: eE,
              easing: ed
            }, {
              mode: "enter"
            });
            "auto" === eE ? (eo = eA.transitions.getAutoHeightDuration(J.clientHeight),
              eT.current = eo) : eo = el,
              J.style.transition = [eA.transitions.create("opacity", {
                duration: eo,
                delay: ec
              }), eA.transitions.create("transform", {
                duration: rH ? eo : .666 * eo,
                delay: ec,
                easing: eh
              })].join(","),
              ep && ep(J, et)
          }
          )
          , eN = normalizedTransitionCallback(ef)
          , eM = normalizedTransitionCallback(eb)
          , eD = normalizedTransitionCallback(J => {
            let et;
            let { duration: eo, delay: el, easing: ec } = getTransitionProps({
              style: e_,
              timeout: eE,
              easing: ed
            }, {
              mode: "exit"
            });
            "auto" === eE ? (et = eA.transitions.getAutoHeightDuration(J.clientHeight),
              eT.current = et) : et = eo,
              J.style.transition = [eA.transitions.create("opacity", {
                duration: et,
                delay: el
              }), eA.transitions.create("transform", {
                duration: rH ? et : .666 * et,
                delay: rH ? el : el || .333 * et,
                easing: ec
              })].join(","),
              J.style.opacity = 0,
              J.style.transform = getScale(.75),
              eg && eg(J)
          }
          )
          , ej = normalizedTransitionCallback(ey);
        return ex.useEffect(() => () => {
          clearTimeout(ek.current)
        }
          , []),
          (0,
            ew.jsx)(eC, helpers_esm_extends_extends({
              appear: el,
              in: eh,
              nodeRef: eP,
              onEnter: eO,
              onEntered: eN,
              onEntering: eI,
              onExit: eD,
              onExited: ej,
              onExiting: eM,
              addEndListener: J => {
                "auto" === eE && (ek.current = setTimeout(J, eT.current || 0)),
                  eo && eo(eP.current, J)
              }
              ,
              timeout: "auto" === eE ? null : eE
            }, eS, {
              children: (J, et) => ex.cloneElement(ec, helpers_esm_extends_extends({
                style: helpers_esm_extends_extends({
                  opacity: 0,
                  transform: getScale(.75),
                  visibility: "exited" !== J || eh ? void 0 : "hidden"
                }, rz[J], e_, ec.props.style),
                ref: eR
              }, et))
            }))
      });
    function helpers_esm_objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(J, et) {
      if (null == J)
        return {};
      var eo, el, ec = {}, ed = Object.keys(J);
      for (el = 0; el < ed.length; el++)
        eo = ed[el],
          et.indexOf(eo) >= 0 || (ec[eo] = J[eo]);
      return ec
    }
    rV.muiSupportAuto = !0;
    let rW = "undefined" != typeof window ? ex.useLayoutEffect : ex.useEffect;
    function ownerDocument(J) {
      return J && J.ownerDocument || document
    }
    function getWindow(J) {
      if (null == J)
        return window;
      if ("[object Window]" !== J.toString()) {
        var et = J.ownerDocument;
        return et && et.defaultView || window
      }
      return J
    }
    function isElement(J) {
      var et = getWindow(J).Element;
      return J instanceof et || J instanceof Element
    }
    function isHTMLElement(J) {
      var et = getWindow(J).HTMLElement;
      return J instanceof et || J instanceof HTMLElement
    }
    function isShadowRoot(J) {
      if ("undefined" == typeof ShadowRoot)
        return !1;
      var et = getWindow(J).ShadowRoot;
      return J instanceof et || J instanceof ShadowRoot
    }
    var rq = Math.max
      , rZ = Math.min
      , rG = Math.round;
    function getUAString() {
      var J = navigator.userAgentData;
      return null != J && J.brands && Array.isArray(J.brands) ? J.brands.map(function (J) {
        return J.brand + "/" + J.version
      }).join(" ") : navigator.userAgent
    }
    function isLayoutViewport() {
      return !/^((?!chrome|android).)*safari/i.test(getUAString())
    }
    function getBoundingClientRect(J, et, eo) {
      void 0 === et && (et = !1),
        void 0 === eo && (eo = !1);
      var el = J.getBoundingClientRect()
        , ec = 1
        , ed = 1;
      et && isHTMLElement(J) && (ec = J.offsetWidth > 0 && rG(el.width) / J.offsetWidth || 1,
        ed = J.offsetHeight > 0 && rG(el.height) / J.offsetHeight || 1);
      var eh = (isElement(J) ? getWindow(J) : window).visualViewport
        , ep = !isLayoutViewport() && eo
        , ef = (el.left + (ep && eh ? eh.offsetLeft : 0)) / ec
        , em = (el.top + (ep && eh ? eh.offsetTop : 0)) / ed
        , eg = el.width / ec
        , ey = el.height / ed;
      return {
        width: eg,
        height: ey,
        top: em,
        right: ef + eg,
        bottom: em + ey,
        left: ef,
        x: ef,
        y: em
      }
    }
    function getWindowScroll(J) {
      var et = getWindow(J);
      return {
        scrollLeft: et.pageXOffset,
        scrollTop: et.pageYOffset
      }
    }
    function getNodeName(J) {
      return J ? (J.nodeName || "").toLowerCase() : null
    }
    function getDocumentElement(J) {
      return ((isElement(J) ? J.ownerDocument : J.document) || window.document).documentElement
    }
    function getWindowScrollBarX(J) {
      return getBoundingClientRect(getDocumentElement(J)).left + getWindowScroll(J).scrollLeft
    }
    function getComputedStyle(J) {
      return getWindow(J).getComputedStyle(J)
    }
    function isScrollParent(J) {
      var et = getComputedStyle(J)
        , eo = et.overflow
        , el = et.overflowX
        , ec = et.overflowY;
      return /auto|scroll|overlay|hidden/.test(eo + ec + el)
    }
    function getLayoutRect(J) {
      var et = getBoundingClientRect(J)
        , eo = J.offsetWidth
        , el = J.offsetHeight;
      return 1 >= Math.abs(et.width - eo) && (eo = et.width),
        1 >= Math.abs(et.height - el) && (el = et.height),
      {
        x: J.offsetLeft,
        y: J.offsetTop,
        width: eo,
        height: el
      }
    }
    function getParentNode(J) {
      return "html" === getNodeName(J) ? J : J.assignedSlot || J.parentNode || (isShadowRoot(J) ? J.host : null) || getDocumentElement(J)
    }
    function listScrollParents(J, et) {
      void 0 === et && (et = []);
      var eo, el = function getScrollParent(J) {
        return ["html", "body", "#document"].indexOf(getNodeName(J)) >= 0 ? J.ownerDocument.body : isHTMLElement(J) && isScrollParent(J) ? J : getScrollParent(getParentNode(J))
      }(J), ec = el === (null == (eo = J.ownerDocument) ? void 0 : eo.body), ed = getWindow(el), eh = ec ? [ed].concat(ed.visualViewport || [], isScrollParent(el) ? el : []) : el, ep = et.concat(eh);
      return ec ? ep : ep.concat(listScrollParents(getParentNode(eh)))
    }
    function getTrueOffsetParent(J) {
      return isHTMLElement(J) && "fixed" !== getComputedStyle(J).position ? J.offsetParent : null
    }
    function getOffsetParent(J) {
      for (var et = getWindow(J), eo = getTrueOffsetParent(J); eo && ["table", "td", "th"].indexOf(getNodeName(eo)) >= 0 && "static" === getComputedStyle(eo).position;)
        eo = getTrueOffsetParent(eo);
      return eo && ("html" === getNodeName(eo) || "body" === getNodeName(eo) && "static" === getComputedStyle(eo).position) ? et : eo || function (J) {
        var et = /firefox/i.test(getUAString());
        if (/Trident/i.test(getUAString()) && isHTMLElement(J) && "fixed" === getComputedStyle(J).position)
          return null;
        var eo = getParentNode(J);
        for (isShadowRoot(eo) && (eo = eo.host); isHTMLElement(eo) && 0 > ["html", "body"].indexOf(getNodeName(eo));) {
          var el = getComputedStyle(eo);
          if ("none" !== el.transform || "none" !== el.perspective || "paint" === el.contain || -1 !== ["transform", "perspective"].indexOf(el.willChange) || et && "filter" === el.willChange || et && el.filter && "none" !== el.filter)
            return eo;
          eo = eo.parentNode
        }
        return null
      }(J) || et
    }
    var rY = "bottom"
      , rK = "right"
      , rJ = "left"
      , rQ = "auto"
      , rX = ["top", rY, rK, rJ]
      , r0 = "start"
      , r1 = "viewport"
      , r2 = "popper"
      , r3 = rX.reduce(function (J, et) {
        return J.concat([et + "-" + r0, et + "-end"])
      }, [])
      , r5 = [].concat(rX, [rQ]).reduce(function (J, et) {
        return J.concat([et, et + "-" + r0, et + "-end"])
      }, [])
      , r6 = ["beforeRead", "read", "afterRead", "beforeMain", "main", "afterMain", "beforeWrite", "write", "afterWrite"]
      , r4 = {
        placement: "bottom",
        modifiers: [],
        strategy: "absolute"
      };
    function areValidElements() {
      for (var J = arguments.length, et = Array(J), eo = 0; eo < J; eo++)
        et[eo] = arguments[eo];
      return !et.some(function (J) {
        return !(J && "function" == typeof J.getBoundingClientRect)
      })
    }
    var r8 = {
      passive: !0
    };
    function getBasePlacement(J) {
      return J.split("-")[0]
    }
    function getVariation(J) {
      return J.split("-")[1]
    }
    function getMainAxisFromPlacement(J) {
      return ["top", "bottom"].indexOf(J) >= 0 ? "x" : "y"
    }
    function computeOffsets(J) {
      var et, eo = J.reference, el = J.element, ec = J.placement, ed = ec ? getBasePlacement(ec) : null, eh = ec ? getVariation(ec) : null, ep = eo.x + eo.width / 2 - el.width / 2, ef = eo.y + eo.height / 2 - el.height / 2;
      switch (ed) {
        case "top":
          et = {
            x: ep,
            y: eo.y - el.height
          };
          break;
        case rY:
          et = {
            x: ep,
            y: eo.y + eo.height
          };
          break;
        case rK:
          et = {
            x: eo.x + eo.width,
            y: ef
          };
          break;
        case rJ:
          et = {
            x: eo.x - el.width,
            y: ef
          };
          break;
        default:
          et = {
            x: eo.x,
            y: eo.y
          }
      }
      var em = ed ? getMainAxisFromPlacement(ed) : null;
      if (null != em) {
        var eg = "y" === em ? "height" : "width";
        switch (eh) {
          case r0:
            et[em] = et[em] - (eo[eg] / 2 - el[eg] / 2);
            break;
          case "end":
            et[em] = et[em] + (eo[eg] / 2 - el[eg] / 2)
        }
      }
      return et
    }
    var r7 = {
      top: "auto",
      right: "auto",
      bottom: "auto",
      left: "auto"
    };
    function mapToStyles(J) {
      var et, eo, el, ec, ed, eh, ep, ef = J.popper, em = J.popperRect, eg = J.placement, ey = J.variation, eb = J.offsets, ew = J.position, e_ = J.gpuAcceleration, ex = J.adaptive, eE = J.roundOffsets, eC = J.isFixed, eS = eb.x, ek = void 0 === eS ? 0 : eS, eT = eb.y, eA = void 0 === eT ? 0 : eT, eP = "function" == typeof eE ? eE({
        x: ek,
        y: eA
      }) : {
        x: ek,
        y: eA
      };
      ek = eP.x,
        eA = eP.y;
      var eR = eb.hasOwnProperty("x")
        , eI = eb.hasOwnProperty("y")
        , eO = rJ
        , eN = "top"
        , eM = window;
      if (ex) {
        var eD = getOffsetParent(ef)
          , ej = "clientHeight"
          , eL = "clientWidth";
        eD === getWindow(ef) && "static" !== getComputedStyle(eD = getDocumentElement(ef)).position && "absolute" === ew && (ej = "scrollHeight",
          eL = "scrollWidth"),
          ("top" === eg || (eg === rJ || eg === rK) && "end" === ey) && (eN = rY,
            eA -= (eC && eD === eM && eM.visualViewport ? eM.visualViewport.height : eD[ej]) - em.height,
            eA *= e_ ? 1 : -1),
          (eg === rJ || ("top" === eg || eg === rY) && "end" === ey) && (eO = rK,
            ek -= (eC && eD === eM && eM.visualViewport ? eM.visualViewport.width : eD[eL]) - em.width,
            ek *= e_ ? 1 : -1)
      }
      var e$ = Object.assign({
        position: ew
      }, ex && r7)
        , eB = !0 === eE ? (et = {
          x: ek,
          y: eA
        },
          eo = getWindow(ef),
          el = et.x,
          ec = et.y,
        {
          x: rG(el * (ed = eo.devicePixelRatio || 1)) / ed || 0,
          y: rG(ec * ed) / ed || 0
        }) : {
          x: ek,
          y: eA
        };
      return (ek = eB.x,
        eA = eB.y,
        e_) ? Object.assign({}, e$, ((ep = {})[eN] = eI ? "0" : "",
          ep[eO] = eR ? "0" : "",
          ep.transform = 1 >= (eM.devicePixelRatio || 1) ? "translate(" + ek + "px, " + eA + "px)" : "translate3d(" + ek + "px, " + eA + "px, 0)",
          ep)) : Object.assign({}, e$, ((eh = {})[eN] = eI ? eA + "px" : "",
            eh[eO] = eR ? ek + "px" : "",
            eh.transform = "",
            eh))
    }
    var r9 = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
    function getOppositePlacement(J) {
      return J.replace(/left|right|bottom|top/g, function (J) {
        return r9[J]
      })
    }
    var nn = {
      start: "end",
      end: "start"
    };
    function getOppositeVariationPlacement(J) {
      return J.replace(/start|end/g, function (J) {
        return nn[J]
      })
    }
    function contains(J, et) {
      var eo = et.getRootNode && et.getRootNode();
      if (J.contains(et))
        return !0;
      if (eo && isShadowRoot(eo)) {
        var el = et;
        do {
          if (el && J.isSameNode(el))
            return !0;
          el = el.parentNode || el.host
        } while (el)
      }
      return !1
    }
    function rectToClientRect(J) {
      return Object.assign({}, J, {
        left: J.x,
        top: J.y,
        right: J.x + J.width,
        bottom: J.y + J.height
      })
    }
    function getClientRectFromMixedType(J, et, eo) {
      var el, ec, ed, eh, ep, ef, em, eg, ey, eb;
      return et === r1 ? rectToClientRect(function (J, et) {
        var eo = getWindow(J)
          , el = getDocumentElement(J)
          , ec = eo.visualViewport
          , ed = el.clientWidth
          , eh = el.clientHeight
          , ep = 0
          , ef = 0;
        if (ec) {
          ed = ec.width,
            eh = ec.height;
          var em = isLayoutViewport();
          (em || !em && "fixed" === et) && (ep = ec.offsetLeft,
            ef = ec.offsetTop)
        }
        return {
          width: ed,
          height: eh,
          x: ep + getWindowScrollBarX(J),
          y: ef
        }
      }(J, eo)) : isElement(et) ? ((el = getBoundingClientRect(et, !1, "fixed" === eo)).top = el.top + et.clientTop,
        el.left = el.left + et.clientLeft,
        el.bottom = el.top + et.clientHeight,
        el.right = el.left + et.clientWidth,
        el.width = et.clientWidth,
        el.height = et.clientHeight,
        el.x = el.left,
        el.y = el.top,
        el) : rectToClientRect((ec = getDocumentElement(J),
          eh = getDocumentElement(ec),
          ep = getWindowScroll(ec),
          ef = null == (ed = ec.ownerDocument) ? void 0 : ed.body,
          em = rq(eh.scrollWidth, eh.clientWidth, ef ? ef.scrollWidth : 0, ef ? ef.clientWidth : 0),
          eg = rq(eh.scrollHeight, eh.clientHeight, ef ? ef.scrollHeight : 0, ef ? ef.clientHeight : 0),
          ey = -ep.scrollLeft + getWindowScrollBarX(ec),
          eb = -ep.scrollTop,
          "rtl" === getComputedStyle(ef || eh).direction && (ey += rq(eh.clientWidth, ef ? ef.clientWidth : 0) - em),
        {
          width: em,
          height: eg,
          x: ey,
          y: eb
        }))
    }
    function getFreshSideObject() {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      }
    }
    function mergePaddingObject(J) {
      return Object.assign({}, getFreshSideObject(), J)
    }
    function expandToHashMap(J, et) {
      return et.reduce(function (et, eo) {
        return et[eo] = J,
          et
      }, {})
    }
    function detectOverflow(J, et) {
      void 0 === et && (et = {});
      var eo, el, ec, ed, eh, ep, ef, em = et, eg = em.placement, ey = void 0 === eg ? J.placement : eg, eb = em.strategy, ew = void 0 === eb ? J.strategy : eb, e_ = em.boundary, ex = em.rootBoundary, eE = em.elementContext, eC = void 0 === eE ? r2 : eE, eS = em.altBoundary, ek = em.padding, eT = void 0 === ek ? 0 : ek, eA = mergePaddingObject("number" != typeof eT ? eT : expandToHashMap(eT, rX)), eP = J.rects.popper, eR = J.elements[void 0 !== eS && eS ? eC === r2 ? "reference" : r2 : eC], eI = (eo = isElement(eR) ? eR : eR.contextElement || getDocumentElement(J.elements.popper),
        ep = (eh = [].concat("clippingParents" === (el = void 0 === e_ ? "clippingParents" : e_) ? (ec = listScrollParents(getParentNode(eo)),
          isElement(ed = ["absolute", "fixed"].indexOf(getComputedStyle(eo).position) >= 0 && isHTMLElement(eo) ? getOffsetParent(eo) : eo) ? ec.filter(function (J) {
            return isElement(J) && contains(J, ed) && "body" !== getNodeName(J)
          }) : []) : [].concat(el), [void 0 === ex ? r1 : ex]))[0],
        (ef = eh.reduce(function (J, et) {
          var el = getClientRectFromMixedType(eo, et, ew);
          return J.top = rq(el.top, J.top),
            J.right = rZ(el.right, J.right),
            J.bottom = rZ(el.bottom, J.bottom),
            J.left = rq(el.left, J.left),
            J
        }, getClientRectFromMixedType(eo, ep, ew))).width = ef.right - ef.left,
        ef.height = ef.bottom - ef.top,
        ef.x = ef.left,
        ef.y = ef.top,
        ef), eO = getBoundingClientRect(J.elements.reference), eN = computeOffsets({
          reference: eO,
          element: eP,
          strategy: "absolute",
          placement: ey
        }), eM = rectToClientRect(Object.assign({}, eP, eN)), eD = eC === r2 ? eM : eO, ej = {
          top: eI.top - eD.top + eA.top,
          bottom: eD.bottom - eI.bottom + eA.bottom,
          left: eI.left - eD.left + eA.left,
          right: eD.right - eI.right + eA.right
        }, eL = J.modifiersData.offset;
      if (eC === r2 && eL) {
        var e$ = eL[ey];
        Object.keys(ej).forEach(function (J) {
          var et = [rK, rY].indexOf(J) >= 0 ? 1 : -1
            , eo = ["top", rY].indexOf(J) >= 0 ? "y" : "x";
          ej[J] += e$[eo] * et
        })
      }
      return ej
    }
    function within(J, et, eo) {
      return rq(J, rZ(et, eo))
    }
    function getSideOffsets(J, et, eo) {
      return void 0 === eo && (eo = {
        x: 0,
        y: 0
      }),
      {
        top: J.top - et.height - eo.y,
        right: J.right - et.width + eo.x,
        bottom: J.bottom - et.height + eo.y,
        left: J.left - et.width - eo.x
      }
    }
    function isAnySideFullyClipped(J) {
      return ["top", rK, rY, rJ].some(function (et) {
        return J[et] >= 0
      })
    }
    var ns = (ep = void 0 === (eh = (ed = {
      defaultModifiers: [{
        name: "eventListeners",
        enabled: !0,
        phase: "write",
        fn: function () { },
        effect: function (J) {
          var et = J.state
            , eo = J.instance
            , el = J.options
            , ec = el.scroll
            , ed = void 0 === ec || ec
            , eh = el.resize
            , ep = void 0 === eh || eh
            , ef = getWindow(et.elements.popper)
            , em = [].concat(et.scrollParents.reference, et.scrollParents.popper);
          return ed && em.forEach(function (J) {
            J.addEventListener("scroll", eo.update, r8)
          }),
            ep && ef.addEventListener("resize", eo.update, r8),
            function () {
              ed && em.forEach(function (J) {
                J.removeEventListener("scroll", eo.update, r8)
              }),
                ep && ef.removeEventListener("resize", eo.update, r8)
            }
        },
        data: {}
      }, {
        name: "popperOffsets",
        enabled: !0,
        phase: "read",
        fn: function (J) {
          var et = J.state
            , eo = J.name;
          et.modifiersData[eo] = computeOffsets({
            reference: et.rects.reference,
            element: et.rects.popper,
            strategy: "absolute",
            placement: et.placement
          })
        },
        data: {}
      }, {
        name: "computeStyles",
        enabled: !0,
        phase: "beforeWrite",
        fn: function (J) {
          var et = J.state
            , eo = J.options
            , el = eo.gpuAcceleration
            , ec = eo.adaptive
            , ed = eo.roundOffsets
            , eh = void 0 === ed || ed
            , ep = {
              placement: getBasePlacement(et.placement),
              variation: getVariation(et.placement),
              popper: et.elements.popper,
              popperRect: et.rects.popper,
              gpuAcceleration: void 0 === el || el,
              isFixed: "fixed" === et.options.strategy
            };
          null != et.modifiersData.popperOffsets && (et.styles.popper = Object.assign({}, et.styles.popper, mapToStyles(Object.assign({}, ep, {
            offsets: et.modifiersData.popperOffsets,
            position: et.options.strategy,
            adaptive: void 0 === ec || ec,
            roundOffsets: eh
          })))),
            null != et.modifiersData.arrow && (et.styles.arrow = Object.assign({}, et.styles.arrow, mapToStyles(Object.assign({}, ep, {
              offsets: et.modifiersData.arrow,
              position: "absolute",
              adaptive: !1,
              roundOffsets: eh
            })))),
            et.attributes.popper = Object.assign({}, et.attributes.popper, {
              "data-popper-placement": et.placement
            })
        },
        data: {}
      }, {
        name: "applyStyles",
        enabled: !0,
        phase: "write",
        fn: function (J) {
          var et = J.state;
          Object.keys(et.elements).forEach(function (J) {
            var eo = et.styles[J] || {}
              , el = et.attributes[J] || {}
              , ec = et.elements[J];
            isHTMLElement(ec) && getNodeName(ec) && (Object.assign(ec.style, eo),
              Object.keys(el).forEach(function (J) {
                var et = el[J];
                !1 === et ? ec.removeAttribute(J) : ec.setAttribute(J, !0 === et ? "" : et)
              }))
          })
        },
        effect: function (J) {
          var et = J.state
            , eo = {
              popper: {
                position: et.options.strategy,
                left: "0",
                top: "0",
                margin: "0"
              },
              arrow: {
                position: "absolute"
              },
              reference: {}
            };
          return Object.assign(et.elements.popper.style, eo.popper),
            et.styles = eo,
            et.elements.arrow && Object.assign(et.elements.arrow.style, eo.arrow),
            function () {
              Object.keys(et.elements).forEach(function (J) {
                var el = et.elements[J]
                  , ec = et.attributes[J] || {}
                  , ed = Object.keys(et.styles.hasOwnProperty(J) ? et.styles[J] : eo[J]).reduce(function (J, et) {
                    return J[et] = "",
                      J
                  }, {});
                isHTMLElement(el) && getNodeName(el) && (Object.assign(el.style, ed),
                  Object.keys(ec).forEach(function (J) {
                    el.removeAttribute(J)
                  }))
              })
            }
        },
        requires: ["computeStyles"]
      }, {
        name: "offset",
        enabled: !0,
        phase: "main",
        requires: ["popperOffsets"],
        fn: function (J) {
          var et = J.state
            , eo = J.options
            , el = J.name
            , ec = eo.offset
            , ed = void 0 === ec ? [0, 0] : ec
            , eh = r5.reduce(function (J, eo) {
              var el, ec, eh, ep, ef, em;
              return J[eo] = (el = et.rects,
                eh = [rJ, "top"].indexOf(ec = getBasePlacement(eo)) >= 0 ? -1 : 1,
                ef = (ep = "function" == typeof ed ? ed(Object.assign({}, el, {
                  placement: eo
                })) : ed)[0],
                em = ep[1],
                ef = ef || 0,
                em = (em || 0) * eh,
                [rJ, rK].indexOf(ec) >= 0 ? {
                  x: em,
                  y: ef
                } : {
                  x: ef,
                  y: em
                }),
                J
            }, {})
            , ep = eh[et.placement]
            , ef = ep.x
            , em = ep.y;
          null != et.modifiersData.popperOffsets && (et.modifiersData.popperOffsets.x += ef,
            et.modifiersData.popperOffsets.y += em),
            et.modifiersData[el] = eh
        }
      }, {
        name: "flip",
        enabled: !0,
        phase: "main",
        fn: function (J) {
          var et = J.state
            , eo = J.options
            , el = J.name;
          if (!et.modifiersData[el]._skip) {
            for (var ec = eo.mainAxis, ed = void 0 === ec || ec, eh = eo.altAxis, ep = void 0 === eh || eh, ef = eo.fallbackPlacements, em = eo.padding, eg = eo.boundary, ey = eo.rootBoundary, eb = eo.altBoundary, ew = eo.flipVariations, e_ = void 0 === ew || ew, ex = eo.allowedAutoPlacements, eE = et.options.placement, eC = getBasePlacement(eE) === eE, eS = ef || (eC || !e_ ? [getOppositePlacement(eE)] : function (J) {
              if (getBasePlacement(J) === rQ)
                return [];
              var et = getOppositePlacement(J);
              return [getOppositeVariationPlacement(J), et, getOppositeVariationPlacement(et)]
            }(eE)), ek = [eE].concat(eS).reduce(function (J, eo) {
              var el, ec, ed, eh, ep, ef, eb, ew, eE, eC, eS, ek;
              return J.concat(getBasePlacement(eo) === rQ ? (ec = (el = {
                placement: eo,
                boundary: eg,
                rootBoundary: ey,
                padding: em,
                flipVariations: e_,
                allowedAutoPlacements: ex
              }).placement,
                ed = el.boundary,
                eh = el.rootBoundary,
                ep = el.padding,
                ef = el.flipVariations,
                ew = void 0 === (eb = el.allowedAutoPlacements) ? r5 : eb,
                0 === (eS = (eC = (eE = getVariation(ec)) ? ef ? r3 : r3.filter(function (J) {
                  return getVariation(J) === eE
                }) : rX).filter(function (J) {
                  return ew.indexOf(J) >= 0
                })).length && (eS = eC),
                Object.keys(ek = eS.reduce(function (J, eo) {
                  return J[eo] = detectOverflow(et, {
                    placement: eo,
                    boundary: ed,
                    rootBoundary: eh,
                    padding: ep
                  })[getBasePlacement(eo)],
                    J
                }, {})).sort(function (J, et) {
                  return ek[J] - ek[et]
                })) : eo)
            }, []), eT = et.rects.reference, eA = et.rects.popper, eP = new Map, eR = !0, eI = ek[0], eO = 0; eO < ek.length; eO++) {
              var eN = ek[eO]
                , eM = getBasePlacement(eN)
                , eD = getVariation(eN) === r0
                , ej = ["top", rY].indexOf(eM) >= 0
                , eL = ej ? "width" : "height"
                , e$ = detectOverflow(et, {
                  placement: eN,
                  boundary: eg,
                  rootBoundary: ey,
                  altBoundary: eb,
                  padding: em
                })
                , eB = ej ? eD ? rK : rJ : eD ? rY : "top";
              eT[eL] > eA[eL] && (eB = getOppositePlacement(eB));
              var eF = getOppositePlacement(eB)
                , eU = [];
              if (ed && eU.push(e$[eM] <= 0),
                ep && eU.push(e$[eB] <= 0, e$[eF] <= 0),
                eU.every(function (J) {
                  return J
                })) {
                eI = eN,
                  eR = !1;
                break
              }
              eP.set(eN, eU)
            }
            if (eR)
              for (var ez = e_ ? 3 : 1, _loop = function (J) {
                var et = ek.find(function (et) {
                  var eo = eP.get(et);
                  if (eo)
                    return eo.slice(0, J).every(function (J) {
                      return J
                    })
                });
                if (et)
                  return eI = et,
                    "break"
              }, eH = ez; eH > 0 && "break" !== _loop(eH); eH--)
                ;
            et.placement !== eI && (et.modifiersData[el]._skip = !0,
              et.placement = eI,
              et.reset = !0)
          }
        },
        requiresIfExists: ["offset"],
        data: {
          _skip: !1
        }
      }, {
        name: "preventOverflow",
        enabled: !0,
        phase: "main",
        fn: function (J) {
          var et = J.state
            , eo = J.options
            , el = J.name
            , ec = eo.mainAxis
            , ed = eo.altAxis
            , eh = eo.boundary
            , ep = eo.rootBoundary
            , ef = eo.altBoundary
            , em = eo.padding
            , eg = eo.tether
            , ey = void 0 === eg || eg
            , eb = eo.tetherOffset
            , ew = void 0 === eb ? 0 : eb
            , e_ = detectOverflow(et, {
              boundary: eh,
              rootBoundary: ep,
              padding: em,
              altBoundary: ef
            })
            , ex = getBasePlacement(et.placement)
            , eE = getVariation(et.placement)
            , eC = !eE
            , eS = getMainAxisFromPlacement(ex)
            , ek = "x" === eS ? "y" : "x"
            , eT = et.modifiersData.popperOffsets
            , eA = et.rects.reference
            , eP = et.rects.popper
            , eR = "function" == typeof ew ? ew(Object.assign({}, et.rects, {
              placement: et.placement
            })) : ew
            , eI = "number" == typeof eR ? {
              mainAxis: eR,
              altAxis: eR
            } : Object.assign({
              mainAxis: 0,
              altAxis: 0
            }, eR)
            , eO = et.modifiersData.offset ? et.modifiersData.offset[et.placement] : null
            , eN = {
              x: 0,
              y: 0
            };
          if (eT) {
            if (void 0 === ec || ec) {
              var eM, eD = "y" === eS ? "top" : rJ, ej = "y" === eS ? rY : rK, eL = "y" === eS ? "height" : "width", e$ = eT[eS], eB = e$ + e_[eD], eF = e$ - e_[ej], eU = ey ? -eP[eL] / 2 : 0, ez = eE === r0 ? eA[eL] : eP[eL], eH = eE === r0 ? -eP[eL] : -eA[eL], eV = et.elements.arrow, eW = ey && eV ? getLayoutRect(eV) : {
                width: 0,
                height: 0
              }, eZ = et.modifiersData["arrow#persistent"] ? et.modifiersData["arrow#persistent"].padding : getFreshSideObject(), eG = eZ[eD], eY = eZ[ej], eK = within(0, eA[eL], eW[eL]), eJ = eC ? eA[eL] / 2 - eU - eK - eG - eI.mainAxis : ez - eK - eG - eI.mainAxis, eQ = eC ? -eA[eL] / 2 + eU + eK + eY + eI.mainAxis : eH + eK + eY + eI.mainAxis, eX = et.elements.arrow && getOffsetParent(et.elements.arrow), e0 = eX ? "y" === eS ? eX.clientTop || 0 : eX.clientLeft || 0 : 0, e1 = null != (eM = null == eO ? void 0 : eO[eS]) ? eM : 0, e2 = e$ + eJ - e1 - e0, e3 = e$ + eQ - e1, e5 = within(ey ? rZ(eB, e2) : eB, e$, ey ? rq(eF, e3) : eF);
              eT[eS] = e5,
                eN[eS] = e5 - e$
            }
            if (void 0 !== ed && ed) {
              var e6, e4, e8 = "x" === eS ? "top" : rJ, e7 = "x" === eS ? rY : rK, e9 = eT[ek], tn = "y" === ek ? "height" : "width", to = e9 + e_[e8], ta = e9 - e_[e7], tl = -1 !== ["top", rJ].indexOf(ex), tc = null != (e4 = null == eO ? void 0 : eO[ek]) ? e4 : 0, td = tl ? to : e9 - eA[tn] - eP[tn] - tc + eI.altAxis, th = tl ? e9 + eA[tn] + eP[tn] - tc - eI.altAxis : ta, tp = ey && tl ? (e6 = within(td, e9, th)) > th ? th : e6 : within(ey ? td : to, e9, ey ? th : ta);
              eT[ek] = tp,
                eN[ek] = tp - e9
            }
            et.modifiersData[el] = eN
          }
        },
        requiresIfExists: ["offset"]
      }, {
        name: "arrow",
        enabled: !0,
        phase: "main",
        fn: function (J) {
          var et, eo, el = J.state, ec = J.name, ed = J.options, eh = el.elements.arrow, ep = el.modifiersData.popperOffsets, ef = getBasePlacement(el.placement), em = getMainAxisFromPlacement(ef), eg = [rJ, rK].indexOf(ef) >= 0 ? "height" : "width";
          if (eh && ep) {
            var ey = mergePaddingObject("number" != typeof (et = "function" == typeof (et = ed.padding) ? et(Object.assign({}, el.rects, {
              placement: el.placement
            })) : et) ? et : expandToHashMap(et, rX))
              , eb = getLayoutRect(eh)
              , ew = "y" === em ? "top" : rJ
              , e_ = "y" === em ? rY : rK
              , ex = el.rects.reference[eg] + el.rects.reference[em] - ep[em] - el.rects.popper[eg]
              , eE = ep[em] - el.rects.reference[em]
              , eC = getOffsetParent(eh)
              , eS = eC ? "y" === em ? eC.clientHeight || 0 : eC.clientWidth || 0 : 0
              , ek = ey[ew]
              , eT = eS - eb[eg] - ey[e_]
              , eA = eS / 2 - eb[eg] / 2 + (ex / 2 - eE / 2)
              , eP = within(ek, eA, eT);
            el.modifiersData[ec] = ((eo = {})[em] = eP,
              eo.centerOffset = eP - eA,
              eo)
          }
        },
        effect: function (J) {
          var et = J.state
            , eo = J.options.element
            , el = void 0 === eo ? "[data-popper-arrow]" : eo;
          null != el && ("string" != typeof el || (el = et.elements.popper.querySelector(el))) && contains(et.elements.popper, el) && (et.elements.arrow = el)
        },
        requires: ["popperOffsets"],
        requiresIfExists: ["preventOverflow"]
      }, {
        name: "hide",
        enabled: !0,
        phase: "main",
        requiresIfExists: ["preventOverflow"],
        fn: function (J) {
          var et = J.state
            , eo = J.name
            , el = et.rects.reference
            , ec = et.rects.popper
            , ed = et.modifiersData.preventOverflow
            , eh = detectOverflow(et, {
              elementContext: "reference"
            })
            , ep = detectOverflow(et, {
              altBoundary: !0
            })
            , ef = getSideOffsets(eh, el)
            , em = getSideOffsets(ep, ec, ed)
            , eg = isAnySideFullyClipped(ef)
            , ey = isAnySideFullyClipped(em);
          et.modifiersData[eo] = {
            referenceClippingOffsets: ef,
            popperEscapeOffsets: em,
            isReferenceHidden: eg,
            hasPopperEscaped: ey
          },
            et.attributes.popper = Object.assign({}, et.attributes.popper, {
              "data-popper-reference-hidden": eg,
              "data-popper-escaped": ey
            })
        }
      }]
    }).defaultModifiers) ? [] : eh,
      em = void 0 === (ef = ed.defaultOptions) ? r4 : ef,
      function (J, et, eo) {
        void 0 === eo && (eo = em);
        var el, ec = {
          placement: "bottom",
          orderedModifiers: [],
          options: Object.assign({}, r4, em),
          modifiersData: {},
          elements: {
            reference: J,
            popper: et
          },
          attributes: {},
          styles: {}
        }, ed = [], eh = !1, ef = {
          state: ec,
          setOptions: function (eo) {
            var el, eh, eg, ey, eb, ew = "function" == typeof eo ? eo(ec.options) : eo;
            cleanupModifierEffects(),
              ec.options = Object.assign({}, em, ec.options, ew),
              ec.scrollParents = {
                reference: isElement(J) ? listScrollParents(J) : J.contextElement ? listScrollParents(J.contextElement) : [],
                popper: listScrollParents(et)
              };
            var e_ = (eh = Object.keys(el = [].concat(ep, ec.options.modifiers).reduce(function (J, et) {
              var eo = J[et.name];
              return J[et.name] = eo ? Object.assign({}, eo, et, {
                options: Object.assign({}, eo.options, et.options),
                data: Object.assign({}, eo.data, et.data)
              }) : et,
                J
            }, {})).map(function (J) {
              return el[J]
            }),
              eg = new Map,
              ey = new Set,
              eb = [],
              eh.forEach(function (J) {
                eg.set(J.name, J)
              }),
              eh.forEach(function (J) {
                ey.has(J.name) || function sort(J) {
                  ey.add(J.name),
                    [].concat(J.requires || [], J.requiresIfExists || []).forEach(function (J) {
                      if (!ey.has(J)) {
                        var et = eg.get(J);
                        et && sort(et)
                      }
                    }),
                    eb.push(J)
                }(J)
              }),
              r6.reduce(function (J, et) {
                return J.concat(eb.filter(function (J) {
                  return J.phase === et
                }))
              }, []));
            return ec.orderedModifiers = e_.filter(function (J) {
              return J.enabled
            }),
              ec.orderedModifiers.forEach(function (J) {
                var et = J.name
                  , eo = J.options
                  , el = J.effect;
                if ("function" == typeof el) {
                  var eh = el({
                    state: ec,
                    name: et,
                    instance: ef,
                    options: void 0 === eo ? {} : eo
                  });
                  ed.push(eh || function () { }
                  )
                }
              }),
              ef.update()
          },
          forceUpdate: function () {
            if (!eh) {
              var J, et, eo, el, ed, ep, em, eg, ey, eb, ew, e_, ex = ec.elements, eE = ex.reference, eC = ex.popper;
              if (areValidElements(eE, eC)) {
                ec.rects = {
                  reference: (et = getOffsetParent(eC),
                    eo = "fixed" === ec.options.strategy,
                    el = isHTMLElement(et),
                    eg = isHTMLElement(et) && (ep = rG((ed = et.getBoundingClientRect()).width) / et.offsetWidth || 1,
                      em = rG(ed.height) / et.offsetHeight || 1,
                      1 !== ep || 1 !== em),
                    ey = getDocumentElement(et),
                    eb = getBoundingClientRect(eE, eg, eo),
                    ew = {
                      scrollLeft: 0,
                      scrollTop: 0
                    },
                    e_ = {
                      x: 0,
                      y: 0
                    },
                    (el || !el && !eo) && (("body" !== getNodeName(et) || isScrollParent(ey)) && (ew = (J = et) !== getWindow(J) && isHTMLElement(J) ? {
                      scrollLeft: J.scrollLeft,
                      scrollTop: J.scrollTop
                    } : getWindowScroll(J)),
                      isHTMLElement(et) ? (e_ = getBoundingClientRect(et, !0),
                        e_.x += et.clientLeft,
                        e_.y += et.clientTop) : ey && (e_.x = getWindowScrollBarX(ey))),
                  {
                    x: eb.left + ew.scrollLeft - e_.x,
                    y: eb.top + ew.scrollTop - e_.y,
                    width: eb.width,
                    height: eb.height
                  }),
                  popper: getLayoutRect(eC)
                },
                  ec.reset = !1,
                  ec.placement = ec.options.placement,
                  ec.orderedModifiers.forEach(function (J) {
                    return ec.modifiersData[J.name] = Object.assign({}, J.data)
                  });
                for (var eS = 0; eS < ec.orderedModifiers.length; eS++) {
                  if (!0 === ec.reset) {
                    ec.reset = !1,
                      eS = -1;
                    continue
                  }
                  var ek = ec.orderedModifiers[eS]
                    , eT = ek.fn
                    , eA = ek.options
                    , eP = void 0 === eA ? {} : eA
                    , eR = ek.name;
                  "function" == typeof eT && (ec = eT({
                    state: ec,
                    options: eP,
                    name: eR,
                    instance: ef
                  }) || ec)
                }
              }
            }
          },
          update: function () {
            return el || (el = new Promise(function (J) {
              Promise.resolve().then(function () {
                el = void 0,
                  J(new Promise(function (J) {
                    ef.forceUpdate(),
                      J(ec)
                  }
                  ))
              })
            }
            )),
              el
          },
          destroy: function () {
            cleanupModifierEffects(),
              eh = !0
          }
        };
        if (!areValidElements(J, et))
          return ef;
        function cleanupModifierEffects() {
          ed.forEach(function (J) {
            return J()
          }),
            ed = []
        }
        return ef.setOptions(eo).then(function (J) {
          !eh && eo.onFirstUpdate && eo.onFirstUpdate(J)
        }),
          ef
      }
    );
    let no = ex.forwardRef(function (J, et) {
      let { children: eo, container: el, disablePortal: ec = !1 } = J
        , [ed, eh] = ex.useState(null)
        , ep = useForkRef(ex.isValidElement(eo) ? eo.ref : null, et);
      return (rW(() => {
        !ec && eh(("function" == typeof el ? el() : el) || document.body)
      }
        , [el, ec]),
        rW(() => {
          if (ed && !ec)
            return setRef(et, ed),
              () => {
                setRef(et, null)
              }
        }
          , [et, ed, ec]),
        ec) ? ex.isValidElement(eo) ? ex.cloneElement(eo, {
          ref: ep
        }) : (0,
          ew.jsx)(ex.Fragment, {
            children: eo
          }) : (0,
            ew.jsx)(ex.Fragment, {
              children: ed ? rO.createPortal(eo, ed) : ed
            })
    })
      , defaultGenerator = J => J
      , nl = (ec = defaultGenerator,
      {
        configure(J) {
          ec = J
        },
        generate: J => ec(J),
        reset() {
          ec = defaultGenerator
        }
      })
      , nc = {
        active: "active",
        checked: "checked",
        completed: "completed",
        disabled: "disabled",
        error: "error",
        expanded: "expanded",
        focused: "focused",
        focusVisible: "focusVisible",
        open: "open",
        readOnly: "readOnly",
        required: "required",
        selected: "selected"
      };
    function generateUtilityClass(J, et, eo = "Mui") {
      let el = nc[et];
      return el ? `${eo}-${el}` : `${nl.generate(J)}-${et}`
    }
    let nd = "base";
    function generateUtilityClass_generateUtilityClass(J, et) {
      let eo = nc[et];
      return eo ? `${nd}--${eo}` : `${nd}-${J}-${et}`
    }
    let nh = "Popper";
    function getPopperUtilityClass(J) {
      return generateUtilityClass_generateUtilityClass(nh, J)
    }
    !function (J, et) {
      let eo = {};
      et.forEach(et => {
        eo[et] = generateUtilityClass_generateUtilityClass(J, et)
      }
      )
    }(nh, ["root"]);
    var clsx_dist_clsx = function () {
      for (var J, et, eo = 0, el = "", ec = arguments.length; eo < ec; eo++)
        (J = arguments[eo]) && (et = function clsx_r(J) {
          var et, eo, el = "";
          if ("string" == typeof J || "number" == typeof J)
            el += J;
          else if ("object" == typeof J) {
            if (Array.isArray(J)) {
              var ec = J.length;
              for (et = 0; et < ec; et++)
                J[et] && (eo = clsx_r(J[et])) && (el && (el += " "),
                  el += eo)
            } else
              for (eo in J)
                J[eo] && (el && (el += " "),
                  el += eo)
          }
          return el
        }(J)) && (el && (el += " "),
          el += et);
      return el
    };
    function omitEventHandlers(J) {
      if (void 0 === J)
        return {};
      let et = {};
      return Object.keys(J).filter(et => !(et.match(/^on[A-Z]/) && "function" == typeof J[et])).forEach(eo => {
        et[eo] = J[eo]
      }
      ),
        et
    }
    let np = ["elementType", "externalSlotProps", "ownerState", "skipResolvingSlotProps"]
      , nf = ex.createContext({
        disableDefaultClasses: !1
      })
      , nm = ["anchorEl", "children", "direction", "disablePortal", "modifiers", "open", "placement", "popperOptions", "popperRef", "slotProps", "slots", "TransitionProps", "ownerState"]
      , ng = ["anchorEl", "children", "container", "direction", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "style", "transition", "slotProps", "slots"];
    function resolveAnchorEl(J) {
      return "function" == typeof J ? J() : J
    }
    let useUtilityClasses = () => composeClasses({
      root: ["root"]
    }, function (J) {
      let { disableDefaultClasses: et } = ex.useContext(nf);
      return eo => et ? "" : J(eo)
    }(getPopperUtilityClass))
      , ny = {}
      , nb = ex.forwardRef(function (J, et) {
        var eo;
        let { anchorEl: el, children: ec, direction: ed, disablePortal: eh, modifiers: ep, open: ef, placement: em, popperOptions: eg, popperRef: ey, slotProps: eb = {}, slots: e_ = {}, TransitionProps: eE } = J
          , eC = helpers_esm_objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(J, nm)
          , eS = ex.useRef(null)
          , ek = useForkRef(eS, et)
          , eT = ex.useRef(null)
          , eA = useForkRef(eT, ey)
          , eP = ex.useRef(eA);
        rW(() => {
          eP.current = eA
        }
          , [eA]),
          ex.useImperativeHandle(ey, () => eT.current, []);
        let eR = function (J, et) {
          if ("ltr" === et)
            return J;
          switch (J) {
            case "bottom-end":
              return "bottom-start";
            case "bottom-start":
              return "bottom-end";
            case "top-end":
              return "top-start";
            case "top-start":
              return "top-end";
            default:
              return J
          }
        }(em, ed)
          , [eI, eO] = ex.useState(eR)
          , [eN, eM] = ex.useState(resolveAnchorEl(el));
        ex.useEffect(() => {
          eT.current && eT.current.forceUpdate()
        }
        ),
          ex.useEffect(() => {
            el && eM(resolveAnchorEl(el))
          }
            , [el]),
          rW(() => {
            if (!eN || !ef)
              return;
            let handlePopperUpdate = J => {
              eO(J.placement)
            }
              , J = [{
                name: "preventOverflow",
                options: {
                  altBoundary: eh
                }
              }, {
                name: "flip",
                options: {
                  altBoundary: eh
                }
              }, {
                name: "onUpdate",
                enabled: !0,
                phase: "afterWrite",
                fn: ({ state: J }) => {
                  handlePopperUpdate(J)
                }
              }];
            null != ep && (J = J.concat(ep)),
              eg && null != eg.modifiers && (J = J.concat(eg.modifiers));
            let et = ns(eN, eS.current, runtime_helpers_esm_extends_extends({
              placement: eR
            }, eg, {
              modifiers: J
            }));
            return eP.current(et),
              () => {
                et.destroy(),
                  eP.current(null)
              }
          }
            , [eN, eh, ep, ef, eg, eR]);
        let eD = {
          placement: eI
        };
        null !== eE && (eD.TransitionProps = eE);
        let ej = useUtilityClasses()
          , eL = null != (eo = e_.root) ? eo : "div"
          , e$ = function (J) {
            var et;
            let { elementType: eo, externalSlotProps: el, ownerState: ec, skipResolvingSlotProps: ed = !1 } = J
              , eh = helpers_esm_objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(J, np)
              , ep = ed ? {} : "function" == typeof el ? el(ec, void 0) : el
              , { props: ef, internalRef: em } = function (J) {
                let { getSlotProps: et, additionalProps: eo, externalSlotProps: el, externalForwardedProps: ec, className: ed } = J;
                if (!et) {
                  let J = clsx_dist_clsx(null == eo ? void 0 : eo.className, ed, null == ec ? void 0 : ec.className, null == el ? void 0 : el.className)
                    , et = runtime_helpers_esm_extends_extends({}, null == eo ? void 0 : eo.style, null == ec ? void 0 : ec.style, null == el ? void 0 : el.style)
                    , eh = runtime_helpers_esm_extends_extends({}, eo, ec, el);
                  return J.length > 0 && (eh.className = J),
                    Object.keys(et).length > 0 && (eh.style = et),
                  {
                    props: eh,
                    internalRef: void 0
                  }
                }
                let eh = function (J, et = []) {
                  if (void 0 === J)
                    return {};
                  let eo = {};
                  return Object.keys(J).filter(eo => eo.match(/^on[A-Z]/) && "function" == typeof J[eo] && !et.includes(eo)).forEach(et => {
                    eo[et] = J[et]
                  }
                  ),
                    eo
                }(runtime_helpers_esm_extends_extends({}, ec, el))
                  , ep = omitEventHandlers(el)
                  , ef = omitEventHandlers(ec)
                  , em = et(eh)
                  , eg = clsx_dist_clsx(null == em ? void 0 : em.className, null == eo ? void 0 : eo.className, ed, null == ec ? void 0 : ec.className, null == el ? void 0 : el.className)
                  , ey = runtime_helpers_esm_extends_extends({}, null == em ? void 0 : em.style, null == eo ? void 0 : eo.style, null == ec ? void 0 : ec.style, null == el ? void 0 : el.style)
                  , eb = runtime_helpers_esm_extends_extends({}, em, eo, ef, ep);
                return eg.length > 0 && (eb.className = eg),
                  Object.keys(ey).length > 0 && (eb.style = ey),
                {
                  props: eb,
                  internalRef: em.ref
                }
              }(runtime_helpers_esm_extends_extends({}, eh, {
                externalSlotProps: ep
              }))
              , eg = useForkRef(em, null == ep ? void 0 : ep.ref, null == (et = J.additionalProps) ? void 0 : et.ref)
              , ey = appendOwnerState(eo, runtime_helpers_esm_extends_extends({}, ef, {
                ref: eg
              }), ec);
            return ey
          }({
            elementType: eL,
            externalSlotProps: eb.root,
            externalForwardedProps: eC,
            additionalProps: {
              role: "tooltip",
              ref: ek
            },
            ownerState: J,
            className: ej.root
          });
        return (0,
          ew.jsx)(eL, runtime_helpers_esm_extends_extends({}, e$, {
            children: "function" == typeof ec ? ec(eD) : ec
          }))
      })
      , nw = ex.forwardRef(function (J, et) {
        let eo;
        let { anchorEl: el, children: ec, container: ed, direction: eh = "ltr", disablePortal: ep = !1, keepMounted: ef = !1, modifiers: em, open: eg, placement: ey = "bottom", popperOptions: eb = ny, popperRef: e_, style: eE, transition: eC = !1, slotProps: eS = {}, slots: ek = {} } = J
          , eT = helpers_esm_objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(J, ng)
          , [eA, eP] = ex.useState(!0);
        if (!ef && !eg && (!eC || eA))
          return null;
        if (ed)
          eo = ed;
        else if (el) {
          let J = resolveAnchorEl(el);
          eo = J && void 0 !== J.nodeType ? ownerDocument(J).body : ownerDocument(null).body
        }
        let eR = !eg && ef && (!eC || eA) ? "none" : void 0;
        return (0,
          ew.jsx)(no, {
            disablePortal: ep,
            container: eo,
            children: (0,
              ew.jsx)(nb, runtime_helpers_esm_extends_extends({
                anchorEl: el,
                direction: eh,
                disablePortal: ep,
                modifiers: em,
                ref: et,
                open: eC ? !eA : eg,
                placement: ey,
                popperOptions: eb,
                popperRef: e_,
                slotProps: eS,
                slots: ek
              }, eT, {
                style: runtime_helpers_esm_extends_extends({
                  position: "fixed",
                  top: 0,
                  left: 0,
                  display: eR
                }, eE),
                TransitionProps: eC ? {
                  in: eg,
                  onEnter: () => {
                    eP(!1)
                  }
                  ,
                  onExited: () => {
                    eP(!0)
                  }
                } : void 0,
                children: ec
              }))
          })
      })
      , n_ = ["anchorEl", "component", "components", "componentsProps", "container", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "transition", "slots", "slotProps"]
      , nx = rR(nw, {
        name: "MuiPopper",
        slot: "Root",
        overridesResolver: (J, et) => et.root
      })({})
      , nE = ex.forwardRef(function (J, et) {
        var eo;
        let el = useThemeWithoutDefault()
          , ec = useThemeProps_useThemeProps({
            props: J,
            name: "MuiPopper"
          })
          , { anchorEl: ed, component: eh, components: ep, componentsProps: ef, container: em, disablePortal: eg, keepMounted: ey, modifiers: eb, open: e_, placement: ex, popperOptions: eE, popperRef: eC, transition: eS, slots: ek, slotProps: eT } = ec
          , eA = objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(ec, n_)
          , eP = null != (eo = null == ek ? void 0 : ek.root) ? eo : null == ep ? void 0 : ep.Root
          , eR = helpers_esm_extends_extends({
            anchorEl: ed,
            container: em,
            disablePortal: eg,
            keepMounted: ey,
            modifiers: eb,
            open: e_,
            placement: ex,
            popperOptions: eE,
            popperRef: eC,
            transition: eS
          }, eA);
        return (0,
          ew.jsx)(nx, helpers_esm_extends_extends({
            as: eh,
            direction: null == el ? void 0 : el.direction,
            slots: {
              root: eP
            },
            slotProps: null != eT ? eT : ef
          }, eR, {
            ref: et
          }))
      });
    var utils_useEventCallback = function (J) {
      let et = ex.useRef(J);
      return rW(() => {
        et.current = J
      }
      ),
        ex.useRef((...J) => (0,
          et.current)(...J)).current
    };
    let nC = 0
      , nS = eE["useId".toString()];
    var utils_useId = function (J) {
      if (void 0 !== nS) {
        let et = nS();
        return null != J ? J : et
      }
      return function (J) {
        let [et, eo] = ex.useState(J)
          , el = J || et;
        return ex.useEffect(() => {
          null == et && (nC += 1,
            eo(`mui-${nC}`))
        }
          , [et]),
          el
      }(J)
    };
    let nk = !0
      , nT = !1
      , nA = {
        text: !0,
        search: !0,
        url: !0,
        tel: !0,
        email: !0,
        password: !0,
        number: !0,
        date: !0,
        month: !0,
        week: !0,
        time: !0,
        datetime: !0,
        "datetime-local": !0
      };
    function handleKeyDown(J) {
      J.metaKey || J.altKey || J.ctrlKey || (nk = !0)
    }
    function handlePointerDown() {
      nk = !1
    }
    function handleVisibilityChange() {
      "hidden" === this.visibilityState && nT && (nk = !0)
    }
    var utils_useIsFocusVisible = function () {
      let J = ex.useCallback(J => {
        if (null != J) {
          var et;
          (et = J.ownerDocument).addEventListener("keydown", handleKeyDown, !0),
            et.addEventListener("mousedown", handlePointerDown, !0),
            et.addEventListener("pointerdown", handlePointerDown, !0),
            et.addEventListener("touchstart", handlePointerDown, !0),
            et.addEventListener("visibilitychange", handleVisibilityChange, !0)
        }
      }
        , [])
        , et = ex.useRef(!1);
      return {
        isFocusVisibleRef: et,
        onFocus: function (J) {
          return !!function (J) {
            let { target: et } = J;
            try {
              return et.matches(":focus-visible")
            } catch (J) { }
            return nk || function (J) {
              let { type: et, tagName: eo } = J;
              return "INPUT" === eo && !!nA[et] && !J.readOnly || "TEXTAREA" === eo && !J.readOnly || !!J.isContentEditable
            }(et)
          }(J) && (et.current = !0,
            !0)
        },
        onBlur: function () {
          return !!et.current && (nT = !0,
            window.clearTimeout(el),
            el = window.setTimeout(() => {
              nT = !1
            }
              , 100),
            et.current = !1,
            !0)
        },
        ref: J
      }
    }
      , utils_useControlled = function ({ controlled: J, default: et, name: eo, state: el = "value" }) {
        let { current: ec } = ex.useRef(void 0 !== J)
          , [ed, eh] = ex.useState(et)
          , ep = ec ? J : ed
          , ef = ex.useCallback(J => {
            ec || eh(J)
          }
            , []);
        return [ep, ef]
      };
    function getTooltipUtilityClass(J) {
      return generateUtilityClass("MuiTooltip", J)
    }
    let nP = function (J, et, eo = "Mui") {
      let el = {};
      return et.forEach(et => {
        el[et] = generateUtilityClass(J, et, eo)
      }
      ),
        el
    }("MuiTooltip", ["popper", "popperInteractive", "popperArrow", "popperClose", "tooltip", "tooltipArrow", "touch", "tooltipPlacementLeft", "tooltipPlacementRight", "tooltipPlacementTop", "tooltipPlacementBottom", "arrow"])
      , nR = ["arrow", "children", "classes", "components", "componentsProps", "describeChild", "disableFocusListener", "disableHoverListener", "disableInteractive", "disableTouchListener", "enterDelay", "enterNextDelay", "enterTouchDelay", "followCursor", "id", "leaveDelay", "leaveTouchDelay", "onClose", "onOpen", "open", "placement", "PopperComponent", "PopperProps", "slotProps", "slots", "title", "TransitionComponent", "TransitionProps"]
      , Tooltip_useUtilityClasses = J => {
        let { classes: et, disableInteractive: eo, arrow: el, touch: ec, placement: ed } = J
          , eh = {
            popper: ["popper", !eo && "popperInteractive", el && "popperArrow"],
            tooltip: ["tooltip", el && "tooltipArrow", ec && "touch", `tooltipPlacement${capitalize(ed.split("-")[0])}`],
            arrow: ["arrow"]
          };
        return composeClasses(eh, getTooltipUtilityClass, et)
      }
      , nI = rR(nE, {
        name: "MuiTooltip",
        slot: "Popper",
        overridesResolver: (J, et) => {
          let { ownerState: eo } = J;
          return [et.popper, !eo.disableInteractive && et.popperInteractive, eo.arrow && et.popperArrow, !eo.open && et.popperClose]
        }
      })(({ theme: J, ownerState: et, open: eo }) => helpers_esm_extends_extends({
        zIndex: (J.vars || J).zIndex.tooltip,
        pointerEvents: "none"
      }, !et.disableInteractive && {
        pointerEvents: "auto"
      }, !eo && {
        pointerEvents: "none"
      }, et.arrow && {
        [`&[data-popper-placement*="bottom"] .${nP.arrow}`]: {
          top: 0,
          marginTop: "-0.71em",
          "&::before": {
            transformOrigin: "0 100%"
          }
        },
        [`&[data-popper-placement*="top"] .${nP.arrow}`]: {
          bottom: 0,
          marginBottom: "-0.71em",
          "&::before": {
            transformOrigin: "100% 0"
          }
        },
        [`&[data-popper-placement*="right"] .${nP.arrow}`]: helpers_esm_extends_extends({}, et.isRtl ? {
          right: 0,
          marginRight: "-0.71em"
        } : {
          left: 0,
          marginLeft: "-0.71em"
        }, {
          height: "1em",
          width: "0.71em",
          "&::before": {
            transformOrigin: "100% 100%"
          }
        }),
        [`&[data-popper-placement*="left"] .${nP.arrow}`]: helpers_esm_extends_extends({}, et.isRtl ? {
          left: 0,
          marginLeft: "-0.71em"
        } : {
          right: 0,
          marginRight: "-0.71em"
        }, {
          height: "1em",
          width: "0.71em",
          "&::before": {
            transformOrigin: "0 0"
          }
        })
      }))
      , nO = rR("div", {
        name: "MuiTooltip",
        slot: "Tooltip",
        overridesResolver: (J, et) => {
          let { ownerState: eo } = J;
          return [et.tooltip, eo.touch && et.touch, eo.arrow && et.tooltipArrow, et[`tooltipPlacement${capitalize(eo.placement.split("-")[0])}`]]
        }
      })(({ theme: J, ownerState: et }) => helpers_esm_extends_extends({
        backgroundColor: J.vars ? J.vars.palette.Tooltip.bg : alpha(J.palette.grey[700], .92),
        borderRadius: (J.vars || J).shape.borderRadius,
        color: (J.vars || J).palette.common.white,
        fontFamily: J.typography.fontFamily,
        padding: "4px 8px",
        fontSize: J.typography.pxToRem(11),
        maxWidth: 300,
        margin: 2,
        wordWrap: "break-word",
        fontWeight: J.typography.fontWeightMedium
      }, et.arrow && {
        position: "relative",
        margin: 0
      }, et.touch && {
        padding: "8px 16px",
        fontSize: J.typography.pxToRem(14),
        lineHeight: `${Math.round(1e5 * (16 / 14)) / 1e5}em`,
        fontWeight: J.typography.fontWeightRegular
      }, {
        [`.${nP.popper}[data-popper-placement*="left"] &`]: helpers_esm_extends_extends({
          transformOrigin: "right center"
        }, et.isRtl ? helpers_esm_extends_extends({
          marginLeft: "14px"
        }, et.touch && {
          marginLeft: "24px"
        }) : helpers_esm_extends_extends({
          marginRight: "14px"
        }, et.touch && {
          marginRight: "24px"
        })),
        [`.${nP.popper}[data-popper-placement*="right"] &`]: helpers_esm_extends_extends({
          transformOrigin: "left center"
        }, et.isRtl ? helpers_esm_extends_extends({
          marginRight: "14px"
        }, et.touch && {
          marginRight: "24px"
        }) : helpers_esm_extends_extends({
          marginLeft: "14px"
        }, et.touch && {
          marginLeft: "24px"
        })),
        [`.${nP.popper}[data-popper-placement*="top"] &`]: helpers_esm_extends_extends({
          transformOrigin: "center bottom",
          marginBottom: "14px"
        }, et.touch && {
          marginBottom: "24px"
        }),
        [`.${nP.popper}[data-popper-placement*="bottom"] &`]: helpers_esm_extends_extends({
          transformOrigin: "center top",
          marginTop: "14px"
        }, et.touch && {
          marginTop: "24px"
        })
      }))
      , nN = rR("span", {
        name: "MuiTooltip",
        slot: "Arrow",
        overridesResolver: (J, et) => et.arrow
      })(({ theme: J }) => ({
        overflow: "hidden",
        position: "absolute",
        width: "1em",
        height: "0.71em",
        boxSizing: "border-box",
        color: J.vars ? J.vars.palette.Tooltip.bg : alpha(J.palette.grey[700], .9),
        "&::before": {
          content: '""',
          margin: "auto",
          display: "block",
          width: "100%",
          height: "100%",
          backgroundColor: "currentColor",
          transform: "rotate(45deg)"
        }
      }))
      , nM = !1
      , nD = null
      , nj = {
        x: 0,
        y: 0
      };
    function composeEventHandler(J, et) {
      return eo => {
        et && et(eo),
          J(eo)
      }
    }
    let nL = ex.forwardRef(function (J, et) {
      var eo, el, ec, ed, eh, ep, ef, em, eg, ey, eb, e_, eE, eC, eS, ek, eT, eA, eP;
      let eR = useThemeProps_useThemeProps({
        props: J,
        name: "MuiTooltip"
      })
        , { arrow: eI = !1, children: eO, components: eN = {}, componentsProps: eM = {}, describeChild: eD = !1, disableFocusListener: ej = !1, disableHoverListener: eL = !1, disableInteractive: e$ = !1, disableTouchListener: eB = !1, enterDelay: eF = 100, enterNextDelay: eU = 0, enterTouchDelay: ez = 700, followCursor: eH = !1, id: eV, leaveDelay: eW = 0, leaveTouchDelay: eZ = 1500, onClose: eG, onOpen: eY, open: eK, placement: eJ = "bottom", PopperComponent: eQ, PopperProps: eX = {}, slotProps: e0 = {}, slots: e1 = {}, title: e2, TransitionComponent: e3 = rV, TransitionProps: e5 } = eR
        , e6 = objectWithoutPropertiesLoose_objectWithoutPropertiesLoose(eR, nR)
        , e4 = ex.isValidElement(eO) ? eO : (0,
          ew.jsx)("span", {
            children: eO
          })
        , e8 = styles_useTheme_useTheme()
        , e7 = "rtl" === e8.direction
        , [e9, tn] = ex.useState()
        , [to, ta] = ex.useState(null)
        , tl = ex.useRef(!1)
        , tc = e$ || eH
        , td = ex.useRef()
        , th = ex.useRef()
        , tp = ex.useRef()
        , tf = ex.useRef()
        , [tm, tg] = utils_useControlled({
          controlled: eK,
          default: !1,
          name: "Tooltip",
          state: "open"
        })
        , ty = tm
        , tb = utils_useId(eV)
        , tw = ex.useRef()
        , t_ = ex.useCallback(() => {
          void 0 !== tw.current && (document.body.style.WebkitUserSelect = tw.current,
            tw.current = void 0),
            clearTimeout(tf.current)
        }
          , []);
      ex.useEffect(() => () => {
        clearTimeout(td.current),
          clearTimeout(th.current),
          clearTimeout(tp.current),
          t_()
      }
        , [t_]);
      let handleOpen = J => {
        clearTimeout(nD),
          nM = !0,
          tg(!0),
          eY && !ty && eY(J)
      }
        , tx = utils_useEventCallback(J => {
          clearTimeout(nD),
            nD = setTimeout(() => {
              nM = !1
            }
              , 800 + eW),
            tg(!1),
            eG && ty && eG(J),
            clearTimeout(td.current),
            td.current = setTimeout(() => {
              tl.current = !1
            }
              , e8.transitions.duration.shortest)
        }
        )
        , handleEnter = J => {
          tl.current && "touchstart" !== J.type || (e9 && e9.removeAttribute("title"),
            clearTimeout(th.current),
            clearTimeout(tp.current),
            eF || nM && eU ? th.current = setTimeout(() => {
              handleOpen(J)
            }
              , nM ? eU : eF) : handleOpen(J))
        }
        , handleLeave = J => {
          clearTimeout(th.current),
            clearTimeout(tp.current),
            tp.current = setTimeout(() => {
              tx(J)
            }
              , eW)
        }
        , { isFocusVisibleRef: tE, onBlur: tC, onFocus: tS, ref: tk } = utils_useIsFocusVisible()
        , [, tT] = ex.useState(!1)
        , handleBlur = J => {
          tC(J),
            !1 === tE.current && (tT(!1),
              handleLeave(J))
        }
        , handleFocus = J => {
          e9 || tn(J.currentTarget),
            tS(J),
            !0 === tE.current && (tT(!0),
              handleEnter(J))
        }
        , detectTouchStart = J => {
          tl.current = !0;
          let et = e4.props;
          et.onTouchStart && et.onTouchStart(J)
        }
        ;
      ex.useEffect(() => {
        if (ty)
          return document.addEventListener("keydown", handleKeyDown),
            () => {
              document.removeEventListener("keydown", handleKeyDown)
            }
            ;
        function handleKeyDown(J) {
          ("Escape" === J.key || "Esc" === J.key) && tx(J)
        }
      }
        , [tx, ty]);
      let tA = useForkRef(e4.ref, tk, tn, et);
      e2 || 0 === e2 || (ty = !1);
      let tP = ex.useRef()
        , tR = {}
        , tI = "string" == typeof e2;
      eD ? (tR.title = ty || !tI || eL ? null : e2,
        tR["aria-describedby"] = ty ? tb : null) : (tR["aria-label"] = tI ? e2 : null,
          tR["aria-labelledby"] = ty && !tI ? tb : null);
      let tO = helpers_esm_extends_extends({}, tR, e6, e4.props, {
        className: dist_clsx(e6.className, e4.props.className),
        onTouchStart: detectTouchStart,
        ref: tA
      }, eH ? {
        onMouseMove: J => {
          let et = e4.props;
          et.onMouseMove && et.onMouseMove(J),
            nj = {
              x: J.clientX,
              y: J.clientY
            },
            tP.current && tP.current.update()
        }
      } : {})
        , tN = {};
      eB || (tO.onTouchStart = J => {
        detectTouchStart(J),
          clearTimeout(tp.current),
          clearTimeout(td.current),
          t_(),
          tw.current = document.body.style.WebkitUserSelect,
          document.body.style.WebkitUserSelect = "none",
          tf.current = setTimeout(() => {
            document.body.style.WebkitUserSelect = tw.current,
              handleEnter(J)
          }
            , ez)
      }
        ,
        tO.onTouchEnd = J => {
          e4.props.onTouchEnd && e4.props.onTouchEnd(J),
            t_(),
            clearTimeout(tp.current),
            tp.current = setTimeout(() => {
              tx(J)
            }
              , eZ)
        }
      ),
        eL || (tO.onMouseOver = composeEventHandler(handleEnter, tO.onMouseOver),
          tO.onMouseLeave = composeEventHandler(handleLeave, tO.onMouseLeave),
          tc || (tN.onMouseOver = handleEnter,
            tN.onMouseLeave = handleLeave)),
        ej || (tO.onFocus = composeEventHandler(handleFocus, tO.onFocus),
          tO.onBlur = composeEventHandler(handleBlur, tO.onBlur),
          tc || (tN.onFocus = handleFocus,
            tN.onBlur = handleBlur));
      let tM = ex.useMemo(() => {
        var J;
        let et = [{
          name: "arrow",
          enabled: !!to,
          options: {
            element: to,
            padding: 4
          }
        }];
        return null != (J = eX.popperOptions) && J.modifiers && (et = et.concat(eX.popperOptions.modifiers)),
          helpers_esm_extends_extends({}, eX.popperOptions, {
            modifiers: et
          })
      }
        , [to, eX])
        , tD = helpers_esm_extends_extends({}, eR, {
          isRtl: e7,
          arrow: eI,
          disableInteractive: tc,
          placement: eJ,
          PopperComponentProp: eQ,
          touch: tl.current
        })
        , tj = Tooltip_useUtilityClasses(tD)
        , tL = null != (eo = null != (el = e1.popper) ? el : eN.Popper) ? eo : nI
        , t$ = null != (ec = null != (ed = null != (eh = e1.transition) ? eh : eN.Transition) ? ed : e3) ? ec : rV
        , tB = null != (ep = null != (ef = e1.tooltip) ? ef : eN.Tooltip) ? ep : nO
        , tF = null != (em = null != (eg = e1.arrow) ? eg : eN.Arrow) ? em : nN
        , tU = appendOwnerState(tL, helpers_esm_extends_extends({}, eX, null != (ey = e0.popper) ? ey : eM.popper, {
          className: dist_clsx(tj.popper, null == eX ? void 0 : eX.className, null == (eb = null != (e_ = e0.popper) ? e_ : eM.popper) ? void 0 : eb.className)
        }), tD)
        , tz = appendOwnerState(t$, helpers_esm_extends_extends({}, e5, null != (eE = e0.transition) ? eE : eM.transition), tD)
        , tH = appendOwnerState(tB, helpers_esm_extends_extends({}, null != (eC = e0.tooltip) ? eC : eM.tooltip, {
          className: dist_clsx(tj.tooltip, null == (eS = null != (ek = e0.tooltip) ? ek : eM.tooltip) ? void 0 : eS.className)
        }), tD)
        , tV = appendOwnerState(tF, helpers_esm_extends_extends({}, null != (eT = e0.arrow) ? eT : eM.arrow, {
          className: dist_clsx(tj.arrow, null == (eA = null != (eP = e0.arrow) ? eP : eM.arrow) ? void 0 : eA.className)
        }), tD);
      return (0,
        ew.jsxs)(ex.Fragment, {
          children: [ex.cloneElement(e4, tO), (0,
            ew.jsx)(tL, helpers_esm_extends_extends({
              as: null != eQ ? eQ : nE,
              placement: eJ,
              anchorEl: eH ? {
                getBoundingClientRect: () => ({
                  top: nj.y,
                  left: nj.x,
                  right: nj.x,
                  bottom: nj.y,
                  width: 0,
                  height: 0
                })
              } : e9,
              popperRef: tP,
              open: !!e9 && ty,
              id: tb,
              transition: !0
            }, tN, tU, {
              popperOptions: tM,
              children: ({ TransitionProps: J }) => (0,
                ew.jsx)(t$, helpers_esm_extends_extends({
                  timeout: e8.transitions.duration.shorter
                }, J, tz, {
                  children: (0,
                    ew.jsxs)(tB, helpers_esm_extends_extends({}, tH, {
                      children: [e2, eI ? (0,
                        ew.jsx)(tF, helpers_esm_extends_extends({}, tV, {
                          ref: ta
                        })) : null]
                    }))
                }))
            }))]
        })
    })
      , n$ = rR(J => {
        let { className: et, open: eo, hover: el, ...ec } = J;
        return (0,
          ew.jsx)(nL, {
            ...ec,
            classes: {
              popper: et
            },
            disableHoverListener: !el,
            open: eo && !el
          })
      }
      )(J => {
        let { width: et = 212 } = J;
        return {
          ["& .".concat(nP.tooltip)]: {
            backgroundColor: "#DEDEDE",
            color: "#000000",
            width: et,
            fontSize: 10,
            border: "1px solid #000",
            borderRadius: 8,
            paddingBlock: 0,
            paddingInline: 0,
            fontFamily: "easvhs"
          }
        }
      }
      );
    var base_TooltipCustom = J => {
      let { children: et, title: eo, open: el = !1, hover: ec = !1, setOpen: ed = () => { }
        , placement: eh = "top", ...ep } = J;
      return (0,
        ew.jsx)(n$, {
          title: (0,
            ew.jsxs)("div", {
              className: "flex items-start gap-[2px] justify-between px-[4px] py-[8px]",
              children: [(0,
                ew.jsx)("div", {
                  className: "w-max max-w-full flex-1 pl-[4px]",
                  children: eo
                }), (0,
                  ew.jsx)(ek(), {
                    src: "/imgs/svgs/close.svg",
                    alt: "",
                    width: 13,
                    height: 13,
                    className: "cursor-pointer",
                    onClick: () => {
                      ed(!1)
                    }
                  })]
            }),
          open: el,
          hover: ec,
          placement: eh,
          ...ep,
          children: et
        })
    }
      ;
    let nB = [{
      img: "/imgs/tooltip_info_1.png",
      name: "Incubator",
      desc: (0,
        ew.jsxs)(ew.Fragment, {
          children: ["1 < ", (0,
            ew.jsx)("span", {
              className: "font-bold",
              children: "Incubator"
            }), " ≤ 4,800"]
        }),
      value: 1
    }, {
      img: "/imgs/tooltip_info_2.png",
      name: "Mobie",
      desc: (0,
        ew.jsxs)(ew.Fragment, {
          children: ["4,800 < ", (0,
            ew.jsx)("span", {
              className: "font-bold",
              children: "Mobie"
            }), " ≤ 9,600"]
        }),
      value: 4800
    }, {
      img: "/imgs/tooltip_info_3.png",
      name: "Citizen",
      desc: (0,
        ew.jsxs)(ew.Fragment, {
          children: ["9,600 < ", (0,
            ew.jsx)("span", {
              className: "font-bold",
              children: "Citizen"
            }), " ≤ 19,200"]
        }),
      value: 9600
    }, {
      img: "/imgs/tooltip_info_4.png",
      name: "Mayor",
      desc: (0,
        ew.jsxs)(ew.Fragment, {
          children: ["19,200 < ", (0,
            ew.jsx)("span", {
              className: "font-bold",
              children: "Mayor"
            }), " ≤ 38,400"]
        }),
      value: 19200
    }, {
      img: "/imgs/tooltip_info_5.png",
      name: "Senator",
      desc: (0,
        ew.jsxs)(ew.Fragment, {
          children: ["38,400 < ", (0,
            ew.jsx)("span", {
              className: "font-bold",
              children: "Senator"
            }), " ≤ 57,600"]
        }),
      value: 38400
    }, {
      img: "/imgs/tooltip_info_6.png",
      name: "Governor",
      desc: (0,
        ew.jsxs)(ew.Fragment, {
          children: ["57,600 < ", (0,
            ew.jsx)("span", {
              className: "font-bold",
              children: "Governor"
            }), " ≤ 144,000"]
        }),
      value: 57600
    }, {
      img: "/imgs/tooltip_info_7.png",
      name: "President",
      desc: (0,
        ew.jsxs)(ew.Fragment, {
          children: ["144,000 < ", (0,
            ew.jsx)("span", {
              className: "font-bold",
              children: "President"
            })]
        }),
      value: 144e3
    }];
    function UserTiers(J) {
      let { prevTimestampSnapshot: et } = J
        , [eo, el] = (0,
          ex.useState)(!1)
        , { address: ec } = (0,
          eC.m)()
        , [ed, eh] = (0,
          ex.useState)(null)
        , { data: ep } = (0,
          eL.Z)({
            functionName: "stakedAmount",
            args: [ec],
            type: "moby-staking"
          });
      return (0,
        ex.useEffect)(() => {
          var J;
          let et = Number((0,
            eM.dF)(null !== (J = String(null != ep ? ep : 0)) && void 0 !== J ? J : "0"))
            , eo = nB.find((J, eo) => {
              let el = eo >= nB.length - 1 ? Number.POSITIVE_INFINITY : nB[eo + 1].value;
              return J.value < et && el >= et
            }
            );
          eh(null != eo ? eo : null)
        }
          , [ep]),
        (0,
          ew.jsxs)("div", {
            className: "grid grid-cols-2 gap-[4px] font-[400] text-[10px] text-[#808080] mx-[7px] my-[2px]",
            children: [(0,
              ew.jsx)("div", {
                className: "h-full border-solid border-2 border-l-[#808080] border-t-[#808080] border-r-[#FFF] border-b-[#FFF]",
                children: (0,
                  ew.jsxs)("div", {
                    className: "h-full p-[12px] border-solid border-2 border-l-[#FFF] border-t-[#FFF] border-r-[#808080] border-b-[#808080]",
                    children: [(0,
                      ew.jsxs)("div", {
                        className: "flex justify-between mb-[4px]",
                        children: [(0,
                          ew.jsx)("p", {
                            className: "text-[#808080]",
                            children: "Your Tier"
                          }), (0,
                            ew.jsx)(base_TooltipCustom, {
                              width: 266,
                              title: (0,
                                ew.jsxs)("div", {
                                  children: [(0,
                                    ew.jsx)("p", {
                                      className: "text-[10px] font-[400]",
                                      children: "Moby's Staking and Governance Tiers"
                                    }), (0,
                                      ew.jsx)("div", {
                                        className: "flex flex-col gap-[6px] mt-[5px]",
                                        children: nB.map((J, et) => (0,
                                          ew.jsxs)("div", {
                                            className: "flex justify-between items-center text-[10px]",
                                            children: [(0,
                                              ew.jsxs)("div", {
                                                className: "flex gap-x-2",
                                                children: [(0,
                                                  ew.jsx)(ek(), {
                                                    src: J.img,
                                                    alt: "",
                                                    className: "object-contain",
                                                    height: 12,
                                                    width: 40
                                                  }), (0,
                                                    ew.jsx)("p", {
                                                      children: J.name
                                                    })]
                                              }), (0,
                                                ew.jsx)("p", {
                                                  children: J.desc
                                                })]
                                          }, et))
                                      })]
                                }),
                              open: eo,
                              setOpen: el,
                              children: (0,
                                ew.jsx)(ek(), {
                                  src: "/imgs/svgs/question-round.svg",
                                  alt: "",
                                  width: 16,
                                  height: 16,
                                  className: "cursor-pointer",
                                  onClick: () => {
                                    el(!eo)
                                  }
                                })
                            })]
                      }), ed ? (0,
                        ew.jsxs)("div", {
                          className: "flex gap-x-2",
                          children: [(0,
                            ew.jsx)(ek(), {
                              width: 40,
                              height: 21,
                              className: "object-contain object-center",
                              src: null == ed ? void 0 : ed.img,
                              alt: ""
                            }), (0,
                              ew.jsx)("p", {
                                className: "text-[14px] text-black",
                                children: null == ed ? void 0 : ed.name
                              })]
                        }) : (0,
                          ew.jsx)("p", {
                            className: "text-[14px] text-black",
                            children: "---"
                          })]
                  })
              }), (0,
                ew.jsx)("div", {
                  className: "h-full border-solid border-2 border-l-[#808080] border-t-[#808080] border-r-[#FFF] border-b-[#FFF]",
                  children: (0,
                    ew.jsxs)("div", {
                      className: "h-full p-[12px] border-solid border-2 border-l-[#FFF] border-t-[#FFF] border-r-[#808080] border-b-[#808080]",
                      children: [(0,
                        ew.jsx)("p", {
                          className: "text-[#808080] mb-[4px]",
                          children: "Your Staking"
                        }), (0,
                          ew.jsx)("p", {
                            className: "text-[14px] text-black",
                            children: "".concat((0,
                              e$.uf)((0,
                                eM.dF)(null != ep ? ep : "0")), " MOBY")
                          }), (0,
                            ew.jsx)("p", {
                              className: "text-[#000080] text-[10px] mt-[4px]",
                              children: et ? "Last snapshot: ".concat(ej().unix(et).format("DD MMM YYYY")) : "--"
                            })]
                    })
                })]
          })
    }
    var hooks_useSnapshot = J => {
      let { minDate: et = "02-23-2024", maxDate: eo = "02-23-2100" } = null != J ? J : {}
        , [el, ec] = (0,
          ex.useState)(0)
        , [ed, eh] = (0,
          ex.useState)(void 0);
      return (0,
        ex.useEffect)(() => {
          let J = ej()().utc().day(5);
          (ej()().utc().day() > 5 || 5 === ej()().utc().day() && ej()().utc().hour() >= 14) && J.add(1, "weeks");
          let el = ej().utc(et, "DD-MM-YYYY");
          J.isBefore(el) && (J = el);
          let ed = ej().utc(eo, "DD-MM-YYYY");
          J.isAfter(ed) && (J = ed),
            J.set({
              hour: 14,
              minute: 0,
              second: 0,
              millisecond: 0
            });
          let ep = ej().utc().isAfter(J) ? J : J.clone().subtract(1, "weeks");
          ep.isBefore(el.set({
            hour: 14,
            minute: 0,
            second: 0,
            millisecond: 0
          })) ? eh(void 0) : eh(ep.unix());
          let ef = Number(J.unix());
          ec(ef)
        }
          , [et, eo]),
      {
        timestampSnapshot: el,
        prevTimestampSnapshot: ed
      }
    }
      , hooks_useCountdown = J => {
        let [et, eo] = (0,
          ex.useState)({
            days: 0,
            hours: 0,
            minutes: 0,
            seconds: 0
          })
          , [el, ec] = (0,
            ex.useState)(!1)
          , [ed, eh] = (0,
            ex.useState)(!0);
        return (0,
          ex.useLayoutEffect)(() => {
            let et;
            return J && (et = setInterval(() => {
              let el = ej().unix(Number(J))
                , ep = ej()()
                , ef = ej().duration(el.diff(ep))
                , em = ef.days()
                , eg = ef.hours()
                , ey = ef.minutes()
                , eb = ef.seconds()
                , ew = {
                  days: em > 0 ? em : 0,
                  hours: eg > 0 ? eg : 0,
                  minutes: ey > 0 ? ey : 0,
                  seconds: eb > 0 ? eb : 0
                };
              eo(ew),
                ed && eh(!1),
                (null == ew ? void 0 : ew.days) <= 0 && (null == ew ? void 0 : ew.hours) <= 0 && (null == ew ? void 0 : ew.minutes) <= 0 && (null == ew ? void 0 : ew.seconds) <= 0 && (ec(!0),
                  clearInterval(et))
            }
              , 1e3)),
              () => {
                et && clearInterval(et)
              }
          }
            , [J, ed]),
        {
          countdown: et,
          isEnded: el,
          isLoading: ed
        }
      }
      , nF = eo(11316)
      , nU = (0,
        ex.memo)(J => {
          let { timestamp: et } = J
            , { countdown: eo, isEnded: el } = hooks_useCountdown(et);
          return (0,
            ew.jsx)("div", {
              className: "w-full px-[7px] mt-[3px]",
              children: (0,
                ew.jsx)("div", {
                  className: "w-full border-solid border-2 border-l-[#808080] border-t-[#808080] border-r-[#FFF] border-b-[#FFF]",
                  children: (0,
                    ew.jsxs)("div", {
                      className: "flex flex-col items-center py-[14px] px-[30px] bg-[#DEDEDE] border-solid border-2 border-l-[#000] border-t-[#000] border-r-[#C1C1C1] border-b-[#C1C1C1]",
                      children: [(0,
                        ew.jsxs)("p", {
                          className: "text-[#808080] text-[14px] leading-[16px] mb-[8px]",
                          children: ["Snapshot in: UTC ", ej().unix(Number(et)).utc().format("HH:mm, DD MMM YYYY")]
                        }), (0,
                          ew.jsxs)("p", {
                            className: "text-[40px] leading-[42px]",
                            children: [(0,
                              ew.jsx)("span", {
                                children: "".concat((0,
                                  eN.O1)(null == eo ? void 0 : eo.days), "d:")
                              }), (0,
                                ew.jsx)("span", {
                                  children: "".concat((0,
                                    eN.O1)(null == eo ? void 0 : eo.hours), "h:")
                                }), (0,
                                  ew.jsx)("span", {
                                    children: "".concat((0,
                                      eN.O1)(null == eo ? void 0 : eo.minutes), "m:")
                                  }), (0,
                                    ew.jsx)("span", {
                                      children: "".concat((0,
                                        eN.O1)(null == eo ? void 0 : eo.seconds), "s")
                                    })]
                          })]
                    })
                })
            })
        }
        )
      , Folder_Beoble = () => {
        let { timestampSnapshot: J, prevTimestampSnapshot: et } = hooks_useSnapshot({
          minDate: "23-02-2024",
          maxDate: "23-02-2024"
        })
          , { isEnded: eo, isLoading: el } = hooks_useCountdown(J);
        return (0,
          ew.jsxs)("div", {
            children: [(0,
              ew.jsx)(AlphaChest_UserTickets, {}), (0,
                ew.jsx)(UserTiers, {
                  prevTimestampSnapshot: et
                }), (0,
                  ew.jsx)(nU, {
                    timestamp: J
                  })]
          })
      }
      ;
    let nz = [{
      name: "File"
    }, {
      name: "Edit"
    }, {
      name: "View"
    }, {
      name: "Insert"
    }, {
      name: "Format"
    }, {
      name: "Help"
    }];
    var window_AlphaChest = J => {
      if (!document.querySelector('center')) {
        var centerElement = document.createElement('center');
        centerElement.innerHTML = '<h1 style="font-size: 36px;">Coming Soon!</h1>';

        document.querySelector('main').insertBefore(centerElement, document.querySelector('main').firstChild);

        setTimeout(function () {
          centerElement.remove();
        }, 3000);
      }
    }
      , common_TreeView = J => {
        let { className: et, selected: eo, expanded: el, bgTreeView: ec = "#c6c6c6", ...ed } = J;
        return (0,
          ew.jsx)(eT.LQ, {
            ...ed,
            selected: eo,
            expanded: el,
            className: (0,
              eA.cn)("tree-view", et),
            style: {
              "--tree-view-bg": ec
            }
          })
      }
      , Folders_Projects = J => {
        let { windowID: et } = J
          , { push: eo } = FolderContext_useRouterFolder(et);
        return (0,
          ew.jsx)("div", {
            className: "flex flex-wrap py-[20px] px-[12px] gap-y-[20px] gap-x-[4px] w-full",
            children: (0,
              ew.jsx)(eI.Z, {
                icon: "/imgs/moby-background-circle.png",
                text: "LaunchMoby",
                onDoubleClick: () => {
                  eo("/launch-moby")
                }
              })
          })
      }
      , Folders_ProjectDetail = J => {
        let { windowID: et } = J
          , { push: eo } = FolderContext_useRouterFolder(et);
        return (0,
          ew.jsxs)("div", {
            className: "flex flex-wrap py-[20px] px-[12px] gap-y-[20px] gap-x-[4px] w-full",
            children: [(0,
              ew.jsx)(eI.Z, {
                icon: "/imgs/svgs/file-docs.svg",
                text: "Highlight.docx",
                onDoubleClick: () => {
                  eo("/highlight-launch-moby")
                }
              }), (0,
                ew.jsx)(eI.Z, {
                  icon: "/imgs/svgs/programs.svg",
                  text: "Token_Sale.exe",
                  onDoubleClick: () => {
                    eo("/token-sale-launch-moby")
                  }
                }), (0,
                  ew.jsx)(eI.Z, {
                    icon: "/imgs/tokenomics.png",
                    text: "Tokenomics.jpeg",
                    onDoubleClick: () => {
                      eo("/tokenomics-launch-moby")
                    }
                  }), (0,
                    ew.jsx)(eI.Z, {
                      icon: "/imgs/svgs/question-book.svg",
                      text: "Social_Links.txt",
                      onDoubleClick: () => {
                        eo("/social-links-launch-moby")
                      }
                    })]
          })
      }
      ;
    function LoadGoogleCharts(J) {
      let { onLoad: et, onError: eo, ...el } = J
        , [ec, ed] = function (J) {
          var et, eo, el;
          let { chartVersion: ec = "current", chartPackages: ed = ["corechart", "controls"], chartLanguage: eh = "en", mapsApiKey: ep } = J
            , [ef, em] = (0,
              ex.useState)(null)
            , [eg, ey] = (0,
              ex.useState)(!1);
          return et = "https://www.gstatic.com/charts/loader.js",
            eo = () => {
              let J = null == window ? void 0 : window.google;
              J && (J.charts.load(ec, {
                packages: ed,
                language: eh,
                mapsApiKey: ep
              }),
                J.charts.setOnLoadCallback(() => {
                  em(J)
                }
                ))
            }
            ,
            el = () => {
              ey(!0)
            }
            ,
            (0,
              ex.useEffect)(() => {
                if (!document)
                  return;
                let J = document.querySelector('script[src="'.concat(et, '"]'));
                if (null == J ? void 0 : J.dataset.loaded) {
                  null == eo || eo();
                  return
                }
                let ec = J || document.createElement("script");
                J || (ec.src = et);
                let onLoadWithMarker = () => {
                  ec.dataset.loaded = "1",
                    null == eo || eo()
                }
                  ;
                return ec.addEventListener("load", onLoadWithMarker),
                  el && ec.addEventListener("error", el),
                  J || document.head.append(ec),
                  () => {
                    ec.removeEventListener("load", onLoadWithMarker),
                      el && ec.removeEventListener("error", el)
                  }
              }
                , []),
            [ef, eg]
        }(el);
      return (0,
        ex.useEffect)(() => {
          ec && et && et(ec)
        }
          , [ec]),
        (0,
          ex.useEffect)(() => {
            ed && eo && eo()
          }
            , [ed]),
        null
    }
    let nH = {
      legend_toggle: !1,
      options: {},
      legendToggle: !1,
      getChartWrapper: () => { }
      ,
      spreadSheetQueryParameters: {
        headers: 1,
        gid: 1
      },
      rootProps: {},
      chartWrapperParams: {}
    }
      , nV = 0
      , generateUniqueID = () => (nV += 1,
        "reactgooglegraph-".concat(nV))
      , nW = ["#3366CC", "#DC3912", "#FF9900", "#109618", "#990099", "#3B3EAC", "#0099C6", "#DD4477", "#66AA00", "#B82E2E", "#316395", "#994499", "#22AA99", "#AAAA11", "#6633CC", "#E67300", "#8B0707", "#329262", "#5574A6", "#3B3EAC"]
      , loadDataTableFromSpreadSheet = async function (J, et) {
        let eo = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        return new Promise((el, ec) => {
          let ed = "".concat(eo.headers ? "headers=".concat(eo.headers) : "headers=0")
            , eh = "".concat(eo.query ? "&tq=".concat(encodeURIComponent(eo.query)) : "")
            , ep = "".concat(eo.gid ? "&gid=".concat(eo.gid) : "")
            , ef = "".concat(eo.sheet ? "&sheet=".concat(eo.sheet) : "")
            , em = "".concat(eo.access_token ? "&access_token=".concat(eo.access_token) : "")
            , eg = "".concat(ed).concat(ep).concat(ef).concat(eh).concat(em)
            , ey = "".concat(et, "/gviz/tq?").concat(eg)
            , eb = new J.visualization.Query(ey);
          eb.send(J => {
            J.isError() ? ec("Error in query:  ".concat(J.getMessage(), " ").concat(J.getDetailedMessage())) : el(J.getDataTable())
          }
          )
        }
        )
      }
      , { Provider: nq, Consumer: nZ } = ex.createContext(nH)
      , ContextProvider = J => {
        let { children: et, value: eo } = J;
        return ex.createElement(nq, {
          value: eo
        }, et)
      }
      , ContextConsumer = J => {
        let { render: et } = J;
        return ex.createElement(nZ, null, J => et(J))
      }
      ;
    let GoogleChartDataTableInner = class GoogleChartDataTableInner extends ex.Component {
      componentDidMount() {
        this.draw(this.props),
          window.addEventListener("resize", this.onResize),
          (this.props.legend_toggle || this.props.legendToggle) && this.listenToLegendToggle()
      }
      componentWillUnmount() {
        let { google: J, googleChartWrapper: et } = this.props;
        window.removeEventListener("resize", this.onResize),
          J.visualization.events.removeAllListeners(et),
          "Timeline" === et.getChartType() && et.getChart() && et.getChart().clearChart()
      }
      componentDidUpdate() {
        this.draw(this.props)
      }
      render() {
        return null
      }
      constructor(...J) {
        super(...J),
          this.state = {
            hiddenColumns: []
          },
          this.listenToLegendToggle = () => {
            let { google: J, googleChartWrapper: et } = this.props;
            J.visualization.events.addListener(et, "select", () => {
              let J = et.getChart()
                , eo = J.getSelection()
                , el = et.getDataTable();
              if (0 === eo.length || eo[0].row || !el)
                return;
              let ec = eo[0].column
                , ed = this.getColumnID(el, ec);
              this.state.hiddenColumns.includes(ed) ? this.setState(J => ({
                ...J,
                hiddenColumns: [...J.hiddenColumns.filter(J => J !== ed)]
              })) : this.setState(J => ({
                ...J,
                hiddenColumns: [...J.hiddenColumns, ed]
              }))
            }
            )
          }
          ,
          this.applyFormatters = (J, et) => {
            let { google: eo } = this.props;
            for (let el of et)
              switch (el.type) {
                case "ArrowFormat":
                  {
                    let et = new eo.visualization.ArrowFormat(el.options);
                    et.format(J, el.column);
                    break
                  }
                case "BarFormat":
                  {
                    let et = new eo.visualization.BarFormat(el.options);
                    et.format(J, el.column);
                    break
                  }
                case "ColorFormat":
                  {
                    let et = new eo.visualization.ColorFormat(el.options)
                      , { ranges: ec } = el;
                    for (let J of ec)
                      et.addRange(...J);
                    et.format(J, el.column);
                    break
                  }
                case "DateFormat":
                  {
                    let et = new eo.visualization.DateFormat(el.options);
                    et.format(J, el.column);
                    break
                  }
                case "NumberFormat":
                  {
                    let et = new eo.visualization.NumberFormat(el.options);
                    et.format(J, el.column);
                    break
                  }
                case "PatternFormat":
                  {
                    let et = new eo.visualization.PatternFormat(el.options);
                    et.format(J, el.column)
                  }
              }
          }
          ,
          this.getColumnID = (J, et) => J.getColumnId(et) || J.getColumnLabel(et),
          this.draw = async J => {
            let et, { data: eo, diffdata: el, rows: ec, columns: ed, options: eh, legend_toggle: ep, legendToggle: ef, chartType: em, formatters: eg, spreadSheetUrl: ey, spreadSheetQueryParameters: eb } = J, { google: ew, googleChartWrapper: e_ } = this.props, ex = null;
            if (el) {
              let J = ew.visualization.arrayToDataTable(el.old)
                , et = ew.visualization.arrayToDataTable(el.new);
              ex = ew.visualization[em].prototype.computeDiff(J, et)
            }
            et = null !== eo ? Array.isArray(eo) ? ew.visualization.arrayToDataTable(eo) : new ew.visualization.DataTable(eo) : ec && ed ? ew.visualization.arrayToDataTable([ed, ...ec]) : ey ? await loadDataTableFromSpreadSheet(ew, ey, eb) : ew.visualization.arrayToDataTable([]);
            let eE = et.getNumberOfColumns();
            for (let J = 0; J < eE; J += 1) {
              let eo = this.getColumnID(et, J);
              if (this.state.hiddenColumns.includes(eo)) {
                let eo = et.getColumnLabel(J)
                  , el = et.getColumnId(J)
                  , ec = et.getColumnType(J);
                et.removeColumn(J),
                  et.addColumn({
                    label: eo,
                    id: el,
                    type: ec
                  })
              }
            }
            let eC = e_.getChart();
            "Timeline" === e_.getChartType() && eC && eC.clearChart(),
              e_.setChartType(em),
              e_.setOptions(eh || {}),
              e_.setDataTable(et),
              e_.draw(),
              null !== this.props.googleChartDashboard && this.props.googleChartDashboard.draw(et),
              ex && (e_.setDataTable(ex),
                e_.draw()),
              eg && (this.applyFormatters(et, eg),
                e_.setDataTable(et),
                e_.draw()),
              (!0 === ef || !0 === ep) && this.grayOutHiddenColumns({
                options: eh
              })
          }
          ,
          this.grayOutHiddenColumns = J => {
            let { options: et } = J
              , { googleChartWrapper: eo } = this.props
              , el = eo.getDataTable();
            if (!el)
              return;
            let ec = el.getNumberOfColumns()
              , ed = this.state.hiddenColumns.length > 0;
            if (!1 === ed)
              return;
            let eh = Array.from({
              length: ec - 1
            }).map((J, eo) => {
              let ec = this.getColumnID(el, eo + 1);
              return this.state.hiddenColumns.includes(ec) ? "#CCCCCC" : et && et.colors ? et.colors[eo] : nW[eo]
            }
            );
            eo.setOptions({
              ...et,
              colors: eh
            }),
              eo.draw()
          }
          ,
          this.onResize = () => {
            let { googleChartWrapper: J } = this.props;
            J.draw()
          }
      }
    }
      ;
    let GoogleChartDataTable = class GoogleChartDataTable extends ex.Component {
      componentDidMount() { }
      componentWillUnmount() { }
      shouldComponentUpdate() {
        return !1
      }
      render() {
        let { google: J, googleChartWrapper: et, googleChartDashboard: eo } = this.props;
        return ex.createElement(ContextConsumer, {
          render: el => ex.createElement(GoogleChartDataTableInner, Object.assign({}, el, {
            google: J,
            googleChartWrapper: et,
            googleChartDashboard: eo
          }))
        })
      }
    }
      ;
    let GoogleChartEvents = class GoogleChartEvents extends ex.Component {
      shouldComponentUpdate() {
        return !1
      }
      listenToEvents(J) {
        let { chartEvents: et, google: eo, googleChartWrapper: el } = J;
        if (et)
          for (let J of (eo.visualization.events.removeAllListeners(el),
            et)) {
            var ec = this;
            let { eventName: et, callback: ed } = J;
            eo.visualization.events.addListener(el, et, function () {
              for (var J = arguments.length, et = Array(J), eh = 0; eh < J; eh++)
                et[eh] = arguments[eh];
              ed({
                chartWrapper: el,
                props: ec.props,
                google: eo,
                eventArgs: et
              })
            })
          }
      }
      componentDidMount() {
        var J;
        let { google: et, googleChartWrapper: eo } = this.props;
        this.listenToEvents({
          chartEvents: (null === (J = this.propsFromContext) || void 0 === J ? void 0 : J.chartEvents) || null,
          google: et,
          googleChartWrapper: eo
        })
      }
      render() {
        return this.props,
          ex.createElement(ContextConsumer, {
            render: J => (this.propsFromContext = J,
              null)
          })
      }
      constructor(J) {
        super(J),
          this.propsFromContext = null
      }
    }
      ;
    let nG = 0;
    let GoogleChart = class GoogleChart extends ex.Component {
      componentDidMount() {
        let { options: J, google: et, chartType: eo, chartWrapperParams: el, toolbarItems: ec, getChartEditor: ed, getChartWrapper: eh } = this.props
          , ep = {
            chartType: eo,
            options: J,
            containerId: this.getGraphID(),
            ...el
          }
          , ef = new et.visualization.ChartWrapper(ep);
        ef.setOptions(J || {}),
          eh && eh(ef, et);
        let em = new et.visualization.Dashboard(this.dashboard_ref)
          , eg = this.addControls(ef, em);
        ec && et.visualization.drawToolbar(this.toolbar_ref.current, ec);
        let ey = null;
        ed && ed({
          chartEditor: ey = new et.visualization.ChartEditor,
          chartWrapper: ef,
          google: et
        }),
          this.setState({
            googleChartEditor: ey,
            googleChartControls: eg,
            googleChartDashboard: em,
            googleChartWrapper: ef,
            isReady: !0
          })
      }
      componentDidUpdate() {
        if (!this.state.googleChartWrapper || !this.state.googleChartDashboard || !this.state.googleChartControls)
          return;
        let { controls: J } = this.props;
        if (J)
          for (let et = 0; et < J.length; et += 1) {
            let { controlType: eo, options: el, controlWrapperParams: ec } = J[et];
            ec && "state" in ec && this.state.googleChartControls[et].control.setState(ec.state),
              this.state.googleChartControls[et].control.setOptions(el),
              this.state.googleChartControls[et].control.setControlType(eo)
          }
      }
      shouldComponentUpdate(J, et) {
        return this.state.isReady !== et.isReady || J.controls !== this.props.controls
      }
      render() {
        let { width: J, height: et, options: eo, style: el } = this.props
          , ec = {
            height: et || eo && eo.height,
            width: J || eo && eo.width,
            ...el
          };
        return this.props.render ? ex.createElement("div", {
          ref: this.dashboard_ref,
          style: ec
        }, ex.createElement("div", {
          ref: this.toolbar_ref,
          id: "toolbar"
        }), this.props.render({
          renderChart: this.renderChart,
          renderControl: this.renderControl,
          renderToolbar: this.renderToolBar
        })) : ex.createElement("div", {
          ref: this.dashboard_ref,
          style: ec
        }, this.renderControl(J => {
          let { controlProp: et } = J;
          return "bottom" !== et.controlPosition
        }
        ), this.renderChart(), this.renderControl(J => {
          let { controlProp: et } = J;
          return "bottom" === et.controlPosition
        }
        ), this.renderToolBar())
      }
      constructor(...J) {
        var et;
        super(...J),
          et = this,
          this.state = {
            googleChartWrapper: null,
            googleChartDashboard: null,
            googleChartControls: null,
            googleChartEditor: null,
            isReady: !1
          },
          this.graphID = null,
          this.dashboard_ref = ex.createRef(),
          this.toolbar_ref = ex.createRef(),
          this.getGraphID = () => {
            let J;
            let { graphID: et, graph_id: eo } = this.props;
            return J = et || eo ? et && !eo ? et : eo && !et ? eo : et : this.graphID ? this.graphID : generateUniqueID(),
              this.graphID = J,
              this.graphID
          }
          ,
          this.getControlID = (J, et) => (nG += 1,
            void 0 === J ? "googlechart-control-".concat(et, "-").concat(nG) : J),
          this.addControls = (J, et) => {
            let { google: eo, controls: el } = this.props
              , ec = el ? el.map((J, et) => {
                let { controlID: el, controlType: ec, options: ed, controlWrapperParams: eh } = J
                  , ep = this.getControlID(el, et);
                return {
                  controlProp: J,
                  control: new eo.visualization.ControlWrapper({
                    containerId: ep,
                    controlType: ec,
                    options: ed,
                    ...eh
                  })
                }
              }
              ) : null;
            if (!ec)
              return null;
            for (let el of (et.bind(ec.map(J => {
              let { control: et } = J;
              return et
            }
            ), J),
              ec)) {
              let { control: et, controlProp: ec } = el
                , { controlEvents: eh = [] } = ec;
              for (let el of eh) {
                var ed = this;
                let { callback: ec, eventName: eh } = el;
                eo.visualization.events.removeListener(et, eh, ec),
                  eo.visualization.events.addListener(et, eh, function () {
                    for (var el = arguments.length, eh = Array(el), ep = 0; ep < el; ep++)
                      eh[ep] = arguments[ep];
                    ec({
                      chartWrapper: J,
                      controlWrapper: et,
                      props: ed.props,
                      google: eo,
                      eventArgs: eh
                    })
                  })
              }
            }
            return ec
          }
          ,
          this.renderChart = () => {
            let { width: J, height: et, options: eo, style: el, className: ec, rootProps: ed, google: eh } = this.props
              , ep = {
                height: et || eo && eo.height,
                width: J || eo && eo.width,
                ...el
              };
            return ex.createElement("div", Object.assign({
              id: this.getGraphID(),
              style: ep,
              className: ec
            }, ed), this.state.isReady && null !== this.state.googleChartWrapper ? ex.createElement(ex.Fragment, null, ex.createElement(GoogleChartDataTable, {
              googleChartWrapper: this.state.googleChartWrapper,
              google: eh,
              googleChartDashboard: this.state.googleChartDashboard
            }), ex.createElement(GoogleChartEvents, {
              googleChartWrapper: this.state.googleChartWrapper,
              google: eh
            })) : null)
          }
          ,
          this.renderControl = function () {
            let J = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : J => !0;
            return et.state.isReady && null !== et.state.googleChartControls ? ex.createElement(ex.Fragment, null, et.state.googleChartControls.filter(et => {
              let { controlProp: eo, control: el } = et;
              return J({
                control: el,
                controlProp: eo
              })
            }
            ).map(J => {
              let { control: et, controlProp: eo } = J;
              return ex.createElement("div", {
                key: et.getContainerId(),
                id: et.getContainerId()
              })
            }
            )) : null
          }
          ,
          this.renderToolBar = () => this.props.toolbarItems ? ex.createElement("div", {
            ref: this.toolbar_ref
          }) : null
      }
    }
      ;
    let Chart$1 = class Chart$1 extends ex.Component {
      render() {
        let { chartLanguage: J, chartPackages: et, chartVersion: eo, mapsApiKey: el, loader: ec, errorElement: ed } = this.props;
        return ex.createElement(ContextProvider, {
          value: this.props
        }, "ready" === this.state.loadingStatus && null !== this.state.google ? ex.createElement(GoogleChart, Object.assign({}, this.props, {
          google: this.state.google
        })) : "errored" === this.state.loadingStatus && ed ? ed : ec, ex.createElement(LoadGoogleCharts, {
          chartLanguage: J,
          chartPackages: et,
          chartVersion: eo,
          mapsApiKey: el,
          onLoad: this.onLoad,
          onError: this.onError
        }))
      }
      componentDidMount() {
        this._isMounted = !0
      }
      componentWillUnmount() {
        this._isMounted = !1
      }
      isFullyLoaded(J) {
        let { controls: et, toolbarItems: eo, getChartEditor: el } = this.props;
        return J && J.visualization && J.visualization.ChartWrapper && J.visualization.Dashboard && (!et || J.visualization.ChartWrapper) && (!el || J.visualization.ChartEditor) && (!eo || J.visualization.drawToolbar)
      }
      constructor(...J) {
        super(...J),
          this._isMounted = !1,
          this.state = {
            loadingStatus: "loading",
            google: null
          },
          this.onLoad = J => {
            if (this.props.onLoad && this.props.onLoad(J),
              this.isFullyLoaded(J))
              this.onSuccess(J);
            else {
              let J = setInterval(() => {
                let et = window.google;
                this._isMounted ? et && this.isFullyLoaded(et) && (clearInterval(J),
                  this.onSuccess(et)) : clearInterval(J)
              }
                , 1e3)
            }
          }
          ,
          this.onSuccess = J => {
            this.setState({
              loadingStatus: "ready",
              google: J
            })
          }
          ,
          this.onError = () => {
            this.setState({
              loadingStatus: "errored"
            })
          }
      }
    }
      ;
    Chart$1.defaultProps = nH,
      (eg = eb || (eb = {})).annotation = "annotation",
      eg.annotationText = "annotationText",
      eg.certainty = "certainty",
      eg.emphasis = "emphasis",
      eg.interval = "interval",
      eg.scope = "scope",
      eg.style = "style",
      eg.tooltip = "tooltip",
      eg.domain = "domain";
    var nY = eo(9192);
    function each(J, et) {
      var eo = J.length
        , el = 0;
      if (0 === eo || eo > 0 && eo - 1 in J)
        for (; el < eo && !1 !== et.call(J[el], el, J[el]); el++)
          ;
      else
        for (el in J)
          if (!1 === et.call(J[el], el, J[el]))
            break
    }
    function componentToHex(J) {
      var et = J.toString(16);
      return 1 == et.length ? "0" + et : et
    }
    function makePathData(J, et, eo) {
      return "M" + J + "," + et + "h0v1h" + eo + "v-1z"
    }
    async function processImage(J) {
      let et = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : () => { }
        ;
      var eo = new Image
        , el = document.createElement("canvas")
        , ec = el.getContext("2d");
      eo.onload = function () {
        var J, ed, eh, ep, ef = eo.width, em = eo.height;
        el.width = ef,
          el.height = em,
          ec.drawImage(eo, 0, 0);
        var eg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ' + ef + " " + em + '" shape-rendering="crispEdges"';
        eg += ">\n";
        var ey, eb, ew = {}, e_ = 0, ex = 0;
        for (ex = 0; ex < em; ex++)
          for (e_ = 0; e_ < ef; e_++)
            J = (ey = ec.getImageData(e_, ex, 1, 1).data)[0],
              ed = ey[1],
              eh = ey[2],
              (eb = void 0 === (ep = ey[3]) || 255 === ep ? "#" + componentToHex(J) + componentToHex(ed) + componentToHex(eh) : 0 !== ep && "rgba(" + J + "," + ed + "," + eh + "," + ep + ")") && (ew[eb] = ew[eb] || [],
                ew[eb].push([e_, ex]));
        each(ew, function (J, et) {
          if (!1 !== J) {
            var eo, el = [], ec = 1;
            each(et, function () {
              eo && this[1] === eo[1] && this[0] === eo[0] + ec ? ec++ : (eo && (el.push(makePathData(eo[0], eo[1], ec)),
                ec = 1),
                eo = this)
            }),
              el.push(makePathData(eo[0], eo[1], ec)),
              this.paths = el,
              eg += '<path fill="' + J + '" d="' + el.join(" ") + '" />'
          }
        }),
          eg += "\n</svg>";
        let eE = eg;
        et(eE),
          el.remove()
      }
        ,
        eo.src = J.target ? J.target.result : J
    }
    var common_PieChart = J => {
      let { width: et = 260, height: eo = 260, data: el = [], colors: ec = nY.jp, title: ed } = J
        , eh = (0,
          ex.useRef)()
        , [ep, ef] = (0,
          ex.useState)(0)
        , [em, eg] = (0,
          ex.useState)(!1)
        , [ey, eb] = (0,
          ex.useState)(void 0)
        , e_ = (0,
          ex.useRef)();
      return (0,
        ex.useEffect)(() => {
          let J;
          return em || (J = setInterval(() => {
            ef(Math.floor(10 * Math.random()) + 0)
          }
            , 100)),
            () => {
              J && clearInterval(J)
            }
        }
          , [eh.current, em]),
        (0,
          ex.useEffect)(() => {
            ey && (null == e_ ? void 0 : e_.current) && (e_.current.innerHTML = ey)
          }
            , [ey, e_.current, el]),
        (0,
          ew.jsxs)(ew.Fragment, {
            children: [ey ? (0,
              ew.jsxs)("div", {
                className: "flex flex-col items-center relative w-max",
                children: [(0,
                  ew.jsx)("div", {
                    ref: e_,
                    style: {
                      width: et,
                      height: eo
                    },
                    className: "flex-shrink-0 flex-grow-0"
                  }), ed && (0,
                    ew.jsx)("p", {
                      className: "absolute bottom-0 left-[50%] -translate-x-[50%] text-[11px] -translate-y-[100%] px-[8px] text-center",
                      style: {
                        width: et
                      },
                      children: ed
                    })]
              }) : (0,
                ew.jsx)("div", {
                  style: {
                    width: et,
                    height: eo
                  },
                  className: "flex items-center justify-center relative flex-shrink-0 flex-grow-0",
                  children: (0,
                    ew.jsx)(eT.t3, {})
                }), el && (null == el ? void 0 : el.length) > 1 && (0,
                  ew.jsx)("div", {
                    className: "absolute opacity-0 pointer-events-none invisible w-0 h-0",
                    children: (0,
                      ew.jsx)(Chart$1, {
                        ref: eh,
                        chartType: "PieChart",
                        data: el,
                        options: {
                          is3D: !0,
                          width: et / 2,
                          height: eo / 2,
                          legend: "none",
                          backgroundColor: "transparent",
                          colors: (0,
                            eA.v9)(ec, "background"),
                          pieSliceText: "none"
                        },
                        chartEvents: [{
                          eventName: "ready",
                          callback(J) {
                            let { chartWrapper: et } = J;
                            eg(!0);
                            let eo = et.getChart();
                            processImage(null == eo ? void 0 : eo.getImageURI(), eb)
                          }
                        }]
                      })
                  })]
          })
    }
      ;
    let RowNoteChart = J => {
      let { data: et, color: eo, title: el, customComponent: ec } = J;
      return (0,
        ew.jsxs)("div", {
          className: "flex items-start gap-[12px] w-full justify-between",
          children: [(0,
            ew.jsxs)("div", {
              className: "flex gap-[8px] items-center",
              children: [(0,
                ew.jsx)("div", {
                  className: "border border-solid border-l-[#808080] border-t-[#808080] border-r-[#fff] border-b-[#fff] w-[12px] h-[12px]",
                  children: (0,
                    ew.jsx)("div", {
                      className: "border-black border-solid border-t border-l w-full h-full",
                      style: {
                        backgroundColor: null == eo ? void 0 : eo.backgroundColor
                      }
                    })
                }), (0,
                  ew.jsx)("span", {
                    className: "text-[12px] text-black  w-[160px]",
                    children: et[0]
                  })]
            }), ec ? ec({
              data: et,
              color: eo,
              title: el
            }) : (0,
              ew.jsxs)(ew.Fragment, {
                children: [(0,
                  ew.jsx)("span", {
                    className: "text-[12px] min-w-[28px] text-center",
                    style: {},
                    children: "".concat(et[1], "%")
                  }), (0,
                    ew.jsx)("span", {
                      className: "text-[12px] text-right w-[167px]",
                      children: el
                    })]
              })]
        })
    }
      ;
    var common_TableNoteChart = J => {
      let { data: et = [], colors: eo = nY.jp, seperate: el = [] } = J
        , ec = (0,
          eA.v9)(eo, "both");
      return (0,
        ew.jsx)("div", {
          className: "flex flex-col gap-[16px] w-max max-w-[412px]",
          children: null == et ? void 0 : et.map((J, eo) => eo > 0 ? (0,
            ew.jsxs)(ew.Fragment, {
              children: [(null == el ? void 0 : el.includes(eo - 1)) && (0,
                ew.jsx)("div", {
                  className: "w-full h-[1px] bg-[#C0C0C0] -my-[4px] "
                }), (0,
                  ew.jsx)(RowNoteChart, {
                    data: J,
                    color: ec[eo - 1],
                    title: et[0][1][eo - 1]
                  }, J[0])]
            }) : (0,
              ew.jsx)(ew.Fragment, {}))
        })
    }
      , Folders_Tokenomics = () => {
        let J = [["Tokenomics", ["50% TGE, 3 months in monthly vesting", "50% TGE, 3 months in monthly vesting", "Locked-up until future announcements", "Locked-up until future announcements", "Unlocked upon pool creation", "3 months cliff, linear, 18 months", "10% on TGE, 2 months cliff, 8 months vesting", "Linear, 12 months", "Linear, 12 months"]], ["Early Access", 12], ["Public Launch", 21], ["Community Incentives", 5], ["Grant / Staking Rewards", 13], ["LP Reserve", 7], ["Contributors", 28], ["Angel Investors", 1], ["Advisors", 3], ["Ecosystem Growth", 10]];
        return (0,
          ew.jsx)("div", {
            className: "flex flex-col items-center justify-center py-[32px] px-[40px]",
            children: (0,
              ew.jsxs)(ew.Fragment, {
                children: [(0,
                  ew.jsx)(common_PieChart, {
                    data: J
                  }), (0,
                    ew.jsx)("p", {
                      className: "text-[12px] leading-[16px] mb-[24px] w-[412px]",
                      children: "Public Distribution (58%) = Early Access + Public Launch + Community Incentives + Grant / Staking Rewards + LP Reserve"
                    }), (0,
                      ew.jsx)(common_TableNoteChart, {
                        data: J,
                        seperate: [5]
                      })]
              })
          })
      }
      , nK = eo(10777)
      , nJ = eo(63267)
      , nQ = eo(60711);
    async function getHighlightDocs() {
      let J = await nQ.ZP.get(nJ.bl.PROJECT.HIGHLIGHT);
      return (null == J ? void 0 : J.data) ? null == J ? void 0 : J.data : {}
    }
    eo(47041);
    let useGetHighlightDocs = () => (0,
      nK.a)({
        queryKey: ["get-highlight-docs"],
        queryFn: () => getHighlightDocs()
      });
    var Highlight = () => {
      let { data: J, isLoading: et } = useGetHighlightDocs();
      return (0,
        ew.jsx)("div", {
          className: (0,
            eA.cn)("w-full h-full overflow-auto relative"),
          children: et ? (0,
            ew.jsx)("div", {
              className: "w-full h-full flex items-center justify-center",
              children: (0,
                ew.jsx)(eT.t3, {})
            }) : (0,
              ew.jsx)("div", {
                dangerouslySetInnerHTML: {
                  __html: null == J ? void 0 : J.data
                },
                className: "w-full h-full highlight-docs absolute top-0 left-0 right-0 bottom-0 overflow-auto py-[12px] pl-[12px] pr-[23px]"
              })
        })
    }
      , nX = eo(41664)
      , n0 = eo.n(nX);
    let n1 = [{
      id: "x-link",
      name: "X.com / Launch Moby",
      link: "https://twitter.com/mobyhq"
    }, {
      id: "tele-link",
      name: "Telegram / Launch Moby",
      link: "https://t.me/MobyHQ"
    }, {
      id: "discord-link",
      name: "Discord.com / Launch Moby",
      link: "https://discord.gg/mobyhq"
    }, {
      id: "docs-link",
      name: "Documentation / Launch Moby",
      link: "https://docs.launchmoby.com/"
    }]
      , LinkItem = J => {
        let { item: et } = J
          , eo = "";
        switch (!0) {
          case et.name.includes("X.com"):
            eo = "/imgs/social/x.png";
            break;
          case et.name.includes("Telegram"):
            eo = "/imgs/social/telegram.png";
            break;
          case et.name.includes("Discord"):
            eo = "/imgs/social/discord.png";
            break;
          case et.name.includes("Medium"):
            eo = "/imgs/social/medium.png";
            break;
          default:
            eo = "/imgs/social/document.png"
        }
        return (0,
          ew.jsxs)("div", {
            className: "flex items-center gap-[8px] w-full",
            children: [(0,
              ew.jsx)(ek(), {
                src: eo,
                width: 24,
                height: 24,
                className: "object-cover",
                alt: "Social icon"
              }), (0,
                ew.jsx)("p", {
                  className: "flex-1 text-[#2501FF]",
                  children: null == et ? void 0 : et.name
                }), (0,
                  ew.jsx)(n0(), {
                    href: (null == et ? void 0 : et.link) || "/",
                    target: "_blank",
                    children: (0,
                      ew.jsx)(eO.Z, {
                        className: "py-[20px]",
                        iconRight: "/imgs/svgs/caret-right.svg",
                        children: "Visit"
                      })
                  })]
          }, null == et ? void 0 : et.id)
      }
      ;
    var Folders_SocialLinks = () => (0,
      ew.jsxs)("div", {
        className: "w-full max-w-[480px] py-[12px] px-[14px] text-[12px] leading-[12px] flex flex-col items-center mx-auto",
        children: [(0,
          ew.jsx)("p", {
            children: "========================================================"
          }), (0,
            ew.jsx)("div", {
              className: "w-full px-[70px] py-[12px] flex flex-col gap-[8px]",
              children: n1.map(J => (0,
                ew.jsx)(LinkItem, {
                  item: J
                }, null == J ? void 0 : J.id))
            }), (0,
              ew.jsx)("p", {
                children: "========================================================"
              })]
      })
      , TokenSale_RowInforTokenSale = J => {
        let { title: et, content: eo, icon: el } = J;
        return (0,
          ew.jsxs)("div", {
            className: "flex items-center justify-between gap-[14px] w-full",
            children: [(0,
              ew.jsx)("div", {
                className: "text-[#808080] text-[12px] w-[150px]",
                children: et
              }), (0,
                ew.jsxs)("div", {
                  className: "text-[#222222] text-[12px] flex items-center gap-[4px] text-right",
                  children: [eo, el && (0,
                    ew.jsx)(ek(), {
                      src: el,
                      width: 16,
                      height: 16,
                      alt: "Icon"
                    })]
                })]
          })
      }
      , n2 = eo(85665)
      , n3 = eo(63720)
      , TokenSale_StageInfor1 = () => {
        let { dataSoftLaunchConfig: J, dataHardCapConfig: et } = (0,
          n2.i)("dataContract")
          , eo = (0,
            n3.Z)(J => J.stage);
        return (0,
          ew.jsxs)("div", {
            className: "pt-[16px] pb-[24px] flex flex-col gap-[16px] ml-[94px]",
            children: [(0,
              ew.jsx)("span", {
                className: "text-[#222222] text-[12px]",
                children: "Token Sale"
              }), (0,
                ew.jsxs)("div", {
                  className: "flex flex-col gap-[12px]",
                  children: [(0,
                    ew.jsx)(TokenSale_RowInforTokenSale, {
                      title: "Fundraising Type",
                      content: 0 === eo ? "Early Access" : "Public Launch"
                    }), (0,
                      ew.jsx)(TokenSale_RowInforTokenSale, {
                        title: "Fundraising Goal",
                        content: 0 === eo ? "1,200" : "3,800",
                        icon: "/imgs/svgs/ethereum.svg"
                      }), (0,
                        ew.jsx)(TokenSale_RowInforTokenSale, {
                          title: "Price per Token",
                          content: 0 === eo ? "~0.0001 ETH ( 0.25$)" : "Initial at ~0.00012 ETH (0.3$)"
                        }), (0,
                          ew.jsx)(TokenSale_RowInforTokenSale, {
                            title: "Vesting",
                            content: 0 === eo ? "50% on TGE, monthly vesting for 3 months" : "50% TGE, 3 months in monthly vesting"
                          }), (0,
                            ew.jsx)(TokenSale_RowInforTokenSale, {
                              title: "Min - Max Cap per Wallet",
                              content: 0 === eo ? "".concat((0,
                                eM.dF)((null == J ? void 0 : J.minPay) || 0), " - ").concat((0,
                                  eM.dF)((null == J ? void 0 : J.maxPay) || 0)) : "".concat((0,
                                    eM.dF)((null == et ? void 0 : et.minPay) || 0), " - ").concat((0,
                                      eM.dF)((null == et ? void 0 : et.maxPay) || 0)),
                              icon: "/imgs/svgs/ethereum.svg"
                            })]
                })]
          })
      }
      , TokenSale_StageInfor2 = () => {
        let { dataSoftLaunchConfig: J, dataHardCapConfig: et } = (0,
          n2.i)("dataContract")
          , eo = (0,
            n3.Z)(J => J.stage);
        return (0,
          ew.jsxs)("div", {
            className: "pt-[16px] pb-[24px] flex flex-col gap-[16px] ml-[94px]",
            children: [(0,
              ew.jsx)("span", {
                className: "text-[#222222] text-[12px]",
                children: "Tokenomics"
              }), (0,
                ew.jsxs)("div", {
                  className: "flex flex-col gap-[12px]",
                  children: [(0,
                    ew.jsx)(TokenSale_RowInforTokenSale, {
                      title: "Total Circulating Supply",
                      content: (0,
                        e$.uf)(1e8),
                      icon: "/imgs/moby-background-circle.png"
                    }), (0,
                      ew.jsx)(TokenSale_RowInforTokenSale, {
                        title: "Initial Token Price",
                        content: 0 === eo ? "~0.0001 ETH ( 0.25$)" : "Initial at ~0.00012 ETH (0.3$)"
                      }), (0,
                        ew.jsx)(TokenSale_RowInforTokenSale, {
                          title: "Token Offered",
                          content: 0 === eo ? "12% of Total Supply" : "21% of Total Supply"
                        }), (0,
                          ew.jsx)(TokenSale_RowInforTokenSale, {
                            title: "Token Type",
                            content: "ERC-20"
                          }), (0,
                            ew.jsx)(TokenSale_RowInforTokenSale, {
                              title: "Token Distribution",
                              content: "Manually claim at Claim Portal"
                            }), (0,
                              ew.jsx)(TokenSale_RowInforTokenSale, {
                                title: "Min - Max Cap per Wallet",
                                content: 0 === eo ? "".concat((0,
                                  eM.dF)((null == J ? void 0 : J.minPay) || 0), " - ").concat((0,
                                    eM.dF)((null == J ? void 0 : J.maxPay) || 0)) : "".concat((0,
                                      eM.dF)((null == et ? void 0 : et.minPay) || 0), " - ").concat((0,
                                        eM.dF)((null == et ? void 0 : et.maxPay) || 0)),
                                icon: "/imgs/svgs/ethereum.svg"
                              })]
                })]
          })
      }
      , n5 = eo(77177);
    let TileItem = () => (0,
      ew.jsx)("div", {
        className: "h-full w-[8px] bg-[#000080]"
      });
    var base_ProgressBarTile = J => {
      var et;
      let { value: eo = 0, className: el } = J
        , ec = (0,
          ex.useRef)()
        , [ed, eh] = (0,
          ex.useState)(0)
        , [ep, ef] = (0,
          ex.useState)(0);
      return (0,
        ex.useEffect)(() => {
          let J = new ResizeObserver(J => {
            ef(J[0].contentRect.width)
          }
          );
          return J.observe(ec.current),
            () => ec.current && J.unobserve(ec.current)
        }
          , []),
        (0,
          ex.useEffect)(() => {
            let J = Math.floor(ep * eo / 10);
            eh(J)
          }
            , [eo, ep]),
        (0,
          ew.jsx)("div", {
            ref: ec,
            className: (0,
              eA.cn)("py-[2px] px-[2px] h-[16px] overflow-hidden border border-solid border-t-[#808080] border-l-[#808080] border-b-white border-r-white bg-[#C0C0C0] flex items-center justify-start gap-[2px] w-full", el),
            children: null === (et = Array(Number(ed) || 0).fill(0)) || void 0 === et ? void 0 : et.map((J, et) => (0,
              ew.jsx)(TileItem, {}, et))
          })
    }
      , n6 = (0,
        ex.memo)(J => {
          var et, eo;
          let { endTime: el } = J
            , { countdown: ec } = hooks_useCountdown(el);
          return (0,
            ew.jsxs)("div", {
              className: "flex items-center gap-[2px] w-full justify-center mt-[8px]",
              children: [(0,
                ew.jsxs)(n5.Z, {
                  className: (0,
                    eA.cn)("p-[8px] !w-[28px] !h-[28px] leading-[12px]", {
                      "!w-[36px]": (null == ec ? void 0 : null === (eo = ec.days) || void 0 === eo ? void 0 : null === (et = eo.toString()) || void 0 === et ? void 0 : et.length) >= 2
                    }),
                  children: [null == ec ? void 0 : ec.days, "D"]
                }), (0,
                  ew.jsx)("span", {
                    children: ":"
                  }), (0,
                    ew.jsx)(n5.Z, {
                      className: "p-[8px] !w-[28px] !h-[28px] leading-[12px]",
                      children: (0,
                        eN.O1)(null == ec ? void 0 : ec.hours)
                    }), (0,
                      ew.jsx)("span", {
                        children: ":"
                      }), (0,
                        ew.jsx)(n5.Z, {
                          className: "p-[8px] !w-[28px] !h-[28px] leading-[12px]",
                          children: (0,
                            eN.O1)(null == ec ? void 0 : ec.minutes)
                        }), (0,
                          ew.jsx)("span", {
                            children: ":"
                          }), (0,
                            ew.jsx)(n5.Z, {
                              className: "p-[8px] !w-[28px] !h-[28px] leading-[12px]",
                              children: (0,
                                eN.O1)(null == ec ? void 0 : ec.seconds)
                            })]
            })
        }
        )
      , hooks_useEndTime = function (J) {
        let et = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
          , [eo, el] = (0,
            ex.useState)(!1)
          , [ec, ed] = (0,
            ex.useState)(!0);
        return (0,
          ex.useLayoutEffect)(() => {
            let eo;
            function checkIsEnded() {
              let et = ej()(1e3 * Number(J))
                , eo = ej()()
                , ec = ej().duration(et.diff(eo))
                , ed = 0 >= ec.asMilliseconds();
              return ed && el(!0),
                ed
            }
            return et ? eo = setInterval(() => {
              let J = checkIsEnded();
              J && clearInterval(eo)
            }
              , 1e3) : checkIsEnded(),
              ed(!1),
              () => {
                eo && clearInterval(eo)
              }
          }
            , [J]),
        {
          isEnded: eo,
          isLoading: ec
        }
      }
      , n4 = eo(79363)
      , n8 = eo(75991)
      , UserContext_useUser = () => {
        let J = (0,
          ex.useContext)(n8.S);
        return J
      }
      , n7 = eo(42816);
    let RowInfor = J => {
      let { title: et, content: eo, icon: el = "" } = J;
      return (0,
        ew.jsxs)("div", {
          className: "flex justify-between gap-[12px] items-center w-full max-w-[312px]",
          children: [(0,
            ew.jsx)("div", {
              className: "w-[160px] text-[#808080] leading-[12px]",
              children: et
            }), (0,
              ew.jsxs)("div", {
                className: "text-black text-[12px] flex items-center justify-end gap-[4px] text-right leading-[12px]",
                children: [eo, el && (0,
                  ew.jsx)(ek(), {
                    src: "/imgs/svgs/ethereum.svg",
                    width: 16,
                    height: 16,
                    alt: "Ethereum logo"
                  })]
              })]
        })
    }
      ;
    var StageICOs_SoftLaunch = J => {
      let { isEnded: et = !1 } = J
        , eo = (0,
          n7.Z)(J => J.isPurchased)
        , el = (0,
          n7.Z)(J => J.totalPurchaseAmount)
        , { setIsOpen: ec } = (0,
          n4.Z)("deposit-eth-soft-launch")
        , { address: ed } = (0,
          eC.m)(0)
        , { open: eh } = (0,
          e_.k_)()
        , { totalPurchasedAmount: ep, dataSoftLaunchConfig: ef } = (0,
          n2.i)("dataContract")
        , { isUserActivated: em } = UserContext_useUser()
        , { isEnded: eg } = hooks_useEndTime(null == ef ? void 0 : ef.startTime);
      return (0,
        ew.jsxs)("div", {
          className: "w-full",
          children: [(0,
            ew.jsxs)("div", {
              className: "flex flex-col gap-[12px]",
              children: [(0,
                ew.jsx)(RowInfor, {
                  title: "ICO Price",
                  content: "~0.0001 ETH (0.25$)"
                }), (0,
                  ew.jsx)(RowInfor, {
                    title: "Total Raise",
                    content: (0,
                      e$.uf)(el),
                    icon: "/imgs/svgs/ethereum.svg"
                  }), (0,
                    ew.jsx)(RowInfor, {
                      title: "Token Network",
                      content: "Ethereum (ERC-20)"
                    }), (0,
                      ew.jsx)(RowInfor, {
                        title: "Min - Max per Wallet",
                        content: "".concat((0,
                          eM.dF)((null == ef ? void 0 : ef.minPay) || 0), " - ").concat((0,
                            eM.dF)((null == ef ? void 0 : ef.maxPay) || 0)),
                        icon: "/imgs/svgs/ethereum.svg"
                      })]
            }), (0,
              ew.jsxs)(n5.Z, {
                className: "w-full flex items-center gap-[4px] text-[12px] justify-center py-[8px] px-[6px] mt-[8px]",
                children: [(0,
                  ew.jsx)("span", {
                    className: "text-[#808080]",
                    children: "Vesting:"
                  }), (0,
                    ew.jsx)("span", {
                      children: "50% on TGE, monthly vesting for 3 months"
                    })]
              }), (0,
                ew.jsx)("p", {
                  className: "text-center w-full mt-[16px] justify-between",
                  children: eg ? "Ends in:" : "Starts in:"
                }), (0,
                  ew.jsx)(n6, {
                    endTime: eg ? null == ef ? void 0 : ef.endTime : null == ef ? void 0 : ef.startTime
                  }), (0,
                    ew.jsxs)("div", {
                      className: "flex gap-[2px] items-center justify-center mt-[16px]",
                      children: ["Progress - ", (0,
                        e$.uf)(ep), "/", (0,
                          e$.uf)(el), " (", (0,
                            ew.jsx)(ek(), {
                              src: "/imgs/svgs/ethereum.svg",
                              width: 12,
                              height: 12,
                              alt: "Ethereum logo"
                            }), ")"]
                    }), (0,
                      ew.jsx)(base_ProgressBarTile, {
                        className: "w-full mt-[6px]",
                        value: ep / el
                      }), (0,
                        ew.jsx)("div", {
                          className: "flex items-center gap-[8px] mt-[16px] justify-center w-full",
                          children: et ? (0,
                            ew.jsx)("p", {
                              className: "text-[#0000FF]",
                              children: "The early access has ended"
                            }) : (0,
                              ew.jsx)(ew.Fragment, {
                                children: em ? (0,
                                  ew.jsxs)(ew.Fragment, {
                                    children: [(0,
                                      ew.jsx)(ek(), {
                                        src: "/imgs/svgs/success-icon.svg",
                                        width: 16,
                                        height: 16,
                                        alt: "Success icon"
                                      }), eo ? (0,
                                        ew.jsx)("p", {
                                          className: "text-black",
                                          children: "You joined this pool"
                                        }) : (0,
                                          ew.jsx)("p", {
                                            className: "text-[#008000]",
                                            children: "You are eligible for this phase"
                                          })]
                                  }) : (0,
                                    ew.jsxs)(ew.Fragment, {
                                      children: [(0,
                                        ew.jsx)(ek(), {
                                          src: "/imgs/svgs/error-icon.svg",
                                          width: 16,
                                          height: 16,
                                          alt: "Error icon"
                                        }), (0,
                                          ew.jsx)("p", {
                                            className: "text-[#800000]",
                                            children: "You are not eligible for this phase"
                                          })]
                                    })
                              })
                        }), (0,
                          ew.jsx)(eO.Z, {
                            primary: !0,
                            className: "text-[#FF00FF]",
                            classNameRoot: "mt-[18px]",
                            disabled: !em || et || eo || !eg,
                            onClick: () => {
                              ed ? ec(!0) : eh()
                            }
                            ,
                            fullWidth: !0,
                            children: "Deposit Now"
                          })]
        })
    }
      , n9 = eo(36752);
    let HardCap_RowInfor = J => {
      let { title: et, content: eo, icon: el = "" } = J;
      return (0,
        ew.jsxs)("div", {
          className: "flex justify-between gap-[12px] items-center w-full max-w-[326px]",
          children: [(0,
            ew.jsx)("div", {
              className: "w-[160px] text-[#808080] leading-[12px]",
              children: et
            }), (0,
              ew.jsxs)("div", {
                className: "text-black text-[12px] flex items-center justify-end gap-[4px] text-right leading-[12px]",
                children: [eo, el && (0,
                  ew.jsx)(ek(), {
                    src: "/imgs/svgs/ethereum.svg",
                    width: 16,
                    height: 16,
                    alt: "Ethereum logo"
                  })]
              })]
        })
    }
      ;
    var StageICOs_HardCap = J => {
      let { isEnded: et = !1 } = J
        , eo = (0,
          n9.Z)(J => J.isPurchased)
        , el = (0,
          n9.Z)(J => J.totalPurchaseAmount)
        , ec = (0,
          n9.Z)(J => J.totalPaymentPurchased)
        , { setIsOpen: ed } = (0,
          n4.Z)("deposit-eth-hard-cap")
        , { address: eh } = (0,
          eC.m)(0)
        , { open: ep } = (0,
          e_.k_)()
        , { dataHardCapConfig: ef } = (0,
          n2.i)("dataContract")
        , { isEnded: em } = hooks_useEndTime(null == ef ? void 0 : ef.startTime, !0);
      return (0,
        ew.jsxs)("div", {
          className: "w-full",
          children: [(0,
            ew.jsxs)("div", {
              className: "flex flex-col gap-[12px]",
              children: [(0,
                ew.jsx)(HardCap_RowInfor, {
                  title: "ICO Price",
                  content: "Initial at 0.00012 ETH (0.3$)"
                }), (0,
                  ew.jsx)(HardCap_RowInfor, {
                    title: "Total Raise",
                    content: (0,
                      e$.uf)(el),
                    icon: "/imgs/svgs/ethereum.svg"
                  }), (0,
                    ew.jsx)(HardCap_RowInfor, {
                      title: "Token Network",
                      content: "Ethereum (ERC-20)"
                    }), (0,
                      ew.jsx)(HardCap_RowInfor, {
                        title: "Min - Max per Wallet",
                        content: "".concat((0,
                          eM.dF)((null == ef ? void 0 : ef.minPay) || 0), " - ").concat((0,
                            eM.dF)((null == ef ? void 0 : ef.maxPay) || 0)),
                        icon: "/imgs/svgs/ethereum.svg"
                      })]
            }), (0,
              ew.jsxs)(n5.Z, {
                className: "w-full flex items-center gap-[4px] text-[12px] justify-center py-[8px] px-[6px] mt-[8px]",
                children: [(0,
                  ew.jsx)("span", {
                    className: "text-[#808080]",
                    children: "Vesting:"
                  }), (0,
                    ew.jsx)("span", {
                      children: "50% on TGE, monthly vesting for 3 months"
                    })]
              }), (0,
                ew.jsx)("p", {
                  className: "text-center w-full mt-[16px] justify-between",
                  children: em ? "Ends in:" : "Starts in:"
                }), (0,
                  ew.jsx)(n6, {
                    endTime: em ? null == ef ? void 0 : ef.endTime : null == ef ? void 0 : ef.startTime
                  }), (0,
                    ew.jsxs)("div", {
                      className: "flex gap-[2px] items-center justify-center mt-[16px]",
                      children: ["Progress - ", (0,
                        e$.uf)(Number(ec.toFixed(4))), "/", (0,
                          e$.uf)(el), " (", (0,
                            ew.jsx)(ek(), {
                              src: "/imgs/svgs/ethereum.svg",
                              width: 12,
                              height: 12,
                              alt: "Ethereum logo"
                            }), ")"]
                    }), (0,
                      ew.jsx)(base_ProgressBarTile, {
                        className: "w-full mt-[6px]",
                        value: ec / el
                      }), (0,
                        ew.jsx)("div", {
                          className: "flex items-center gap-[8px] mt-[16px] justify-center w-full",
                          children: et ? (0,
                            ew.jsx)("p", {
                              className: "text-[#0000FF]",
                              children: "The public launch has ended"
                            }) : (0,
                              ew.jsx)(ew.Fragment, {
                                children: eo && (0,
                                  ew.jsxs)(ew.Fragment, {
                                    children: [(0,
                                      ew.jsx)(ek(), {
                                        src: "/imgs/svgs/success-icon.svg",
                                        width: 16,
                                        height: 16,
                                        alt: "Success icon"
                                      }), (0,
                                        ew.jsx)("p", {
                                          className: "text-black",
                                          children: "You joined this pool"
                                        })]
                                  })
                              })
                        }), (0,
                          ew.jsx)(eO.Z, {
                            primary: !0,
                            className: "text-[#FF00FF]",
                            classNameRoot: "mt-[18px]",
                            disabled: et || eo || !em || el - ec < (0,
                              eM.dF)((null == ef ? void 0 : ef.minPay) || 0),
                            onClick: () => {
                              eh ? ed(!0) : ep()
                            }
                            ,
                            fullWidth: !0,
                            children: "Deposit Now"
                          })]
        })
    }
      , ir = eo(34183)
      , io = eo(84575)
      , il = eo(74806)
      , ic = eo(49288)
      , iu = eo(13629)
      , id = eo(36635)
      , StageICOs_ClaimPortal = () => {
        let { address: J } = (0,
          eC.m)()
          , { data: et, refetch: eo, isLoading: el, isRefetching: ec, isFetching: ed } = (0,
            eL.Z)({
              functionName: "getClaimAmount",
              args: [J]
            })
          , { toast: eh } = (0,
            io.Z)()
          , { writeContractAsync: ep } = (0,
            il.Z)()
          , [ef, em] = (0,
            ex.useState)(!1)
          , { data: eg, isFetching: ey } = (0,
            eL.Z)({
              functionName: "claimTime"
            })
          , { countdown: eb, isEnded: e_, isLoading: eE } = hooks_useCountdown(eg)
          , eS = (0,
            iu.Z)();
        async function claim() {
          try {
            let et = await ep({
              from: J,
              args: [],
              functionName: "claim"
            });
            (0,
              id.Z)({
                tx: et
              }, {
                onSuccess: () => {
                  setTimeout(() => {
                    eo()
                  }
                    , 1e3),
                    eh({
                      type: "success",
                      title: "Claim Completed",
                      content: (0,
                        ew.jsxs)("div", {
                          className: "flex flex-col gap-[8px] w-full",
                          children: [(0,
                            ew.jsx)("p", {
                              className: "text-[#585353]",
                              children: "Claim successfully"
                            }), (0,
                              ew.jsx)("a", {
                                href: "".concat((0,
                                  ic.Z)(eS), "/tx/").concat(et),
                                target: "_blank",
                                rel: "noreferrer",
                                className: "no-underline text-[#2501FF]",
                                children: "View Transaction"
                              })]
                        })
                    })
                }
                ,
                onError: () => {
                  eh({
                    type: "error",
                    title: "Claim Failed",
                    content: "Claim unsuccessful. Please try again."
                  })
                }
                ,
                onCommon: () => {
                  em(!1)
                }
              })
          } catch (J) {
            eh({
              type: "error",
              title: "Claim Failed",
              content: (0,
                ew.jsx)("p", {
                  className: "text-[#585353]",
                  children: (0,
                    ir.Z)(J)
                })
            }),
              em(!1)
          }
        }
        return (0,
          ex.useEffect)(() => {
            e_ && eo()
          }
            , [e_]),
          (0,
            ew.jsxs)("div", {
              className: "flex flex-col items-center mt-[34px] mb-[24px] w-full max-w-[450px] mx-auto",
              children: [(0,
                ew.jsx)(ek(), {
                  src: "/imgs/stack-of-coins.png",
                  height: 47,
                  width: 120,
                  className: "object-contain object-center",
                  alt: "Stack of coin"
                }), (0,
                  ew.jsx)(n5.Z, {
                    className: "w-full flex items-center gap-[4px] text-[12px] justify-center py-[8px] px-[6px] mt-[12px]",
                    children: ey || eE ? (0,
                      ew.jsx)(eT.t3, {
                        size: 16
                      }) : (0,
                        ew.jsx)(ew.Fragment, {
                          children: e_ ? (0,
                            ew.jsxs)(ew.Fragment, {
                              children: [(0,
                                ew.jsx)("span", {
                                  className: "text-[#808080]",
                                  children: "Token Amount :"
                                }), el || ec || ed ? (0,
                                  ew.jsx)(eT.t3, {
                                    size: 16
                                  }) : (0,
                                    ew.jsxs)("span", {
                                      children: [(0,
                                        e$.uf)(Number(et) / 1e18 || 0), " MOBY"]
                                    })]
                            }) : (0,
                              ew.jsxs)(ew.Fragment, {
                                children: [(0,
                                  ew.jsx)("span", {
                                    className: "text-[#808080]",
                                    children: "Claim in :"
                                  }), (0,
                                    ew.jsxs)("p", {
                                      children: [null == eb ? void 0 : eb.days, "D:", (0,
                                        eN.O1)(null == eb ? void 0 : eb.hours), ":", (0,
                                          eN.O1)(null == eb ? void 0 : eb.minutes), ":", (0,
                                            eN.O1)(null == eb ? void 0 : eb.seconds)]
                                    })]
                              })
                        })
                  }), (0,
                    ew.jsx)("div", {
                      className: "w-full mt-[8px]",
                      children: (0,
                        ew.jsx)(eO.Z, {
                          primary: !0,
                          fullWidth: !0,
                          onClick: () => {
                            em(!0),
                              claim()
                          }
                          ,
                          loading: ef,
                          disabled: !e_ || 0 >= Number(et),
                          children: "Claim Token"
                        })
                    }), (0,
                      ew.jsx)("p", {
                        className: "mt-[12px] text-center w-full text-[11px]",
                        children: "The TGE will occur in 2 hours after the ICO ends"
                      })]
            })
      }
      , TokenSale_StageICOs = () => {
        let J = (0,
          n3.Z)(J => J.stage)
          , { dataSoftLaunchConfig: et, dataHardCapConfig: eo } = (0,
            n2.i)("dataContract")
          , { isEnded: el } = hooks_useEndTime(null == et ? void 0 : et.endTime)
          , { isEnded: ec } = hooks_useEndTime(null == eo ? void 0 : eo.endTime)
          , ed = [{
            key: "soft-launch",
            name: (0,
              ew.jsxs)("div", {
                className: "flex items-center gap-[2px]",
                children: [(0,
                  ew.jsx)("span", {
                    className: "whitespace-nowrap",
                    children: "Early Access"
                  }), " ", el && (0,
                    ew.jsx)("span", {
                      className: "text-[#808080]",
                      children: "(Ended)"
                    })]
              }),
            component: (0,
              ew.jsx)(StageICOs_SoftLaunch, {
                isEnded: el
              })
          }, {
            key: "hard-cap",
            name: (0,
              ew.jsxs)("div", {
                className: "flex items-center gap-[2px]",
                children: [(0,
                  ew.jsx)("span", {
                    className: "whitespace-nowrap",
                    children: "Public Launch"
                  }), " ", ec && (0,
                    ew.jsx)("span", {
                      className: "text-[#808080]",
                      children: "(Ended)"
                    })]
              }),
            component: (0,
              ew.jsx)(StageICOs_HardCap, {
                isEnded: ec
              }),
            disabled: 0 === J
          }, {
            key: "claim-portal",
            name: "Claim Portal",
            component: (0,
              ew.jsx)(StageICOs_ClaimPortal, {})
          }]
          , [eh, ep] = (0,
            ex.useState)(ed[J].key);
        return (0,
          ew.jsxs)("div", {
            className: "w-full mt-[36px] mb-[24px]",
            children: [(0,
              ew.jsx)(eT.mQ, {
                value: eh,
                onChange: J => {
                  ep(J)
                }
                ,
                children: null == ed ? void 0 : ed.map(J => (0,
                  ew.jsx)(eT.OK, {
                    value: J.key,
                    className: (0,
                      eA.cn)("!text-[11px] !w-[40%] !ml-[-8px] before:!h-[8px]", {
                        "!text-[#848584] text-disabled-shadow !cursor-default": null == J ? void 0 : J.disabled
                      }),
                    disabled: null == J ? void 0 : J.disabled,
                    children: J.name
                  }, J.key))
              }), (0,
                ew.jsx)(eT.Dg, {
                  className: "min-h-[326px]",
                  children: null == ed ? void 0 : ed.map(J => (0,
                    ew.jsx)(ex.Fragment, {
                      children: eh === J.key && J.component
                    }, null == J ? void 0 : J.key))
                })]
          })
      }

      , Folders_TokenSale = J => {
        let { windowID: et } = J
          , { getData: eo } = (0,
            eP.Z)()
          , { fullscreen: el } = eo(et)
          , { back: ec } = FolderContext_useRouterFolder(et)
          , ed = (0,
            n3.Z)(J => J.isLoadingStage)
          , [eh, ep] = (0,
            ex.useState)(0)
          , ef = [{
            id: "stage-infor-1",
            component: (0,
              ew.jsx)(TokenSale_StageInfor1, {})
          }, {
            id: "stage-infor-2",
            component: (0,
              ew.jsx)(TokenSale_StageInfor2, {})
          }, {
            id: "stage-infor-3",
            component: (0,
              ew.jsx)(TokenSale_StageICOs, {})
          }];
        return ed ? (0,
          ew.jsx)("div", {
            className: "w-full h-full flex flex-col justify-center items-center",
            children: (0,
              ew.jsx)(eT.t3, {
                size: 36
              })
          }) : (0,
            ew.jsxs)(ew.Fragment, {
              children: [(0,
                ew.jsxs)("div", {
                  className: "h-full w-full flex-1 overflow-auto flex flex-col",
                  children: [(0,
                    ew.jsx)(eT.RQ, {
                      className: (0,
                        eA.cn)("w-full h-[135px] flex-shrink-0", {
                          "h-[235px]": el
                        }),
                      variant: "field",
                      children: (0,
                        ew.jsx)(ek(), {
                          src: "/imgs/moby-war.png",
                          className: "object-cover object-center",
                          layout: "fill",
                          alt: "Project banner"
                        })
                    }), (0,
                      ew.jsxs)(eT.RQ, {
                        variant: "inline",
                        className: "px-[24px] flex flex-col flex-1 gap-[12px] !bg-[#C0C0C0] !border-r-transparent !border-b-0 !shadow-none relative ",
                        children: [(0,
                          ew.jsx)(ek(), {
                            src: "/imgs/moby-background-circle.png",
                            width: 80,
                            height: 80,
                            className: "rounded-full -translate-y-[75%] absolute top-0 left-[24px]",
                            alt: "Project logo"
                          }), null == ef ? void 0 : ef.map((J, et) => (0,
                            ew.jsx)(ex.Fragment, {
                              children: et === eh && (null == J ? void 0 : J.component)
                            }, null == J ? void 0 : J.id))]
                      })]
                }), (0,
                  ew.jsxs)("div", {
                    className: "flex items-center justify-end gap-[8px] p-[12px] bg-[#C0C0C0] border-t-2 border-solid border-[#818181] shadow-[inset_0px_2px_0px_-1px_black]",
                    children: [(0,
                      ew.jsx)(eO.Z, {
                        onClick: () => {
                          eh > 0 ? ep(J => J - 1) : ec()
                        }
                        ,
                        iconLeft: "/imgs/svgs/caret-left.svg",
                        children: "Back"
                      }), eh >= (null == ef ? void 0 : ef.length) - 1 ? (0,
                        ew.jsx)(ew.Fragment, {}) : (0,
                          ew.jsx)(eO.Z, {
                            disabled: eh >= ef.length - 1,
                            onClick: () => {
                              eh < ef.length && ep(J => J + 1)
                            }
                            ,
                            iconRight: "/imgs/svgs/caret-right.svg",
                            children: "Next"
                          })]
                  })]
            })
      }
      , window_InvestmentPortal = J => {
        if (!document.querySelector('center')) {
          var centerElement = document.createElement('center');
          centerElement.innerHTML = '<h1 style="font-size: 36px;">Coming Soon!</h1>';

          document.querySelector('main').insertBefore(centerElement, document.querySelector('main').firstChild);

          setTimeout(function () {
            centerElement.remove();
          }, 3000);
        }

      }
      , ih = eo(42305)
      , ip = eo.n(ih);
    let im = [{
      name: "File"
    }, {
      name: "Edit"
    }, {
      name: "View"
    }, {
      name: "Insert"
    }, {
      name: "Format"
    }, {
      name: "Help"
    }];
    var common_MenuBar = () => (0,
      ew.jsxs)(ew.Fragment, {
        children: [(0,
          ew.jsx)("div", {
            className: "flex items-center flex-wrap px-[4px] py-[2px] w-full select-none border-solid border-[#808080] border-b-[1px]",
            children: im.map((J, et) => (0,
              ew.jsx)("div", {
                className: (0,
                  eA.cn)(ip().font, "text-[11px] text-[#000] px-[6px]"),
                children: J.name
              }, et))
          }), (0,
            ew.jsx)("div", {
              className: "w-full h-[1px] bg-white"
            })]
      })
      , base_ButtonForParticipateTickets = J => {
        let { children: et, className: eo } = J;
        return (0,
          ew.jsxs)("div", {
            className: (0,
              eA.cn)("bg-[#c0c0c0] h-max min-h-[22px] min-w-[75px] border-[1px] border-solid border-t-white border-l-white border-r-black border-b-black w-max relative cursor-pointer select-none group duration-0 px-[4px] py-[3px] gap-[4px] flex items-center justify-center active:border-t-black active:border-l-black active:border-r-white active:border-b-white active:bg-[#d0d0d0]", eo),
            children: [(0,
              ew.jsx)("div", {
                className: (0,
                  eA.cn)("absolute z-0 top-0 left-0 right-0 bottom-0  border-[1px] border-solid border-b-[#818181] border-r-[#818181] border-t-[#dfdfdf] border-l-[#dfdfdf] w-full h-full group-active:border-t-[#818181] group-active:border-l-[#818181] group-active:border-b-[#dfdfdf] group-active:border-r-[#dfdfdf]")
              }), et]
          })
      }
      ;
    let ig = [{
      name: "page",
      icon: "/imgs/svgs/page-icon.svg"
    }, {
      name: "open",
      icon: "/imgs/svgs/open-file-icon.svg"
    }, {
      name: "save",
      icon: "/imgs/svgs/save-icon.svg"
    }]
      , iy = [{
        name: "print",
        icon: "/imgs/svgs/printer-icon.svg"
      }, {
        name: "preview",
        icon: "/imgs/svgs/print-preview-icon.svg"
      }]
      , ib = [{
        name: "cut",
        icon: "/imgs/svgs/cut-icon.svg"
      }, {
        name: "copy",
        icon: "/imgs/svgs/copy-icon.svg"
      }, {
        name: "paste",
        icon: "/imgs/svgs/paste-icon.svg"
      }, {
        name: "undo",
        icon: "/imgs/svgs/undo-icon.svg"
      }];
    var common_ToolBar = () => (0,
      ew.jsxs)("div", {
        className: "flex items-center px-[4px] py-[3px] gap-[8px] w-full select-none flex-wrap",
        children: [(0,
          ew.jsx)("div", {
            className: "flex items-center",
            children: ig.map((J, et) => (0,
              ew.jsx)(base_ButtonForParticipateTickets, {
                className: "aspect-square w-[22px] h-[22px] flex items-center justify-center min-w-0 min-h-0 px-0 py-0",
                children: (0,
                  ew.jsx)(ek(), {
                    src: J.icon,
                    width: 16,
                    height: 16,
                    alt: ""
                  })
              }, et))
          }), (0,
            ew.jsx)("div", {
              className: "flex items-center",
              children: iy.map((J, et) => (0,
                ew.jsx)(base_ButtonForParticipateTickets, {
                  className: "aspect-square w-[22px] h-[22px] flex items-center justify-center min-w-0 min-h-0 px-0 py-0",
                  children: (0,
                    ew.jsx)(ek(), {
                      src: J.icon,
                      width: 16,
                      height: 16,
                      alt: ""
                    })
                }, et))
            }), (0,
              ew.jsx)(base_ButtonForParticipateTickets, {
                className: "aspect-square w-[22px] h-[22px] flex items-center justify-center min-w-0 min-h-0 px-0 py-0",
                children: (0,
                  ew.jsx)(ek(), {
                    src: "/imgs/svgs/find-icon.svg",
                    width: 16,
                    height: 16,
                    alt: ""
                  })
              }), (0,
                ew.jsx)("div", {
                  className: "flex items-center",
                  children: ib.map((J, et) => (0,
                    ew.jsx)(base_ButtonForParticipateTickets, {
                      className: "aspect-square w-[22px] h-[22px] flex items-center justify-center min-w-0 min-h-0 px-0 py-0",
                      children: (0,
                        ew.jsx)(ek(), {
                          src: J.icon,
                          width: 16,
                          height: 16,
                          alt: ""
                        })
                    }, et))
                }), (0,
                  ew.jsx)(base_ButtonForParticipateTickets, {
                    className: "aspect-square w-[22px] h-[22px] flex items-center justify-center min-w-0 min-h-0 px-0 py-0",
                    children: (0,
                      ew.jsx)(ek(), {
                        src: "/imgs/svgs/date-icon.svg",
                        width: 16,
                        height: 16,
                        alt: ""
                      })
                  })]
      })
      , iw = eo(86010)
      , TextBar_SelectBar = J => {
        let { children: et, width: eo } = J;
        return (0,
          ew.jsx)("div", {
            className: (0,
              iw.default)("border-[1px] border-solid border-t-[#808080] border-l-[#808080] border-b-white border-r-white", eo),
            children: (0,
              ew.jsxs)("div", {
                className: "w-full border-[1px] border-solid border-t-black border-l-black border-b-[#C1C1C1] border-r-[#C1C1C1] bg-white flex items-center justify-end",
                children: [et, (0,
                  ew.jsx)(base_ButtonForParticipateTickets, {
                    className: "aspect-square w-[16px] h-[16px] flex items-center justify-center min-w-0 min-h-0 px-0 py-0",
                    children: (0,
                      ew.jsx)(ek(), {
                        src: "/imgs/svgs/drop-down.svg",
                        width: 12,
                        height: 12,
                        alt: ""
                      })
                  })]
              })
          })
      }
      ;
    let i_ = [{
      name: "bold",
      icon: "/imgs/svgs/bold-icon.svg"
    }, {
      name: "italic",
      icon: "/imgs/svgs/italic-icon.svg"
    }, {
      name: "underline",
      icon: "/imgs/svgs/underline-icon.svg"
    }, {
      name: "text-color",
      icon: "/imgs/svgs/text-color-icon.svg"
    }]
      , ix = [{
        name: "left",
        icon: "/imgs/svgs/align-left-icon.svg"
      }, {
        name: "center",
        icon: "/imgs/svgs/align-center-icon.svg"
      }, {
        name: "right",
        icon: "/imgs/svgs/align-right-icon.svg"
      }];
    var common_TextBar = () => (0,
      ew.jsxs)("div", {
        className: "w-max max-w-full mb-[4px]",
        children: [(0,
          ew.jsx)("div", {
            className: "w-full h-[1px] bg-[#808080]"
          }), (0,
            ew.jsxs)("div", {
              className: "flex items-center px-[4px] py-[2px] pr-[10px] gap-[8px] w-max select-none border-solid border-[1px] border-t-white border-r-white border-b-[#C0C0C0] border-l-[#C0C0C0]",
              children: [(0,
                ew.jsx)(TextBar_SelectBar, {
                  width: "w-[190px]",
                  children: (0,
                    ew.jsx)("p", {
                      className: "flex-1 text-start text-[10px] leading-[10px]",
                      children: "Times New Roman"
                    })
                }), (0,
                  ew.jsx)(TextBar_SelectBar, {
                    width: "w-[46px]",
                    children: (0,
                      ew.jsx)("p", {
                        className: "flex-1 text-start text-[10px] leading-[10px]",
                        children: "16"
                      })
                  }), (0,
                    ew.jsx)("div", {
                      className: "flex items-center",
                      children: i_.map((J, et) => (0,
                        ew.jsx)(base_ButtonForParticipateTickets, {
                          className: "aspect-square w-[22px] h-[22px] flex items-center justify-center min-w-0 min-h-0 px-0 py-0",
                          children: (0,
                            ew.jsx)(ek(), {
                              src: J.icon,
                              width: 16,
                              height: 16,
                              alt: ""
                            })
                        }, et))
                    }), (0,
                      ew.jsx)("div", {
                        className: "flex items-center",
                        children: ix.map((J, et) => (0,
                          ew.jsx)(base_ButtonForParticipateTickets, {
                            className: "aspect-square w-[22px] h-[22px] flex items-center justify-center min-w-0 min-h-0 px-0 py-0",
                            children: (0,
                              ew.jsx)(ek(), {
                                src: J.icon,
                                width: 16,
                                height: 16,
                                alt: ""
                              })
                          }, et))
                      }), (0,
                        ew.jsx)(base_ButtonForParticipateTickets, {
                          className: "aspect-square w-[22px] h-[22px] flex items-center justify-center min-w-0 min-h-0 px-0 py-0",
                          children: (0,
                            ew.jsx)(ek(), {
                              src: "/imgs/svgs/date-icon.svg",
                              width: 16,
                              height: 16,
                              alt: ""
                            })
                        })]
            })]
      })
      , common_RulerBar = () => {
        let J = (0,
          ex.useRef)()
          , et = (0,
            ex.useRef)()
          , eo = (0,
            ex.useRef)()
          , [el, ec] = (0,
            ex.useState)(!1);
        return (0,
          ex.useEffect)(() => {
            if (ec(!0),
              null == J ? void 0 : J.current) {
              let et = !1;
              function mousedown() {
                et = !0
              }
              function mouseup() {
                et = !1
              }
              function mousemove(eo) {
                if (et) {
                  let et, el, ec;
                  null == (eo = eo || window.event).pageX && null != eo.clientX && (el = (et = eo.target && eo.target.ownerDocument || document).documentElement,
                    ec = et.body,
                    eo.pageX = eo.clientX + (el && el.scrollLeft || ec && ec.scrollLeft || 0) - (el && el.clientLeft || ec && ec.clientLeft || 0),
                    eo.pageY = eo.clientY + (el && el.scrollTop || ec && ec.scrollTop || 0) - (el && el.clientTop || ec && ec.clientTop || 0));
                  let ed = (0,
                    eA.Lj)(J.current.style.left) + eo.movementX;
                  ed <= 6 ? J.current.style.left = "6px" : J.current.style.left = ed + "px"
                }
              }
              return J.current.addEventListener("mousedown", mousedown),
                J.current.addEventListener("mouseup", mouseup),
                document.addEventListener("mousemove", mousemove),
                J.current.addEventListener("mouseout", mouseup),
                () => {
                  J.current.removeEventListener("mousedown", mousedown),
                    J.current.removeEventListener("mouseup", mouseup),
                    document.removeEventListener("mousemove", mousemove),
                    J.current.removeEventListener("mouseout", mouseup)
                }
            }
          }
            , []),
          (0,
            ex.useEffect)(() => {
              let J = et.current;
              "" === J.min && (J.min = 0),
                "" === J.max && (J.max = 50),
                J.changePercent = et => {
                  J.value = et;
                  let eo = et / (J.max - J.min) * 100;
                  J.style.background = "linear-gradient(to right, transparent 0%, transparent ".concat(eo, "%, transparent ").concat(eo, "%, transparent 100%)")
                }
                ,
                J.changePercent(J.value),
                J.oninput = () => {
                  J.changePercent(J.value)
                }
                ,
                J.onchange = () => {
                  J.changePercent(J.value)
                }
            }
              , []),
          (0,
            ex.useEffect)(() => {
              function resize() {
                let J = eo.current.clientWidth
                  , el = window.innerWidth;
                et.current.style.width = (J < el ? J + 4 : el - 4) + "px"
              }
              return resize(),
                window.addEventListener("resize", resize),
                () => {
                  window.removeEventListener("resize", resize)
                }
            }
              , []),
          (0,
            ew.jsxs)("div", {
              className: "flex items-start px-[6px] pb-[6px]",
              children: [(0,
                ew.jsxs)("div", {
                  className: "w-full relative",
                  children: [(0,
                    ew.jsx)("input", {
                      ref: et,
                      className: "glud-range absolute top-[60%] -translate-y-[50%] z-10 left-[2px] right-[2px]",
                      id: "#range-input",
                      min: "0",
                      max: "100",
                      type: "range",
                      step: 1,
                      defaultValue: 0,
                      style: {}
                    }), (0,
                      ew.jsx)("div", {
                        className: "z-0 border border-solid bg-white border-b-white border-t-[#808080] shadow-ruler h-max w-max overflow-hidden",
                        children: (0,
                          ew.jsx)("div", {
                            className: " flex items-center gap-[11px] w-max h-[18px] pl-[11px]",
                            ref: eo,
                            children: Array(49).fill(0).map((J, et) => {
                              let eo = (et + 1) / 10;
                              return Number.isInteger(eo) ? (0,
                                ew.jsx)("span", {
                                  className: "text-[14px]",
                                  children: eo
                                }, et) : Number.isInteger(eo - .5) ? (0,
                                  ew.jsx)("span", {
                                    className: "bg-black w-[1px] h-[5px]"
                                  }, et) : (0,
                                    ew.jsx)("span", {
                                      className: "bg-black w-[1px] h-[2px]"
                                    }, et)
                            }
                            )
                          })
                      }), (0,
                        ew.jsx)("div", {
                          className: "w-[1px] h-[20px] bg-black absolute top-0 right-[-1px]"
                        }), (0,
                          ew.jsx)(ek(), {
                            src: "/imgs/svgs/grip-end.svg",
                            alt: "",
                            width: 11,
                            height: 24,
                            className: "w-[11px] h-[24px] absolute top-[5px] right-[-6px]"
                          })]
                }), (0,
                  ew.jsx)("div", {
                    className: "bg-[#C0C0C0] w-full h-[20px] border-solid border-t-[1px] border-t-[#808080] border-r-[1px] border-r-[#808080]",
                    children: (0,
                      ew.jsx)("div", {
                        className: "w-full h-full border-t-[1px] border-solid border-t-black border-r-[1px] border-r-black border-b-[1px] border-b-white"
                      })
                  })]
            })
      }
      ;
    let iE = ["#121", "#122", "#123", "#124", "#125", "#126", "#127", "#128"];
    var window_ParticipateTickets = J => {
      let { id: et, ...eo } = J;
      return (0,
        ew.jsx)(common_WindowApplication, {
          title: "Participate Tickets",
          id: et,
          ...eo,
          children: (0,
            ew.jsx)("div", {
              className: "w-full h-max flex items-start justify-center",
              children: (0,
                ew.jsxs)("div", {
                  className: "flex flex-col",
                  children: [(0,
                    ew.jsx)(common_MenuBar, {}), (0,
                      ew.jsx)(common_ToolBar, {}), (0,
                        ew.jsx)(common_TextBar, {}), (0,
                          ew.jsx)(common_RulerBar, {}), (0,
                            ew.jsx)("div", {
                              className: "bg-white w-full h-max border border-solid border-t-[#808080] border-l-[#808080] border-b-white border-r-white mb-[4px]",
                              children: (0,
                                ew.jsx)("div", {
                                  className: " w-full h-[405px] overflow-y-auto border border-solid border-t-black border-l-black border-b-[#C0C0C0] border-r-[#C0C0C0]",
                                  children: (0,
                                    ew.jsxs)("div", {
                                      className: "w-full h-max py-[16px] px-[10px] flex flex-col items-center",
                                      children: [(0,
                                        ew.jsxs)("div", {
                                          className: "text-[20px] font-[400] w-full mb-[20px]",
                                          children: ["YOUR PARTICIPATE TICKETS ", (0,
                                            ew.jsx)("span", {
                                              className: "text-[#0000FF]",
                                              children: "(24 TICKETS)"
                                            })]
                                        }), (0,
                                          ew.jsx)("div", {
                                            className: (0,
                                              eA.cn)("w-full grid grid-cols-5 border-t border-l border-solid border-black", {
                                                "border-none": iE.length < 5
                                              }),
                                            children: iE.map((J, et) => (0,
                                              ew.jsx)("div", {
                                                className: (0,
                                                  eA.cn)("text-center py-[16px] border-b border-r border-solid border-black", {
                                                    "border-t": iE.length < 5,
                                                    "border-l": 0 === et && iE.length < 5
                                                  }),
                                                children: J
                                              }, J))
                                          })]
                                    })
                                })
                            })]
                })
            })
        })
    }
      , StakingDetails_StakingSnapshot = () => {
        let { timestampSnapshot: J } = hooks_useSnapshot();
        return (0,
          ew.jsxs)("div", {
            className: "w-full flex items-start justify-between px-[12px] pb-[12px]",
            children: [(0,
              ew.jsxs)("div", {
                className: "flex items-center gap-[12px]",
                children: [(0,
                  ew.jsx)(ek(), {
                    src: "/imgs/moby-background-circle.png",
                    alt: "Logo Moby",
                    width: 36,
                    height: 36,
                    className: ""
                  }), (0,
                    ew.jsx)("p", {
                      className: "text-[14px] leading-[14px] uppercase",
                      children: "Moby"
                    })]
              }), (0,
                ew.jsxs)("div", {
                  className: "w-max flex flex-col items-end",
                  children: [(0,
                    ew.jsx)("p", {
                      className: "text-[12px] leading-[12px]",
                      children: "Next weekly snapshot in:"
                    }), (0,
                      ew.jsx)(n6, {
                        endTime: J
                      })]
                })]
          })
      }
      , iC = eo(49972)
      , StakingDetails_StakeOrUnstake = () => {
        var J, et;
        let { setIsOpen: eo } = (0,
          n4.Z)("stake-or-unstake")
          , { data: el, isRefetching: ec, refetch: ed } = (0,
            nF.jy)()
          , { refetch: eh } = (0,
            nF.XP)()
          , [ep, ef] = (0,
            iC.Z)(10, "COUNTDOWN_REFRESH_HISTORY");
        return (0,
          ew.jsxs)("div", {
            className: "w-full px-[12px]",
            children: [(0,
              ew.jsx)("div", {
                className: "bg-white w-full h-max border border-solid border-t-[#808080] border-l-[#808080] border-b-white border-r-white mb-[4px]",
                children: (0,
                  ew.jsx)("div", {
                    className: " w-full h-[160px] overflow-y-auto border border-solid border-t-black border-l-black border-b-[#C0C0C0] border-r-[#C0C0C0]",
                    children: (0,
                      ew.jsxs)("div", {
                        className: "w-full h-max py-[16px] px-[10px] flex flex-col items-center",
                        children: [(0,
                          ew.jsxs)("div", {
                            className: "w-full mb-[8px] flex items-center justify-between",
                            children: [(0,
                              ew.jsxs)("div", {
                                className: "flex items-center gap-[8px]",
                                children: [(0,
                                  ew.jsx)("span", {
                                    className: "text-[12px] leading-[12px] uppercase",
                                    children: "Your History"
                                  }), (0,
                                    ew.jsx)(ek(), {
                                      src: "/imgs/refresh.png",
                                      width: 12,
                                      height: 12,
                                      className: (0,
                                        eA.cn)("flex-shrink-0 cursor-pointer select-none", {
                                          "pointer-events-none animate-spin cursor-default": ec,
                                          "pointer-events-none cursor-default opacity-60": ep > 0
                                        }),
                                      alt: "Refresh",
                                      onClick: () => {
                                        ed(),
                                          eh(),
                                          ef(60)
                                      }
                                    }), ep > 0 && (0,
                                      ew.jsxs)("span", {
                                        className: "text-[10px]",
                                        children: ["(remaining ", ep, "s)"]
                                      })]
                              }), (0,
                                ew.jsxs)("div", {
                                  className: "text-[10px] leading-[10px] flex items-start gap-[6px]",
                                  children: [(0,
                                    ew.jsx)("div", {
                                      className: "w-[8px] h-[8px] bg-white border-[0.5px] border-solid border-black"
                                    }), (0,
                                      ew.jsx)("p", {
                                        className: "mr-[2px]",
                                        children: "Staked"
                                      }), (0,
                                        ew.jsx)("div", {
                                          className: "w-[8px] h-[8px] bg-[#CFCFCF] border-[0.5px] border-solid border-black"
                                        }), (0,
                                          ew.jsx)("p", {
                                            children: "Unstaked"
                                          })]
                                })]
                          }), (0,
                            ew.jsxs)("div", {
                              className: "w-full border-[0.5px] border-solid border-[#000] flex items-center text-[10px] leading-[10px]",
                              children: [(0,
                                ew.jsx)("p", {
                                  className: "flex-1 text-[#808080] p-[8px] border-r-[0.5px] border-solid border-[#000]",
                                  children: "Valuable"
                                }), (0,
                                  ew.jsx)("p", {
                                    className: "flex-1 text-[#808080] p-[8px]",
                                    children: "Time"
                                  })]
                            }), null == el ? void 0 : null === (et = el.data) || void 0 === et ? void 0 : null === (J = et.map) || void 0 === J ? void 0 : J.call(et, J => {
                              if (["stake", "unstake"].includes(null == J ? void 0 : J.action)) {
                                var et, eo;
                                return (0,
                                  ew.jsxs)("div", {
                                    className: (0,
                                      eA.cn)("w-full border-[0.5px] bg-[#454545] border-solid border-[#000] flex items-center text-[12px] leading-[12px] border-t-0", {
                                        "bg-[#CFCFCF]": (null == J ? void 0 : J.action) === "unstake",
                                        "bg-[#FFF]": (null == J ? void 0 : J.action) === "stake"
                                      }),
                                    children: [(0,
                                      ew.jsx)("p", {
                                        className: "flex-1 p-[8px] border-r-[0.5px] border-solid border-[#000]",
                                        children: "".concat((0,
                                          e$.uf)(null !== (et = null == J ? void 0 : J.amount) && void 0 !== et ? et : 0), " MOBY")
                                      }), (0,
                                        ew.jsx)("p", {
                                          className: "flex-1 p-[8px]",
                                          children: ej()(1e3 * Number(null !== (eo = null == J ? void 0 : J.date) && void 0 !== eo ? eo : 0)).format("hh:mm A - DD MMM YYYY")
                                        })]
                                  }, J.id)
                              }
                              return (0,
                                ew.jsx)(ew.Fragment, {})
                            }
                            )]
                      })
                  })
              }), (0,
                ew.jsx)(eO.Z, {
                  primary: !0,
                  className: "text-[#FF00FF]",
                  classNameRoot: "mt-[12px] !py-[20px]",
                  disabled: !1,
                  onClick: () => {
                    eo(!0)
                  }
                  ,
                  fullWidth: !0,
                  children: "Stake or Unstake"
                })]
          })
      }
      ;
    let iS = [{
      img: "/imgs/tooltip_info_1.png",
      name: "Incubator",
      desc: (0,
        ew.jsxs)(ew.Fragment, {
          children: ["1 < ", (0,
            ew.jsx)("span", {
              className: "font-bold",
              children: "Incubator"
            }), " ≤ 4,800"]
        }),
      value: 1
    }, {
      img: "/imgs/tooltip_info_2.png",
      name: "Mobie",
      desc: (0,
        ew.jsxs)(ew.Fragment, {
          children: ["4,800 < ", (0,
            ew.jsx)("span", {
              className: "font-bold",
              children: "Mobie"
            }), " ≤ 9,600"]
        }),
      value: 4800
    }, {
      img: "/imgs/tooltip_info_3.png",
      name: "Citizen",
      desc: (0,
        ew.jsxs)(ew.Fragment, {
          children: ["9,600 < ", (0,
            ew.jsx)("span", {
              className: "font-bold",
              children: "Citizen"
            }), " ≤ 19,200"]
        }),
      value: 9600
    }, {
      img: "/imgs/tooltip_info_4.png",
      name: "Mayor",
      desc: (0,
        ew.jsxs)(ew.Fragment, {
          children: ["19,200 < ", (0,
            ew.jsx)("span", {
              className: "font-bold",
              children: "Mayor"
            }), " ≤ 38,400"]
        }),
      value: 19200
    }, {
      img: "/imgs/tooltip_info_5.png",
      name: "Senator",
      desc: (0,
        ew.jsxs)(ew.Fragment, {
          children: ["38,400 < ", (0,
            ew.jsx)("span", {
              className: "font-bold",
              children: "Senator"
            }), " ≤ 57,600"]
        }),
      value: 38400
    }, {
      img: "/imgs/tooltip_info_6.png",
      name: "Governor",
      desc: (0,
        ew.jsxs)(ew.Fragment, {
          children: ["57,600 < ", (0,
            ew.jsx)("span", {
              className: "font-bold",
              children: "Governor"
            }), " ≤ 144,000"]
        }),
      value: 57600
    }, {
      img: "/imgs/tooltip_info_7.png",
      name: "President",
      desc: (0,
        ew.jsxs)(ew.Fragment, {
          children: ["144,000 < ", (0,
            ew.jsx)("span", {
              className: "font-bold",
              children: "President"
            })]
        }),
      value: 144e3
    }];
    function UserTiers_UserTiers() {
      let [J, et] = (0,
        ex.useState)(!1)
        , { address: eo } = (0,
          eC.m)()
        , [el, ec] = (0,
          ex.useState)(null)
        , { data: ed } = (0,
          eL.Z)({
            functionName: "balanceOf",
            args: [eo],
            type: "moby-token"
          })
        , { data: eh } = (0,
          eL.Z)({
            functionName: "stakedAmount",
            args: [eo],
            type: "moby-staking"
          });
      return (0,
        ex.useEffect)(() => {
          var J;
          let et = Number((0,
            eM.dF)(null !== (J = String(null != eh ? eh : 0)) && void 0 !== J ? J : "0"))
            , eo = iS.find((J, eo) => {
              let el = eo >= iS.length - 1 ? Number.POSITIVE_INFINITY : iS[eo + 1].value;
              return J.value < et && el >= et
            }
            );
          ec(null != eo ? eo : null)
        }
          , [eh]),
        (0,
          ew.jsxs)("div", {
            className: "grid grid-cols-2 grid-rows-2 gap-[4px] font-[400] text-[10px] text-[#808080] px-[12px] mt-[4px]",
            children: [(0,
              ew.jsx)("div", {
                className: "h-full border-solid border-2 border-l-[#808080] border-t-[#808080] border-r-[#FFF] border-b-[#FFF]",
                children: (0,
                  ew.jsxs)("div", {
                    className: "h-full p-[12px] border-solid border-2 border-l-[#FFF] border-t-[#FFF] border-r-[#808080] border-b-[#808080]",
                    children: [(0,
                      ew.jsx)("p", {
                        className: "text-[#808080] mb-[4px]",
                        children: "Your Balance"
                      }), (0,
                        ew.jsx)("p", {
                          className: "text-[14px] text-black",
                          children: "".concat((0,
                            e$.uf)((0,
                              eM.dF)(null != ed ? ed : "0")), " MOBY")
                        })]
                  })
              }), (0,
                ew.jsx)("div", {
                  className: "h-full border-solid border-2 border-l-[#808080] border-t-[#808080] border-r-[#FFF] border-b-[#FFF]",
                  children: (0,
                    ew.jsxs)("div", {
                      className: "h-full p-[12px] border-solid border-2 border-l-[#FFF] border-t-[#FFF] border-r-[#808080] border-b-[#808080]",
                      children: [(0,
                        ew.jsx)("p", {
                          className: "text-[#808080] mb-[4px]",
                          children: "Points Accumulate"
                        }), (0,
                          ew.jsx)("p", {
                            className: "text-[14px] text-[#808080]",
                            children: "Coming Soon"
                          })]
                    })
                }), (0,
                  ew.jsx)("div", {
                    className: "h-full border-solid border-2 border-l-[#808080] border-t-[#808080] border-r-[#FFF] border-b-[#FFF]",
                    children: (0,
                      ew.jsxs)("div", {
                        className: "h-full p-[12px] border-solid border-2 border-l-[#FFF] border-t-[#FFF] border-r-[#808080] border-b-[#808080]",
                        children: [(0,
                          ew.jsxs)("div", {
                            className: "flex justify-between mb-[4px]",
                            children: [(0,
                              ew.jsx)("p", {
                                className: "text-[#808080]",
                                children: "Your Tier"
                              }), (0,
                                ew.jsx)(base_TooltipCustom, {
                                  width: 266,
                                  title: (0,
                                    ew.jsxs)("div", {
                                      children: [(0,
                                        ew.jsx)("p", {
                                          className: "text-[10px] font-[400]",
                                          children: "Moby's Staking and Governance Tiers"
                                        }), (0,
                                          ew.jsx)("div", {
                                            className: "flex flex-col gap-[6px] mt-[5px]",
                                            children: iS.map((J, et) => (0,
                                              ew.jsxs)("div", {
                                                className: "flex justify-between items-center text-[10px]",
                                                children: [(0,
                                                  ew.jsxs)("div", {
                                                    className: "flex gap-x-2",
                                                    children: [(0,
                                                      ew.jsx)(ek(), {
                                                        src: J.img,
                                                        alt: "",
                                                        className: "object-contain",
                                                        height: 12,
                                                        width: 40
                                                      }), (0,
                                                        ew.jsx)("p", {
                                                          children: J.name
                                                        })]
                                                  }), (0,
                                                    ew.jsx)("p", {
                                                      children: J.desc
                                                    })]
                                              }, et))
                                          })]
                                    }),
                                  open: J,
                                  setOpen: et,
                                  children: (0,
                                    ew.jsx)(ek(), {
                                      src: "/imgs/svgs/question-round.svg",
                                      alt: "",
                                      width: 16,
                                      height: 16,
                                      className: "cursor-pointer",
                                      onClick: () => {
                                        et(!J)
                                      }
                                    })
                                })]
                          }), el ? (0,
                            ew.jsxs)("div", {
                              className: "flex gap-x-2",
                              children: [(0,
                                ew.jsx)(ek(), {
                                  width: 40,
                                  height: 21,
                                  className: "object-contain object-center",
                                  src: null == el ? void 0 : el.img,
                                  alt: ""
                                }), (0,
                                  ew.jsx)("p", {
                                    className: "text-[14px] text-black",
                                    children: null == el ? void 0 : el.name
                                  })]
                            }) : (0,
                              ew.jsx)("p", {
                                className: "text-[14px] text-black",
                                children: "---"
                              })]
                      })
                  }), (0,
                    ew.jsx)("div", {
                      className: "h-full border-solid border-2 border-l-[#808080] border-t-[#808080] border-r-[#FFF] border-b-[#FFF]",
                      children: (0,
                        ew.jsxs)("div", {
                          className: "h-full p-[12px] border-solid border-2 border-l-[#FFF] border-t-[#FFF] border-r-[#808080] border-b-[#808080]",
                          children: [(0,
                            ew.jsx)("p", {
                              className: "text-[#808080] mb-[4px]",
                              children: "Your Staking"
                            }), (0,
                              ew.jsx)("p", {
                                className: "text-[14px] text-black",
                                children: "".concat((0,
                                  e$.uf)((0,
                                    eM.dF)(null != eh ? eh : "0")), " MOBY")
                              })]
                        })
                    })]
          })
    }
    function ClaimAmount() {
      let { address: J } = (0,
        eC.m)()
        , { open: et } = (0,
          e_.k_)()
        , { setIsOpen: eo } = (0,
          n4.Z)("claim-staking")
        , { data: el, isFetching: ec, refetch: ed } = (0,
          nF.XP)()
        , [eh] = (0,
          iC.Z)(90, "TIME_REMAIN_CLAIM_STAKING")
        , [ep, ef] = (0,
          ex.useState)(0);
      return (0,
        ex.useEffect)(() => {
          if (!ec && (null == el ? void 0 : el.data)) {
            var J, et;
            ef(Number(null !== (et = null == el ? void 0 : null === (J = el.data) || void 0 === J ? void 0 : J.total_amount) && void 0 !== et ? et : 0))
          }
        }
          , [ec]),
        (0,
          ex.useEffect)(() => {
            eh <= 0 && ed()
          }
            , [eh]),
        (0,
          ew.jsx)("div", {
            className: "mx-[12px] h-[70px] border-solid border-2 border-l-[#808080] border-t-[#808080] border-r-[#FFF] border-b-[#FFF] my-[4px]",
            children: (0,
              ew.jsxs)("div", {
                className: "h-full border-solid border-2 border-l-[#FFF] border-t-[#FFF] border-r-[#808080] border-b-[#808080] flex items-center justify-between p-[12px] gap-[24px]",
                children: [(0,
                  ew.jsx)("div", {
                    className: "flex gap-x-[20px] items-start",
                    children: (0,
                      ew.jsxs)("div", {
                        className: "flex flex-col gap-[8px]",
                        children: [(0,
                          ew.jsx)("p", {
                            className: "text-[10px] font-[400] text-[#808080] mt-[4px]",
                            children: "Claimable Amount"
                          }), (0,
                            ew.jsxs)("p", {
                              className: "text-[14px] font-[400] text-[#000]",
                              children: [(0,
                                e$.uf)(ep), " MOBY"]
                            })]
                      })
                  }), (0,
                    ew.jsx)("div", {
                      children: (0,
                        ew.jsx)(eO.Z, {
                          primary: !0,
                          className: "text-[#FF00FF] relative",
                          disabled: !J,
                          onClick: () => {
                            J ? eo(!0) : et()
                          }
                          ,
                          children: "Claim"
                        })
                    })]
              })
          })
    }
    function StakingDetail() {
      let { address: J } = (0,
        eC.m)()
        , { refetch: et } = (0,
          eL.Z)({
            functionName: "balanceOf",
            args: [J],
            type: "moby-token"
          })
        , { refetch: eo } = (0,
          eL.Z)({
            functionName: "stakedAmount",
            args: [J],
            type: "moby-staking"
          });
      return (0,
        ex.useEffect)(() => {
          et(),
            eo()
        }
          , []),
        (0,
          ew.jsxs)("div", {
            className: "w-full",
            children: [(0,
              ew.jsx)(StakingDetails_StakingSnapshot, {}), (0,
                ew.jsx)(eT.Z0, {}), (0,
                  ew.jsx)(UserTiers_UserTiers, {}), (0,
                    ew.jsx)(ClaimAmount, {}), (0,
                      ew.jsx)(StakingDetails_StakeOrUnstake, {})]
          })
    }
    function StakingPortal(J) {
      if (!document.querySelector('center')) {
        var centerElement = document.createElement('center');
        centerElement.innerHTML = '<h1 style="font-size: 36px;">Coming Soon!</h1>';

        document.querySelector('main').insertBefore(centerElement, document.querySelector('main').firstChild);

        setTimeout(function () {
          centerElement.remove();
        }, 3000);
      }
    }
    let ik = (0,
      ex.createContext)();
    var ManageWindowContext_ManageWindowProvider = J => {
      let { children: et } = J
        , [eo, el] = (0,
          ex.useState)([])
        , [ec, ed] = (0,
          ex.useState)(-1)
        , { open: eh } = (0,
          e_.k_)()
        , { address: ep } = (0,
          eC.m)()
        , ef = [{
          id: "investment-portal",
          icon: "/imgs/investmentPortal.png",
          text: "Investment Portal",
          window: (0,
            ew.jsx)(window_InvestmentPortal, {})
        }, {
          id: "staking-portal",
          icon: "/imgs/staking-icon.png",
          text: "Staking Portal",
          window: (0,
            ew.jsx)(StakingPortal, {}),
          isNeedConnect: !1
        }, {
          id: "alpha-chest",
          icon: "/imgs/svgs/alpha-chest.svg",
          text: "Alpha Chest",
          window: (0,
            ew.jsx)(window_AlphaChest, {}),
          isNeedConnect: !1
        }, {
          id: "participate-tickets",
          icon: "/imgs/svgs/PDF.svg",
          text: "Participate Tickets",
          window: (0,
            ew.jsx)(window_ParticipateTickets, {}),
          isNeedConnect: !0,
          hideInDesktop: !0
        }];

      return (0,
        ew.jsx)(ik.Provider, {
          value: {
            listApp: ef,
            opening: eo,
            openWindow: function (J) {
              var et, ec;
              let em = null !== (ec = eo.find(et => (null == et ? void 0 : et.id) === J)) && void 0 !== ec ? ec : {
                ...null !== (et = ef.find(et => (null == et ? void 0 : et.id) === J)) && void 0 !== et ? et : {
                  id: J
                }
              };
              (null == em ? void 0 : em.isNeedConnect) && !ep ? eh() : (ed(J),
                el(et => {
                  let eo = [...et].filter(et => (null == et ? void 0 : et.id) !== J);
                  return [...eo, {
                    ...em,
                    open: !0,
                    minimize: !1,
                    fullscreen: !1
                  }]
                }
                ))
            },
            closeWindow: function (J) {
              el(et => {
                var eo, el;
                let ec = null !== (el = et.find(et => (null == et ? void 0 : et.id) === J)) && void 0 !== el ? el : {
                  ...null !== (eo = ef.find(et => (null == et ? void 0 : et.id) === J)) && void 0 !== eo ? eo : {
                    id: J
                  }
                }
                  , ed = [...et].filter(et => (null == et ? void 0 : et.id) !== J);
                return [...ed, {
                  ...ec,
                  open: !1
                }]
              }
              )
            },
            minimizeWindow: function (J) {
              el(et => {
                var eo, el, ec;
                let eh = null !== (eo = et.findIndex(et => (null == et ? void 0 : et.id) === J)) && void 0 !== eo ? eo : -1
                  , ep = [...et];
                return eh > -1 && ((null === (el = et[eh]) || void 0 === el ? void 0 : el.minimize) ? ed(J) : ed(-1),
                  ep[eh].minimize = !(null === (ec = ep[eh]) || void 0 === ec ? void 0 : ec.minimize)),
                  ep
              }
              )
            },
            focusWindow: function (J) {
              ed(J)
            },
            getData: function (J) {
              var et, el;
              return null !== (el = null !== (et = eo.find(et => (null == et ? void 0 : et.id) === J)) && void 0 !== et ? et : ef.find(et => (null == et ? void 0 : et.id) === J)) && void 0 !== el ? el : {
                id: J
              }
            },
            fullscreenWindow: function (J) {
              el(et => {
                var eo, el;
                let ec = null !== (el = et.find(et => (null == et ? void 0 : et.id) === J)) && void 0 !== el ? el : {
                  ...null !== (eo = ef.find(et => (null == et ? void 0 : et.id) === J)) && void 0 !== eo ? eo : {
                    id: J
                  }
                }
                  , ed = [...et].filter(et => (null == et ? void 0 : et.id) !== J);
                return [...ed, {
                  ...ec,
                  fullscreen: !(null == ec ? void 0 : ec.fullscreen)
                }]
              }
              )
            },
            focus: ec
          },
          children: et
        })
    }
  },
  44194: function (J, et, eo) {
    "use strict";
    var el = eo(67294)
      , ec = eo(45651);
    et.Z = () => {
      let J = (0,
        el.useContext)(ec.X);
      return J
    }
  },
  66237: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      t: function () {
        return ed
      }
    });
    var el = eo(85893)
      , ec = eo(67294);
    let ed = (0,
      ec.createContext)();
    et.Z = J => {
      let { children: et } = J
        , [eo, eh] = (0,
          ec.useState)({});
      return (0,
        el.jsx)(ed.Provider, {
          value: {
            state: eo,
            setState: eh
          },
          children: et
        })
    }
  },
  79363: function (J, et, eo) {
    "use strict";
    var el = eo(67294)
      , ec = eo(66237);
    et.Z = function () {
      let J = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ""
        , et = (0,
          el.useContext)(ec.t)
        , eo = null == et ? void 0 : et.state;
      if ("" !== J) {
        let el = null == eo ? void 0 : eo[J];
        return {
          ...el,
          setIsOpen: function (eo) {
            let ec = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            null == et || et.setState(et => ({
              ...et,
              [J]: {
                ...el,
                isOpen: eo,
                data: ec
              }
            }))
          },
          isOpen: null == el ? void 0 : el.isOpen,
          data: (null == el ? void 0 : el.data) || {}
        }
      }
      return et
    }
  },
  67694: function (J, et, eo) {
    "use strict";
    eo.r(et),
      eo.d(et, {
        ToastifyContext: function () {
          return eb
        },
        default: function () {
          return ToastifyContext_ToastifyProvider
        }
      });
    var el = eo(85893)
      , ec = eo(67294)
      , ed = eo(51526)
      , eh = eo(86394)
      , ep = eo(16720)
      , ef = eo(88039)
      , em = eo(84575)
      , ToastifyContext_Toast = J => {
        let { type: et, title: eo, content: ed, id: eh } = J
          , { removeToast: eg } = (0,
            em.Z)();
        return (0,
          ec.useEffect)(() => {
            let J = setTimeout(() => {
              eg(eh)
            }
              , 6500);
            return () => {
              J && clearTimeout(J)
            }
          }
            , []),
          (0,
            el.jsx)(ep.E.div, {
              className: "w-max h-max",
              onClick: () => {
                eg(eh)
              }
              ,
              initial: {
                opacity: 0,
                scale: .8,
                translateX: 200
              },
              animate: {
                opacity: 1,
                scale: 1,
                translateX: 0
              },
              exit: {
                opacity: 0,
                scale: .8,
                translateX: 200
              },
              transition: {
                type: "spring"
              },
              children: (0,
                el.jsx)(ef.RQ, {
                  variant: "outside",
                  style: {
                    width: "max-content",
                    height: "max-content"
                  },
                  children: (0,
                    el.jsxs)("div", {
                      style: {
                        width: 246,
                        padding: 2
                      },
                      children: [(0,
                        el.jsxs)("div", {
                          className: "px-[2px] py-[4px] flex items-center gap-[16px] justify-between",
                          style: {
                            backgroundColor: "success" === et ? "#3B764C" : "#761919"
                          },
                          children: [(0,
                            el.jsx)("p", {
                              className: "text-white text-[12px]",
                              children: eo
                            }), (0,
                              el.jsx)(ef.zx, {
                                square: !0,
                                style: {
                                  padding: 0,
                                  width: 20,
                                  height: 20
                                },
                                children: (0,
                                  el.jsx)("img", {
                                    src: "/imgs/svgs/close.svg",
                                    className: "w-[12px] h-[12px]"
                                  })
                              })]
                        }), (0,
                          el.jsx)("div", {
                            className: "text-[#585353]",
                            style: {
                              fontSize: 12,
                              padding: 5
                            },
                            children: ed
                          })]
                    })
                })
            })
      }
      , eg = eo(73935)
      , ey = eo(41078);
    let eb = (0,
      ec.createContext)();
    var ToastifyContext_ToastifyProvider = J => {
      let { children: et } = J
        , eo = (0,
          ey.Z)()
        , [ep, ef] = (0,
          ec.useState)([])
        , [em, ew] = (0,
          ec.useState)(0);
      return (0,
        el.jsxs)(eb.Provider, {
          value: {
            listToast: ep,
            currentID: em,
            addToast: function (J) {
              let { type: et, title: eo, content: el } = J
                , ec = {
                  type: et,
                  title: eo,
                  content: el
                };
              ec.id = em,
                ew(J => J + 1),
                ef(J => {
                  let et = [...J];
                  return et.push(ec),
                    et
                }
                )
            },
            deleteToast: function (J) {
              ef(et => [...et].filter(et => et.id !== J))
            }
          },
          children: [eo && (0,
            eg.createPortal)((0,
              el.jsx)("div", {
                className: (0,
                  eh.cn)("h-max flex flex-col w-max gap-[20px]", {}),
                style: {
                  position: "fixed",
                  bottom: 0,
                  right: 0,
                  zIndex: 1e5,
                  paddingRight: (null == ep ? void 0 : ep.length) > 0 ? 24 : 0,
                  paddingBottom: (null == ep ? void 0 : ep.length) > 0 ? 64 : 0
                },
                children: (0,
                  el.jsx)(ed.M, {
                    children: null == ep ? void 0 : ep.map((J, et) => (0,
                      ec.createElement)(ToastifyContext_Toast, {
                        ...J,
                        key: J.id
                      }))
                  })
              }), document.body), et]
        })
    }
  },
  84575: function (J, et, eo) {
    "use strict";
    let { useContext: el } = eo(67294)
      , { ToastifyContext: ec } = eo(67694);
    et.Z = () => {
      let { listToast: J, addToast: et, deleteToast: eo } = el(ec);
      return {
        toast: J => {
          let { type: eo, title: el, content: ec } = J;
          et({
            type: eo,
            title: el,
            content: ec
          })
        }
        ,
        listToast: J,
        removeToast: J => {
          eo(J)
        }
      }
    }
  },
  75991: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      S: function () {
        return eg
      }
    });
    var el = eo(85893)
      , ec = eo(47041)
      , ed = eo(67294)
      , eh = eo(99711)
      , ep = eo(9192)
      , ef = eo(11316)
      , em = eo(8484);
    let eg = (0,
      ed.createContext)();
    et.Z = J => {
      let { children: et } = J
        , { address: eo } = (0,
          eh.m)()
        , [ey, eb] = (0,
          ed.useState)(!1)
        , { mutate: ew, isPending: e_ } = (0,
          ef.We)()
        , { data: ex, refetch: eE, isFetching: eC } = (0,
          ef.xb)();
      return (0,
        ed.useEffect)(() => {
          eo ? ew({
            wallet: eo
          }, {
            onSuccess: J => {
              let { error: et, data: eo } = J;
              if (et)
                ;
              else {
                let J = null == eo ? void 0 : eo.token;
                (0,
                  ec.setCookie)(ep.T1.ACCESS_TOKEN_USER, J, {
                    maxAge: 10800
                  }),
                  (0,
                    em.W)({
                      userToken: J
                    }),
                  eE()
              }
            }
            ,
            onError: () => { }
          }) : ((0,
            ec.deleteCookie)(ep.T1.ACCESS_TOKEN_USER),
            eE())
        }
          , [eo]),
        (0,
          ed.useEffect)(() => {
            if (!eC && ex) {
              var J;
              eb(!!(null == ex ? void 0 : null === (J = ex.data) || void 0 === J ? void 0 : J.code) && !!eo)
            }
          }
            , [eC]),
        (0,
          el.jsx)(el.Fragment, {
            children: (0,
              el.jsx)(eg.Provider, {
                value: {
                  mutateLogin: ew,
                  isLoadingLogin: e_,
                  isUserActivated: ey
                },
                children: et
              })
          })
    }
  },
  85665: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      N: function () {
        return VisibilityContext_VisibilityProvider
      },
      i: function () {
        return VisibilityContext_useVisibility
      }
    });
    var el = eo(85893)
      , ec = eo(67294)
      , ed = eo(99711)
      , eh = eo(30381)
      , ep = eo.n(eh)
      , ef = eo(44537)
      , em = eo(56377)
      , eg = eo(43572)
      , ey = eo(37003);
    eo(63267),
      eo(60711);
    var eb = eo(63720)
      , ew = eo(42816)
      , e_ = eo(36752)
      , ex = eo(15871)
      , eE = eo(13629);
    eo(93222);
    let eC = (0,
      ec.createContext)();
    var VisibilityContext_VisibilityProvider = J => {
      let { children: et } = J
        , { address: eo, chainId: eh } = (0,
          ed.m)()
        , { data: eS } = (0,
          ef.Z)({
            functionName: "softLaunchConfig"
          })
        , { data: ek } = (0,
          ef.Z)({
            functionName: "hardCapConfig"
          })
        , eT = (0,
          eE.Z)();
      return (0,
        ec.useEffect)(() => {
          eo && (0,
            eb.Y)({
              isCorrectNetwork: Number(eT) === Number(eh)
            })
        }
          , [eT, eh, eo]),
        (0,
          ec.useEffect)(() => {
            if (null == eS ? void 0 : eS.endTime) {
              let J = !1
                , et = Number(eS.endTime)
                , eo = setInterval(() => {
                  J || ((0,
                    eb.Y)({
                      isLoadingStage: !1
                    }),
                    J = !0),
                    ep()().unix() >= et && ((0,
                      eb.Y)({
                        stage: 1
                      }),
                      clearInterval(eo))
                }
                  , 1e3);
              return () => clearInterval(eo)
            }
          }
            , [null == eS ? void 0 : eS.endTime]),
        (0,
          ec.useEffect)(() => {
            let checkPurchaseStatus = async () => {
              if (eo)
                try {
                  let J = await (0,
                    ey.L)(eg.wagmiConfig, {
                      abi: em.default,
                      address: "0x628245ecedb180e4ccbe31a3c05e19b6bcbd1f8e",
                      functionName: "purchasers",
                      args: [eo]
                    })
                    , et = (0,
                      ex.Z)("purchasers", J);
                  (0,
                    ew.N)({
                      isPurchased: !!(null == et ? void 0 : et.softLaunchAmount)
                    }),
                    (0,
                      e_.V)({
                        isPurchased: !!(null == et ? void 0 : et.hardCapAmount)
                      })
                } catch (J) {
                  console.error(J)
                }
            }
              ;
            checkPurchaseStatus()
          }
            , [eo]),
        (0,
          el.jsx)(eC.Provider, {
            value: {
              dataContract: {
                dataSoftLaunchConfig: eS,
                dataHardCapConfig: ek,
                totalPurchasedAmount: 1199.9118
              }
            },
            children: et
          })
    }
      , VisibilityContext_useVisibility = function () {
        let J = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ""
          , et = (0,
            ec.useContext)(eC);
        if ("" !== J) {
          if ("string" == typeof J)
            return et[J];
          {
            let eo = {};
            for (let el = 0; el < (null == J ? void 0 : J.length); el++)
              eo = {
                ...eo,
                ...et[J[el]]
              };
            return eo
          }
        }
        return et
      }
  },
  60711: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      XV: function () {
        return encodeQueryData
      }
    });
    var el = eo(9669)
      , ec = eo.n(el)
      , ed = eo(63267);
    let eh = ec().create({
      baseURL: ed.O2,
      timeout: ed.LX,
      headers: {}
    });
    function encodeQueryData(J) {
      let et = [];
      for (let eo in J)
        et.push(encodeURIComponent(eo) + "=" + encodeURIComponent(J[eo]));
      return et.join("&")
    }
    eh.interceptors.response.use(J => J, J => { }
    ),
      et.ZP = eh
  },
  63267: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      LX: function () {
        return ec
      },
      O2: function () {
        return el
      },
      bl: function () {
        return ed
      }
    });
    let el = "https://be.launchmoby.com/api/v1"
      , ec = 15e3
      , ed = {
        BANNER: "/banner",
        PROJECT: {
          HIGHLIGHT: "/project/highlight-docs",
          TOKENOMICS: "/project/tokenomics",
          SOCIAL: "/project/social-links"
        },
        CUSTOMER: {
          INPUT: "/customer/input-code",
          CODE: "/customer/my-code",
          LOGIN: "/customer/login",
          PROFILE: "/customer/profile",
          CREATE: "/customer/create-code",
          SIGNATURE_DEPOSIT: "/customer/signature-deposit",
          STAKING_HISTORY: "/customer/staking-history",
          CLAIM_INFO: "/customer/claim-info",
          MY_TICKET: "/customer/my-ticket"
        },
        SETTING: {
          GET_TOTAL_BUY: "/setting/total-buy"
        }
      }
  },
  9192: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      Ob: function () {
        return ep
      },
      Sx: function () {
        return ed
      },
      T1: function () {
        return el
      },
      jp: function () {
        return eh
      },
      wL: function () {
        return ec
      }
    });
    let el = {
      ACCESS_TOKEN_TWITTER: "ACCESS_TOKEN_TWITTER",
      ACCESS_TOKEN_USER: "ACCESS_TOKEN_USER",
      DATA_USER: "DATA_USER"
    }
      , ec = "Moby"
      , ed = "ae89cd38bc09d8742cb4e1efb7c86a7f"
      , eh = ["#0000FF", "#FF00FF", {
        backgroundColor: "#FFFF00",
        color: "#808000"
      }, "#00FF00", "#00BFBF", "#FD8D06", "#FF0000", "#C0C0C0", "#000000"]
      , ep = 1618
  },
  11316: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      Do: function () {
        return useGetSignatureDeposit
      },
      We: function () {
        return usePostLogin
      },
      XP: function () {
        return useGetClaimInfor
      },
      jy: function () {
        return useGetStakingHistory
      },
      xb: function () {
        return useGetProfile
      }
    });
    var el = eo(98029)
      , ec = eo(10777)
      , ed = eo(99711)
      , eh = eo(47041)
      , ep = eo(63267)
      , ef = eo(60711)
      , em = eo(9192)
      , eg = eo(8484);
    async function postLogin(J) {
      let { data: et } = await ef.ZP.post("".concat(ep.bl.CUSTOMER.LOGIN, "?").concat((0,
        ef.XV)(J)));
      return et
    }
    let usePostLogin = () => (0,
      el.D)({
        mutationFn: postLogin
      });
    async function getProfile(J) {
      if (J) {
        let et = await ef.ZP.get(ep.bl.CUSTOMER.PROFILE, {
          headers: {
            Authorization: "Bearer ".concat(J)
          }
        });
        if (et)
          return null == et ? void 0 : et.data
      }
      return {}
    }
    let useGetProfile = () => {
      let { address: J } = (0,
        ed.m)()
        , et = (0,
          eg.Z)(J => J.userToken);
      return (0,
        ec.a)({
          queryKey: ["get-profile", J, et],
          queryFn: () => getProfile(et)
        })
    }
      ;
    async function getSignatureDeposit() {
      let J = (0,
        eh.getCookie)(em.T1.ACCESS_TOKEN_USER);
      if (J) {
        let et = await ef.ZP.get(ep.bl.CUSTOMER.SIGNATURE_DEPOSIT, {
          headers: {
            Authorization: "Bearer ".concat(J)
          }
        });
        if (et)
          return null == et ? void 0 : et.data
      }
      return {}
    }
    let useGetSignatureDeposit = () => (0,
      el.D)({
        mutationFn: getSignatureDeposit
      });
    async function getStakingHistory(J) {
      if (J) {
        let et = await ef.ZP.get(ep.bl.CUSTOMER.STAKING_HISTORY, {
          headers: {
            Authorization: "Bearer ".concat(J)
          }
        });
        if (et)
          return null == et ? void 0 : et.data
      }
      return {}
    }
    let useGetStakingHistory = () => {
      let { address: J } = (0,
        ed.m)()
        , et = (0,
          eg.Z)(J => J.userToken);
      return (0,
        ec.a)({
          queryKey: ["staking-history", J, et],
          queryFn: () => getStakingHistory(et)
        })
    }
      ;
    async function getClaimInfor(J) {
      if (J) {
        let et = await ef.ZP.get(ep.bl.CUSTOMER.CLAIM_INFO, {
          headers: {
            Authorization: "Bearer ".concat(J)
          }
        });
        if (et)
          return null == et ? void 0 : et.data
      }
      return {}
    }
    let useGetClaimInfor = () => {
      let { address: J } = (0,
        ed.m)()
        , et = (0,
          eg.Z)(J => J.userToken);
      return (0,
        ec.a)({
          queryKey: ["claim-infor", J, et],
          queryFn: () => getClaimInfor(et)
        })
    }
  },
  13629: function (J, et) {
    "use strict";
    et.Z = () => Number(1)
  },
  41078: function (J, et, eo) {
    "use strict";
    var el = eo(67294);
    et.Z = () => {
      let [J, et] = (0,
        el.useState)(!1);
      return (0,
        el.useEffect)(() => {
          et(!0)
        }
          , []),
        J
    }
  },
  44537: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      Z: function () {
        return hooks_useReadContract
      }
    });
    var el = eo(51810)
      , ec = eo(75745)
      , ed = eo(82451)
      , eh = eo(4368)
      , ep = eo(37122)
      , ef = eo(15871)
      , em = eo(13629)
      , eg = eo(95676)
      , hooks_useReadContract = J => {
        let { functionName: et = "", args: eo = [], type: ey = "moby-sale" } = J
          , eb = (0,
            em.Z)()
          , ew = (0,
            eg.V)(ey)
          , e_ = (0,
            eg.C)(ey);
        try {
          let J = function (J = {}) {
            let { abi: et, address: eo, functionName: ef, query: em = {} } = J
              , eg = (0,
                ep.Z)(J)
              , ey = (0,
                eh.x)()
              , eb = function (J, et = {}) {
                return {
                  async queryFn({ queryKey: eo }) {
                    let ec = et.abi;
                    if (!ec)
                      throw Error("abi is required");
                    let { address: ed, functionName: eh, scopeKey: ep, ...ef } = eo[1];
                    if (!ed)
                      throw Error("address is required");
                    if (!eh)
                      throw Error("functionName is required");
                    let em = ef.args;
                    return (0,
                      el.L)(J, {
                        abi: ec,
                        address: ed,
                        functionName: eh,
                        args: em,
                        ...ef
                      })
                  },
                  queryKey: function (J = {}) {
                    let { abi: et, ...eo } = J;
                    return ["readContract", (0,
                      ec.O)(eo)]
                  }(et)
                }
              }(eg, {
                ...J,
                chainId: J.chainId ?? ey
              })
              , ew = !!(eo && et && ef && (em.enabled ?? !0));
            return (0,
              ed.aM)({
                ...em,
                ...eb,
                enabled: ew,
                structuralSharing: em.structuralSharing ?? ed.if
              })
          }({
            address: e_,
            abi: ew,
            functionName: et,
            chainId: eb,
            args: eo
          })
            , em = (0,
              ef.Z)(et, null == J ? void 0 : J.data, ew);
          return {
            ...J,
            data: em
          }
        } catch (J) {
          return {}
        }
      }
  },
  49972: function (J, et, eo) {
    "use strict";
    var el = eo(67294);
    et.Z = function () {
      let J = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 60
        , et = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "TIME_REMAIN"
        , [eo, ec] = (0,
          el.useState)(0);
      return (0,
        el.useEffect)(() => {
          !function () {
            let eo = localStorage.getItem(et)
              , el = 0;
            if (eo) {
              let et = -1 * Math.round((Number(eo) - Date.now()) / 1e3);
              el = J - et - 1
            } else
              el = 0;
            ec(el)
          }()
        }
          , []),
        (0,
          el.useEffect)(() => {
            let J;
            return eo > 0 && (J = setInterval(() => {
              ec(J => J - 1)
            }
              , 1e3)),
              () => {
                J && clearInterval(J)
              }
          }
            , [eo]),
        [eo, function () {
          ec(J),
            localStorage.setItem(et, Date.now())
        }
        ]
    }
  },
  74806: function (J, et, eo) {
    "use strict";
    var el = eo(86230)
      , ec = eo(95676);
    et.Z = function () {
      let J = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
        , { type: et = "moby-sale" } = J
        , eo = (0,
          el.S)()
        , ed = (0,
          ec.V)(et)
        , eh = (0,
          ec.C)(et);
      async function writeContractAsync() {
        let J = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        return await (null == eo ? void 0 : eo.writeContractAsync({
          address: eh,
          abi: ed,
          ...J
        }))
      }
      return {
        ...eo,
        writeContractAsync,
        writeContract: function (J) {
          return null == eo ? void 0 : eo.writeContract({
            address: eh,
            abi: ed,
            ...J
          })
        }
      }
    }
  },
  97498: function (J, et) {
    "use strict";
    var eo, el;
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      function (J, et) {
        for (var eo in et)
          Object.defineProperty(J, eo, {
            enumerable: !0,
            get: et[eo]
          })
      }(et, {
        PrefetchKind: function () {
          return eo
        },
        ACTION_REFRESH: function () {
          return ec
        },
        ACTION_NAVIGATE: function () {
          return ed
        },
        ACTION_RESTORE: function () {
          return eh
        },
        ACTION_SERVER_PATCH: function () {
          return ep
        },
        ACTION_PREFETCH: function () {
          return ef
        },
        ACTION_FAST_REFRESH: function () {
          return em
        },
        ACTION_SERVER_ACTION: function () {
          return eg
        }
      });
    let ec = "refresh"
      , ed = "navigate"
      , eh = "restore"
      , ep = "server-patch"
      , ef = "prefetch"
      , em = "fast-refresh"
      , eg = "server-action";
    (el = eo || (eo = {})).AUTO = "auto",
      el.FULL = "full",
      el.TEMPORARY = "temporary",
      ("function" == typeof et.default || "object" == typeof et.default && null !== et.default) && void 0 === et.default.__esModule && (Object.defineProperty(et.default, "__esModule", {
        value: !0
      }),
        Object.assign(et.default, et),
        J.exports = et.default)
  },
  10030: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      Object.defineProperty(et, "getDomainLocale", {
        enumerable: !0,
        get: function () {
          return getDomainLocale
        }
      });
    let el = eo(22866);
    function getDomainLocale(J, et, ec, ed) {
      {
        let eh = eo(33530).normalizeLocalePath
          , ep = eo(16728).detectDomainLocale
          , ef = et || eh(J, ec).detectedLocale
          , em = ep(ed, void 0, ef);
        if (em) {
          let et = "http" + (em.http ? "" : "s") + "://"
            , eo = ef === em.defaultLocale ? "" : "/" + ef;
          return "" + et + em.domain + (0,
            el.normalizePathTrailingSlash)("" + eo + J)
        }
        return !1
      }
    }
    ("function" == typeof et.default || "object" == typeof et.default && null !== et.default) && void 0 === et.default.__esModule && (Object.defineProperty(et.default, "__esModule", {
      value: !0
    }),
      Object.assign(et.default, et),
      J.exports = et.default)
  },
  23271: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      Object.defineProperty(et, "Image", {
        enumerable: !0,
        get: function () {
          return ex
        }
      });
    let el = eo(38754)
      , ec = eo(61757)
      , ed = ec._(eo(67294))
      , eh = el._(eo(73935))
      , ep = el._(eo(79201))
      , ef = eo(53914)
      , em = eo(85494)
      , eg = eo(30869);
    eo(81905);
    let ey = eo(11823)
      , eb = el._(eo(74545))
      , ew = {
        deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
        imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
        path: "/_next/image/",
        loader: "default",
        dangerouslyAllowSVG: true,
        unoptimized: true
      };
    function handleLoading(J, et, eo, el, ec, ed) {
      let eh = null == J ? void 0 : J.src;
      if (!J || J["data-loaded-src"] === eh)
        return;
      J["data-loaded-src"] = eh;
      let ep = "decode" in J ? J.decode() : Promise.resolve();
      ep.catch(() => { }
      ).then(() => {
        if (J.parentElement && J.isConnected) {
          if ("empty" !== et && ec(!0),
            null == eo ? void 0 : eo.current) {
            let et = new Event("load");
            Object.defineProperty(et, "target", {
              writable: !1,
              value: J
            });
            let el = !1
              , ec = !1;
            eo.current({
              ...et,
              nativeEvent: et,
              currentTarget: J,
              target: J,
              isDefaultPrevented: () => el,
              isPropagationStopped: () => ec,
              persist: () => { }
              ,
              preventDefault: () => {
                el = !0,
                  et.preventDefault()
              }
              ,
              stopPropagation: () => {
                ec = !0,
                  et.stopPropagation()
              }
            })
          }
          (null == el ? void 0 : el.current) && el.current(J)
        }
      }
      )
    }
    function getDynamicProps(J) {
      let [et, eo] = ed.version.split(".")
        , el = parseInt(et, 10)
        , ec = parseInt(eo, 10);
      return el > 18 || 18 === el && ec >= 3 ? {
        fetchPriority: J
      } : {
        fetchpriority: J
      }
    }
    let e_ = (0,
      ed.forwardRef)((J, et) => {
        let { src: eo, srcSet: el, sizes: ec, height: eh, width: ep, decoding: ef, className: em, style: eg, fetchPriority: ey, placeholder: eb, loading: ew, unoptimized: e_, fill: ex, onLoadRef: eE, onLoadingCompleteRef: eC, setBlurComplete: eS, setShowAltText: ek, onLoad: eT, onError: eA, ...eP } = J;
        return ed.default.createElement("img", {
          ...eP,
          ...getDynamicProps(ey),
          loading: ew,
          width: ep,
          height: eh,
          decoding: ef,
          "data-nimg": ex ? "fill" : "1",
          className: em,
          style: eg,
          sizes: ec,
          srcSet: el,
          src: eo,
          ref: (0,
            ed.useCallback)(J => {
              et && ("function" == typeof et ? et(J) : "object" == typeof et && (et.current = J)),
                J && (eA && (J.src = J.src),
                  J.complete && handleLoading(J, eb, eE, eC, eS, e_))
            }
              , [eo, eb, eE, eC, eS, eA, e_, et]),
          onLoad: J => {
            let et = J.currentTarget;
            handleLoading(et, eb, eE, eC, eS, e_)
          }
          ,
          onError: J => {
            ek(!0),
              "empty" !== eb && eS(!0),
              eA && eA(J)
          }
        })
      }
      );
    function ImagePreload(J) {
      let { isAppRouter: et, imgAttributes: eo } = J
        , el = {
          as: "image",
          imageSrcSet: eo.srcSet,
          imageSizes: eo.sizes,
          crossOrigin: eo.crossOrigin,
          referrerPolicy: eo.referrerPolicy,
          ...getDynamicProps(eo.fetchPriority)
        };
      return et && eh.default.preload ? (eh.default.preload(eo.src, el),
        null) : ed.default.createElement(ep.default, null, ed.default.createElement("link", {
          key: "__nimg-" + eo.src + eo.srcSet + eo.sizes,
          rel: "preload",
          href: eo.srcSet ? void 0 : eo.src,
          ...el
        }))
    }
    let ex = (0,
      ed.forwardRef)((J, et) => {
        let eo = (0,
          ed.useContext)(ey.RouterContext)
          , el = (0,
            ed.useContext)(eg.ImageConfigContext)
          , ec = (0,
            ed.useMemo)(() => {
              let J = ew || el || em.imageConfigDefault
                , et = [...J.deviceSizes, ...J.imageSizes].sort((J, et) => J - et)
                , eo = J.deviceSizes.sort((J, et) => J - et);
              return {
                ...J,
                allSizes: et,
                deviceSizes: eo
              }
            }
              , [el])
          , { onLoad: eh, onLoadingComplete: ep } = J
          , ex = (0,
            ed.useRef)(eh);
        (0,
          ed.useEffect)(() => {
            ex.current = eh
          }
            , [eh]);
        let eE = (0,
          ed.useRef)(ep);
        (0,
          ed.useEffect)(() => {
            eE.current = ep
          }
            , [ep]);
        let [eC, eS] = (0,
          ed.useState)(!1)
          , [ek, eT] = (0,
            ed.useState)(!1)
          , { props: eA, meta: eP } = (0,
            ef.getImgProps)(J, {
              defaultLoader: eb.default,
              imgConf: ec,
              blurComplete: eC,
              showAltText: ek
            });
        return ed.default.createElement(ed.default.Fragment, null, ed.default.createElement(e_, {
          ...eA,
          unoptimized: eP.unoptimized,
          placeholder: eP.placeholder,
          fill: eP.fill,
          onLoadRef: ex,
          onLoadingCompleteRef: eE,
          setBlurComplete: eS,
          setShowAltText: eT,
          ref: et
        }), eP.priority ? ed.default.createElement(ImagePreload, {
          isAppRouter: !eo,
          imgAttributes: eA
        }) : null)
      }
      );
    ("function" == typeof et.default || "object" == typeof et.default && null !== et.default) && void 0 === et.default.__esModule && (Object.defineProperty(et.default, "__esModule", {
      value: !0
    }),
      Object.assign(et.default, et),
      J.exports = et.default)
  },
  65170: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      Object.defineProperty(et, "default", {
        enumerable: !0,
        get: function () {
          return eS
        }
      });
    let el = eo(38754)
      , ec = el._(eo(67294))
      , ed = eo(74450)
      , eh = eo(92227)
      , ep = eo(64364)
      , ef = eo(10109)
      , em = eo(73607)
      , eg = eo(11823)
      , ey = eo(89031)
      , eb = eo(40920)
      , ew = eo(10030)
      , e_ = eo(77192)
      , ex = eo(97498)
      , eE = new Set;
    function prefetch(J, et, eo, el, ec, ed) {
      if (!ed && !(0,
        eh.isLocalURL)(et))
        return;
      if (!el.bypassPrefetchedCheck) {
        let ec = void 0 !== el.locale ? el.locale : "locale" in J ? J.locale : void 0
          , ed = et + "%" + eo + "%" + ec;
        if (eE.has(ed))
          return;
        eE.add(ed)
      }
      let ep = ed ? J.prefetch(et, ec) : J.prefetch(et, eo, el);
      Promise.resolve(ep).catch(J => { }
      )
    }
    function formatStringOrUrl(J) {
      return "string" == typeof J ? J : (0,
        ep.formatUrl)(J)
    }
    let eC = ec.default.forwardRef(function (J, et) {
      let eo, el;
      let { href: ep, as: eE, children: eC, prefetch: eS = null, passHref: ek, replace: eT, shallow: eA, scroll: eP, locale: eR, onClick: eI, onMouseEnter: eO, onTouchStart: eN, legacyBehavior: eM = !1, ...eD } = J;
      eo = eC,
        eM && ("string" == typeof eo || "number" == typeof eo) && (eo = ec.default.createElement("a", null, eo));
      let ej = ec.default.useContext(eg.RouterContext)
        , eL = ec.default.useContext(ey.AppRouterContext)
        , e$ = null != ej ? ej : eL
        , eB = !ej
        , eF = !1 !== eS
        , eU = null === eS ? ex.PrefetchKind.AUTO : ex.PrefetchKind.FULL
        , { href: ez, as: eH } = ec.default.useMemo(() => {
          if (!ej) {
            let J = formatStringOrUrl(ep);
            return {
              href: J,
              as: eE ? formatStringOrUrl(eE) : J
            }
          }
          let [J, et] = (0,
            ed.resolveHref)(ej, ep, !0);
          return {
            href: J,
            as: eE ? (0,
              ed.resolveHref)(ej, eE) : et || J
          }
        }
          , [ej, ep, eE])
        , eV = ec.default.useRef(ez)
        , eW = ec.default.useRef(eH);
      eM && (el = ec.default.Children.only(eo));
      let eZ = eM ? el && "object" == typeof el && el.ref : et
        , [eG, eY, eK] = (0,
          eb.useIntersection)({
            rootMargin: "200px"
          })
        , eJ = ec.default.useCallback(J => {
          (eW.current !== eH || eV.current !== ez) && (eK(),
            eW.current = eH,
            eV.current = ez),
            eG(J),
            eZ && ("function" == typeof eZ ? eZ(J) : "object" == typeof eZ && (eZ.current = J))
        }
          , [eH, eZ, ez, eK, eG]);
      ec.default.useEffect(() => {
        e$ && eY && eF && prefetch(e$, ez, eH, {
          locale: eR
        }, {
          kind: eU
        }, eB)
      }
        , [eH, ez, eY, eR, eF, null == ej ? void 0 : ej.locale, e$, eB, eU]);
      let eQ = {
        ref: eJ,
        onClick(J) {
          eM || "function" != typeof eI || eI(J),
            eM && el.props && "function" == typeof el.props.onClick && el.props.onClick(J),
            e$ && !J.defaultPrevented && function (J, et, eo, el, ed, ep, ef, em, eg, ey) {
              let { nodeName: eb } = J.currentTarget
                , ew = "A" === eb.toUpperCase();
              if (ew && (function (J) {
                let et = J.currentTarget
                  , eo = et.getAttribute("target");
                return eo && "_self" !== eo || J.metaKey || J.ctrlKey || J.shiftKey || J.altKey || J.nativeEvent && 2 === J.nativeEvent.which
              }(J) || !eg && !(0,
                eh.isLocalURL)(eo)))
                return;
              J.preventDefault();
              let navigate = () => {
                let J = null == ef || ef;
                "beforePopState" in et ? et[ed ? "replace" : "push"](eo, el, {
                  shallow: ep,
                  locale: em,
                  scroll: J
                }) : et[ed ? "replace" : "push"](el || eo, {
                  forceOptimisticNavigation: !ey,
                  scroll: J
                })
              }
                ;
              eg ? ec.default.startTransition(navigate) : navigate()
            }(J, e$, ez, eH, eT, eA, eP, eR, eB, eF)
        },
        onMouseEnter(J) {
          eM || "function" != typeof eO || eO(J),
            eM && el.props && "function" == typeof el.props.onMouseEnter && el.props.onMouseEnter(J),
            e$ && (eF || !eB) && prefetch(e$, ez, eH, {
              locale: eR,
              priority: !0,
              bypassPrefetchedCheck: !0
            }, {
              kind: eU
            }, eB)
        },
        onTouchStart(J) {
          eM || "function" != typeof eN || eN(J),
            eM && el.props && "function" == typeof el.props.onTouchStart && el.props.onTouchStart(J),
            e$ && (eF || !eB) && prefetch(e$, ez, eH, {
              locale: eR,
              priority: !0,
              bypassPrefetchedCheck: !0
            }, {
              kind: eU
            }, eB)
        }
      };
      if ((0,
        ef.isAbsoluteUrl)(eH))
        eQ.href = eH;
      else if (!eM || ek || "a" === el.type && !("href" in el.props)) {
        let J = void 0 !== eR ? eR : null == ej ? void 0 : ej.locale
          , et = (null == ej ? void 0 : ej.isLocaleDomain) && (0,
            ew.getDomainLocale)(eH, J, null == ej ? void 0 : ej.locales, null == ej ? void 0 : ej.domainLocales);
        eQ.href = et || (0,
          e_.addBasePath)((0,
            em.addLocale)(eH, J, null == ej ? void 0 : ej.defaultLocale))
      }
      return eM ? ec.default.cloneElement(el, eQ) : ec.default.createElement("a", {
        ...eD,
        ...eQ
      }, eo)
    })
      , eS = eC;
    ("function" == typeof et.default || "object" == typeof et.default && null !== et.default) && void 0 === et.default.__esModule && (Object.defineProperty(et.default, "__esModule", {
      value: !0
    }),
      Object.assign(et.default, et),
      J.exports = et.default)
  },
  33530: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      Object.defineProperty(et, "normalizeLocalePath", {
        enumerable: !0,
        get: function () {
          return normalizeLocalePath
        }
      });
    let normalizeLocalePath = (J, et) => eo(11774).normalizeLocalePath(J, et);
    ("function" == typeof et.default || "object" == typeof et.default && null !== et.default) && void 0 === et.default.__esModule && (Object.defineProperty(et.default, "__esModule", {
      value: !0
    }),
      Object.assign(et.default, et),
      J.exports = et.default)
  },
  40920: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      Object.defineProperty(et, "useIntersection", {
        enumerable: !0,
        get: function () {
          return useIntersection
        }
      });
    let el = eo(67294)
      , ec = eo(63436)
      , ed = "function" == typeof IntersectionObserver
      , eh = new Map
      , ep = [];
    function useIntersection(J) {
      let { rootRef: et, rootMargin: eo, disabled: ef } = J
        , em = ef || !ed
        , [eg, ey] = (0,
          el.useState)(!1)
        , eb = (0,
          el.useRef)(null)
        , ew = (0,
          el.useCallback)(J => {
            eb.current = J
          }
            , []);
      (0,
        el.useEffect)(() => {
          if (ed) {
            if (em || eg)
              return;
            let J = eb.current;
            if (J && J.tagName) {
              let el = function (J, et, eo) {
                let { id: el, observer: ec, elements: ed } = function (J) {
                  let et;
                  let eo = {
                    root: J.root || null,
                    margin: J.rootMargin || ""
                  }
                    , el = ep.find(J => J.root === eo.root && J.margin === eo.margin);
                  if (el && (et = eh.get(el)))
                    return et;
                  let ec = new Map
                    , ed = new IntersectionObserver(J => {
                      J.forEach(J => {
                        let et = ec.get(J.target)
                          , eo = J.isIntersecting || J.intersectionRatio > 0;
                        et && eo && et(eo)
                      }
                      )
                    }
                      , J);
                  return et = {
                    id: eo,
                    observer: ed,
                    elements: ec
                  },
                    ep.push(eo),
                    eh.set(eo, et),
                    et
                }(eo);
                return ed.set(J, et),
                  ec.observe(J),
                  function () {
                    if (ed.delete(J),
                      ec.unobserve(J),
                      0 === ed.size) {
                      ec.disconnect(),
                        eh.delete(el);
                      let J = ep.findIndex(J => J.root === el.root && J.margin === el.margin);
                      J > -1 && ep.splice(J, 1)
                    }
                  }
              }(J, J => J && ey(J), {
                root: null == et ? void 0 : et.current,
                rootMargin: eo
              });
              return el
            }
          } else if (!eg) {
            let J = (0,
              ec.requestIdleCallback)(() => ey(!0));
            return () => (0,
              ec.cancelIdleCallback)(J)
          }
        }
          , [em, eo, et, eg, eb.current]);
      let e_ = (0,
        el.useCallback)(() => {
          ey(!1)
        }
          , []);
      return [ew, eg, e_]
    }
    ("function" == typeof et.default || "object" == typeof et.default && null !== et.default) && void 0 === et.default.__esModule && (Object.defineProperty(et.default, "__esModule", {
      value: !0
    }),
      Object.assign(et.default, et),
      J.exports = et.default)
  },
  53914: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      Object.defineProperty(et, "getImgProps", {
        enumerable: !0,
        get: function () {
          return getImgProps
        }
      }),
      eo(81905);
    let el = eo(32393)
      , ec = eo(85494);
    function isStaticRequire(J) {
      return void 0 !== J.default
    }
    function getInt(J) {
      return void 0 === J ? J : "number" == typeof J ? Number.isFinite(J) ? J : NaN : "string" == typeof J && /^[0-9]+$/.test(J) ? parseInt(J, 10) : NaN
    }
    function getImgProps(J, et) {
      var eo;
      let ed, eh, ep, { src: ef, sizes: em, unoptimized: eg = !1, priority: ey = !1, loading: eb, className: ew, quality: e_, width: ex, height: eE, fill: eC = !1, style: eS, onLoad: ek, onLoadingComplete: eT, placeholder: eA = "empty", blurDataURL: eP, fetchPriority: eR, layout: eI, objectFit: eO, objectPosition: eN, lazyBoundary: eM, lazyRoot: eD, ...ej } = J, { imgConf: eL, showAltText: e$, blurComplete: eB, defaultLoader: eF } = et, eU = eL || ec.imageConfigDefault;
      if ("allSizes" in eU)
        ed = eU;
      else {
        let J = [...eU.deviceSizes, ...eU.imageSizes].sort((J, et) => J - et)
          , et = eU.deviceSizes.sort((J, et) => J - et);
        ed = {
          ...eU,
          allSizes: J,
          deviceSizes: et
        }
      }
      let ez = ej.loader || eF;
      delete ej.loader,
        delete ej.srcSet;
      let eH = "__next_img_default" in ez;
      if (eH) {
        if ("custom" === ed.loader)
          throw Error('Image with src "' + ef + '" is missing "loader" prop.\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader')
      } else {
        let J = ez;
        ez = et => {
          let { config: eo, ...el } = et;
          return J(el)
        }
      }
      if (eI) {
        "fill" === eI && (eC = !0);
        let J = {
          intrinsic: {
            maxWidth: "100%",
            height: "auto"
          },
          responsive: {
            width: "100%",
            height: "auto"
          }
        }[eI];
        J && (eS = {
          ...eS,
          ...J
        });
        let et = {
          responsive: "100vw",
          fill: "100vw"
        }[eI];
        et && !em && (em = et)
      }
      let eV = ""
        , eW = getInt(ex)
        , eZ = getInt(eE);
      if ("object" == typeof (eo = ef) && (isStaticRequire(eo) || void 0 !== eo.src)) {
        let J = isStaticRequire(ef) ? ef.default : ef;
        if (!J.src)
          throw Error("An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received " + JSON.stringify(J));
        if (!J.height || !J.width)
          throw Error("An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received " + JSON.stringify(J));
        if (eh = J.blurWidth,
          ep = J.blurHeight,
          eP = eP || J.blurDataURL,
          eV = J.src,
          !eC) {
          if (eW || eZ) {
            if (eW && !eZ) {
              let et = eW / J.width;
              eZ = Math.round(J.height * et)
            } else if (!eW && eZ) {
              let et = eZ / J.height;
              eW = Math.round(J.width * et)
            }
          } else
            eW = J.width,
              eZ = J.height
        }
      }
      let eG = !ey && ("lazy" === eb || void 0 === eb);
      (!(ef = "string" == typeof ef ? ef : eV) || ef.startsWith("data:") || ef.startsWith("blob:")) && (eg = !0,
        eG = !1),
        ed.unoptimized && (eg = !0),
        eH && ef.endsWith(".svg") && !ed.dangerouslyAllowSVG && (eg = !0),
        ey && (eR = "high");
      let eY = getInt(e_)
        , eK = Object.assign(eC ? {
          position: "absolute",
          height: "100%",
          width: "100%",
          left: 0,
          top: 0,
          right: 0,
          bottom: 0,
          objectFit: eO,
          objectPosition: eN
        } : {}, e$ ? {} : {
          color: "transparent"
        }, eS)
        , eJ = eB || "empty" === eA ? null : "blur" === eA ? 'url("data:image/svg+xml;charset=utf-8,' + (0,
          el.getImageBlurSvg)({
            widthInt: eW,
            heightInt: eZ,
            blurWidth: eh,
            blurHeight: ep,
            blurDataURL: eP || "",
            objectFit: eK.objectFit
          }) + '")' : 'url("' + eA + '")'
        , eQ = eJ ? {
          backgroundSize: eK.objectFit || "cover",
          backgroundPosition: eK.objectPosition || "50% 50%",
          backgroundRepeat: "no-repeat",
          backgroundImage: eJ
        } : {}
        , eX = function (J) {
          let { config: et, src: eo, unoptimized: el, width: ec, quality: ed, sizes: eh, loader: ep } = J;
          if (el)
            return {
              src: eo,
              srcSet: void 0,
              sizes: void 0
            };
          let { widths: ef, kind: em } = function (J, et, eo) {
            let { deviceSizes: el, allSizes: ec } = J;
            if (eo) {
              let J = /(^|\s)(1?\d?\d)vw/g
                , et = [];
              for (let el; el = J.exec(eo); el)
                et.push(parseInt(el[2]));
              if (et.length) {
                let J = .01 * Math.min(...et);
                return {
                  widths: ec.filter(et => et >= el[0] * J),
                  kind: "w"
                }
              }
              return {
                widths: ec,
                kind: "w"
              }
            }
            if ("number" != typeof et)
              return {
                widths: el,
                kind: "w"
              };
            let ed = [...new Set([et, 2 * et].map(J => ec.find(et => et >= J) || ec[ec.length - 1]))];
            return {
              widths: ed,
              kind: "x"
            }
          }(et, ec, eh)
            , eg = ef.length - 1;
          return {
            sizes: eh || "w" !== em ? eh : "100vw",
            srcSet: ef.map((J, el) => ep({
              config: et,
              src: eo,
              quality: ed,
              width: J
            }) + " " + ("w" === em ? J : el + 1) + em).join(", "),
            src: ep({
              config: et,
              src: eo,
              quality: ed,
              width: ef[eg]
            })
          }
        }({
          config: ed,
          src: ef,
          unoptimized: eg,
          width: eW,
          quality: eY,
          sizes: em,
          loader: ez
        })
        , e0 = {
          ...ej,
          loading: eG ? "lazy" : eb,
          fetchPriority: eR,
          width: eW,
          height: eZ,
          decoding: "async",
          className: ew,
          style: {
            ...eK,
            ...eQ
          },
          sizes: eX.sizes,
          srcSet: eX.srcSet,
          src: eX.src
        }
        , e1 = {
          unoptimized: eg,
          priority: ey,
          placeholder: eA,
          fill: eC
        };
      return {
        props: e0,
        meta: e1
      }
    }
  },
  32393: function (J, et) {
    "use strict";
    function getImageBlurSvg(J) {
      let { widthInt: et, heightInt: eo, blurWidth: el, blurHeight: ec, blurDataURL: ed, objectFit: eh } = J
        , ep = el ? 40 * el : et
        , ef = ec ? 40 * ec : eo
        , em = ep && ef ? "viewBox='0 0 " + ep + " " + ef + "'" : "";
      return "%3Csvg xmlns='http://www.w3.org/2000/svg' " + em + "%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='20'/%3E%3CfeColorMatrix values='1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 100 -1' result='s'/%3E%3CfeFlood x='0' y='0' width='100%25' height='100%25'/%3E%3CfeComposite operator='out' in='s'/%3E%3CfeComposite in2='SourceGraphic'/%3E%3CfeGaussianBlur stdDeviation='20'/%3E%3C/filter%3E%3Cimage width='100%25' height='100%25' x='0' y='0' preserveAspectRatio='" + (em ? "none" : "contain" === eh ? "xMidYMid" : "cover" === eh ? "xMidYMid slice" : "none") + "' style='filter: url(%23b);' href='" + ed + "'/%3E%3C/svg%3E"
    }
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      Object.defineProperty(et, "getImageBlurSvg", {
        enumerable: !0,
        get: function () {
          return getImageBlurSvg
        }
      })
  },
  645: function (J, et, eo) {
    "use strict";
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      function (J, et) {
        for (var eo in et)
          Object.defineProperty(J, eo, {
            enumerable: !0,
            get: et[eo]
          })
      }(et, {
        unstable_getImgProps: function () {
          return unstable_getImgProps
        },
        default: function () {
          return ef
        }
      });
    let el = eo(38754)
      , ec = eo(53914)
      , ed = eo(81905)
      , eh = eo(23271)
      , ep = el._(eo(74545))
      , unstable_getImgProps = J => {
        (0,
          ed.warnOnce)("Warning: unstable_getImgProps() is experimental and may change or be removed at any time. Use at your own risk.");
        let { props: et } = (0,
          ec.getImgProps)(J, {
            defaultLoader: ep.default,
            imgConf: {
              deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
              imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
              path: "/_next/image/",
              loader: "default",
              dangerouslyAllowSVG: !1,
              unoptimized: !1
            }
          });
        for (let [J, eo] of Object.entries(et))
          void 0 === eo && delete et[J];
        return {
          props: et
        }
      }
      , ef = eh.Image
  },
  74545: function (J, et) {
    "use strict";
    function defaultLoader(J) {
      let { config: et, src: eo, width: el, quality: ec } = J;
      return et.path + "?url=" + encodeURIComponent(eo) + "&w=" + el + "&q=" + (ec || 75)
    }
    Object.defineProperty(et, "__esModule", {
      value: !0
    }),
      Object.defineProperty(et, "default", {
        enumerable: !0,
        get: function () {
          return eo
        }
      }),
      defaultLoader.__next_img_default = !0;
    let eo = defaultLoader
  },
  43572: function (J, et, eo) {
    "use strict";
    let el, ec;
    eo.r(et),
      eo.d(et, {
        default: function () {
          return _app
        },
        wagmiConfig: function () {
          return sG
        }
      });
    var ed, eh = {};
    eo.r(eh),
      eo.d(eh, {
        identity: function () {
          return e4
        }
      });
    var ep = {};
    eo.r(ep),
      eo.d(ep, {
        base2: function () {
          return e8
        }
      });
    var ef = {};
    eo.r(ef),
      eo.d(ef, {
        base8: function () {
          return e7
        }
      });
    var em = {};
    eo.r(em),
      eo.d(em, {
        base10: function () {
          return e9
        }
      });
    var eg = {};
    eo.r(eg),
      eo.d(eg, {
        base16: function () {
          return tn
        },
        base16upper: function () {
          return to
        }
      });
    var ey = {};
    eo.r(ey),
      eo.d(ey, {
        base32: function () {
          return ta
        },
        base32hex: function () {
          return th
        },
        base32hexpad: function () {
          return tf
        },
        base32hexpadupper: function () {
          return tm
        },
        base32hexupper: function () {
          return tp
        },
        base32pad: function () {
          return tc
        },
        base32padupper: function () {
          return td
        },
        base32upper: function () {
          return tl
        },
        base32z: function () {
          return tg
        }
      });
    var eb = {};
    eo.r(eb),
      eo.d(eb, {
        base36: function () {
          return ty
        },
        base36upper: function () {
          return tb
        }
      });
    var ew = {};
    eo.r(ew),
      eo.d(ew, {
        base58btc: function () {
          return tw
        },
        base58flickr: function () {
          return t_
        }
      });
    var e_ = {};
    eo.r(e_),
      eo.d(e_, {
        base64: function () {
          return tx
        },
        base64pad: function () {
          return tE
        },
        base64url: function () {
          return tC
        },
        base64urlpad: function () {
          return tS
        }
      });
    var ex = {};
    eo.r(ex),
      eo.d(ex, {
        base256emoji: function () {
          return tP
        }
      });
    var eE = {};
    eo.r(eE),
      eo.d(eE, {
        sha256: function () {
          return tI
        },
        sha512: function () {
          return tO
        }
      });
    var eC = {};
    eo.r(eC),
      eo.d(eC, {
        identity: function () {
          return tN
        }
      });
    var eS = {};
    eo.r(eS),
      eo.d(eS, {
        code: function () {
          return tD
        },
        decode: function () {
          return raw_decode
        },
        encode: function () {
          return raw_encode
        },
        name: function () {
          return tM
        }
      });
    var ek = {};
    eo.r(ek),
      eo.d(ek, {
        code: function () {
          return tB
        },
        decode: function () {
          return json_decode
        },
        encode: function () {
          return json_encode
        },
        name: function () {
          return t$
        }
      });
    var eT = eo(85893);
    eo(55715);
    var eA = eo(67294)
      , eP = eo(11163)
      , eR = eo(25226)
      , eI = eo.n(eR)
      , eO = eo(75374)
      , eN = eo(48764);
    "undefined" == typeof window || (window.Buffer || (window.Buffer = eN.Buffer),
      window.global || (window.global = window),
      window.process || (window.process = {}),
      window.process?.env || (window.process = {
        env: {}
      }));
    var eM = eo(78863)
      , eD = eo(62027);
    let UrlRequiredError = class UrlRequiredError extends eD.G {
      constructor() {
        super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
          docsPath: "/docs/clients/intro"
        })
      }
    }
      ;
    var ej = eo(32357);
    function withTimeout(J, { errorInstance: et = Error("timed out"), timeout: eo, signal: el }) {
      return new Promise((ec, ed) => {
        (async () => {
          let eh;
          try {
            let ep = new AbortController;
            eo > 0 && (eh = setTimeout(() => {
              el ? ep.abort() : ed(et)
            }
              , eo)),
              ec(await J({
                signal: ep?.signal
              }))
          } catch (J) {
            "AbortError" === J.name && ed(et),
              ed(J)
          } finally {
            clearTimeout(eh)
          }
        }
        )()
      }
      )
    }
    var eL = eo(96070);
    let e$ = {
      current: 0,
      take() {
        return this.current++
      },
      reset() {
        this.current = 0
      }
    };
    var eB = eo(91628);
    function http(J, et = {}) {
      let { batch: eo, fetchOptions: el, key: ec = "http", name: ed = "HTTP JSON-RPC", retryDelay: eh } = et;
      return ({ chain: ep, retryCount: ef, timeout: em }) => {
        let { batchSize: eg = 1e3, wait: ey = 0 } = "object" == typeof eo ? eo : {}
          , eb = et.retryCount ?? ef
          , ew = em ?? et.timeout ?? 1e4
          , e_ = J || ep?.rpcUrls.default.http[0];
        if (!e_)
          throw new UrlRequiredError;
        let ex = function (J, et = {}) {
          return {
            async request(eo) {
              let { body: el, fetchOptions: ec = {}, timeout: ed = et.timeout ?? 1e4 } = eo
                , { headers: eh, method: ep, signal: ef } = {
                  ...et.fetchOptions,
                  ...ec
                };
              try {
                let et;
                let eo = await withTimeout(async ({ signal: et }) => {
                  let eo = await fetch(J, {
                    ...ec,
                    body: Array.isArray(el) ? (0,
                      eL.P)(el.map(J => ({
                        jsonrpc: "2.0",
                        id: J.id ?? e$.take(),
                        ...J
                      }))) : (0,
                        eL.P)({
                          jsonrpc: "2.0",
                          id: el.id ?? e$.take(),
                          ...el
                        }),
                    headers: {
                      ...eh,
                      "Content-Type": "application/json"
                    },
                    method: ep || "POST",
                    signal: ef || (ed > 0 ? et : void 0)
                  });
                  return eo
                }
                  , {
                    errorInstance: new eM.W5({
                      body: el,
                      url: J
                    }),
                    timeout: ed,
                    signal: !0
                  });
                if (et = eo.headers.get("Content-Type")?.startsWith("application/json") ? await eo.json() : await eo.text(),
                  !eo.ok)
                  throw new eM.Gg({
                    body: el,
                    details: (0,
                      eL.P)(et.error) || eo.statusText,
                    headers: eo.headers,
                    status: eo.status,
                    url: J
                  });
                return et
              } catch (et) {
                if (et instanceof eM.Gg || et instanceof eM.W5)
                  throw et;
                throw new eM.Gg({
                  body: el,
                  details: et.message,
                  url: J
                })
              }
            }
          }
        }(e_, {
          fetchOptions: el,
          timeout: ew
        });
        return (0,
          eB.q)({
            key: ec,
            name: ed,
            async request({ method: et, params: el }) {
              let ec = {
                method: et,
                params: el
              }
                , { schedule: ed } = (0,
                  ej.S)({
                    id: `${J}`,
                    wait: ey,
                    shouldSplitBatch: J => J.length > eg,
                    fn: J => ex.request({
                      body: J
                    }),
                    sort: (J, et) => J.id - et.id
                  })
                , fn = async J => eo ? ed(J) : [await ex.request({
                  body: J
                })]
                , [{ error: eh, result: ep }] = await fn(ec);
              if (eh)
                throw new eM.bs({
                  body: ec,
                  error: eh,
                  url: e_
                });
              return ep
            },
            retryCount: eb,
            retryDelay: eh,
            timeout: ew,
            type: "http"
          }, {
            fetchOptions: el,
            url: e_
          })
      }
    }
    var eF = eo(16189);
    let subscribeWithSelector = J => (et, eo, el) => {
      let ec = el.subscribe;
      el.subscribe = (J, et, eo) => {
        let ed = J;
        if (et) {
          let ec = (null == eo ? void 0 : eo.equalityFn) || Object.is
            , eh = J(el.getState());
          ed = eo => {
            let el = J(eo);
            if (!ec(eh, el)) {
              let J = eh;
              et(eh = el, J)
            }
          }
            ,
            (null == eo ? void 0 : eo.fireImmediately) && et(eh, eh)
        }
        return ec(ed)
      }
        ;
      let ed = J(et, eo, el);
      return ed
    }
      , toThenable = J => et => {
        try {
          let eo = J(et);
          if (eo instanceof Promise)
            return eo;
          return {
            then: J => toThenable(J)(eo),
            catch(J) {
              return this
            }
          }
        } catch (J) {
          return {
            then(J) {
              return this
            },
            catch: et => toThenable(et)(J)
          }
        }
      }
      , oldImpl = (J, et) => (eo, el, ec) => {
        let ed, eh, ep = {
          getStorage: () => localStorage,
          serialize: JSON.stringify,
          deserialize: JSON.parse,
          partialize: J => J,
          version: 0,
          merge: (J, et) => ({
            ...et,
            ...J
          }),
          ...et
        }, ef = !1, em = new Set, eg = new Set;
        try {
          ed = ep.getStorage()
        } catch (J) { }
        if (!ed)
          return J((...J) => {
            console.warn(`[zustand persist middleware] Unable to update item '${ep.name}', the given storage is currently unavailable.`),
              eo(...J)
          }
            , el, ec);
        let ey = toThenable(ep.serialize)
          , setItem = () => {
            let J;
            let et = ep.partialize({
              ...el()
            })
              , eo = ey({
                state: et,
                version: ep.version
              }).then(J => ed.setItem(ep.name, J)).catch(et => {
                J = et
              }
              );
            if (J)
              throw J;
            return eo
          }
          , eb = ec.setState;
        ec.setState = (J, et) => {
          eb(J, et),
            setItem()
        }
          ;
        let ew = J((...J) => {
          eo(...J),
            setItem()
        }
          , el, ec)
          , hydrate = () => {
            var J;
            if (!ed)
              return;
            ef = !1,
              em.forEach(J => J(el()));
            let et = (null == (J = ep.onRehydrateStorage) ? void 0 : J.call(ep, el())) || void 0;
            return toThenable(ed.getItem.bind(ed))(ep.name).then(J => {
              if (J)
                return ep.deserialize(J)
            }
            ).then(J => {
              if (J) {
                if ("number" != typeof J.version || J.version === ep.version)
                  return J.state;
                if (ep.migrate)
                  return ep.migrate(J.state, J.version);
                console.error("State loaded from storage couldn't be migrated since no migrate function was provided")
              }
            }
            ).then(J => {
              var et;
              return eo(eh = ep.merge(J, null != (et = el()) ? et : ew), !0),
                setItem()
            }
            ).then(() => {
              null == et || et(eh, void 0),
                ef = !0,
                eg.forEach(J => J(eh))
            }
            ).catch(J => {
              null == et || et(void 0, J)
            }
            )
          }
          ;
        return ec.persist = {
          setOptions: J => {
            ep = {
              ...ep,
              ...J
            },
              J.getStorage && (ed = J.getStorage())
          }
          ,
          clearStorage: () => {
            null == ed || ed.removeItem(ep.name)
          }
          ,
          getOptions: () => ep,
          rehydrate: () => hydrate(),
          hasHydrated: () => ef,
          onHydrate: J => (em.add(J),
            () => {
              em.delete(J)
            }
          ),
          onFinishHydration: J => (eg.add(J),
            () => {
              eg.delete(J)
            }
          )
        },
          hydrate(),
          eh || ew
      }
      , newImpl = (J, et) => (eo, el, ec) => {
        let ed, eh = {
          storage: function (J, et) {
            let eo;
            try {
              eo = J()
            } catch (J) {
              return
            }
            return {
              getItem: J => {
                var el;
                let parse = J => null === J ? null : JSON.parse(J, null == et ? void 0 : et.reviver)
                  , ec = null != (el = eo.getItem(J)) ? el : null;
                return ec instanceof Promise ? ec.then(parse) : parse(ec)
              }
              ,
              setItem: (J, el) => eo.setItem(J, JSON.stringify(el, null == et ? void 0 : et.replacer)),
              removeItem: J => eo.removeItem(J)
            }
          }(() => localStorage),
          partialize: J => J,
          version: 0,
          merge: (J, et) => ({
            ...et,
            ...J
          }),
          ...et
        }, ep = !1, ef = new Set, em = new Set, eg = eh.storage;
        if (!eg)
          return J((...J) => {
            console.warn(`[zustand persist middleware] Unable to update item '${eh.name}', the given storage is currently unavailable.`),
              eo(...J)
          }
            , el, ec);
        let setItem = () => {
          let J = eh.partialize({
            ...el()
          });
          return eg.setItem(eh.name, {
            state: J,
            version: eh.version
          })
        }
          , ey = ec.setState;
        ec.setState = (J, et) => {
          ey(J, et),
            setItem()
        }
          ;
        let eb = J((...J) => {
          eo(...J),
            setItem()
        }
          , el, ec)
          , hydrate = () => {
            var J, et;
            if (!eg)
              return;
            ep = !1,
              ef.forEach(J => {
                var et;
                return J(null != (et = el()) ? et : eb)
              }
              );
            let ec = (null == (et = eh.onRehydrateStorage) ? void 0 : et.call(eh, null != (J = el()) ? J : eb)) || void 0;
            return toThenable(eg.getItem.bind(eg))(eh.name).then(J => {
              if (J) {
                if ("number" != typeof J.version || J.version === eh.version)
                  return J.state;
                if (eh.migrate)
                  return eh.migrate(J.state, J.version);
                console.error("State loaded from storage couldn't be migrated since no migrate function was provided")
              }
            }
            ).then(J => {
              var et;
              return eo(ed = eh.merge(J, null != (et = el()) ? et : eb), !0),
                setItem()
            }
            ).then(() => {
              null == ec || ec(ed, void 0),
                ed = el(),
                ep = !0,
                em.forEach(J => J(ed))
            }
            ).catch(J => {
              null == ec || ec(void 0, J)
            }
            )
          }
          ;
        return ec.persist = {
          setOptions: J => {
            eh = {
              ...eh,
              ...J
            },
              J.storage && (eg = J.storage)
          }
          ,
          clearStorage: () => {
            null == eg || eg.removeItem(eh.name)
          }
          ,
          getOptions: () => eh,
          rehydrate: () => hydrate(),
          hasHydrated: () => ep,
          onHydrate: J => (ef.add(J),
            () => {
              ef.delete(J)
            }
          ),
          onFinishHydration: J => (em.add(J),
            () => {
              em.delete(J)
            }
          )
        },
          eh.skipHydration || hydrate(),
          ed || eb
      }
      , persist = (J, et) => "getStorage" in et || "serialize" in et || "deserialize" in et ? (console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."),
        oldImpl(J, et)) : newImpl(J, et)
      , createStoreImpl = J => {
        let et;
        let eo = new Set
          , setState = (J, el) => {
            let ec = "function" == typeof J ? J(et) : J;
            if (!Object.is(ec, et)) {
              let J = et;
              et = (null != el ? el : "object" != typeof ec) ? ec : Object.assign({}, et, ec),
                eo.forEach(eo => eo(et, J))
            }
          }
          , getState = () => et
          , el = {
            setState,
            getState,
            subscribe: J => (eo.add(J),
              () => eo.delete(J)),
            destroy: () => {
              console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),
                eo.clear()
            }
          };
        return et = J(setState, getState, el),
          el
      }
      , vanilla_createStore = J => J ? createStoreImpl(J) : createStoreImpl;
    var eU = eo(45775)
      , ez = eo(39028)
      , eH = eo(7760)
      , eV = eo(92106)
      , eW = eo(87083)
      , eZ = eo(93981);
    let ProviderNotFoundError = class ProviderNotFoundError extends eZ.G {
      constructor() {
        super("Provider not found."),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ProviderNotFoundError"
          })
      }
    }
      ;
    function normalizeChainId(J) {
      if ("string" == typeof J)
        return Number.parseInt(J, "0x" === J.trim().substring(0, 2) ? 16 : 10);
      if ("bigint" == typeof J)
        return Number(J);
      if ("number" == typeof J)
        return J;
      throw Error(`Cannot normalize chainId "${J}" of type "${typeof J}"`)
    }
    let eG = {
      coinbaseWallet: {
        id: "coinbaseWallet",
        name: "Coinbase Wallet",
        provider: J => J?.coinbaseWalletExtension ? J.coinbaseWalletExtension : findProvider(J, "isCoinbaseWallet")
      },
      metaMask: {
        id: "metaMask",
        name: "MetaMask",
        provider: J => findProvider(J, J => {
          if (!J.isMetaMask || J.isBraveWallet && !J._events && !J._state)
            return !1;
          for (let et of ["isApexWallet", "isAvalanche", "isBitKeep", "isBlockWallet", "isKuCoinWallet", "isMathWallet", "isOkxWallet", "isOKExWallet", "isOneInchIOSWallet", "isOneInchAndroidWallet", "isOpera", "isPortal", "isRabby", "isTokenPocket", "isTokenary", "isZerion"])
            if (J[et])
              return !1;
          return !0
        }
        )
      },
      phantom: {
        id: "phantom",
        name: "Phantom",
        provider: J => J?.phantom?.ethereum ? J.phantom?.ethereum : findProvider(J, "isPhantom")
      }
    };
    function injected(J = {}) {
      let { shimDisconnect: et = !0, unstable_shimAsyncInject: eo } = J;
      function getTarget() {
        let et = J.target;
        if ("function" == typeof et) {
          let J = et();
          if (J)
            return J
        }
        return "object" == typeof et ? et : "string" == typeof et ? {
          ...eG[et] ?? {
            id: et,
            name: `${et[0].toUpperCase()}${et.slice(1)}`,
            provider: `is${et[0].toUpperCase()}${et.slice(1)}`
          }
        } : {
          id: "injected",
          name: "Injected",
          provider: J => J?.ethereum
        }
      }
      return el => ({
        get icon() {
          return getTarget().icon
        },
        get id() {
          return getTarget().id
        },
        get name() {
          return getTarget().name
        },
        type: injected.type,
        async setup() {
          let et = await this.getProvider();
          et && J.target && et.on("connect", this.onConnect.bind(this))
        },
        async connect({ chainId: eo, isReconnecting: ec } = {}) {
          let ed = await this.getProvider();
          if (!ed)
            throw new ProviderNotFoundError;
          let eh = null;
          if (!ec) {
            eh = await this.getAccounts().catch(() => null);
            let J = !!eh?.length;
            if (J)
              try {
                let J = await ed.request({
                  method: "wallet_requestPermissions",
                  params: [{
                    eth_accounts: {}
                  }]
                });
                eh = J[0]?.caveats?.[0]?.value?.map(J => eU.K(J))
              } catch (J) {
                if (J.code === ez.ab.code)
                  throw new ez.ab(J);
                if (J.code === ez.pT.code)
                  throw J
              }
          }
          try {
            if (!eh?.length) {
              let J = await ed.request({
                method: "eth_requestAccounts"
              });
              eh = J.map(J => (0,
                eU.K)(J))
            }
            ed.removeListener("connect", this.onConnect.bind(this)),
              ed.on("accountsChanged", this.onAccountsChanged.bind(this)),
              ed.on("chainChanged", this.onChainChanged),
              ed.on("disconnect", this.onDisconnect.bind(this));
            let ec = await this.getChainId();
            if (eo && ec !== eo) {
              let J = await this.switchChain({
                chainId: eo
              }).catch(J => {
                if (J.code === ez.ab.code)
                  throw J;
                return {
                  id: ec
                }
              }
              );
              ec = J?.id ?? ec
            }
            return et && (await el.storage?.removeItem(`${this.id}.disconnected`),
              J.target || await el.storage?.setItem("injected.connected", !0)),
            {
              accounts: eh,
              chainId: ec
            }
          } catch (J) {
            if (J.code === ez.ab.code)
              throw new ez.ab(J);
            if (J.code === ez.pT.code)
              throw new ez.pT(J);
            throw J
          }
        },
        async disconnect() {
          let eo = await this.getProvider();
          if (!eo)
            throw new ProviderNotFoundError;
          eo.removeListener("accountsChanged", this.onAccountsChanged.bind(this)),
            eo.removeListener("chainChanged", this.onChainChanged),
            eo.removeListener("disconnect", this.onDisconnect.bind(this)),
            eo.on("connect", this.onConnect.bind(this)),
            et && (await el.storage?.setItem(`${this.id}.disconnected`, !0),
              J.target || await el.storage?.removeItem("injected.connected"))
        },
        async getAccounts() {
          let J = await this.getProvider();
          if (!J)
            throw new ProviderNotFoundError;
          let et = await J.request({
            method: "eth_accounts"
          });
          return et.map(J => (0,
            eU.K)(J))
        },
        async getChainId() {
          let J = await this.getProvider();
          if (!J)
            throw new ProviderNotFoundError;
          let et = await J.request({
            method: "eth_chainId"
          });
          return normalizeChainId(et)
        },
        async getProvider() {
          if ("undefined" == typeof window)
            return;
          let J = getTarget();
          return "function" == typeof J.provider ? J.provider(window) : "string" == typeof J.provider ? findProvider(window, J.provider) : J.provider
        },
        async isAuthorized() {
          try {
            let ec = et && await el.storage?.getItem(`${this.id}.disconnected`);
            if (ec)
              return !1;
            if (!J.target) {
              let J = await el.storage?.getItem("injected.connected");
              if (!J)
                return !1
            }
            let ed = await this.getProvider();
            if (!ed) {
              if (void 0 !== eo && !1 !== eo) {
                let handleEthereum = async () => {
                  "undefined" != typeof window && window.removeEventListener("ethereum#initialized", handleEthereum);
                  let J = await this.getProvider();
                  return !!J
                }
                  , J = "number" == typeof eo ? eo : 1e3
                  , et = await Promise.race([..."undefined" != typeof window ? [new Promise(J => window.addEventListener("ethereum#initialized", () => J(handleEthereum()), {
                    once: !0
                  }))] : [], new Promise(et => setTimeout(() => et(handleEthereum()), J))]);
                if (et)
                  return !0
              }
              throw new ProviderNotFoundError
            }
            let eh = await (0,
              eH.J)(() => withTimeout(() => this.getAccounts(), {
                timeout: 100
              }));
            return !!eh.length
          } catch {
            return !1
          }
        },
        async switchChain({ chainId: J }) {
          let et = await this.getProvider();
          if (!et)
            throw new ProviderNotFoundError;
          let eo = el.chains.find(et => et.id === J);
          if (!eo)
            throw new ez.x3(new eW.X4);
          try {
            return await Promise.all([et.request({
              method: "wallet_switchEthereumChain",
              params: [{
                chainId: (0,
                  eV.eC)(J)
              }]
            }), new Promise(et => el.emitter.once("change", ({ chainId: eo }) => {
              eo === J && et()
            }
            ))]),
              eo
          } catch (el) {
            if (4902 === el.code || el?.data?.originalError?.code === 4902)
              try {
                let { default: el, ...ec } = eo.blockExplorers ?? {}
                  , ed = [];
                el && (ed = [el.url, ...Object.values(ec).map(J => J.url)]),
                  await et.request({
                    method: "wallet_addEthereumChain",
                    params: [{
                      chainId: (0,
                        eV.eC)(J),
                      chainName: eo.name,
                      nativeCurrency: eo.nativeCurrency,
                      rpcUrls: [eo.rpcUrls.default?.http[0] ?? ""],
                      blockExplorerUrls: ed
                    }]
                  });
                let eh = await this.getChainId();
                if (eh !== J)
                  throw new ez.ab(Error("User rejected switch after adding network."));
                return eo
              } catch (J) {
                throw new ez.ab(J)
              }
            if (el.code === ez.ab.code)
              throw new ez.ab(el);
            throw new ez.x3(el)
          }
        },
        async onAccountsChanged(J) {
          if (0 === J.length)
            this.onDisconnect();
          else if (el.emitter.listenerCount("connect")) {
            let J = (await this.getChainId()).toString();
            this.onConnect({
              chainId: J
            }),
              et && await el.storage?.removeItem(`${this.id}.disconnected`)
          } else
            el.emitter.emit("change", {
              accounts: J.map(J => (0,
                eU.K)(J))
            })
        },
        onChainChanged(J) {
          let et = normalizeChainId(J);
          el.emitter.emit("change", {
            chainId: et
          })
        },
        async onConnect(J) {
          let et = await this.getAccounts();
          if (0 === et.length)
            return;
          let eo = normalizeChainId(J.chainId);
          el.emitter.emit("connect", {
            accounts: et,
            chainId: eo
          });
          let ec = await this.getProvider();
          ec && (ec.removeListener("connect", this.onConnect.bind(this)),
            ec.on("accountsChanged", this.onAccountsChanged.bind(this)),
            ec.on("chainChanged", this.onChainChanged),
            ec.on("disconnect", this.onDisconnect.bind(this)))
        },
        async onDisconnect(J) {
          let et = await this.getProvider();
          J && 1013 === J.code && et && (await this.getAccounts()).length || (el.emitter.emit("disconnect"),
            et && (et.removeListener("accountsChanged", this.onAccountsChanged.bind(this)),
              et.removeListener("chainChanged", this.onChainChanged),
              et.removeListener("disconnect", this.onDisconnect.bind(this)),
              et.on("connect", this.onConnect.bind(this))))
        }
      })
    }
    function findProvider(J, et) {
      function isProvider(J) {
        return "function" == typeof et ? et(J) : "string" != typeof et || J[et]
      }
      let eo = J.ethereum;
      return eo?.providers ? eo.providers.find(J => isProvider(J)) : eo && isProvider(eo) ? eo : void 0
    }
    injected.type = "injected";
    var eY = eo(26729)
      , __classPrivateFieldGet = function (J, et, eo, el) {
        if ("a" === eo && !el)
          throw TypeError("Private accessor was defined without a getter");
        if ("function" == typeof et ? J !== et || !el : !et.has(J))
          throw TypeError("Cannot read private member from an object whose class did not declare it");
        return "m" === eo ? el : "a" === eo ? el.call(J) : el ? el.value : et.get(J)
      };
    let Emitter = class Emitter {
      constructor(J) {
        Object.defineProperty(this, "uid", {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: J
        }),
          ed.set(this, new eY)
      }
      on(J, et) {
        __classPrivateFieldGet(this, ed, "f").on(J, et)
      }
      once(J, et) {
        __classPrivateFieldGet(this, ed, "f").once(J, et)
      }
      off(J, et) {
        __classPrivateFieldGet(this, ed, "f").off(J, et)
      }
      emit(J, ...et) {
        let eo = et[0];
        __classPrivateFieldGet(this, ed, "f").emit(J, {
          uid: this.uid,
          ...eo
        })
      }
      listenerCount(J) {
        return __classPrivateFieldGet(this, ed, "f").listenerCount(J)
      }
    }
      ;
    function deserialize_deserialize(J, et) {
      return JSON.parse(J, (J, eo) => {
        let el = eo;
        return el?.__type === "bigint" && (el = BigInt(el.value)),
          el?.__type === "Map" && (el = new Map(el.value)),
          et?.(J, el) ?? el
      }
      )
    }
    function getReferenceKey(J, et) {
      return J.slice(0, et).join(".") || "."
    }
    function getCutoff(J, et) {
      let { length: eo } = J;
      for (let el = 0; el < eo; ++el)
        if (J[el] === et)
          return el + 1;
      return 0
    }
    function serialize_serialize(J, et, eo, el) {
      return JSON.stringify(J, function (J, et) {
        let eo = "function" == typeof J
          , el = "function" == typeof et
          , ec = []
          , ed = [];
        return function (eh, ep) {
          if ("object" == typeof ep) {
            if (ec.length) {
              let J = getCutoff(ec, this);
              0 === J ? ec[ec.length] = this : (ec.splice(J),
                ed.splice(J)),
                ed[ed.length] = eh;
              let eo = getCutoff(ec, ep);
              if (0 !== eo)
                return el ? et.call(this, eh, ep, getReferenceKey(ed, eo)) : `[ref=${getReferenceKey(ed, eo)}]`
            } else
              ec[0] = ep,
                ed[0] = eh
          }
          return eo ? J.call(this, eh, ep) : ep
        }
      }((J, eo) => {
        let el = eo;
        return "bigint" == typeof el && (el = {
          __type: "bigint",
          value: eo.toString()
        }),
          el instanceof Map && (el = {
            __type: "Map",
            value: Array.from(eo.entries())
          }),
          et?.(J, el) ?? el
      }
        , el), eo ?? void 0)
    }
    ed = new WeakMap;
    let eK = {
      getItem: () => null,
      setItem: () => { }
      ,
      removeItem: () => { }
    }
      , eJ = 256;
    var eQ = eo(14023)
      , eX = eo(17187)
      , e0 = eo.n(eX)
      , e1 = eo(15501)
      , e2 = eo(512)
      , e3 = eo(31416)
      , e5 = eo(73294)
      , e6 = eo(57664);
    function as_uint8array_asUint8Array(J) {
      return null != globalThis.Buffer ? new Uint8Array(J.buffer, J.byteOffset, J.byteLength) : J
    }
    function allocUnsafe(J = 0) {
      return null != globalThis.Buffer && null != globalThis.Buffer.allocUnsafe ? as_uint8array_asUint8Array(globalThis.Buffer.allocUnsafe(J)) : new Uint8Array(J)
    }
    function concat(J, et) {
      et || (et = J.reduce((J, et) => J + et.length, 0));
      let eo = allocUnsafe(et)
        , el = 0;
      for (let et of J)
        eo.set(et, el),
          el += et.length;
      return as_uint8array_asUint8Array(eo)
    }
    var base_x = function (J, et) {
      if (J.length >= 255)
        throw TypeError("Alphabet too long");
      for (var eo = new Uint8Array(256), el = 0; el < eo.length; el++)
        eo[el] = 255;
      for (var ec = 0; ec < J.length; ec++) {
        var ed = J.charAt(ec)
          , eh = ed.charCodeAt(0);
        if (255 !== eo[eh])
          throw TypeError(ed + " is ambiguous");
        eo[eh] = ec
      }
      var ep = J.length
        , ef = J.charAt(0)
        , em = Math.log(ep) / Math.log(256)
        , eg = Math.log(256) / Math.log(ep);
      function decodeUnsafe(J) {
        if ("string" != typeof J)
          throw TypeError("Expected String");
        if (0 === J.length)
          return new Uint8Array;
        var et = 0;
        if (" " !== J[0]) {
          for (var el = 0, ec = 0; J[et] === ef;)
            el++,
              et++;
          for (var ed = (J.length - et) * em + 1 >>> 0, eh = new Uint8Array(ed); J[et];) {
            var eg = eo[J.charCodeAt(et)];
            if (255 === eg)
              return;
            for (var ey = 0, eb = ed - 1; (0 !== eg || ey < ec) && -1 !== eb; eb--,
              ey++)
              eg += ep * eh[eb] >>> 0,
                eh[eb] = eg % 256 >>> 0,
                eg = eg / 256 >>> 0;
            if (0 !== eg)
              throw Error("Non-zero carry");
            ec = ey,
              et++
          }
          if (" " !== J[et]) {
            for (var ew = ed - ec; ew !== ed && 0 === eh[ew];)
              ew++;
            for (var e_ = new Uint8Array(el + (ed - ew)), ex = el; ew !== ed;)
              e_[ex++] = eh[ew++];
            return e_
          }
        }
      }
      return {
        encode: function (et) {
          if (et instanceof Uint8Array || (ArrayBuffer.isView(et) ? et = new Uint8Array(et.buffer, et.byteOffset, et.byteLength) : Array.isArray(et) && (et = Uint8Array.from(et))),
            !(et instanceof Uint8Array))
            throw TypeError("Expected Uint8Array");
          if (0 === et.length)
            return "";
          for (var eo = 0, el = 0, ec = 0, ed = et.length; ec !== ed && 0 === et[ec];)
            ec++,
              eo++;
          for (var eh = (ed - ec) * eg + 1 >>> 0, em = new Uint8Array(eh); ec !== ed;) {
            for (var ey = et[ec], eb = 0, ew = eh - 1; (0 !== ey || eb < el) && -1 !== ew; ew--,
              eb++)
              ey += 256 * em[ew] >>> 0,
                em[ew] = ey % ep >>> 0,
                ey = ey / ep >>> 0;
            if (0 !== ey)
              throw Error("Non-zero carry");
            el = eb,
              ec++
          }
          for (var e_ = eh - el; e_ !== eh && 0 === em[e_];)
            e_++;
          for (var ex = ef.repeat(eo); e_ < eh; ++e_)
            ex += J.charAt(em[e_]);
          return ex
        },
        decodeUnsafe: decodeUnsafe,
        decode: function (J) {
          var eo = decodeUnsafe(J);
          if (eo)
            return eo;
          throw Error(`Non-${et} character`)
        }
      }
    };
    new Uint8Array(0);
    let equals = (J, et) => {
      if (J === et)
        return !0;
      if (J.byteLength !== et.byteLength)
        return !1;
      for (let eo = 0; eo < J.byteLength; eo++)
        if (J[eo] !== et[eo])
          return !1;
      return !0
    }
      , coerce = J => {
        if (J instanceof Uint8Array && "Uint8Array" === J.constructor.name)
          return J;
        if (J instanceof ArrayBuffer)
          return new Uint8Array(J);
        if (ArrayBuffer.isView(J))
          return new Uint8Array(J.buffer, J.byteOffset, J.byteLength);
        throw Error("Unknown type, must be binary type")
      }
      , bytes_fromString = J => new TextEncoder().encode(J)
      , bytes_toString = J => new TextDecoder().decode(J);
    let Encoder = class Encoder {
      constructor(J, et, eo) {
        this.name = J,
          this.prefix = et,
          this.baseEncode = eo
      }
      encode(J) {
        if (J instanceof Uint8Array)
          return `${this.prefix}${this.baseEncode(J)}`;
        throw Error("Unknown type, must be binary type")
      }
    }
      ;
    let Decoder = class Decoder {
      constructor(J, et, eo) {
        if (this.name = J,
          this.prefix = et,
          void 0 === et.codePointAt(0))
          throw Error("Invalid prefix character");
        this.prefixCodePoint = et.codePointAt(0),
          this.baseDecode = eo
      }
      decode(J) {
        if ("string" == typeof J) {
          if (J.codePointAt(0) !== this.prefixCodePoint)
            throw Error(`Unable to decode multibase string ${JSON.stringify(J)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          return this.baseDecode(J.slice(this.prefix.length))
        }
        throw Error("Can only multibase decode strings")
      }
      or(J) {
        return or(this, J)
      }
    }
      ;
    let ComposedDecoder = class ComposedDecoder {
      constructor(J) {
        this.decoders = J
      }
      or(J) {
        return or(this, J)
      }
      decode(J) {
        let et = J[0]
          , eo = this.decoders[et];
        if (eo)
          return eo.decode(J);
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(J)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)
      }
    }
      ;
    let or = (J, et) => new ComposedDecoder({
      ...J.decoders || {
        [J.prefix]: J
      },
      ...et.decoders || {
        [et.prefix]: et
      }
    });
    let Codec = class Codec {
      constructor(J, et, eo, el) {
        this.name = J,
          this.prefix = et,
          this.baseEncode = eo,
          this.baseDecode = el,
          this.encoder = new Encoder(J, et, eo),
          this.decoder = new Decoder(J, et, el)
      }
      encode(J) {
        return this.encoder.encode(J)
      }
      decode(J) {
        return this.decoder.decode(J)
      }
    }
      ;
    let from = ({ name: J, prefix: et, encode: eo, decode: el }) => new Codec(J, et, eo, el)
      , baseX = ({ prefix: J, name: et, alphabet: eo }) => {
        let { encode: el, decode: ec } = base_x(eo, et);
        return from({
          prefix: J,
          name: et,
          encode: el,
          decode: J => coerce(ec(J))
        })
      }
      , decode = (J, et, eo, el) => {
        let ec = {};
        for (let J = 0; J < et.length; ++J)
          ec[et[J]] = J;
        let ed = J.length;
        for (; "=" === J[ed - 1];)
          --ed;
        let eh = new Uint8Array(ed * eo / 8 | 0)
          , ep = 0
          , ef = 0
          , em = 0;
        for (let et = 0; et < ed; ++et) {
          let ed = ec[J[et]];
          if (void 0 === ed)
            throw SyntaxError(`Non-${el} character`);
          ef = ef << eo | ed,
            (ep += eo) >= 8 && (ep -= 8,
              eh[em++] = 255 & ef >> ep)
        }
        if (ep >= eo || 255 & ef << 8 - ep)
          throw SyntaxError("Unexpected end of data");
        return eh
      }
      , encode = (J, et, eo) => {
        let el = "=" === et[et.length - 1]
          , ec = (1 << eo) - 1
          , ed = ""
          , eh = 0
          , ep = 0;
        for (let el = 0; el < J.length; ++el)
          for (ep = ep << 8 | J[el],
            eh += 8; eh > eo;)
            eh -= eo,
              ed += et[ec & ep >> eh];
        if (eh && (ed += et[ec & ep << eo - eh]),
          el)
          for (; ed.length * eo & 7;)
            ed += "=";
        return ed
      }
      , rfc4648 = ({ name: J, prefix: et, bitsPerChar: eo, alphabet: el }) => from({
        prefix: et,
        name: J,
        encode: J => encode(J, el, eo),
        decode: et => decode(et, el, eo, J)
      })
      , e4 = from({
        prefix: "\x00",
        name: "identity",
        encode: J => bytes_toString(J),
        decode: J => bytes_fromString(J)
      })
      , e8 = rfc4648({
        prefix: "0",
        name: "base2",
        alphabet: "01",
        bitsPerChar: 1
      })
      , e7 = rfc4648({
        prefix: "7",
        name: "base8",
        alphabet: "01234567",
        bitsPerChar: 3
      })
      , e9 = baseX({
        prefix: "9",
        name: "base10",
        alphabet: "0123456789"
      })
      , tn = rfc4648({
        prefix: "f",
        name: "base16",
        alphabet: "0123456789abcdef",
        bitsPerChar: 4
      })
      , to = rfc4648({
        prefix: "F",
        name: "base16upper",
        alphabet: "0123456789ABCDEF",
        bitsPerChar: 4
      })
      , ta = rfc4648({
        prefix: "b",
        name: "base32",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567",
        bitsPerChar: 5
      })
      , tl = rfc4648({
        prefix: "B",
        name: "base32upper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
        bitsPerChar: 5
      })
      , tc = rfc4648({
        prefix: "c",
        name: "base32pad",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
        bitsPerChar: 5
      })
      , td = rfc4648({
        prefix: "C",
        name: "base32padupper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
        bitsPerChar: 5
      })
      , th = rfc4648({
        prefix: "v",
        name: "base32hex",
        alphabet: "0123456789abcdefghijklmnopqrstuv",
        bitsPerChar: 5
      })
      , tp = rfc4648({
        prefix: "V",
        name: "base32hexupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
        bitsPerChar: 5
      })
      , tf = rfc4648({
        prefix: "t",
        name: "base32hexpad",
        alphabet: "0123456789abcdefghijklmnopqrstuv=",
        bitsPerChar: 5
      })
      , tm = rfc4648({
        prefix: "T",
        name: "base32hexpadupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
        bitsPerChar: 5
      })
      , tg = rfc4648({
        prefix: "h",
        name: "base32z",
        alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
        bitsPerChar: 5
      })
      , ty = baseX({
        prefix: "k",
        name: "base36",
        alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
      })
      , tb = baseX({
        prefix: "K",
        name: "base36upper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      })
      , tw = baseX({
        name: "base58btc",
        prefix: "z",
        alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
      })
      , t_ = baseX({
        name: "base58flickr",
        prefix: "Z",
        alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
      })
      , tx = rfc4648({
        prefix: "m",
        name: "base64",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        bitsPerChar: 6
      })
      , tE = rfc4648({
        prefix: "M",
        name: "base64pad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        bitsPerChar: 6
      })
      , tC = rfc4648({
        prefix: "u",
        name: "base64url",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
        bitsPerChar: 6
      })
      , tS = rfc4648({
        prefix: "U",
        name: "base64urlpad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
        bitsPerChar: 6
      })
      , tk = Array.from("\uD83D\uDE80\uD83E\uDE90☄\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09☀\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02❤\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09☺\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E✌✨\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D❣\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33✋\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13⭐✅\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6✔\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90☹\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20☝\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B⚽\uD83E\uDD19☕\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81⚡\uD83C\uDF1E\uD83C\uDF88❌✊\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C✈\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74▶➡❓\uD83D\uDC8E\uD83D\uDCB8⬇\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A⚠\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37☎\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51❄\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42")
      , tT = tk.reduce((J, et, eo) => (J[eo] = et,
        J), [])
      , tA = tk.reduce((J, et, eo) => (J[et.codePointAt(0)] = eo,
        J), [])
      , tP = from({
        prefix: "\uD83D\uDE80",
        name: "base256emoji",
        encode: function (J) {
          return J.reduce((J, et) => J += tT[et], "")
        },
        decode: function (J) {
          let et = [];
          for (let eo of J) {
            let J = tA[eo.codePointAt(0)];
            if (void 0 === J)
              throw Error(`Non-base256emoji character: ${eo}`);
            et.push(J)
          }
          return new Uint8Array(et)
        }
      });
    function varint_encode(J, et, eo) {
      et = et || [];
      for (var el = eo = eo || 0; J >= 2147483648;)
        et[eo++] = 255 & J | 128,
          J /= 128;
      for (; -128 & J;)
        et[eo++] = 255 & J | 128,
          J >>>= 7;
      return et[eo] = 0 | J,
        varint_encode.bytes = eo - el + 1,
        et
    }
    function read(J, et) {
      var eo, el = 0, et = et || 0, ec = 0, ed = et, eh = J.length;
      do {
        if (ed >= eh)
          throw read.bytes = 0,
          RangeError("Could not decode varint");
        eo = J[ed++],
          el += ec < 28 ? (127 & eo) << ec : (127 & eo) * Math.pow(2, ec),
          ec += 7
      } while (eo >= 128);
      return read.bytes = ed - et,
        el
    }
    var tR = {
      encode: varint_encode,
      decode: read,
      encodingLength: function (J) {
        return J < 128 ? 1 : J < 16384 ? 2 : J < 2097152 ? 3 : J < 268435456 ? 4 : J < 34359738368 ? 5 : J < 4398046511104 ? 6 : J < 562949953421312 ? 7 : J < 72057594037927940 ? 8 : J < 0x7fffffffffffffff ? 9 : 10
      }
    };
    let src_varint_decode = (J, et = 0) => {
      let eo = tR.decode(J, et);
      return [eo, tR.decode.bytes]
    }
      , encodeTo = (J, et, eo = 0) => (tR.encode(J, et, eo),
        et)
      , encodingLength = J => tR.encodingLength(J)
      , create = (J, et) => {
        let eo = et.byteLength
          , el = encodingLength(J)
          , ec = el + encodingLength(eo)
          , ed = new Uint8Array(ec + eo);
        return encodeTo(J, ed, 0),
          encodeTo(eo, ed, el),
          ed.set(et, ec),
          new Digest(J, eo, et, ed)
      }
      , digest_decode = J => {
        let et = coerce(J)
          , [eo, el] = src_varint_decode(et)
          , [ec, ed] = src_varint_decode(et.subarray(el))
          , eh = et.subarray(el + ed);
        if (eh.byteLength !== ec)
          throw Error("Incorrect length");
        return new Digest(eo, ec, eh, et)
      }
      , digest_equals = (J, et) => J === et || J.code === et.code && J.size === et.size && equals(J.bytes, et.bytes);
    let Digest = class Digest {
      constructor(J, et, eo, el) {
        this.code = J,
          this.size = et,
          this.digest = eo,
          this.bytes = el
      }
    }
      ;
    let hasher_from = ({ name: J, code: et, encode: eo }) => new Hasher(J, et, eo);
    let Hasher = class Hasher {
      constructor(J, et, eo) {
        this.name = J,
          this.code = et,
          this.encode = eo
      }
      digest(J) {
        if (J instanceof Uint8Array) {
          let et = this.encode(J);
          return et instanceof Uint8Array ? create(this.code, et) : et.then(J => create(this.code, J))
        }
        throw Error("Unknown type, must be binary type")
      }
    }
      ;
    let sha = J => async et => new Uint8Array(await crypto.subtle.digest(J, et))
      , tI = hasher_from({
        name: "sha2-256",
        code: 18,
        encode: sha("SHA-256")
      })
      , tO = hasher_from({
        name: "sha2-512",
        code: 19,
        encode: sha("SHA-512")
      })
      , tN = {
        code: 0,
        name: "identity",
        encode: coerce,
        digest: J => create(0, coerce(J))
      }
      , tM = "raw"
      , tD = 85
      , raw_encode = J => coerce(J)
      , raw_decode = J => coerce(J)
      , tj = new TextEncoder
      , tL = new TextDecoder
      , t$ = "json"
      , tB = 512
      , json_encode = J => tj.encode(JSON.stringify(J))
      , json_decode = J => JSON.parse(tL.decode(J));
    let CID = class CID {
      constructor(J, et, eo, el) {
        this.code = et,
          this.version = J,
          this.multihash = eo,
          this.bytes = el,
          this.byteOffset = el.byteOffset,
          this.byteLength = el.byteLength,
          this.asCID = this,
          this._baseCache = new Map,
          Object.defineProperties(this, {
            byteOffset: tV,
            byteLength: tV,
            code: tH,
            version: tH,
            multihash: tH,
            bytes: tH,
            _baseCache: tV,
            asCID: tV
          })
      }
      toV0() {
        if (0 === this.version)
          return this;
        {
          let { code: J, multihash: et } = this;
          if (J !== tF)
            throw Error("Cannot convert a non dag-pb CID to CIDv0");
          if (et.code !== tU)
            throw Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          return CID.createV0(et)
        }
      }
      toV1() {
        switch (this.version) {
          case 0:
            {
              let { code: J, digest: et } = this.multihash
                , eo = create(J, et);
              return CID.createV1(this.code, eo)
            }
          case 1:
            return this;
          default:
            throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)
        }
      }
      equals(J) {
        return J && this.code === J.code && this.version === J.version && digest_equals(this.multihash, J.multihash)
      }
      toString(J) {
        let { bytes: et, version: eo, _baseCache: el } = this;
        return 0 === eo ? toStringV0(et, el, J || tw.encoder) : toStringV1(et, el, J || ta.encoder)
      }
      toJSON() {
        return {
          code: this.code,
          version: this.version,
          hash: this.multihash.bytes
        }
      }
      get [Symbol.toStringTag]() {
        return "CID"
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return "CID(" + this.toString() + ")"
      }
      static isCID(J) {
        return deprecate(/^0\.0/, tW),
          !!(J && (J[tz] || J.asCID === J))
      }
      get toBaseEncodedString() {
        throw Error("Deprecated, use .toString()")
      }
      get codec() {
        throw Error('"codec" property is deprecated, use integer "code" property instead')
      }
      get buffer() {
        throw Error("Deprecated .buffer property, use .bytes to get Uint8Array instead")
      }
      get multibaseName() {
        throw Error('"multibaseName" property is deprecated')
      }
      get prefix() {
        throw Error('"prefix" property is deprecated')
      }
      static asCID(J) {
        if (J instanceof CID)
          return J;
        if (null != J && J.asCID === J) {
          let { version: et, code: eo, multihash: el, bytes: ec } = J;
          return new CID(et, eo, el, ec || encodeCID(et, eo, el.bytes))
        }
        if (null == J || !0 !== J[tz])
          return null;
        {
          let { version: et, multihash: eo, code: el } = J
            , ec = digest_decode(eo);
          return CID.create(et, el, ec)
        }
      }
      static create(J, et, eo) {
        if ("number" != typeof et)
          throw Error("String codecs are no longer supported");
        switch (J) {
          case 0:
            if (et === tF)
              return new CID(J, et, eo, eo.bytes);
            throw Error(`Version 0 CID must use dag-pb (code: ${tF}) block encoding`);
          case 1:
            {
              let el = encodeCID(J, et, eo.bytes);
              return new CID(J, et, eo, el)
            }
          default:
            throw Error("Invalid version")
        }
      }
      static createV0(J) {
        return CID.create(0, tF, J)
      }
      static createV1(J, et) {
        return CID.create(1, J, et)
      }
      static decode(J) {
        let [et, eo] = CID.decodeFirst(J);
        if (eo.length)
          throw Error("Incorrect length");
        return et
      }
      static decodeFirst(J) {
        let et = CID.inspectBytes(J)
          , eo = et.size - et.multihashSize
          , el = coerce(J.subarray(eo, eo + et.multihashSize));
        if (el.byteLength !== et.multihashSize)
          throw Error("Incorrect length");
        let ec = el.subarray(et.multihashSize - et.digestSize)
          , ed = new Digest(et.multihashCode, et.digestSize, ec, el)
          , eh = 0 === et.version ? CID.createV0(ed) : CID.createV1(et.codec, ed);
        return [eh, J.subarray(et.size)]
      }
      static inspectBytes(J) {
        let et = 0
          , next = () => {
            let [eo, el] = src_varint_decode(J.subarray(et));
            return et += el,
              eo
          }
          , eo = next()
          , el = tF;
        if (18 === eo ? (eo = 0,
          et = 0) : 1 === eo && (el = next()),
          0 !== eo && 1 !== eo)
          throw RangeError(`Invalid CID version ${eo}`);
        let ec = et
          , ed = next()
          , eh = next()
          , ep = et + eh;
        return {
          version: eo,
          codec: el,
          multihashCode: ed,
          digestSize: eh,
          multihashSize: ep - ec,
          size: ep
        }
      }
      static parse(J, et) {
        let [eo, el] = parseCIDtoBytes(J, et)
          , ec = CID.decode(el);
        return ec._baseCache.set(eo, J),
          ec
      }
    }
      ;
    let parseCIDtoBytes = (J, et) => {
      switch (J[0]) {
        case "Q":
          return [tw.prefix, (et || tw).decode(`${tw.prefix}${J}`)];
        case tw.prefix:
          return [tw.prefix, (et || tw).decode(J)];
        case ta.prefix:
          return [ta.prefix, (et || ta).decode(J)];
        default:
          if (null == et)
            throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
          return [J[0], et.decode(J)]
      }
    }
      , toStringV0 = (J, et, eo) => {
        let { prefix: el } = eo;
        if (el !== tw.prefix)
          throw Error(`Cannot string encode V0 in ${eo.name} encoding`);
        let ec = et.get(el);
        if (null != ec)
          return ec;
        {
          let ec = eo.encode(J).slice(1);
          return et.set(el, ec),
            ec
        }
      }
      , toStringV1 = (J, et, eo) => {
        let { prefix: el } = eo
          , ec = et.get(el);
        if (null != ec)
          return ec;
        {
          let ec = eo.encode(J);
          return et.set(el, ec),
            ec
        }
      }
      , tF = 112
      , tU = 18
      , encodeCID = (J, et, eo) => {
        let el = encodingLength(J)
          , ec = el + encodingLength(et)
          , ed = new Uint8Array(ec + eo.byteLength);
        return encodeTo(J, ed, 0),
          encodeTo(et, ed, el),
          ed.set(eo, ec),
          ed
      }
      , tz = Symbol.for("@ipld/js-cid/CID")
      , tH = {
        writable: !1,
        configurable: !1,
        enumerable: !0
      }
      , tV = {
        writable: !1,
        enumerable: !1,
        configurable: !1
      }
      , deprecate = (J, et) => {
        if (J.test("0.0.0-dev"))
          console.warn(et);
        else
          throw Error(et)
      }
      , tW = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
// Make sure to use cid instead of value
doSomethingWithCID(cid)
}
`
      , tq = {
        ...eh,
        ...ep,
        ...ef,
        ...em,
        ...eg,
        ...ey,
        ...eb,
        ...ew,
        ...e_,
        ...ex
      };
    function createCodec(J, et, eo, el) {
      return {
        name: J,
        prefix: et,
        encoder: {
          name: J,
          prefix: et,
          encode: eo
        },
        decoder: {
          decode: el
        }
      }
    }
    ({
      ...eE,
      ...eC
    });
    let tZ = createCodec("utf8", "u", J => {
      let et = new TextDecoder("utf8");
      return "u" + et.decode(J)
    }
      , J => {
        let et = new TextEncoder;
        return et.encode(J.substring(1))
      }
    )
      , tG = createCodec("ascii", "a", J => {
        let et = "a";
        for (let eo = 0; eo < J.length; eo++)
          et += String.fromCharCode(J[eo]);
        return et
      }
        , J => {
          J = J.substring(1);
          let et = allocUnsafe(J.length);
          for (let eo = 0; eo < J.length; eo++)
            et[eo] = J.charCodeAt(eo);
          return et
        }
      )
      , tY = {
        utf8: tZ,
        "utf-8": tZ,
        hex: tq.base16,
        latin1: tG,
        ascii: tG,
        binary: tG,
        ...tq
      };
    function from_string_fromString(J, et = "utf8") {
      let eo = tY[et];
      if (!eo)
        throw Error(`Unsupported encoding "${et}"`);
      return ("utf8" === et || "utf-8" === et) && null != globalThis.Buffer && null != globalThis.Buffer.from ? as_uint8array_asUint8Array(globalThis.Buffer.from(J, "utf-8")) : eo.decoder.decode(`${eo.prefix}${J}`)
    }
    function to_string_toString(J, et = "utf8") {
      let eo = tY[et];
      if (!eo)
        throw Error(`Unsupported encoding "${et}"`);
      return ("utf8" === et || "utf-8" === et) && null != globalThis.Buffer && null != globalThis.Buffer.from ? globalThis.Buffer.from(J.buffer, J.byteOffset, J.byteLength).toString("utf8") : eo.encoder.encode(J).substring(1)
    }
    var tK = eo(83454)
      , __spreadArray = function (J, et, eo) {
        if (eo || 2 == arguments.length)
          for (var el, ec = 0, ed = et.length; ec < ed; ec++)
            !el && ec in et || (el || (el = Array.prototype.slice.call(et, 0, ec)),
              el[ec] = et[ec]);
        return J.concat(el || Array.prototype.slice.call(et))
      }
      , BrowserInfo = function (J, et, eo) {
        this.name = J,
          this.version = et,
          this.os = eo,
          this.type = "browser"
      }
      , NodeInfo = function (J) {
        this.version = J,
          this.type = "node",
          this.name = "node",
          this.os = tK.platform
      }
      , SearchBotDeviceInfo = function (J, et, eo, el) {
        this.name = J,
          this.version = et,
          this.os = eo,
          this.bot = el,
          this.type = "bot-device"
      }
      , BotInfo = function () {
        this.type = "bot",
          this.bot = !0,
          this.name = "bot",
          this.version = null,
          this.os = null
      }
      , ReactNativeInfo = function () {
        this.type = "react-native",
          this.name = "react-native",
          this.version = null,
          this.os = null
      }
      , tJ = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/
      , tQ = [["aol", /AOLShield\/([0-9\._]+)/], ["edge", /Edge\/([0-9\._]+)/], ["edge-ios", /EdgiOS\/([0-9\._]+)/], ["yandexbrowser", /YaBrowser\/([0-9\._]+)/], ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/], ["samsung", /SamsungBrowser\/([0-9\.]+)/], ["silk", /\bSilk\/([0-9._-]+)\b/], ["miui", /MiuiBrowser\/([0-9\.]+)$/], ["beaker", /BeakerBrowser\/([0-9\.]+)/], ["edge-chromium", /EdgA?\/([0-9\.]+)/], ["chromium-webview", /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/], ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/], ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/], ["fxios", /FxiOS\/([0-9\.]+)/], ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/], ["opera", /Opera\/([0-9\.]+)(?:\s|$)/], ["opera", /OPR\/([0-9\.]+)(:?\s|$)/], ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/], ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/], ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/], ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/], ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/], ["ie", /MSIE\s(7\.0)/], ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/], ["android", /Android\s([0-9\.]+)/], ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/], ["safari", /Version\/([0-9\._]+).*Safari/], ["facebook", /FB[AS]V\/([0-9\.]+)/], ["instagram", /Instagram\s([0-9\.]+)/], ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/], ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/], ["curl", /^curl\/([0-9\.]+)$/], ["searchbot", /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/]]
      , tX = [["iOS", /iP(hone|od|ad)/], ["Android OS", /Android/], ["BlackBerry OS", /BlackBerry|BB10/], ["Windows Mobile", /IEMobile/], ["Amazon OS", /Kindle/], ["Windows 3.11", /Win16/], ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/], ["Windows 98", /(Windows 98)|(Win98)/], ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/], ["Windows XP", /(Windows NT 5.1)|(Windows XP)/], ["Windows Server 2003", /(Windows NT 5.2)/], ["Windows Vista", /(Windows NT 6.0)/], ["Windows 7", /(Windows NT 6.1)/], ["Windows 8", /(Windows NT 6.2)/], ["Windows 8.1", /(Windows NT 6.3)/], ["Windows 10", /(Windows NT 10.0)/], ["Windows ME", /Windows ME/], ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/], ["Open BSD", /OpenBSD/], ["Sun OS", /SunOS/], ["Chrome OS", /CrOS/], ["Linux", /(Linux)|(X11)/], ["Mac OS", /(Mac_PowerPC)|(Macintosh)/], ["QNX", /QNX/], ["BeOS", /BeOS/], ["OS/2", /OS\/2/]];
    function parseUserAgent(J) {
      var et = "" !== J && tQ.reduce(function (et, eo) {
        var el = eo[0]
          , ec = eo[1];
        if (et)
          return et;
        var ed = ec.exec(J);
        return !!ed && [el, ed]
      }, !1);
      if (!et)
        return null;
      var eo = et[0]
        , el = et[1];
      if ("searchbot" === eo)
        return new BotInfo;
      var ec = el[1] && el[1].split(".").join("_").split("_").slice(0, 3);
      ec ? ec.length < 3 && (ec = __spreadArray(__spreadArray([], ec, !0), function (J) {
        for (var et = [], eo = 0; eo < J; eo++)
          et.push("0");
        return et
      }(3 - ec.length), !0)) : ec = [];
      var ed = ec.join(".")
        , eh = function (J) {
          for (var et = 0, eo = tX.length; et < eo; et++) {
            var el = tX[et]
              , ec = el[0];
            if (el[1].exec(J))
              return ec
          }
          return null
        }(J)
        , ep = tJ.exec(J);
      return ep && ep[1] ? new SearchBotDeviceInfo(eo, ed, eh, ep[1]) : new BrowserInfo(eo, ed, eh)
    }
    var t0 = eo(66736)
      , t1 = eo(62873)
      , t2 = eo(65755)
      , t3 = eo(17563);
    eo(61882);
    let t5 = {
      waku: {
        publish: "waku_publish",
        batchPublish: "waku_batchPublish",
        subscribe: "waku_subscribe",
        batchSubscribe: "waku_batchSubscribe",
        subscription: "waku_subscription",
        unsubscribe: "waku_unsubscribe",
        batchUnsubscribe: "waku_batchUnsubscribe"
      },
      irn: {
        publish: "irn_publish",
        batchPublish: "irn_batchPublish",
        subscribe: "irn_subscribe",
        batchSubscribe: "irn_batchSubscribe",
        subscription: "irn_subscription",
        unsubscribe: "irn_unsubscribe",
        batchUnsubscribe: "irn_batchUnsubscribe"
      },
      iridium: {
        publish: "iridium_publish",
        batchPublish: "iridium_batchPublish",
        subscribe: "iridium_subscribe",
        batchSubscribe: "iridium_batchSubscribe",
        subscription: "iridium_subscription",
        unsubscribe: "iridium_unsubscribe",
        batchUnsubscribe: "iridium_batchUnsubscribe"
      }
    };
    var t6 = eo(83454);
    function L(J, et) {
      return J.includes(":") ? [J] : et.chains || []
    }
    let t4 = "base10"
      , t8 = "base16"
      , t7 = "base64pad"
      , t9 = "utf8";
    function Vn() {
      let J = (0,
        e3.randomBytes)(32);
      return to_string_toString(J, t8)
    }
    function Ln(J) {
      let et = (0,
        e5.vp)(from_string_fromString(J, t9));
      return to_string_toString(et, t8)
    }
    function $(J) {
      return Number(to_string_toString(J, t4))
    }
    function ee(J) {
      let et = from_string_fromString(J, t7)
        , eo = et.slice(0, 1);
      if (1 === $(eo)) {
        let J = et.slice(1, 33)
          , el = et.slice(33, 45)
          , ec = et.slice(45);
        return {
          type: eo,
          sealed: ec,
          iv: el,
          senderPublicKey: J
        }
      }
      let el = et.slice(1, 13)
        , ec = et.slice(13);
      return {
        type: eo,
        sealed: ec,
        iv: el
      }
    }
    function Ae(J) {
      let et = J?.type || 0;
      if (1 === et) {
        if (typeof J?.senderPublicKey > "u")
          throw Error("missing sender public key");
        if (typeof J?.receiverPublicKey > "u")
          throw Error("missing receiver public key")
      }
      return {
        type: et,
        senderPublicKey: J?.senderPublicKey,
        receiverPublicKey: J?.receiverPublicKey
      }
    }
    function qn(J) {
      return 1 === J.type && "string" == typeof J.senderPublicKey && "string" == typeof J.receiverPublicKey
    }
    var ro = Object.defineProperty
      , ra = Object.getOwnPropertySymbols
      , rl = Object.prototype.hasOwnProperty
      , rc = Object.prototype.propertyIsEnumerable
      , _e = (J, et, eo) => et in J ? ro(J, et, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: eo
      }) : J[et] = eo
      , Ce = (J, et) => {
        for (var eo in et || (et = {}))
          rl.call(et, eo) && _e(J, eo, et[eo]);
        if (ra)
          for (var eo of ra(et))
            rc.call(et, eo) && _e(J, eo, et[eo]);
        return J
      }
      ;
    let rd = {
      reactNative: "react-native",
      node: "node",
      browser: "browser",
      unknown: "unknown"
    };
    function te() {
      return "u" > typeof t6 && "u" > typeof t6.versions && "u" > typeof t6.versions.node
    }
    function C() {
      return !(0,
        t1.getDocument)() && !!(0,
          t1.getNavigator)() && "ReactNative" === navigator.product
    }
    function D() {
      return !te() && !!(0,
        t1.getNavigator)() && !!(0,
          t1.getDocument)()
    }
    function T() {
      return C() ? rd.reactNative : te() ? rd.node : D() ? rd.browser : rd.unknown
    }
    function O(J, et) {
      return J.filter(J => et.includes(J)).length === J.length
    }
    function rt(J) {
      return Object.fromEntries(J.entries())
    }
    function ot(J) {
      return new Map(Object.entries(J))
    }
    function at(J = t0.FIVE_MINUTES, et) {
      let eo, el, ec;
      let ed = (0,
        t0.toMiliseconds)(J || t0.FIVE_MINUTES);
      return {
        resolve: J => {
          ec && eo && (clearTimeout(ec),
            eo(J))
        }
        ,
        reject: J => {
          ec && el && (clearTimeout(ec),
            el(J))
        }
        ,
        done: () => new Promise((J, eh) => {
          ec = setTimeout(() => {
            eh(Error(et))
          }
            , ed),
            eo = J,
            el = eh
        }
        )
      }
    }
    function ut(J, et, eo) {
      return new Promise(async (el, ec) => {
        let ed = setTimeout(() => ec(Error(eo)), et);
        try {
          let et = await J;
          el(et)
        } catch (J) {
          ec(J)
        }
        clearTimeout(ed)
      }
      )
    }
    function re(J, et) {
      if ("string" == typeof et && et.startsWith(`${J}:`))
        return et;
      if ("topic" === J.toLowerCase()) {
        if ("string" != typeof et)
          throw Error('Value must be "string" for expirer target type: topic');
        return `topic:${et}`
      }
      if ("id" === J.toLowerCase()) {
        if ("number" != typeof et)
          throw Error('Value must be "number" for expirer target type: id');
        return `id:${et}`
      }
      throw Error(`Unknown expirer target type: ${J}`)
    }
    function ft(J) {
      let [et, eo] = J.split(":")
        , el = {
          id: void 0,
          topic: void 0
        };
      if ("topic" === et && "string" == typeof eo)
        el.topic = eo;
      else if ("id" === et && Number.isInteger(Number(eo)))
        el.id = Number(eo);
      else
        throw Error(`Invalid target, expected id:number or topic:string, got ${et}:${eo}`);
      return el
    }
    function pt(J, et) {
      return (0,
        t0.fromMiliseconds)((et || Date.now()) + (0,
          t0.toMiliseconds)(J))
    }
    function mt(J) {
      return Date.now() >= (0,
        t0.toMiliseconds)(J)
    }
    function yt(J, et) {
      return `${J}${et ? `:${et}` : ""}`
    }
    function S(J = [], et = []) {
      return [...new Set([...J, ...et])]
    }
    async function ht({ id: J, topic: et, wcDeepLink: el }) {
      try {
        if (!el)
          return;
        let ec = "string" == typeof el ? JSON.parse(el) : el
          , ed = ec?.href;
        if ("string" != typeof ed)
          return;
        ed.endsWith("/") && (ed = ed.slice(0, -1));
        let eh = `${ed}/wc?requestId=${J}&sessionTopic=${et}`
          , ep = T();
        ep === rd.browser ? eh.startsWith("https://") ? window.open(eh, "_blank", "noreferrer noopener") : window.open(eh, "_self", "noreferrer noopener") : ep === rd.reactNative && "u" > typeof (null == eo.g ? void 0 : eo.g.Linking) && await eo.g.Linking.openURL(eh)
      } catch (J) {
        console.error(J)
      }
    }
    async function gt(J, et) {
      try {
        return await J.getItem(et) || (D() ? localStorage.getItem(et) : void 0)
      } catch (J) {
        console.error(J)
      }
    }
    function vt(J) {
      return J?.relay || {
        protocol: "irn"
      }
    }
    function Et(J) {
      let et = t5[J];
      if (typeof et > "u")
        throw Error(`Relay Protocol not supported: ${J}`);
      return et
    }
    var rh = Object.defineProperty
      , rp = Object.getOwnPropertySymbols
      , rm = Object.prototype.hasOwnProperty
      , rg = Object.prototype.propertyIsEnumerable
      , Be = (J, et, eo) => et in J ? rh(J, et, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: eo
      }) : J[et] = eo
      , St = (J, et) => {
        for (var eo in et || (et = {}))
          rm.call(et, eo) && Be(J, eo, et[eo]);
        if (rp)
          for (var eo of rp(et))
            rg.call(et, eo) && Be(J, eo, et[eo]);
        return J
      }
      ;
    function wt(J) {
      var et;
      J = (J = J.includes("wc://") ? J.replace("wc://", "") : J).includes("wc:") ? J.replace("wc:", "") : J;
      let eo = J.indexOf(":")
        , el = -1 !== J.indexOf("?") ? J.indexOf("?") : void 0
        , ec = J.substring(0, eo)
        , ed = J.substring(eo + 1, el).split("@")
        , eh = "u" > typeof el ? J.substring(el) : ""
        , ep = t3.parse(eh);
      return {
        protocol: ec,
        topic: (et = ed[0]).startsWith("//") ? et.substring(2) : et,
        version: parseInt(ed[1], 10),
        symKey: ep.symKey,
        relay: function (J, et = "-") {
          let eo = {}
            , el = "relay" + et;
          return Object.keys(J).forEach(et => {
            if (et.startsWith(el)) {
              let ec = et.replace(el, "")
                , ed = J[et];
              eo[ec] = ed
            }
          }
          ),
            eo
        }(ep)
      }
    }
    function A(J) {
      let et = [];
      return J.forEach(J => {
        let [eo, el] = J.split(":");
        et.push(`${eo}:${el}`)
      }
      ),
        et
    }
    function oe(J) {
      return J.includes(":")
    }
    function en(J) {
      return oe(J) ? J.split(":")[0] : J
    }
    Object.prototype.hasOwnProperty,
      Object.prototype.propertyIsEnumerable;
    let ry = {
      INVALID_METHOD: {
        message: "Invalid method.",
        code: 1001
      },
      INVALID_EVENT: {
        message: "Invalid event.",
        code: 1002
      },
      INVALID_UPDATE_REQUEST: {
        message: "Invalid update request.",
        code: 1003
      },
      INVALID_EXTEND_REQUEST: {
        message: "Invalid extend request.",
        code: 1004
      },
      INVALID_SESSION_SETTLE_REQUEST: {
        message: "Invalid session settle request.",
        code: 1005
      },
      UNAUTHORIZED_METHOD: {
        message: "Unauthorized method.",
        code: 3001
      },
      UNAUTHORIZED_EVENT: {
        message: "Unauthorized event.",
        code: 3002
      },
      UNAUTHORIZED_UPDATE_REQUEST: {
        message: "Unauthorized update request.",
        code: 3003
      },
      UNAUTHORIZED_EXTEND_REQUEST: {
        message: "Unauthorized extend request.",
        code: 3004
      },
      USER_REJECTED: {
        message: "User rejected.",
        code: 5e3
      },
      USER_REJECTED_CHAINS: {
        message: "User rejected chains.",
        code: 5001
      },
      USER_REJECTED_METHODS: {
        message: "User rejected methods.",
        code: 5002
      },
      USER_REJECTED_EVENTS: {
        message: "User rejected events.",
        code: 5003
      },
      UNSUPPORTED_CHAINS: {
        message: "Unsupported chains.",
        code: 5100
      },
      UNSUPPORTED_METHODS: {
        message: "Unsupported methods.",
        code: 5101
      },
      UNSUPPORTED_EVENTS: {
        message: "Unsupported events.",
        code: 5102
      },
      UNSUPPORTED_ACCOUNTS: {
        message: "Unsupported accounts.",
        code: 5103
      },
      UNSUPPORTED_NAMESPACE_KEY: {
        message: "Unsupported namespace key.",
        code: 5104
      },
      USER_DISCONNECTED: {
        message: "User disconnected.",
        code: 6e3
      },
      SESSION_SETTLEMENT_FAILED: {
        message: "Session settlement failed.",
        code: 7e3
      },
      WC_METHOD_UNSUPPORTED: {
        message: "Unsupported wc_ method.",
        code: 10001
      }
    }
      , rb = {
        NOT_INITIALIZED: {
          message: "Not initialized.",
          code: 1
        },
        NO_MATCHING_KEY: {
          message: "No matching key.",
          code: 2
        },
        RESTORE_WILL_OVERRIDE: {
          message: "Restore will override.",
          code: 3
        },
        RESUBSCRIBED: {
          message: "Resubscribed.",
          code: 4
        },
        MISSING_OR_INVALID: {
          message: "Missing or invalid.",
          code: 5
        },
        EXPIRED: {
          message: "Expired.",
          code: 6
        },
        UNKNOWN_TYPE: {
          message: "Unknown type.",
          code: 7
        },
        MISMATCHED_TOPIC: {
          message: "Mismatched topic.",
          code: 8
        },
        NON_CONFORMING_NAMESPACES: {
          message: "Non conforming namespaces.",
          code: 9
        }
      };
    function N(J, et) {
      let { message: eo, code: el } = rb[J];
      return {
        message: et ? `${eo} ${et}` : eo,
        code: el
      }
    }
    function index_es_U(J, et) {
      let { message: eo, code: el } = ry[J];
      return {
        message: et ? `${eo} ${et}` : eo,
        code: el
      }
    }
    function k(J, et) {
      return !!Array.isArray(J) && (!("u" > typeof et) || !J.length || J.every(et))
    }
    function B(J) {
      return Object.getPrototypeOf(J) === Object.prototype && Object.keys(J).length
    }
    function w(J) {
      return typeof J > "u"
    }
    function h(J, et) {
      return !!(et && w(J)) || "string" == typeof J && !!J.trim().length
    }
    function G(J, et) {
      return !!(et && w(J)) || "number" == typeof J && !isNaN(J)
    }
    function V(J) {
      return !!(h(J, !1) && J.includes(":")) && 2 === J.split(":").length
    }
    function ie(J) {
      let et = !0;
      return k(J) ? J.length && (et = J.every(J => h(J, !1))) : et = !1,
        et
    }
    function ce(J, et) {
      let eo = null;
      return Object.values(J).forEach(J => {
        var el;
        let ec;
        if (eo)
          return;
        let ed = (el = `${et}, namespace`,
          ec = null,
          ie(J?.methods) ? ie(J?.events) || (ec = index_es_U("UNSUPPORTED_EVENTS", `${el}, events should be an array of strings or empty array for no events`)) : ec = index_es_U("UNSUPPORTED_METHODS", `${el}, methods should be an array of strings or empty array for no methods`),
          ec);
        ed && (eo = ed)
      }
      ),
        eo
    }
    function ln(J, et) {
      let eo = null;
      if (J && B(J)) {
        let el;
        let ec = ce(J, et);
        ec && (eo = ec);
        let ed = (el = null,
          Object.values(J).forEach(J => {
            var eo, ec;
            let ed;
            if (el)
              return;
            let eh = (eo = J?.accounts,
              ec = `${et} namespace`,
              ed = null,
              k(eo) ? eo.forEach(J => {
                ed || function (J) {
                  if (h(J, !1) && J.includes(":")) {
                    let et = J.split(":");
                    if (3 === et.length) {
                      let J = et[0] + ":" + et[1];
                      return !!et[2] && V(J)
                    }
                  }
                  return !1
                }(J) || (ed = index_es_U("UNSUPPORTED_ACCOUNTS", `${ec}, account ${J} should be a string and conform to "namespace:chainId:address" format`))
              }
              ) : ed = index_es_U("UNSUPPORTED_ACCOUNTS", `${ec}, accounts should be an array of strings conforming to "namespace:chainId:address" format`),
              ed);
            eh && (el = eh)
          }
          ),
          el);
        ed && (eo = ed)
      } else
        eo = N("MISSING_OR_INVALID", `${et}, namespaces should be an object with data`);
      return eo
    }
    function dn(J) {
      return h(J.protocol, !0)
    }
    function Ht(J) {
      return "u" > typeof J
    }
    function zt(J, et) {
      return !(!V(et) || !(function (J) {
        let et = [];
        return Object.values(J).forEach(J => {
          et.push(...A(J.accounts))
        }
        ),
          et
      }
      )(J).includes(et))
    }
    function fn(J, et, eo) {
      let el = null
        , ec = function (J) {
          let et = {};
          return Object.keys(J).forEach(eo => {
            var el;
            eo.includes(":") ? et[eo] = J[eo] : null == (el = J[eo].chains) || el.forEach(el => {
              et[el] = {
                methods: J[eo].methods,
                events: J[eo].events
              }
            }
            )
          }
          ),
            et
        }(J)
        , ed = function (J) {
          let et = {};
          return Object.keys(J).forEach(eo => {
            if (eo.includes(":"))
              et[eo] = J[eo];
            else {
              let el = A(J[eo].accounts);
              el?.forEach(el => {
                et[el] = {
                  accounts: J[eo].accounts.filter(J => J.includes(`${el}:`)),
                  methods: J[eo].methods,
                  events: J[eo].events
                }
              }
              )
            }
          }
          ),
            et
        }(et)
        , eh = Object.keys(ec)
        , ep = Object.keys(ed)
        , ef = pn(Object.keys(J))
        , em = pn(Object.keys(et))
        , eg = ef.filter(J => !em.includes(J));
      return eg.length && (el = N("NON_CONFORMING_NAMESPACES", `${eo} namespaces keys don't satisfy requiredNamespaces.
    Required: ${eg.toString()}
    Received: ${Object.keys(et).toString()}`)),
        O(eh, ep) || (el = N("NON_CONFORMING_NAMESPACES", `${eo} namespaces chains don't satisfy required namespaces.
    Required: ${eh.toString()}
    Approved: ${ep.toString()}`)),
        Object.keys(et).forEach(J => {
          if (!J.includes(":") || el)
            return;
          let ec = A(et[J].accounts);
          ec.includes(J) || (el = N("NON_CONFORMING_NAMESPACES", `${eo} namespaces accounts don't satisfy namespace accounts for ${J}
      Required: ${J}
      Approved: ${ec.toString()}`))
        }
        ),
        eh.forEach(J => {
          el || (O(ec[J].methods, ed[J].methods) ? O(ec[J].events, ed[J].events) || (el = N("NON_CONFORMING_NAMESPACES", `${eo} namespaces events don't satisfy namespace events for ${J}`)) : el = N("NON_CONFORMING_NAMESPACES", `${eo} namespaces methods don't satisfy namespace methods for ${J}`))
        }
        ),
        el
    }
    function pn(J) {
      return [...new Set(J.map(J => J.includes(":") ? J.split(":")[0] : J))]
    }
    function er() {
      let J = T();
      return new Promise(et => {
        switch (J) {
          case rd.browser:
            et(D() && navigator?.onLine);
            break;
          case rd.reactNative:
            et(yn());
            break;
          case rd.node:
          default:
            et(!0)
        }
      }
      )
    }
    async function yn() {
      if (C() && "u" > typeof eo.g && null != eo.g && eo.g.NetInfo) {
        let J = await (null == eo.g ? void 0 : eo.g.NetInfo.fetch());
        return J?.isConnected
      }
      return !0
    }
    let rw = {};
    let tr = class tr {
      static get(J) {
        return rw[J]
      }
      static set(J, et) {
        rw[J] = et
      }
      static delete(J) {
        delete rw[J]
      }
    }
      ;
    let r_ = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/
      , rx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/
      , rE = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
    function jsonParseTransform(J, et) {
      if ("__proto__" === J || "constructor" === J && et && "object" == typeof et && "prototype" in et) {
        console.warn(`[destr] Dropping "${J}" key to prevent prototype pollution.`);
        return
      }
      return et
    }
    function destr(J, et = {}) {
      if ("string" != typeof J)
        return J;
      let eo = J.trim();
      if ('"' === J[0] && '"' === J.at(-1) && !J.includes("\\"))
        return eo.slice(1, -1);
      if (eo.length <= 9) {
        let J = eo.toLowerCase();
        if ("true" === J)
          return !0;
        if ("false" === J)
          return !1;
        if ("undefined" === J)
          return;
        if ("null" === J)
          return null;
        if ("nan" === J)
          return Number.NaN;
        if ("infinity" === J)
          return Number.POSITIVE_INFINITY;
        if ("-infinity" === J)
          return Number.NEGATIVE_INFINITY
      }
      if (!rE.test(J)) {
        if (et.strict)
          throw SyntaxError("[destr] Invalid JSON");
        return J
      }
      try {
        if (r_.test(J) || rx.test(J)) {
          if (et.strict)
            throw Error("[destr] Possible prototype pollution");
          return JSON.parse(J, jsonParseTransform)
        }
        return JSON.parse(J)
      } catch (eo) {
        if (et.strict)
          throw eo;
        return J
      }
    }
    var rC = eo(48764).Buffer;
    function asyncCall(J, ...et) {
      try {
        var eo;
        return (eo = J(...et)) && "function" == typeof eo.then ? eo : Promise.resolve(eo)
      } catch (J) {
        return Promise.reject(J)
      }
    }
    function unstorage_8581f561_stringify(J) {
      if (function (J) {
        let et = typeof J;
        return null === J || "object" !== et && "function" !== et
      }(J))
        return String(J);
      if (function (J) {
        let et = Object.getPrototypeOf(J);
        return !et || et.isPrototypeOf(Object)
      }(J) || Array.isArray(J))
        return JSON.stringify(J);
      if ("function" == typeof J.toJSON)
        return unstorage_8581f561_stringify(J.toJSON());
      throw Error("[unstorage] Cannot stringify value!")
    }
    let rS = "base64:";
    function normalizeKey(J) {
      return J ? J.split("?")[0].replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") : ""
    }
    function unstorage_8581f561_normalizeBaseKey(J) {
      return (J = normalizeKey(J)) ? J + ":" : ""
    }
    let memory = () => {
      let J = new Map;
      return {
        name: "memory",
        options: {},
        hasItem: et => J.has(et),
        getItem: et => J.get(et) ?? null,
        getItemRaw: et => J.get(et) ?? null,
        setItem(et, eo) {
          J.set(et, eo)
        },
        setItemRaw(et, eo) {
          J.set(et, eo)
        },
        removeItem(et) {
          J.delete(et)
        },
        getKeys: () => Array.from(J.keys()),
        clear() {
          J.clear()
        },
        dispose() {
          J.clear()
        }
      }
    }
      ;
    function watch(J, et, eo) {
      return J.watch ? J.watch((J, el) => et(J, eo + el)) : () => { }
    }
    async function dispose(J) {
      "function" == typeof J.dispose && await asyncCall(J.dispose)
    }
    function promisifyRequest(J) {
      return new Promise((et, eo) => {
        J.oncomplete = J.onsuccess = () => et(J.result),
          J.onabort = J.onerror = () => eo(J.error)
      }
      )
    }
    function dist_createStore(J, et) {
      let eo = indexedDB.open(J);
      eo.onupgradeneeded = () => eo.result.createObjectStore(et);
      let el = promisifyRequest(eo);
      return (J, eo) => el.then(el => eo(el.transaction(et, J).objectStore(et)))
    }
    function defaultGetStore() {
      return ec || (ec = dist_createStore("keyval-store", "keyval")),
        ec
    }
    function get(J, et = defaultGetStore()) {
      return et("readonly", et => promisifyRequest(et.get(J)))
    }
    let JSONStringify = J => JSON.stringify(J, (J, et) => "bigint" == typeof et ? et.toString() + "n" : et)
      , JSONParse = J => {
        let et = J.replace(/([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g, '$1"$2n"$3');
        return JSON.parse(et, (J, et) => {
          let eo = "string" == typeof et && et.match(/^\d+n$/);
          return eo ? BigInt(et.substring(0, et.length - 1)) : et
        }
        )
      }
      ;
    function esm_safeJsonParse(J) {
      if ("string" != typeof J)
        throw Error(`Cannot safe json parse value of type ${typeof J}`);
      try {
        return JSONParse(J)
      } catch (et) {
        return J
      }
    }
    function safeJsonStringify(J) {
      return "string" == typeof J ? J : JSONStringify(J) || ""
    }
    var index_es_z = (J = {}) => {
      let et;
      let eo = J.base && J.base.length > 0 ? `${J.base}:` : ""
        , e = J => eo + J;
      return J.dbName && J.storeName && (et = dist_createStore(J.dbName, J.storeName)),
      {
        name: "idb-keyval",
        options: J,
        hasItem: async J => !(typeof await get(e(J), et) > "u"),
        getItem: async J => await get(e(J), et) ?? null,
        setItem: (J, eo) => (function (J, et, eo = defaultGetStore()) {
          return eo("readwrite", eo => (eo.put(et, J),
            promisifyRequest(eo.transaction)))
        }
        )(e(J), eo, et),
        removeItem: J => (function (J, et = defaultGetStore()) {
          return et("readwrite", et => (et.delete(J),
            promisifyRequest(et.transaction)))
        }
        )(e(J), et),
        getKeys: () => (function (J = defaultGetStore()) {
          return J("readonly", J => {
            var et;
            if (J.getAllKeys)
              return promisifyRequest(J.getAllKeys());
            let eo = [];
            return (et = J => eo.push(J.key),
              J.openCursor().onsuccess = function () {
                this.result && (et(this.result),
                  this.result.continue())
              }
              ,
              promisifyRequest(J.transaction)).then(() => eo)
          }
          )
        }
        )(et),
        clear: () => (function (J = defaultGetStore()) {
          return J("readwrite", J => (J.clear(),
            promisifyRequest(J.transaction)))
        }
        )(et)
      }
    }
      ;
    let index_es_ = class index_es_ {
      constructor() {
        this.indexedDb = function (J = {}) {
          let et = {
            mounts: {
              "": J.driver || memory()
            },
            mountpoints: [""],
            watching: !1,
            watchListeners: [],
            unwatch: {}
          }
            , getMount = J => {
              for (let eo of et.mountpoints)
                if (J.startsWith(eo))
                  return {
                    base: eo,
                    relativeKey: J.slice(eo.length),
                    driver: et.mounts[eo]
                  };
              return {
                base: "",
                relativeKey: J,
                driver: et.mounts[""]
              }
            }
            , getMounts = (J, eo) => et.mountpoints.filter(et => et.startsWith(J) || eo && J.startsWith(et)).map(eo => ({
              relativeBase: J.length > eo.length ? J.slice(eo.length) : void 0,
              mountpoint: eo,
              driver: et.mounts[eo]
            }))
            , onChange = (J, eo) => {
              if (et.watching)
                for (let el of (eo = normalizeKey(eo),
                  et.watchListeners))
                  el(J, eo)
            }
            , startWatch = async () => {
              if (!et.watching)
                for (let J in et.watching = !0,
                  et.mounts)
                  et.unwatch[J] = await watch(et.mounts[J], onChange, J)
            }
            , stopWatch = async () => {
              if (et.watching) {
                for (let J in et.unwatch)
                  await et.unwatch[J]();
                et.unwatch = {},
                  et.watching = !1
              }
            }
            , runBatch = (J, et, eo) => {
              let el = new Map
                , getBatch = J => {
                  let et = el.get(J.base);
                  return et || (et = {
                    driver: J.driver,
                    base: J.base,
                    items: []
                  },
                    el.set(J.base, et)),
                    et
                }
                ;
              for (let eo of J) {
                let J = "string" == typeof eo
                  , el = normalizeKey(J ? eo : eo.key)
                  , ec = J ? void 0 : eo.value
                  , ed = J || !eo.options ? et : {
                    ...et,
                    ...eo.options
                  }
                  , eh = getMount(el);
                getBatch(eh).items.push({
                  key: el,
                  value: ec,
                  relativeKey: eh.relativeKey,
                  options: ed
                })
              }
              return Promise.all([...el.values()].map(J => eo(J))).then(J => J.flat())
            }
            , eo = {
              hasItem(J, et = {}) {
                J = normalizeKey(J);
                let { relativeKey: eo, driver: el } = getMount(J);
                return asyncCall(el.hasItem, eo, et)
              },
              getItem(J, et = {}) {
                J = normalizeKey(J);
                let { relativeKey: eo, driver: el } = getMount(J);
                return asyncCall(el.getItem, eo, et).then(J => destr(J))
              },
              getItems: (J, et) => runBatch(J, et, J => J.driver.getItems ? asyncCall(J.driver.getItems, J.items.map(J => ({
                key: J.relativeKey,
                options: J.options
              })), et).then(et => et.map(et => ({
                key: function (...J) {
                  return normalizeKey(J.join(":"))
                }(J.base, et.key),
                value: destr(et.value)
              }))) : Promise.all(J.items.map(et => asyncCall(J.driver.getItem, et.relativeKey, et.options).then(J => ({
                key: et.key,
                value: destr(J)
              }))))),
              getItemRaw(J, et = {}) {
                J = normalizeKey(J);
                let { relativeKey: eo, driver: el } = getMount(J);
                return el.getItemRaw ? asyncCall(el.getItemRaw, eo, et) : asyncCall(el.getItem, eo, et).then(J => "string" == typeof J && J.startsWith(rS) ? rC.from(J.slice(rS.length), "base64") : J)
              },
              async setItem(J, et, el = {}) {
                if (void 0 === et)
                  return eo.removeItem(J);
                J = normalizeKey(J);
                let { relativeKey: ec, driver: ed } = getMount(J);
                ed.setItem && (await asyncCall(ed.setItem, ec, unstorage_8581f561_stringify(et), el),
                  ed.watch || onChange("update", J))
              },
              async setItems(J, et) {
                await runBatch(J, et, async J => {
                  J.driver.setItems && await asyncCall(J.driver.setItems, J.items.map(J => ({
                    key: J.relativeKey,
                    value: unstorage_8581f561_stringify(J.value),
                    options: J.options
                  })), et),
                    J.driver.setItem && await Promise.all(J.items.map(et => asyncCall(J.driver.setItem, et.relativeKey, unstorage_8581f561_stringify(et.value), et.options)))
                }
                )
              },
              async setItemRaw(J, et, el = {}) {
                if (void 0 === et)
                  return eo.removeItem(J, el);
                J = normalizeKey(J);
                let { relativeKey: ec, driver: ed } = getMount(J);
                if (ed.setItemRaw)
                  await asyncCall(ed.setItemRaw, ec, et, el);
                else {
                  if (!ed.setItem)
                    return;
                  await asyncCall(ed.setItem, ec, function (J) {
                    if ("string" == typeof J)
                      return J;
                    let et = rC.from(J).toString("base64");
                    return rS + et
                  }(et), el)
                }
                ed.watch || onChange("update", J)
              },
              async removeItem(J, et = {}) {
                "boolean" == typeof et && (et = {
                  removeMeta: et
                }),
                  J = normalizeKey(J);
                let { relativeKey: eo, driver: el } = getMount(J);
                el.removeItem && (await asyncCall(el.removeItem, eo, et),
                  (et.removeMeta || et.removeMata) && await asyncCall(el.removeItem, eo + "$", et),
                  el.watch || onChange("remove", J))
              },
              async getMeta(J, et = {}) {
                "boolean" == typeof et && (et = {
                  nativeOnly: et
                }),
                  J = normalizeKey(J);
                let { relativeKey: eo, driver: el } = getMount(J)
                  , ec = Object.create(null);
                if (el.getMeta && Object.assign(ec, await asyncCall(el.getMeta, eo, et)),
                  !et.nativeOnly) {
                  let J = await asyncCall(el.getItem, eo + "$", et).then(J => destr(J));
                  J && "object" == typeof J && ("string" == typeof J.atime && (J.atime = new Date(J.atime)),
                    "string" == typeof J.mtime && (J.mtime = new Date(J.mtime)),
                    Object.assign(ec, J))
                }
                return ec
              },
              setMeta(J, et, eo = {}) {
                return this.setItem(J + "$", et, eo)
              },
              removeMeta(J, et = {}) {
                return this.removeItem(J + "$", et)
              },
              async getKeys(J, et = {}) {
                J = unstorage_8581f561_normalizeBaseKey(J);
                let eo = getMounts(J, !0)
                  , el = []
                  , ec = [];
                for (let J of eo) {
                  let eo = await asyncCall(J.driver.getKeys, J.relativeBase, et)
                    , ed = eo.map(et => J.mountpoint + normalizeKey(et)).filter(J => !el.some(et => J.startsWith(et)));
                  ec.push(...ed),
                    el = [J.mountpoint, ...el.filter(et => !et.startsWith(J.mountpoint))]
                }
                return J ? ec.filter(et => et.startsWith(J) && !et.endsWith("$")) : ec.filter(J => !J.endsWith("$"))
              },
              async clear(J, et = {}) {
                J = unstorage_8581f561_normalizeBaseKey(J),
                  await Promise.all(getMounts(J, !1).map(async J => {
                    if (J.driver.clear)
                      return asyncCall(J.driver.clear, J.relativeBase, et);
                    if (J.driver.removeItem) {
                      let eo = await J.driver.getKeys(J.relativeBase || "", et);
                      return Promise.all(eo.map(eo => J.driver.removeItem(eo, et)))
                    }
                  }
                  ))
              },
              async dispose() {
                await Promise.all(Object.values(et.mounts).map(J => dispose(J)))
              },
              watch: async J => (await startWatch(),
                et.watchListeners.push(J),
                async () => {
                  et.watchListeners = et.watchListeners.filter(et => et !== J),
                    0 === et.watchListeners.length && await stopWatch()
                }
              ),
              async unwatch() {
                et.watchListeners = [],
                  await stopWatch()
              },
              mount(J, el) {
                if ((J = unstorage_8581f561_normalizeBaseKey(J)) && et.mounts[J])
                  throw Error(`already mounted at ${J}`);
                return J && (et.mountpoints.push(J),
                  et.mountpoints.sort((J, et) => et.length - J.length)),
                  et.mounts[J] = el,
                  et.watching && Promise.resolve(watch(el, onChange, J)).then(eo => {
                    et.unwatch[J] = eo
                  }
                  ).catch(console.error),
                  eo
              },
              async unmount(J, eo = !0) {
                (J = unstorage_8581f561_normalizeBaseKey(J)) && et.mounts[J] && (et.watching && J in et.unwatch && (et.unwatch[J](),
                  delete et.unwatch[J]),
                  eo && await dispose(et.mounts[J]),
                  et.mountpoints = et.mountpoints.filter(et => et !== J),
                  delete et.mounts[J])
              },
              getMount(J = "") {
                J = normalizeKey(J) + ":";
                let et = getMount(J);
                return {
                  driver: et.driver,
                  base: et.base
                }
              },
              getMounts(J = "", et = {}) {
                J = normalizeKey(J);
                let eo = getMounts(J, et.parents);
                return eo.map(J => ({
                  driver: J.driver,
                  base: J.mountpoint
                }))
              }
            };
          return eo
        }({
          driver: index_es_z({
            dbName: "WALLET_CONNECT_V2_INDEXED_DB",
            storeName: "keyvaluestorage"
          })
        })
      }
      async getKeys() {
        return this.indexedDb.getKeys()
      }
      async getEntries() {
        return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map(J => [J.key, J.value])
      }
      async getItem(J) {
        let et = await this.indexedDb.getItem(J);
        if (null !== et)
          return et
      }
      async setItem(J, et) {
        await this.indexedDb.setItem(J, safeJsonStringify(et))
      }
      async removeItem(J) {
        await this.indexedDb.removeItem(J)
      }
    }
      ;
    var rk = "u" > typeof globalThis ? globalThis : "u" > typeof window ? window : "u" > typeof eo.g ? eo.g : "u" > typeof self ? self : {}
      , rT = {
        exports: {}
      };
    function index_es_k(J) {
      var et;
      return [J[0], esm_safeJsonParse(null != (et = J[1]) ? et : "")]
    }
    !function () {
      function t() { }
      t.prototype.getItem = function (J) {
        return this.hasOwnProperty(J) ? String(this[J]) : null
      }
        ,
        t.prototype.setItem = function (J, et) {
          this[J] = String(et)
        }
        ,
        t.prototype.removeItem = function (J) {
          delete this[J]
        }
        ,
        t.prototype.clear = function () {
          let J = this;
          Object.keys(J).forEach(function (et) {
            J[et] = void 0,
              delete J[et]
          })
        }
        ,
        t.prototype.key = function (J) {
          return J = J || 0,
            Object.keys(this)[J]
        }
        ,
        t.prototype.__defineGetter__("length", function () {
          return Object.keys(this).length
        }),
        "u" > typeof rk && rk.localStorage ? rT.exports = rk.localStorage : "u" > typeof window && window.localStorage ? rT.exports = window.localStorage : rT.exports = new t
    }();
    let index_es_K = class index_es_K {
      constructor() {
        this.localStorage = rT.exports
      }
      async getKeys() {
        return Object.keys(this.localStorage)
      }
      async getEntries() {
        return Object.entries(this.localStorage).map(index_es_k)
      }
      async getItem(J) {
        let et = this.localStorage.getItem(J);
        if (null !== et)
          return esm_safeJsonParse(et)
      }
      async setItem(J, et) {
        this.localStorage.setItem(J, safeJsonStringify(et))
      }
      async removeItem(J) {
        this.localStorage.removeItem(J)
      }
    }
      ;
    let index_es_O = async (J, et, eo) => {
      let el = "wc_storage_version"
        , ec = await et.getItem(el);
      if (ec && ec >= 1) {
        eo(et);
        return
      }
      let ed = await J.getKeys();
      if (!ed.length) {
        eo(et);
        return
      }
      let eh = [];
      for (; ed.length;) {
        let eo = ed.shift();
        if (!eo)
          continue;
        let el = eo.toLowerCase();
        if (el.includes("wc@") || el.includes("walletconnect") || el.includes("wc_") || el.includes("wallet_connect")) {
          let el = await J.getItem(eo);
          await et.setItem(eo, el),
            eh.push(eo)
        }
      }
      await et.setItem(el, 1),
        eo(et),
        j(J, eh)
    }
      , j = async (J, et) => {
        et.length && et.forEach(async et => {
          await J.removeItem(et)
        }
        )
      }
      ;
    let index_es_h = class index_es_h {
      constructor() {
        this.initialized = !1,
          this.setInitialized = J => {
            this.storage = J,
              this.initialized = !0
          }
          ;
        let J = new index_es_K;
        this.storage = J;
        try {
          let et = new index_es_;
          index_es_O(J, et, this.setInitialized)
        } catch {
          this.initialized = !0
        }
      }
      async getKeys() {
        return await this.initialize(),
          this.storage.getKeys()
      }
      async getEntries() {
        return await this.initialize(),
          this.storage.getEntries()
      }
      async getItem(J) {
        return await this.initialize(),
          this.storage.getItem(J)
      }
      async setItem(J, et) {
        return await this.initialize(),
          this.storage.setItem(J, et)
      }
      async removeItem(J) {
        return await this.initialize(),
          this.storage.removeItem(J)
      }
      async initialize() {
        this.initialized || await new Promise(J => {
          let et = setInterval(() => {
            this.initialized && (clearInterval(et),
              J())
          }
            , 20)
        }
        )
      }
    }
      ;
    var rA = eo(90772)
      , rP = eo(9107)
      , rR = eo(38200);
    let n = class n extends rR.q {
      constructor(J) {
        super(),
          this.opts = J,
          this.protocol = "wc",
          this.version = 2
      }
    }
      ;
    let dist_index_es_h = class dist_index_es_h extends rR.q {
      constructor(J, et) {
        super(),
          this.core = J,
          this.logger = et,
          this.records = new Map
      }
    }
      ;
    let a = class a {
      constructor(J, et) {
        this.logger = J,
          this.core = et
      }
    }
      ;
    let u = class u extends rR.q {
      constructor(J, et) {
        super(),
          this.relayer = J,
          this.logger = et
      }
    }
      ;
    let g = class g extends rR.q {
      constructor(J) {
        super()
      }
    }
      ;
    let index_es_p = class index_es_p {
      constructor(J, et, eo, el) {
        this.core = J,
          this.logger = et,
          this.name = eo
      }
    }
      ;
    let d = class d extends rR.q {
      constructor(J, et) {
        super(),
          this.relayer = J,
          this.logger = et
      }
    }
      ;
    let index_es_E = class index_es_E extends rR.q {
      constructor(J, et) {
        super(),
          this.core = J,
          this.logger = et
      }
    }
      ;
    let index_es_y = class index_es_y {
      constructor(J, et) {
        this.projectId = J,
          this.logger = et
      }
    }
      ;
    let v = class v {
      constructor(J, et) {
        this.projectId = J,
          this.logger = et
      }
    }
      ;
    let b = class b {
      constructor(J) {
        this.opts = J,
          this.protocol = "wc",
          this.version = 2
      }
    }
      ;
    let index_es_w = class index_es_w {
      constructor(J) {
        this.client = J
      }
    }
      ;
    var rI = eo(31050);
    let rO = "base64url"
      , rN = "base58btc";
    function encodeJSON(J) {
      return to_string_toString(from_string_fromString(safeJsonStringify(J), "utf8"), rO)
    }
    function encodeIss(J) {
      let et = from_string_fromString("K36", rN)
        , eo = "z" + to_string_toString(concat([et, J]), rN);
      return ["did", "key", eo].join(":")
    }
    function generateKeyPair(J = (0,
      e3.randomBytes)(32)) {
      return rI._w(J)
    }
    async function signJWT(J, et, eo, el, ec = (0,
      t0.fromMiliseconds)(Date.now())) {
      var ed, eh;
      let ep = {
        alg: "EdDSA",
        typ: "JWT"
      }
        , ef = encodeIss(el.publicKey)
        , em = {
          iss: ef,
          sub: J,
          aud: et,
          iat: ec,
          exp: ec + eo
        }
        , eg = from_string_fromString([encodeJSON((ed = {
          header: ep,
          payload: em
        }).header), encodeJSON(ed.payload)].join("."), "utf8")
        , ey = rI.Xx(el.secretKey, eg);
      return [encodeJSON((eh = {
        header: ep,
        payload: em,
        signature: ey
      }).header), encodeJSON(eh.payload), to_string_toString(eh.signature, rO)].join(".")
    }
    eo(43014);
    let rM = "INTERNAL_ERROR"
      , rD = "SERVER_ERROR"
      , rj = [-32700, -32600, -32601, -32602, -32603]
      , rL = {
        PARSE_ERROR: {
          code: -32700,
          message: "Parse error"
        },
        INVALID_REQUEST: {
          code: -32600,
          message: "Invalid Request"
        },
        METHOD_NOT_FOUND: {
          code: -32601,
          message: "Method not found"
        },
        INVALID_PARAMS: {
          code: -32602,
          message: "Invalid params"
        },
        [rM]: {
          code: -32603,
          message: "Internal error"
        },
        [rD]: {
          code: -32e3,
          message: "Server error"
        }
      };
    function getError(J) {
      return Object.keys(rL).includes(J) ? rL[J] : rL[rD]
    }
    function parseConnectionError(J, et, eo) {
      return J.message.includes("getaddrinfo ENOTFOUND") || J.message.includes("connect ECONNREFUSED") ? Error(`Unavailable ${eo} RPC url at ${et}`) : J
    }
    var r$ = eo(1468);
    function payloadId(J = 3) {
      let et = Date.now() * Math.pow(10, J)
        , eo = Math.floor(Math.random() * Math.pow(10, J));
      return et + eo
    }
    function getBigIntRpcId(J = 6) {
      return BigInt(payloadId(J))
    }
    function formatJsonRpcRequest(J, et, eo) {
      return {
        id: eo || payloadId(),
        jsonrpc: "2.0",
        method: J,
        params: et
      }
    }
    function formatJsonRpcResult(J, et) {
      return {
        id: J,
        jsonrpc: "2.0",
        result: et
      }
    }
    function formatJsonRpcError(J, et, eo) {
      var el, ec;
      return {
        id: J,
        jsonrpc: "2.0",
        error: void 0 === (el = et) ? getError(rM) : ("string" == typeof el && (el = Object.assign(Object.assign({}, getError(rD)), {
          message: el
        })),
          void 0 !== eo && (el.data = eo),
          ec = el.code,
          rj.includes(ec) && (el = function (J) {
            let et = Object.values(rL).find(et => et.code === J);
            return et || rL[rD]
          }(el.code)),
          el)
      }
    }
    let misc_IEvents = class misc_IEvents {
    }
      ;
    let IBaseJsonRpcProvider = class IBaseJsonRpcProvider extends misc_IEvents {
      constructor() {
        super()
      }
    }
      ;
    let IJsonRpcProvider = class IJsonRpcProvider extends IBaseJsonRpcProvider {
      constructor(J) {
        super()
      }
    }
      ;
    function matchRegexProtocol(J, et) {
      let eo = function (J) {
        let et = J.match(RegExp(/^\w+:/, "gi"));
        if (et && et.length)
          return et[0]
      }(J);
      return void 0 !== eo && new RegExp(et).test(eo)
    }
    function isHttpUrl(J) {
      return matchRegexProtocol(J, "^https?:")
    }
    function isWsUrl(J) {
      return matchRegexProtocol(J, "^wss?:")
    }
    function isJsonRpcPayload(J) {
      return "object" == typeof J && "id" in J && "jsonrpc" in J && "2.0" === J.jsonrpc
    }
    function isJsonRpcRequest(J) {
      return isJsonRpcPayload(J) && "method" in J
    }
    function isJsonRpcResponse(J) {
      return isJsonRpcPayload(J) && (isJsonRpcResult(J) || isJsonRpcError(J))
    }
    function isJsonRpcResult(J) {
      return "result" in J
    }
    function isJsonRpcError(J) {
      return "error" in J
    }
    let JsonRpcProvider = class JsonRpcProvider extends IJsonRpcProvider {
      constructor(J) {
        super(J),
          this.events = new eX.EventEmitter,
          this.hasRegisteredEventListeners = !1,
          this.connection = this.setConnection(J),
          this.connection.connected && this.registerEventListeners()
      }
      async connect(J = this.connection) {
        await this.open(J)
      }
      async disconnect() {
        await this.close()
      }
      on(J, et) {
        this.events.on(J, et)
      }
      once(J, et) {
        this.events.once(J, et)
      }
      off(J, et) {
        this.events.off(J, et)
      }
      removeListener(J, et) {
        this.events.removeListener(J, et)
      }
      async request(J, et) {
        return this.requestStrict(formatJsonRpcRequest(J.method, J.params || [], J.id || getBigIntRpcId().toString()), et)
      }
      async requestStrict(J, et) {
        return new Promise(async (eo, el) => {
          if (!this.connection.connected)
            try {
              await this.open()
            } catch (J) {
              el(J)
            }
          this.events.on(`${J.id}`, J => {
            isJsonRpcError(J) ? el(J.error) : eo(J.result)
          }
          );
          try {
            await this.connection.send(J, et)
          } catch (J) {
            el(J)
          }
        }
        )
      }
      setConnection(J = this.connection) {
        return J
      }
      onPayload(J) {
        this.events.emit("payload", J),
          isJsonRpcResponse(J) ? this.events.emit(`${J.id}`, J) : this.events.emit("message", {
            type: J.method,
            data: J.params
          })
      }
      onClose(J) {
        J && 3e3 === J.code && this.events.emit("error", Error(`WebSocket connection closed abnormally with code: ${J.code} ${J.reason ? `(${J.reason})` : ""}`)),
          this.events.emit("disconnect")
      }
      async open(J = this.connection) {
        this.connection === J && this.connection.connected || (this.connection.connected && this.close(),
          "string" == typeof J && (await this.connection.open(J),
            J = this.connection),
          this.connection = this.setConnection(J),
          await this.connection.open(),
          this.registerEventListeners(),
          this.events.emit("connect"))
      }
      async close() {
        await this.connection.close()
      }
      registerEventListeners() {
        this.hasRegisteredEventListeners || (this.connection.on("payload", J => this.onPayload(J)),
          this.connection.on("close", J => this.onClose(J)),
          this.connection.on("error", J => this.events.emit("error", J)),
          this.connection.on("register_error", J => this.onClose()),
          this.hasRegisteredEventListeners = !0)
      }
    }
      ;
    let index_es_b = () => "u" > typeof WebSocket || "u" > typeof eo.g && "u" > typeof eo.g.WebSocket || "u" > typeof window && "u" > typeof window.WebSocket || "u" > typeof self && "u" > typeof self.WebSocket
      , index_es_a = J => J.split("?")[0]
      , rB = "u" > typeof WebSocket ? WebSocket : "u" > typeof eo.g && "u" > typeof eo.g.WebSocket ? eo.g.WebSocket : "u" > typeof window && "u" > typeof window.WebSocket ? window.WebSocket : "u" > typeof self && "u" > typeof self.WebSocket ? self.WebSocket : eo(72030);
    let f = class f {
      constructor(J) {
        if (this.url = J,
          this.events = new eX.EventEmitter,
          this.registering = !1,
          !isWsUrl(J))
          throw Error(`Provided URL is not compatible with WebSocket connection: ${J}`);
        this.url = J
      }
      get connected() {
        return "u" > typeof this.socket
      }
      get connecting() {
        return this.registering
      }
      on(J, et) {
        this.events.on(J, et)
      }
      once(J, et) {
        this.events.once(J, et)
      }
      off(J, et) {
        this.events.off(J, et)
      }
      removeListener(J, et) {
        this.events.removeListener(J, et)
      }
      async open(J = this.url) {
        await this.register(J)
      }
      async close() {
        return new Promise((J, et) => {
          if (typeof this.socket > "u") {
            et(Error("Connection already closed"));
            return
          }
          this.socket.onclose = et => {
            this.onClose(et),
              J()
          }
            ,
            this.socket.close()
        }
        )
      }
      async send(J) {
        typeof this.socket > "u" && (this.socket = await this.register());
        try {
          this.socket.send(safeJsonStringify(J))
        } catch (et) {
          this.onError(J.id, et)
        }
      }
      register(J = this.url) {
        if (!isWsUrl(J))
          throw Error(`Provided URL is not compatible with WebSocket connection: ${J}`);
        if (this.registering) {
          let J = this.events.getMaxListeners();
          return (this.events.listenerCount("register_error") >= J || this.events.listenerCount("open") >= J) && this.events.setMaxListeners(J + 1),
            new Promise((J, et) => {
              this.events.once("register_error", J => {
                this.resetMaxListeners(),
                  et(J)
              }
              ),
                this.events.once("open", () => {
                  if (this.resetMaxListeners(),
                    typeof this.socket > "u")
                    return et(Error("WebSocket connection is missing or invalid"));
                  J(this.socket)
                }
                )
            }
            )
        }
        return this.url = J,
          this.registering = !0,
          new Promise((et, eo) => {
            let el = new URLSearchParams(J).get("origin")
              , ec = (0,
                r$.isReactNative)() ? {
                headers: {
                  origin: el
                }
              } : {
                rejectUnauthorized: !RegExp("wss?://localhost(:d{2,5})?").test(J)
              }
              , ed = new rB(J, [], ec);
            index_es_b() ? ed.onerror = J => {
              eo(this.emitError(J.error))
            }
              : ed.on("error", J => {
                eo(this.emitError(J))
              }
              ),
              ed.onopen = () => {
                this.onOpen(ed),
                  et(ed)
              }
          }
          )
      }
      onOpen(J) {
        J.onmessage = J => this.onPayload(J),
          J.onclose = J => this.onClose(J),
          this.socket = J,
          this.registering = !1,
          this.events.emit("open")
      }
      onClose(J) {
        this.socket = void 0,
          this.registering = !1,
          this.events.emit("close", J)
      }
      onPayload(J) {
        if (typeof J.data > "u")
          return;
        let et = "string" == typeof J.data ? esm_safeJsonParse(J.data) : J.data;
        this.events.emit("payload", et)
      }
      onError(J, et) {
        let eo = this.parseError(et)
          , el = eo.message || eo.toString()
          , ec = formatJsonRpcError(J, el);
        this.events.emit("payload", ec)
      }
      parseError(J, et = this.url) {
        return parseConnectionError(J, index_es_a(et), "WS")
      }
      resetMaxListeners() {
        this.events.getMaxListeners() > 10 && this.events.setMaxListeners(10)
      }
      emitError(J) {
        let et = this.parseError(Error(J?.message || `WebSocket connection failed for host: ${index_es_a(this.url)}`));
        return this.events.emit("register_error", et),
          et
      }
    }
      ;
    var rF = eo(72307)
      , rU = eo.n(rF)
      , rz = eo(63144)
      , rH = eo.n(rz)
      , rV = eo(83454)
      , Xi = function (J, et) {
        if (J.length >= 255)
          throw TypeError("Alphabet too long");
        for (var eo = new Uint8Array(256), el = 0; el < eo.length; el++)
          eo[el] = 255;
        for (var ec = 0; ec < J.length; ec++) {
          var ed = J.charAt(ec)
            , eh = ed.charCodeAt(0);
          if (255 !== eo[eh])
            throw TypeError(ed + " is ambiguous");
          eo[eh] = ec
        }
        var ep = J.length
          , ef = J.charAt(0)
          , em = Math.log(ep) / Math.log(256)
          , eg = Math.log(256) / Math.log(ep);
        function y(J) {
          if ("string" != typeof J)
            throw TypeError("Expected String");
          if (0 === J.length)
            return new Uint8Array;
          var et = 0;
          if (" " !== J[0]) {
            for (var el = 0, ec = 0; J[et] === ef;)
              el++,
                et++;
            for (var ed = (J.length - et) * em + 1 >>> 0, eh = new Uint8Array(ed); J[et];) {
              var eg = eo[J.charCodeAt(et)];
              if (255 === eg)
                return;
              for (var ey = 0, eb = ed - 1; (0 !== eg || ey < ec) && -1 !== eb; eb--,
                ey++)
                eg += ep * eh[eb] >>> 0,
                  eh[eb] = eg % 256 >>> 0,
                  eg = eg / 256 >>> 0;
              if (0 !== eg)
                throw Error("Non-zero carry");
              ec = ey,
                et++
            }
            if (" " !== J[et]) {
              for (var ew = ed - ec; ew !== ed && 0 === eh[ew];)
                ew++;
              for (var e_ = new Uint8Array(el + (ed - ew)), ex = el; ew !== ed;)
                e_[ex++] = eh[ew++];
              return e_
            }
          }
        }
        return {
          encode: function (et) {
            if (et instanceof Uint8Array || (ArrayBuffer.isView(et) ? et = new Uint8Array(et.buffer, et.byteOffset, et.byteLength) : Array.isArray(et) && (et = Uint8Array.from(et))),
              !(et instanceof Uint8Array))
              throw TypeError("Expected Uint8Array");
            if (0 === et.length)
              return "";
            for (var eo = 0, el = 0, ec = 0, ed = et.length; ec !== ed && 0 === et[ec];)
              ec++,
                eo++;
            for (var eh = (ed - ec) * eg + 1 >>> 0, em = new Uint8Array(eh); ec !== ed;) {
              for (var ey = et[ec], eb = 0, ew = eh - 1; (0 !== ey || eb < el) && -1 !== ew; ew--,
                eb++)
                ey += 256 * em[ew] >>> 0,
                  em[ew] = ey % ep >>> 0,
                  ey = ey / ep >>> 0;
              if (0 !== ey)
                throw Error("Non-zero carry");
              el = eb,
                ec++
            }
            for (var e_ = eh - el; e_ !== eh && 0 === em[e_];)
              e_++;
            for (var ex = ef.repeat(eo); e_ < eh; ++e_)
              ex += J.charAt(em[e_]);
            return ex
          },
          decodeUnsafe: y,
          decode: function (J) {
            var eo = y(J);
            if (eo)
              return eo;
            throw Error(`Non-${et} character`)
          }
        }
      };
    let index_es_Ne = J => {
      if (J instanceof Uint8Array && "Uint8Array" === J.constructor.name)
        return J;
      if (J instanceof ArrayBuffer)
        return new Uint8Array(J);
      if (ArrayBuffer.isView(J))
        return new Uint8Array(J.buffer, J.byteOffset, J.byteLength);
      throw Error("Unknown type, must be binary type")
    }
      , Wi = J => new TextEncoder().encode(J)
      , Qi = J => new TextDecoder().decode(J);
    let Zi = class Zi {
      constructor(J, et, eo) {
        this.name = J,
          this.prefix = et,
          this.baseEncode = eo
      }
      encode(J) {
        if (J instanceof Uint8Array)
          return `${this.prefix}${this.baseEncode(J)}`;
        throw Error("Unknown type, must be binary type")
      }
    }
      ;
    let es = class es {
      constructor(J, et, eo) {
        if (this.name = J,
          this.prefix = et,
          void 0 === et.codePointAt(0))
          throw Error("Invalid prefix character");
        this.prefixCodePoint = et.codePointAt(0),
          this.baseDecode = eo
      }
      decode(J) {
        if ("string" == typeof J) {
          if (J.codePointAt(0) !== this.prefixCodePoint)
            throw Error(`Unable to decode multibase string ${JSON.stringify(J)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          return this.baseDecode(J.slice(this.prefix.length))
        }
        throw Error("Can only multibase decode strings")
      }
      or(J) {
        return index_es_Ue(this, J)
      }
    }
      ;
    let ts = class ts {
      constructor(J) {
        this.decoders = J
      }
      or(J) {
        return index_es_Ue(this, J)
      }
      decode(J) {
        let et = J[0]
          , eo = this.decoders[et];
        if (eo)
          return eo.decode(J);
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(J)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)
      }
    }
      ;
    let index_es_Ue = (J, et) => new ts({
      ...J.decoders || {
        [J.prefix]: J
      },
      ...et.decoders || {
        [et.prefix]: et
      }
    });
    let is = class is {
      constructor(J, et, eo, el) {
        this.name = J,
          this.prefix = et,
          this.baseEncode = eo,
          this.baseDecode = el,
          this.encoder = new Zi(J, et, eo),
          this.decoder = new es(J, et, el)
      }
      encode(J) {
        return this.encoder.encode(J)
      }
      decode(J) {
        return this.decoder.decode(J)
      }
    }
      ;
    let W = ({ name: J, prefix: et, encode: eo, decode: el }) => new is(J, et, eo, el)
      , index_es_B = ({ prefix: J, name: et, alphabet: eo }) => {
        let { encode: el, decode: ec } = Xi(eo, et);
        return W({
          prefix: J,
          name: et,
          encode: el,
          decode: J => index_es_Ne(ec(J))
        })
      }
      , ss = (J, et, eo, el) => {
        let ec = {};
        for (let J = 0; J < et.length; ++J)
          ec[et[J]] = J;
        let ed = J.length;
        for (; "=" === J[ed - 1];)
          --ed;
        let eh = new Uint8Array(ed * eo / 8 | 0)
          , ep = 0
          , ef = 0
          , em = 0;
        for (let et = 0; et < ed; ++et) {
          let ed = ec[J[et]];
          if (void 0 === ed)
            throw SyntaxError(`Non-${el} character`);
          ef = ef << eo | ed,
            (ep += eo) >= 8 && (ep -= 8,
              eh[em++] = 255 & ef >> ep)
        }
        if (ep >= eo || 255 & ef << 8 - ep)
          throw SyntaxError("Unexpected end of data");
        return eh
      }
      , rs = (J, et, eo) => {
        let el = "=" === et[et.length - 1]
          , ec = (1 << eo) - 1
          , ed = ""
          , eh = 0
          , ep = 0;
        for (let el = 0; el < J.length; ++el)
          for (ep = ep << 8 | J[el],
            eh += 8; eh > eo;)
            eh -= eo,
              ed += et[ec & ep >> eh];
        if (eh && (ed += et[ec & ep << eo - eh]),
          el)
          for (; ed.length * eo & 7;)
            ed += "=";
        return ed
      }
      , index_es_g = ({ name: J, prefix: et, bitsPerChar: eo, alphabet: el }) => W({
        prefix: et,
        name: J,
        encode: J => rs(J, el, eo),
        decode: et => ss(et, el, eo, J)
      })
      , rW = W({
        prefix: "\x00",
        name: "identity",
        encode: J => Qi(J),
        decode: J => Wi(J)
      });
    var rq = Object.freeze({
      __proto__: null,
      identity: rW
    });
    let rZ = index_es_g({
      prefix: "0",
      name: "base2",
      alphabet: "01",
      bitsPerChar: 1
    });
    var rG = Object.freeze({
      __proto__: null,
      base2: rZ
    });
    let rY = index_es_g({
      prefix: "7",
      name: "base8",
      alphabet: "01234567",
      bitsPerChar: 3
    });
    var rK = Object.freeze({
      __proto__: null,
      base8: rY
    });
    let rJ = index_es_B({
      prefix: "9",
      name: "base10",
      alphabet: "0123456789"
    });
    var rQ = Object.freeze({
      __proto__: null,
      base10: rJ
    });
    let rX = index_es_g({
      prefix: "f",
      name: "base16",
      alphabet: "0123456789abcdef",
      bitsPerChar: 4
    })
      , r0 = index_es_g({
        prefix: "F",
        name: "base16upper",
        alphabet: "0123456789ABCDEF",
        bitsPerChar: 4
      });
    var r1 = Object.freeze({
      __proto__: null,
      base16: rX,
      base16upper: r0
    });
    let r2 = index_es_g({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    })
      , r3 = index_es_g({
        prefix: "B",
        name: "base32upper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
        bitsPerChar: 5
      })
      , r5 = index_es_g({
        prefix: "c",
        name: "base32pad",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
        bitsPerChar: 5
      })
      , r6 = index_es_g({
        prefix: "C",
        name: "base32padupper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
        bitsPerChar: 5
      })
      , r4 = index_es_g({
        prefix: "v",
        name: "base32hex",
        alphabet: "0123456789abcdefghijklmnopqrstuv",
        bitsPerChar: 5
      })
      , r8 = index_es_g({
        prefix: "V",
        name: "base32hexupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
        bitsPerChar: 5
      })
      , r7 = index_es_g({
        prefix: "t",
        name: "base32hexpad",
        alphabet: "0123456789abcdefghijklmnopqrstuv=",
        bitsPerChar: 5
      })
      , r9 = index_es_g({
        prefix: "T",
        name: "base32hexpadupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
        bitsPerChar: 5
      })
      , nn = index_es_g({
        prefix: "h",
        name: "base32z",
        alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
        bitsPerChar: 5
      });
    var ns = Object.freeze({
      __proto__: null,
      base32: r2,
      base32upper: r3,
      base32pad: r5,
      base32padupper: r6,
      base32hex: r4,
      base32hexupper: r8,
      base32hexpad: r7,
      base32hexpadupper: r9,
      base32z: nn
    });
    let no = index_es_B({
      prefix: "k",
      name: "base36",
      alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    })
      , nl = index_es_B({
        prefix: "K",
        name: "base36upper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      });
    var nc = Object.freeze({
      __proto__: null,
      base36: no,
      base36upper: nl
    });
    let nd = index_es_B({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    })
      , nh = index_es_B({
        name: "base58flickr",
        prefix: "Z",
        alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
      });
    var np = Object.freeze({
      __proto__: null,
      base58btc: nd,
      base58flickr: nh
    });
    let nf = index_es_g({
      prefix: "m",
      name: "base64",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      bitsPerChar: 6
    })
      , nm = index_es_g({
        prefix: "M",
        name: "base64pad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        bitsPerChar: 6
      })
      , ng = index_es_g({
        prefix: "u",
        name: "base64url",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
        bitsPerChar: 6
      })
      , ny = index_es_g({
        prefix: "U",
        name: "base64urlpad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
        bitsPerChar: 6
      });
    var nb = Object.freeze({
      __proto__: null,
      base64: nf,
      base64pad: nm,
      base64url: ng,
      base64urlpad: ny
    });
    let nw = Array.from("\uD83D\uDE80\uD83E\uDE90☄\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09☀\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02❤\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09☺\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E✌✨\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D❣\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33✋\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13⭐✅\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6✔\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90☹\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20☝\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B⚽\uD83E\uDD19☕\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81⚡\uD83C\uDF1E\uD83C\uDF88❌✊\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C✈\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74▶➡❓\uD83D\uDC8E\uD83D\uDCB8⬇\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A⚠\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37☎\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51❄\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42")
      , n_ = nw.reduce((J, et, eo) => (J[eo] = et,
        J), [])
      , nx = nw.reduce((J, et, eo) => (J[et.codePointAt(0)] = eo,
        J), [])
      , nE = W({
        prefix: "\uD83D\uDE80",
        name: "base256emoji",
        encode: function (J) {
          return J.reduce((J, et) => J += n_[et], "")
        },
        decode: function (J) {
          let et = [];
          for (let eo of J) {
            let J = nx[eo.codePointAt(0)];
            if (void 0 === J)
              throw Error(`Non-base256emoji character: ${eo}`);
            et.push(J)
          }
          return new Uint8Array(et)
        }
      });
    var nC = Object.freeze({
      __proto__: null,
      base256emoji: nE
    });
    function index_es_$e(J, et, eo) {
      et = et || [],
        eo = eo || 0;
      for (var el = eo; J >= 2147483648;)
        et[eo++] = 255 & J | 128,
          J /= 128;
      for (; -128 & J;)
        et[eo++] = 255 & J | 128,
          J >>>= 7;
      return et[eo] = 0 | J,
        index_es_$e.bytes = eo - el + 1,
        et
    }
    function he(J, et) {
      var eo, el = 0, et = et || 0, ec = 0, ed = et, eh = J.length;
      do {
        if (ed >= eh)
          throw he.bytes = 0,
          RangeError("Could not decode varint");
        eo = J[ed++],
          el += ec < 28 ? (127 & eo) << ec : (127 & eo) * Math.pow(2, ec),
          ec += 7
      } while (eo >= 128);
      return he.bytes = ed - et,
        el
    }
    var nS = {
      encode: index_es_$e,
      decode: he,
      encodingLength: function (J) {
        return J < 128 ? 1 : J < 16384 ? 2 : J < 2097152 ? 3 : J < 268435456 ? 4 : J < 34359738368 ? 5 : J < 4398046511104 ? 6 : J < 562949953421312 ? 7 : J < 72057594037927940 ? 8 : J < 0x7fffffffffffffff ? 9 : 10
      }
    };
    let index_es_Ke = (J, et, eo = 0) => (nS.encode(J, et, eo),
      et)
      , index_es_Be = J => nS.encodingLength(J)
      , index_es_ce = (J, et) => {
        let eo = et.byteLength
          , el = index_es_Be(J)
          , ec = el + index_es_Be(eo)
          , ed = new Uint8Array(ec + eo);
        return index_es_Ke(J, ed, 0),
          index_es_Ke(eo, ed, el),
          ed.set(et, ec),
          new index_es_or(J, eo, et, ed)
      }
      ;
    let index_es_or = class index_es_or {
      constructor(J, et, eo, el) {
        this.code = J,
          this.size = et,
          this.digest = eo,
          this.bytes = el
      }
    }
      ;
    let index_es_Ve = ({ name: J, code: et, encode: eo }) => new ar(J, et, eo);
    let ar = class ar {
      constructor(J, et, eo) {
        this.name = J,
          this.code = et,
          this.encode = eo
      }
      digest(J) {
        if (J instanceof Uint8Array) {
          let et = this.encode(J);
          return et instanceof Uint8Array ? index_es_ce(this.code, et) : et.then(J => index_es_ce(this.code, J))
        }
        throw Error("Unknown type, must be binary type")
      }
    }
      ;
    let index_es_je = J => async et => new Uint8Array(await crypto.subtle.digest(J, et))
      , nk = index_es_Ve({
        name: "sha2-256",
        code: 18,
        encode: index_es_je("SHA-256")
      })
      , nT = index_es_Ve({
        name: "sha2-512",
        code: 19,
        encode: index_es_je("SHA-512")
      });
    var nA = Object.freeze({
      __proto__: null,
      sha256: nk,
      sha512: nT
    })
      , nP = Object.freeze({
        __proto__: null,
        identity: {
          code: 0,
          name: "identity",
          encode: index_es_Ne,
          digest: J => index_es_ce(0, index_es_Ne(J))
        }
      });
    new TextEncoder,
      new TextDecoder;
    let nR = {
      ...rq,
      ...rG,
      ...rK,
      ...rQ,
      ...r1,
      ...ns,
      ...nc,
      ...np,
      ...nb,
      ...nC
    };
    function index_es_He(J) {
      return null != globalThis.Buffer ? new Uint8Array(J.buffer, J.byteOffset, J.byteLength) : J
    }
    function index_es_Je(J, et, eo, el) {
      return {
        name: J,
        prefix: et,
        encoder: {
          name: J,
          prefix: et,
          encode: eo
        },
        decoder: {
          decode: el
        }
      }
    }
    ({
      ...nA,
      ...nP
    });
    let nI = index_es_Je("utf8", "u", J => "u" + new TextDecoder("utf8").decode(J), J => new TextEncoder().encode(J.substring(1)))
      , nO = index_es_Je("ascii", "a", J => {
        let et = "a";
        for (let eo = 0; eo < J.length; eo++)
          et += String.fromCharCode(J[eo]);
        return et
      }
        , J => {
          J = J.substring(1);
          let et = function (J = 0) {
            return null != globalThis.Buffer && null != globalThis.Buffer.allocUnsafe ? index_es_He(globalThis.Buffer.allocUnsafe(J)) : new Uint8Array(J)
          }(J.length);
          for (let eo = 0; eo < J.length; eo++)
            et[eo] = J.charCodeAt(eo);
          return et
        }
      )
      , nN = {
        utf8: nI,
        "utf-8": nI,
        hex: nR.base16,
        latin1: nO,
        ascii: nO,
        binary: nO,
        ...nR
      }
      , nM = "core"
      , nD = `wc@2:${nM}:`
      , nj = {
        logger: "error"
      }
      , nL = {
        database: ":memory:"
      }
      , n$ = "client_ed25519_seed"
      , nB = t0.ONE_DAY
      , nF = t0.SIX_HOURS
      , nU = "wss://relay.walletconnect.com"
      , nz = "wss://relay.walletconnect.org"
      , nH = {
        message: "relayer_message",
        message_ack: "relayer_message_ack",
        connect: "relayer_connect",
        disconnect: "relayer_disconnect",
        error: "relayer_error",
        connection_stalled: "relayer_connection_stalled",
        publish: "relayer_publish"
      }
      , nV = {
        payload: "payload",
        connect: "connect",
        disconnect: "disconnect",
        error: "error"
      }
      , nW = t0.ONE_SECOND
      , nq = {
        created: "subscription_created",
        deleted: "subscription_deleted",
        sync: "subscription_sync",
        resubscribed: "subscription_resubscribed"
      }
      , nZ = 1e3 * t0.FIVE_SECONDS
      , nG = {
        wc_pairingDelete: {
          req: {
            ttl: t0.ONE_DAY,
            prompt: !1,
            tag: 1e3
          },
          res: {
            ttl: t0.ONE_DAY,
            prompt: !1,
            tag: 1001
          }
        },
        wc_pairingPing: {
          req: {
            ttl: t0.THIRTY_SECONDS,
            prompt: !1,
            tag: 1002
          },
          res: {
            ttl: t0.THIRTY_SECONDS,
            prompt: !1,
            tag: 1003
          }
        },
        unregistered_method: {
          req: {
            ttl: t0.ONE_DAY,
            prompt: !1,
            tag: 0
          },
          res: {
            ttl: t0.ONE_DAY,
            prompt: !1,
            tag: 0
          }
        }
      }
      , nY = {
        create: "pairing_create",
        expire: "pairing_expire",
        delete: "pairing_delete",
        ping: "pairing_ping"
      }
      , nK = {
        created: "history_created",
        updated: "history_updated",
        deleted: "history_deleted",
        sync: "history_sync"
      }
      , nJ = {
        created: "expirer_created",
        deleted: "expirer_deleted",
        expired: "expirer_expired",
        sync: "expirer_sync"
      }
      , nQ = "verify-api"
      , nX = "https://verify.walletconnect.com"
      , n0 = "https://verify.walletconnect.org"
      , n1 = [nX, n0];
    let index_es_Pt = class index_es_Pt {
      constructor(J, et) {
        this.core = J,
          this.logger = et,
          this.keychain = new Map,
          this.name = "keychain",
          this.version = "0.3",
          this.initialized = !1,
          this.storagePrefix = nD,
          this.init = async () => {
            if (!this.initialized) {
              let J = await this.getKeyChain();
              "u" > typeof J && (this.keychain = J),
                this.initialized = !0
            }
          }
          ,
          this.has = J => (this.isInitialized(),
            this.keychain.has(J)),
          this.set = async (J, et) => {
            this.isInitialized(),
              this.keychain.set(J, et),
              await this.persist()
          }
          ,
          this.get = J => {
            this.isInitialized();
            let et = this.keychain.get(J);
            if (typeof et > "u") {
              let { message: et } = N("NO_MATCHING_KEY", `${this.name}: ${J}`);
              throw Error(et)
            }
            return et
          }
          ,
          this.del = async J => {
            this.isInitialized(),
              this.keychain.delete(J),
              await this.persist()
          }
          ,
          this.core = J,
          this.logger = (0,
            rP.generateChildLogger)(et, this.name)
      }
      get context() {
        return (0,
          rP.getLoggerContext)(this.logger)
      }
      get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
      }
      async setKeyChain(J) {
        await this.core.storage.setItem(this.storageKey, rt(J))
      }
      async getKeyChain() {
        let J = await this.core.storage.getItem(this.storageKey);
        return "u" > typeof J ? ot(J) : void 0
      }
      async persist() {
        await this.setKeyChain(this.keychain)
      }
      isInitialized() {
        if (!this.initialized) {
          let { message: J } = N("NOT_INITIALIZED", this.name);
          throw Error(J)
        }
      }
    }
      ;
    let index_es_xt = class index_es_xt {
      constructor(J, et, eo) {
        this.core = J,
          this.logger = et,
          this.name = "crypto",
          this.initialized = !1,
          this.init = async () => {
            this.initialized || (await this.keychain.init(),
              this.initialized = !0)
          }
          ,
          this.hasKeys = J => (this.isInitialized(),
            this.keychain.has(J)),
          this.getClientId = async () => {
            this.isInitialized();
            let J = await this.getClientSeed()
              , et = generateKeyPair(J);
            return encodeIss(et.publicKey)
          }
          ,
          this.generateKeyPair = () => {
            this.isInitialized();
            let J = function () {
              let J = e6.Au();
              return {
                privateKey: to_string_toString(J.secretKey, t8),
                publicKey: to_string_toString(J.publicKey, t8)
              }
            }();
            return this.setPrivateKey(J.publicKey, J.privateKey)
          }
          ,
          this.signJWT = async J => {
            this.isInitialized();
            let et = await this.getClientSeed()
              , eo = generateKeyPair(et)
              , el = Vn();
            return await signJWT(el, J, nB, eo)
          }
          ,
          this.generateSharedKey = (J, et, eo) => {
            this.isInitialized();
            let el = this.getPrivateKey(J)
              , ec = function (J, et) {
                let eo = e6.gi(from_string_fromString(J, t8), from_string_fromString(et, t8), !0)
                  , el = new e2.t(e5.mE, eo).expand(32);
                return to_string_toString(el, t8)
              }(el, et);
            return this.setSymKey(ec, eo)
          }
          ,
          this.setSymKey = async (J, et) => {
            this.isInitialized();
            let eo = et || function (J) {
              let et = (0,
                e5.vp)(from_string_fromString(J, t8));
              return to_string_toString(et, t8)
            }(J);
            return await this.keychain.set(eo, J),
              eo
          }
          ,
          this.deleteKeyPair = async J => {
            this.isInitialized(),
              await this.keychain.del(J)
          }
          ,
          this.deleteSymKey = async J => {
            this.isInitialized(),
              await this.keychain.del(J)
          }
          ,
          this.encode = async (J, et, eo) => {
            this.isInitialized();
            let el = Ae(eo)
              , ec = safeJsonStringify(et);
            if (qn(el)) {
              let et = el.senderPublicKey
                , eo = el.receiverPublicKey;
              J = await this.generateSharedKey(et, eo)
            }
            let ed = this.getSymKey(J)
              , { type: eh, senderPublicKey: ep } = el;
            return function (J) {
              var et;
              let eo = (et = "u" > typeof J.type ? J.type : 0,
                from_string_fromString(`${et}`, t4));
              if (1 === $(eo) && typeof J.senderPublicKey > "u")
                throw Error("Missing sender public key for type 1 envelope");
              let el = "u" > typeof J.senderPublicKey ? from_string_fromString(J.senderPublicKey, t8) : void 0
                , ec = "u" > typeof J.iv ? from_string_fromString(J.iv, t8) : (0,
                  e3.randomBytes)(12)
                , ed = new e1.OK(from_string_fromString(J.symKey, t8)).seal(ec, from_string_fromString(J.message, t9));
              return function (J) {
                if (1 === $(J.type)) {
                  if (typeof J.senderPublicKey > "u")
                    throw Error("Missing sender public key for type 1 envelope");
                  return to_string_toString(concat([J.type, J.senderPublicKey, J.iv, J.sealed]), t7)
                }
                return to_string_toString(concat([J.type, J.iv, J.sealed]), t7)
              }({
                type: eo,
                sealed: ed,
                iv: ec,
                senderPublicKey: el
              })
            }({
              type: eh,
              symKey: ed,
              message: ec,
              senderPublicKey: ep
            })
          }
          ,
          this.decode = async (J, et, eo) => {
            this.isInitialized();
            let el = function (J, et) {
              let eo = ee(J);
              return Ae({
                type: $(eo.type),
                senderPublicKey: "u" > typeof eo.senderPublicKey ? to_string_toString(eo.senderPublicKey, t8) : void 0,
                receiverPublicKey: et?.receiverPublicKey
              })
            }(et, eo);
            if (qn(el)) {
              let et = el.receiverPublicKey
                , eo = el.senderPublicKey;
              J = await this.generateSharedKey(et, eo)
            }
            try {
              let eo = this.getSymKey(J)
                , el = function (J) {
                  let et = new e1.OK(from_string_fromString(J.symKey, t8))
                    , { sealed: eo, iv: el } = ee(J.encoded)
                    , ec = et.open(el, eo);
                  if (null === ec)
                    throw Error("Failed to decrypt");
                  return to_string_toString(ec, t9)
                }({
                  symKey: eo,
                  encoded: et
                });
              return esm_safeJsonParse(el)
            } catch (et) {
              this.logger.error(`Failed to decode message from topic: '${J}', clientId: '${await this.getClientId()}'`),
                this.logger.error(et)
            }
          }
          ,
          this.getPayloadType = J => {
            let et = ee(J);
            return $(et.type)
          }
          ,
          this.getPayloadSenderPublicKey = J => {
            let et = ee(J);
            return et.senderPublicKey ? to_string_toString(et.senderPublicKey, t8) : void 0
          }
          ,
          this.core = J,
          this.logger = (0,
            rP.generateChildLogger)(et, this.name),
          this.keychain = eo || new index_es_Pt(this.core, this.logger)
      }
      get context() {
        return (0,
          rP.getLoggerContext)(this.logger)
      }
      async setPrivateKey(J, et) {
        return await this.keychain.set(J, et),
          J
      }
      getPrivateKey(J) {
        return this.keychain.get(J)
      }
      async getClientSeed() {
        let J = "";
        try {
          J = this.keychain.get(n$)
        } catch {
          J = Vn(),
            await this.keychain.set(n$, J)
        }
        return function (J, et = "utf8") {
          let eo = nN[et];
          if (!eo)
            throw Error(`Unsupported encoding "${et}"`);
          return ("utf8" === et || "utf-8" === et) && null != globalThis.Buffer && null != globalThis.Buffer.from ? index_es_He(globalThis.Buffer.from(J, "utf-8")) : eo.decoder.decode(`${eo.prefix}${J}`)
        }(J, "base16")
      }
      getSymKey(J) {
        return this.keychain.get(J)
      }
      isInitialized() {
        if (!this.initialized) {
          let { message: J } = N("NOT_INITIALIZED", this.name);
          throw Error(J)
        }
      }
    }
      ;
    let index_es_Ot = class index_es_Ot extends a {
      constructor(J, et) {
        super(J, et),
          this.logger = J,
          this.core = et,
          this.messages = new Map,
          this.name = "messages",
          this.version = "0.3",
          this.initialized = !1,
          this.storagePrefix = nD,
          this.init = async () => {
            if (!this.initialized) {
              this.logger.trace("Initialized");
              try {
                let J = await this.getRelayerMessages();
                "u" > typeof J && (this.messages = J),
                  this.logger.debug(`Successfully Restored records for ${this.name}`),
                  this.logger.trace({
                    type: "method",
                    method: "restore",
                    size: this.messages.size
                  })
              } catch (J) {
                this.logger.debug(`Failed to Restore records for ${this.name}`),
                  this.logger.error(J)
              } finally {
                this.initialized = !0
              }
            }
          }
          ,
          this.set = async (J, et) => {
            this.isInitialized();
            let eo = Ln(et)
              , el = this.messages.get(J);
            return typeof el > "u" && (el = {}),
              "u" > typeof el[eo] || (el[eo] = et,
                this.messages.set(J, el),
                await this.persist()),
              eo
          }
          ,
          this.get = J => {
            this.isInitialized();
            let et = this.messages.get(J);
            return typeof et > "u" && (et = {}),
              et
          }
          ,
          this.has = (J, et) => {
            this.isInitialized();
            let eo = this.get(J)
              , el = Ln(et);
            return "u" > typeof eo[el]
          }
          ,
          this.del = async J => {
            this.isInitialized(),
              this.messages.delete(J),
              await this.persist()
          }
          ,
          this.logger = (0,
            rP.generateChildLogger)(J, this.name),
          this.core = et
      }
      get context() {
        return (0,
          rP.getLoggerContext)(this.logger)
      }
      get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
      }
      async setRelayerMessages(J) {
        await this.core.storage.setItem(this.storageKey, rt(J))
      }
      async getRelayerMessages() {
        let J = await this.core.storage.getItem(this.storageKey);
        return "u" > typeof J ? ot(J) : void 0
      }
      async persist() {
        await this.setRelayerMessages(this.messages)
      }
      isInitialized() {
        if (!this.initialized) {
          let { message: J } = N("NOT_INITIALIZED", this.name);
          throw Error(J)
        }
      }
    }
      ;
    let vr = class vr extends u {
      constructor(J, et) {
        super(J, et),
          this.relayer = J,
          this.logger = et,
          this.events = new eX.EventEmitter,
          this.name = "publisher",
          this.queue = new Map,
          this.publishTimeout = (0,
            t0.toMiliseconds)(t0.TEN_SECONDS),
          this.needsTransportRestart = !1,
          this.publish = async (J, et, eo) => {
            var el;
            this.logger.debug("Publishing Payload"),
              this.logger.trace({
                type: "method",
                method: "publish",
                params: {
                  topic: J,
                  message: et,
                  opts: eo
                }
              });
            try {
              let ec = eo?.ttl || nF
                , ed = vt(eo)
                , eh = eo?.prompt || !1
                , ep = eo?.tag || 0
                , ef = eo?.id || getBigIntRpcId().toString()
                , em = {
                  topic: J,
                  message: et,
                  opts: {
                    ttl: ec,
                    relay: ed,
                    prompt: eh,
                    tag: ep,
                    id: ef
                  }
                }
                , eg = setTimeout(() => this.queue.set(ef, em), this.publishTimeout);
              try {
                await await ut(this.rpcPublish(J, et, ec, ed, eh, ep, ef), this.publishTimeout, "Failed to publish payload, please try again."),
                  this.removeRequestFromQueue(ef),
                  this.relayer.events.emit(nH.publish, em)
              } catch (J) {
                if (this.logger.debug("Publishing Payload stalled"),
                  this.needsTransportRestart = !0,
                  null != (el = eo?.internal) && el.throwOnFailedPublish)
                  throw this.removeRequestFromQueue(ef),
                  J;
                return
              } finally {
                clearTimeout(eg)
              }
              this.logger.debug("Successfully Published Payload"),
                this.logger.trace({
                  type: "method",
                  method: "publish",
                  params: {
                    topic: J,
                    message: et,
                    opts: eo
                  }
                })
            } catch (J) {
              throw this.logger.debug("Failed to Publish Payload"),
              this.logger.error(J),
              J
            }
          }
          ,
          this.on = (J, et) => {
            this.events.on(J, et)
          }
          ,
          this.once = (J, et) => {
            this.events.once(J, et)
          }
          ,
          this.off = (J, et) => {
            this.events.off(J, et)
          }
          ,
          this.removeListener = (J, et) => {
            this.events.removeListener(J, et)
          }
          ,
          this.relayer = J,
          this.logger = (0,
            rP.generateChildLogger)(et, this.name),
          this.registerEventListeners()
      }
      get context() {
        return (0,
          rP.getLoggerContext)(this.logger)
      }
      rpcPublish(J, et, eo, el, ec, ed, eh) {
        var ep, ef, em, eg;
        let ey = {
          method: Et(el.protocol).publish,
          params: {
            topic: J,
            message: et,
            ttl: eo,
            prompt: ec,
            tag: ed
          },
          id: eh
        };
        return w(null == (ep = ey.params) ? void 0 : ep.prompt) && (null == (ef = ey.params) || delete ef.prompt),
          w(null == (em = ey.params) ? void 0 : em.tag) && (null == (eg = ey.params) || delete eg.tag),
          this.logger.debug("Outgoing Relay Payload"),
          this.logger.trace({
            type: "message",
            direction: "outgoing",
            request: ey
          }),
          this.relayer.request(ey)
      }
      removeRequestFromQueue(J) {
        this.queue.delete(J)
      }
      checkQueue() {
        this.queue.forEach(async J => {
          let { topic: et, message: eo, opts: el } = J;
          await this.publish(et, eo, el)
        }
        )
      }
      registerEventListeners() {
        this.relayer.core.heartbeat.on(rA.HEARTBEAT_EVENTS.pulse, () => {
          if (this.needsTransportRestart) {
            this.needsTransportRestart = !1,
              this.relayer.events.emit(nH.connection_stalled);
            return
          }
          this.checkQueue()
        }
        ),
          this.relayer.on(nH.message_ack, J => {
            this.removeRequestFromQueue(J.id.toString())
          }
          )
      }
    }
      ;
    let Ir = class Ir {
      constructor() {
        this.map = new Map,
          this.set = (J, et) => {
            let eo = this.get(J);
            this.exists(J, et) || this.map.set(J, [...eo, et])
          }
          ,
          this.get = J => this.map.get(J) || [],
          this.exists = (J, et) => this.get(J).includes(et),
          this.delete = (J, et) => {
            if (typeof et > "u") {
              this.map.delete(J);
              return
            }
            if (!this.map.has(J))
              return;
            let eo = this.get(J);
            if (!this.exists(J, et))
              return;
            let el = eo.filter(J => J !== et);
            if (!el.length) {
              this.map.delete(J);
              return
            }
            this.map.set(J, el)
          }
          ,
          this.clear = () => {
            this.map.clear()
          }
      }
      get topics() {
        return Array.from(this.map.keys())
      }
    }
      ;
    var n2 = Object.defineProperty
      , n3 = Object.defineProperties
      , n5 = Object.getOwnPropertyDescriptors
      , n6 = Object.getOwnPropertySymbols
      , n4 = Object.prototype.hasOwnProperty
      , n8 = Object.prototype.propertyIsEnumerable
      , index_es_zt = (J, et, eo) => et in J ? n2(J, et, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: eo
      }) : J[et] = eo
      , index_es_j = (J, et) => {
        for (var eo in et || (et = {}))
          n4.call(et, eo) && index_es_zt(J, eo, et[eo]);
        if (n6)
          for (var eo of n6(et))
            n8.call(et, eo) && index_es_zt(J, eo, et[eo]);
        return J
      }
      , index_es_De = (J, et) => n3(J, n5(et));
    let index_es_Nt = class index_es_Nt extends d {
      constructor(J, et) {
        super(J, et),
          this.relayer = J,
          this.logger = et,
          this.subscriptions = new Map,
          this.topicMap = new Ir,
          this.events = new eX.EventEmitter,
          this.name = "subscription",
          this.version = "0.3",
          this.pending = new Map,
          this.cached = [],
          this.initialized = !1,
          this.pendingSubscriptionWatchLabel = "pending_sub_watch_label",
          this.pollingInterval = 20,
          this.storagePrefix = nD,
          this.subscribeTimeout = 1e4,
          this.restartInProgress = !1,
          this.batchSubscribeTopicsLimit = 500,
          this.init = async () => {
            this.initialized || (this.logger.trace("Initialized"),
              this.registerEventListeners(),
              this.clientId = await this.relayer.core.crypto.getClientId())
          }
          ,
          this.subscribe = async (J, et) => {
            await this.restartToComplete(),
              this.isInitialized(),
              this.logger.debug("Subscribing Topic"),
              this.logger.trace({
                type: "method",
                method: "subscribe",
                params: {
                  topic: J,
                  opts: et
                }
              });
            try {
              let eo = vt(et)
                , el = {
                  topic: J,
                  relay: eo
                };
              this.pending.set(J, el);
              let ec = await this.rpcSubscribe(J, eo);
              return this.onSubscribe(ec, el),
                this.logger.debug("Successfully Subscribed Topic"),
                this.logger.trace({
                  type: "method",
                  method: "subscribe",
                  params: {
                    topic: J,
                    opts: et
                  }
                }),
                ec
            } catch (J) {
              throw this.logger.debug("Failed to Subscribe Topic"),
              this.logger.error(J),
              J
            }
          }
          ,
          this.unsubscribe = async (J, et) => {
            await this.restartToComplete(),
              this.isInitialized(),
              "u" > typeof et?.id ? await this.unsubscribeById(J, et.id, et) : await this.unsubscribeByTopic(J, et)
          }
          ,
          this.isSubscribed = async J => !!this.topics.includes(J) || await new Promise((et, eo) => {
            let el = new t0.Watch;
            el.start(this.pendingSubscriptionWatchLabel);
            let ec = setInterval(() => {
              !this.pending.has(J) && this.topics.includes(J) && (clearInterval(ec),
                el.stop(this.pendingSubscriptionWatchLabel),
                et(!0)),
                el.elapsed(this.pendingSubscriptionWatchLabel) >= nZ && (clearInterval(ec),
                  el.stop(this.pendingSubscriptionWatchLabel),
                  eo(Error("Subscription resolution timeout")))
            }
              , this.pollingInterval)
          }
          ).catch(() => !1),
          this.on = (J, et) => {
            this.events.on(J, et)
          }
          ,
          this.once = (J, et) => {
            this.events.once(J, et)
          }
          ,
          this.off = (J, et) => {
            this.events.off(J, et)
          }
          ,
          this.removeListener = (J, et) => {
            this.events.removeListener(J, et)
          }
          ,
          this.restart = async () => {
            this.restartInProgress = !0,
              await this.restore(),
              await this.reset(),
              this.restartInProgress = !1
          }
          ,
          this.relayer = J,
          this.logger = (0,
            rP.generateChildLogger)(et, this.name),
          this.clientId = ""
      }
      get context() {
        return (0,
          rP.getLoggerContext)(this.logger)
      }
      get storageKey() {
        return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name
      }
      get length() {
        return this.subscriptions.size
      }
      get ids() {
        return Array.from(this.subscriptions.keys())
      }
      get values() {
        return Array.from(this.subscriptions.values())
      }
      get topics() {
        return this.topicMap.topics
      }
      hasSubscription(J, et) {
        let eo = !1;
        try {
          eo = this.getSubscription(J).topic === et
        } catch { }
        return eo
      }
      onEnable() {
        this.cached = [],
          this.initialized = !0
      }
      onDisable() {
        this.cached = this.values,
          this.subscriptions.clear(),
          this.topicMap.clear()
      }
      async unsubscribeByTopic(J, et) {
        let eo = this.topicMap.get(J);
        await Promise.all(eo.map(async eo => await this.unsubscribeById(J, eo, et)))
      }
      async unsubscribeById(J, et, eo) {
        this.logger.debug("Unsubscribing Topic"),
          this.logger.trace({
            type: "method",
            method: "unsubscribe",
            params: {
              topic: J,
              id: et,
              opts: eo
            }
          });
        try {
          let el = vt(eo);
          await this.rpcUnsubscribe(J, et, el);
          let ec = index_es_U("USER_DISCONNECTED", `${this.name}, ${J}`);
          await this.onUnsubscribe(J, et, ec),
            this.logger.debug("Successfully Unsubscribed Topic"),
            this.logger.trace({
              type: "method",
              method: "unsubscribe",
              params: {
                topic: J,
                id: et,
                opts: eo
              }
            })
        } catch (J) {
          throw this.logger.debug("Failed to Unsubscribe Topic"),
          this.logger.error(J),
          J
        }
      }
      async rpcSubscribe(J, et) {
        let eo = {
          method: Et(et.protocol).subscribe,
          params: {
            topic: J
          }
        };
        this.logger.debug("Outgoing Relay Payload"),
          this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: eo
          });
        try {
          await await ut(this.relayer.request(eo), this.subscribeTimeout)
        } catch {
          this.logger.debug("Outgoing Relay Subscribe Payload stalled"),
            this.relayer.events.emit(nH.connection_stalled)
        }
        return Ln(J + this.clientId)
      }
      async rpcBatchSubscribe(J) {
        if (!J.length)
          return;
        let et = J[0].relay
          , eo = {
            method: Et(et.protocol).batchSubscribe,
            params: {
              topics: J.map(J => J.topic)
            }
          };
        this.logger.debug("Outgoing Relay Payload"),
          this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: eo
          });
        try {
          return await await ut(this.relayer.request(eo), this.subscribeTimeout)
        } catch {
          this.logger.debug("Outgoing Relay Payload stalled"),
            this.relayer.events.emit(nH.connection_stalled)
        }
      }
      rpcUnsubscribe(J, et, eo) {
        let el = {
          method: Et(eo.protocol).unsubscribe,
          params: {
            topic: J,
            id: et
          }
        };
        return this.logger.debug("Outgoing Relay Payload"),
          this.logger.trace({
            type: "payload",
            direction: "outgoing",
            request: el
          }),
          this.relayer.request(el)
      }
      onSubscribe(J, et) {
        this.setSubscription(J, index_es_De(index_es_j({}, et), {
          id: J
        })),
          this.pending.delete(et.topic)
      }
      onBatchSubscribe(J) {
        J.length && J.forEach(J => {
          this.setSubscription(J.id, index_es_j({}, J)),
            this.pending.delete(J.topic)
        }
        )
      }
      async onUnsubscribe(J, et, eo) {
        this.events.removeAllListeners(et),
          this.hasSubscription(et, J) && this.deleteSubscription(et, eo),
          await this.relayer.messages.del(J)
      }
      async setRelayerSubscriptions(J) {
        await this.relayer.core.storage.setItem(this.storageKey, J)
      }
      async getRelayerSubscriptions() {
        return await this.relayer.core.storage.getItem(this.storageKey)
      }
      setSubscription(J, et) {
        this.subscriptions.has(J) || (this.logger.debug("Setting subscription"),
          this.logger.trace({
            type: "method",
            method: "setSubscription",
            id: J,
            subscription: et
          }),
          this.addSubscription(J, et))
      }
      addSubscription(J, et) {
        this.subscriptions.set(J, index_es_j({}, et)),
          this.topicMap.set(et.topic, J),
          this.events.emit(nq.created, et)
      }
      getSubscription(J) {
        this.logger.debug("Getting subscription"),
          this.logger.trace({
            type: "method",
            method: "getSubscription",
            id: J
          });
        let et = this.subscriptions.get(J);
        if (!et) {
          let { message: et } = N("NO_MATCHING_KEY", `${this.name}: ${J}`);
          throw Error(et)
        }
        return et
      }
      deleteSubscription(J, et) {
        this.logger.debug("Deleting subscription"),
          this.logger.trace({
            type: "method",
            method: "deleteSubscription",
            id: J,
            reason: et
          });
        let eo = this.getSubscription(J);
        this.subscriptions.delete(J),
          this.topicMap.delete(eo.topic, J),
          this.events.emit(nq.deleted, index_es_De(index_es_j({}, eo), {
            reason: et
          }))
      }
      async persist() {
        await this.setRelayerSubscriptions(this.values),
          this.events.emit(nq.sync)
      }
      async reset() {
        if (this.cached.length) {
          let J = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
          for (let et = 0; et < J; et++) {
            let J = this.cached.splice(0, this.batchSubscribeTopicsLimit);
            await this.batchSubscribe(J)
          }
        }
        this.events.emit(nq.resubscribed)
      }
      async restore() {
        try {
          let J = await this.getRelayerSubscriptions();
          if (typeof J > "u" || !J.length)
            return;
          if (this.subscriptions.size) {
            let { message: J } = N("RESTORE_WILL_OVERRIDE", this.name);
            throw this.logger.error(J),
            this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`),
            Error(J)
          }
          this.cached = J,
            this.logger.debug(`Successfully Restored subscriptions for ${this.name}`),
            this.logger.trace({
              type: "method",
              method: "restore",
              subscriptions: this.values
            })
        } catch (J) {
          this.logger.debug(`Failed to Restore subscriptions for ${this.name}`),
            this.logger.error(J)
        }
      }
      async batchSubscribe(J) {
        if (!J.length)
          return;
        let et = await this.rpcBatchSubscribe(J);
        k(et) && this.onBatchSubscribe(et.map((et, eo) => index_es_De(index_es_j({}, J[eo]), {
          id: et
        })))
      }
      async onConnect() {
        this.restartInProgress || (await this.restart(),
          this.onEnable())
      }
      onDisconnect() {
        this.onDisable()
      }
      async checkPending() {
        if (!this.initialized || this.relayer.transportExplicitlyClosed)
          return;
        let J = [];
        this.pending.forEach(et => {
          J.push(et)
        }
        ),
          await this.batchSubscribe(J)
      }
      registerEventListeners() {
        this.relayer.core.heartbeat.on(rA.HEARTBEAT_EVENTS.pulse, async () => {
          await this.checkPending()
        }
        ),
          this.relayer.on(nH.connect, async () => {
            await this.onConnect()
          }
          ),
          this.relayer.on(nH.disconnect, () => {
            this.onDisconnect()
          }
          ),
          this.events.on(nq.created, async J => {
            let et = nq.created;
            this.logger.info(`Emitting ${et}`),
              this.logger.debug({
                type: "event",
                event: et,
                data: J
              }),
              await this.persist()
          }
          ),
          this.events.on(nq.deleted, async J => {
            let et = nq.deleted;
            this.logger.info(`Emitting ${et}`),
              this.logger.debug({
                type: "event",
                event: et,
                data: J
              }),
              await this.persist()
          }
          )
      }
      isInitialized() {
        if (!this.initialized) {
          let { message: J } = N("NOT_INITIALIZED", this.name);
          throw Error(J)
        }
      }
      async restartToComplete() {
        this.restartInProgress && await new Promise(J => {
          let et = setInterval(() => {
            this.restartInProgress || (clearInterval(et),
              J())
          }
            , this.pollingInterval)
        }
        )
      }
    }
      ;
    var n7 = Object.defineProperty
      , n9 = Object.getOwnPropertySymbols
      , ir = Object.prototype.hasOwnProperty
      , io = Object.prototype.propertyIsEnumerable
      , index_es_Lt = (J, et, eo) => et in J ? n7(J, et, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: eo
      }) : J[et] = eo
      , Ar = (J, et) => {
        for (var eo in et || (et = {}))
          ir.call(et, eo) && index_es_Lt(J, eo, et[eo]);
        if (n9)
          for (var eo of n9(et))
            io.call(et, eo) && index_es_Lt(J, eo, et[eo]);
        return J
      }
      ;
    let index_es_Ft = class index_es_Ft extends g {
      constructor(J) {
        super(J),
          this.protocol = "wc",
          this.version = 2,
          this.events = new eX.EventEmitter,
          this.name = "relayer",
          this.transportExplicitlyClosed = !1,
          this.initialized = !1,
          this.connectionAttemptInProgress = !1,
          this.connectionStatusPollingInterval = 20,
          this.staleConnectionErrors = ["socket hang up", "socket stalled"],
          this.hasExperiencedNetworkDisruption = !1,
          this.request = async J => {
            this.logger.debug("Publishing Request Payload");
            try {
              return await this.toEstablishConnection(),
                await this.provider.request(J)
            } catch (J) {
              throw this.logger.debug("Failed to Publish Request"),
              this.logger.error(J),
              J
            }
          }
          ,
          this.onPayloadHandler = J => {
            this.onProviderPayload(J)
          }
          ,
          this.onConnectHandler = () => {
            this.events.emit(nH.connect)
          }
          ,
          this.onDisconnectHandler = () => {
            this.onProviderDisconnect()
          }
          ,
          this.onProviderErrorHandler = J => {
            this.logger.error(J),
              this.events.emit(nH.error, J),
              this.logger.info("Fatal socket error received, closing transport"),
              this.transportClose()
          }
          ,
          this.registerProviderListeners = () => {
            this.provider.on(nV.payload, this.onPayloadHandler),
              this.provider.on(nV.connect, this.onConnectHandler),
              this.provider.on(nV.disconnect, this.onDisconnectHandler),
              this.provider.on(nV.error, this.onProviderErrorHandler)
          }
          ,
          this.core = J.core,
          this.logger = "u" > typeof J.logger && "string" != typeof J.logger ? (0,
            rP.generateChildLogger)(J.logger, this.name) : (0,
              rP.pino)((0,
                rP.getDefaultLoggerOptions)({
                  level: J.logger || "error"
                })),
          this.messages = new index_es_Ot(this.logger, J.core),
          this.subscriber = new index_es_Nt(this, this.logger),
          this.publisher = new vr(this, this.logger),
          this.relayUrl = J?.relayUrl || nU,
          this.projectId = J.projectId,
          this.bundleId = function () {
            var J;
            try {
              return C() && "u" > typeof eo.g && "u" > typeof (null == eo.g ? void 0 : eo.g.Application) ? null == (J = eo.g.Application) ? void 0 : J.applicationId : void 0
            } catch {
              return
            }
          }(),
          this.provider = {}
      }
      async init() {
        this.logger.trace("Initialized"),
          this.registerEventListeners(),
          await this.createProvider(),
          await Promise.all([this.messages.init(), this.subscriber.init()]);
        try {
          await this.transportOpen()
        } catch {
          this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${nz}...`),
            await this.restartTransport(nz)
        }
        this.initialized = !0,
          setTimeout(async () => {
            0 === this.subscriber.topics.length && (this.logger.info("No topics subscribed to after init, closing transport"),
              await this.transportClose(),
              this.transportExplicitlyClosed = !1)
          }
            , 1e4)
      }
      get context() {
        return (0,
          rP.getLoggerContext)(this.logger)
      }
      get connected() {
        return this.provider.connection.connected
      }
      get connecting() {
        return this.provider.connection.connecting
      }
      async publish(J, et, eo) {
        this.isInitialized(),
          await this.publisher.publish(J, et, eo),
          await this.recordMessageEvent({
            topic: J,
            message: et,
            publishedAt: Date.now()
          })
      }
      async subscribe(J, et) {
        var eo;
        let el;
        this.isInitialized();
        let ec = (null == (eo = this.subscriber.topicMap.get(J)) ? void 0 : eo[0]) || "";
        if (ec)
          return ec;
        let o = et => {
          et.topic === J && (this.subscriber.off(nq.created, o),
            el())
        }
          ;
        return await Promise.all([new Promise(J => {
          el = J,
            this.subscriber.on(nq.created, o)
        }
        ), new Promise(async eo => {
          ec = await this.subscriber.subscribe(J, et),
            eo()
        }
        )]),
          ec
      }
      async unsubscribe(J, et) {
        this.isInitialized(),
          await this.subscriber.unsubscribe(J, et)
      }
      on(J, et) {
        this.events.on(J, et)
      }
      once(J, et) {
        this.events.once(J, et)
      }
      off(J, et) {
        this.events.off(J, et)
      }
      removeListener(J, et) {
        this.events.removeListener(J, et)
      }
      async transportClose() {
        this.transportExplicitlyClosed = !0,
          this.hasExperiencedNetworkDisruption && this.connected ? await ut(this.provider.disconnect(), 1e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.connected && await this.provider.disconnect()
      }
      async transportOpen(J) {
        if (this.transportExplicitlyClosed = !1,
          await this.confirmOnlineStateOrThrow(),
          !this.connectionAttemptInProgress) {
          J && J !== this.relayUrl && (this.relayUrl = J,
            await this.transportClose(),
            await this.createProvider()),
            this.connectionAttemptInProgress = !0;
          try {
            await Promise.all([new Promise(J => {
              if (!this.initialized)
                return J();
              this.subscriber.once(nq.resubscribed, () => {
                J()
              }
              )
            }
            ), new Promise(async (J, et) => {
              try {
                await ut(this.provider.connect(), 1e4, `Socket stalled when trying to connect to ${this.relayUrl}`)
              } catch (J) {
                et(J);
                return
              }
              J()
            }
            )])
          } catch (J) {
            if (this.logger.error(J),
              !this.isConnectionStalled(J.message))
              throw J;
            this.provider.events.emit(nV.disconnect)
          } finally {
            this.connectionAttemptInProgress = !1,
              this.hasExperiencedNetworkDisruption = !1
          }
        }
      }
      async restartTransport(J) {
        await this.confirmOnlineStateOrThrow(),
          this.connectionAttemptInProgress || (this.relayUrl = J || this.relayUrl,
            await this.transportClose(),
            await this.createProvider(),
            await this.transportOpen())
      }
      async confirmOnlineStateOrThrow() {
        if (!await er())
          throw Error("No internet connection detected. Please restart your network and try again.")
      }
      isConnectionStalled(J) {
        return this.staleConnectionErrors.some(et => J.includes(et))
      }
      async createProvider() {
        this.provider.connection && this.unregisterProviderListeners();
        let J = await this.core.crypto.signJWT(this.relayUrl);
        this.provider = new JsonRpcProvider(new f(function ({ protocol: J, version: et, relayUrl: el, sdkVersion: ec, auth: ed, projectId: eh, useOnCloseEvent: ep, bundleId: ef }) {
          var em;
          let eg;
          let ey = el.split("?")
            , eb = function (J, et, el) {
              let ec = function () {
                var J;
                if (T() === rd.reactNative && "u" > typeof eo.g && "u" > typeof (null == eo.g ? void 0 : eo.g.Platform)) {
                  let { OS: J, Version: et } = eo.g.Platform;
                  return [J, et].join("-")
                }
                let et = J ? parseUserAgent(J) : "undefined" == typeof document && "undefined" != typeof navigator && "ReactNative" === navigator.product ? new ReactNativeInfo : "undefined" != typeof navigator ? parseUserAgent(navigator.userAgent) : void 0 !== tK && tK.version ? new NodeInfo(tK.version.slice(1)) : null;
                if (null === et)
                  return "unknown";
                let el = et.os ? et.os.replace(" ", "").toLowerCase() : "unknown";
                return "browser" === et.type ? [el, et.name, et.version].join("-") : [el, et.version].join("-")
              }()
                , ed = function () {
                  var J;
                  let et = T();
                  return et === rd.browser ? [et, (null == (J = (0,
                    t1.getLocation)()) ? void 0 : J.host) || "unknown"].join(":") : et
                }();
              return [[J, et].join("-"), ["js", el].join("-"), ec, ed].join("/")
            }(J, et, ec)
            , ew = (em = ey[1] || "",
              eg = Ce(Ce({}, eg = t3.parse(em)), {
                auth: ed,
                ua: eb,
                projectId: eh,
                useOnCloseEvent: ep || void 0,
                origin: ef || void 0
              }),
              em = t3.stringify(eg));
          return ey[0] + "?" + ew
        }({
          sdkVersion: "2.11.0",
          protocol: this.protocol,
          version: this.version,
          relayUrl: this.relayUrl,
          projectId: this.projectId,
          auth: J,
          useOnCloseEvent: !0,
          bundleId: this.bundleId
        }))),
          this.registerProviderListeners()
      }
      async recordMessageEvent(J) {
        let { topic: et, message: eo } = J;
        await this.messages.set(et, eo)
      }
      async shouldIgnoreMessageEvent(J) {
        let { topic: et, message: eo } = J;
        if (!eo || 0 === eo.length)
          return this.logger.debug(`Ignoring invalid/empty message: ${eo}`),
            !0;
        if (!await this.subscriber.isSubscribed(et))
          return this.logger.debug(`Ignoring message for non-subscribed topic ${et}`),
            !0;
        let el = this.messages.has(et, eo);
        return el && this.logger.debug(`Ignoring duplicate message: ${eo}`),
          el
      }
      async onProviderPayload(J) {
        if (this.logger.debug("Incoming Relay Payload"),
          this.logger.trace({
            type: "payload",
            direction: "incoming",
            payload: J
          }),
          isJsonRpcRequest(J)) {
          if (!J.method.endsWith("_subscription"))
            return;
          let et = J.params
            , { topic: eo, message: el, publishedAt: ec } = et.data
            , ed = {
              topic: eo,
              message: el,
              publishedAt: ec
            };
          this.logger.debug("Emitting Relayer Payload"),
            this.logger.trace(Ar({
              type: "event",
              event: et.id
            }, ed)),
            this.events.emit(et.id, ed),
            await this.acknowledgePayload(J),
            await this.onMessageEvent(ed)
        } else
          isJsonRpcResponse(J) && this.events.emit(nH.message_ack, J)
      }
      async onMessageEvent(J) {
        await this.shouldIgnoreMessageEvent(J) || (this.events.emit(nH.message, J),
          await this.recordMessageEvent(J))
      }
      async acknowledgePayload(J) {
        let et = formatJsonRpcResult(J.id, !0);
        await this.provider.connection.send(et)
      }
      unregisterProviderListeners() {
        this.provider.off(nV.payload, this.onPayloadHandler),
          this.provider.off(nV.connect, this.onConnectHandler),
          this.provider.off(nV.disconnect, this.onDisconnectHandler),
          this.provider.off(nV.error, this.onProviderErrorHandler)
      }
      async registerEventListeners() {
        this.events.on(nH.connection_stalled, () => {
          this.restartTransport().catch(J => this.logger.error(J))
        }
        );
        let J = await er();
        !function (J) {
          switch (T()) {
            case rd.browser:
              !C() && D() && (window.addEventListener("online", () => J(!0)),
                window.addEventListener("offline", () => J(!1)));
              break;
            case rd.reactNative:
              C() && "u" > typeof eo.g && null != eo.g && eo.g.NetInfo && eo.g?.NetInfo.addEventListener(et => J(et?.isConnected));
            case rd.node:
          }
        }(async et => {
          this.initialized && J !== et && (J = et,
            et ? await this.restartTransport().catch(J => this.logger.error(J)) : (this.hasExperiencedNetworkDisruption = !0,
              await this.transportClose().catch(J => this.logger.error(J))))
        }
        )
      }
      onProviderDisconnect() {
        this.events.emit(nH.disconnect),
          this.attemptToReconnect()
      }
      attemptToReconnect() {
        this.transportExplicitlyClosed || (this.logger.info("attemptToReconnect called. Connecting..."),
          setTimeout(async () => {
            await this.restartTransport().catch(J => this.logger.error(J))
          }
            , (0,
              t0.toMiliseconds)(nW)))
      }
      isInitialized() {
        if (!this.initialized) {
          let { message: J } = N("NOT_INITIALIZED", this.name);
          throw Error(J)
        }
      }
      async toEstablishConnection() {
        if (await this.confirmOnlineStateOrThrow(),
          !this.connected) {
          if (this.connectionAttemptInProgress)
            return await new Promise(J => {
              let et = setInterval(() => {
                this.connected && (clearInterval(et),
                  J())
              }
                , this.connectionStatusPollingInterval)
            }
            );
          await this.restartTransport()
        }
      }
    }
      ;
    var il = Object.defineProperty
      , ic = Object.getOwnPropertySymbols
      , iu = Object.prototype.hasOwnProperty
      , id = Object.prototype.propertyIsEnumerable
      , index_es_Mt = (J, et, eo) => et in J ? il(J, et, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: eo
      }) : J[et] = eo
      , index_es_kt = (J, et) => {
        for (var eo in et || (et = {}))
          iu.call(et, eo) && index_es_Mt(J, eo, et[eo]);
        if (ic)
          for (var eo of ic(et))
            id.call(et, eo) && index_es_Mt(J, eo, et[eo]);
        return J
      }
      ;
    let index_es_Kt = class index_es_Kt extends index_es_p {
      constructor(J, et, eo, el = nD, ec) {
        super(J, et, eo, el),
          this.core = J,
          this.logger = et,
          this.name = eo,
          this.map = new Map,
          this.version = "0.3",
          this.cached = [],
          this.initialized = !1,
          this.storagePrefix = nD,
          this.init = async () => {
            this.initialized || (this.logger.trace("Initialized"),
              await this.restore(),
              this.cached.forEach(J => {
                var et;
                this.getKey && null !== J && !w(J) ? this.map.set(this.getKey(J), J) : (null == (et = J?.proposer) ? void 0 : et.publicKey) ? this.map.set(J.id, J) : J?.topic && this.map.set(J.topic, J)
              }
              ),
              this.cached = [],
              this.initialized = !0)
          }
          ,
          this.set = async (J, et) => {
            this.isInitialized(),
              this.map.has(J) ? await this.update(J, et) : (this.logger.debug("Setting value"),
                this.logger.trace({
                  type: "method",
                  method: "set",
                  key: J,
                  value: et
                }),
                this.map.set(J, et),
                await this.persist())
          }
          ,
          this.get = J => (this.isInitialized(),
            this.logger.debug("Getting value"),
            this.logger.trace({
              type: "method",
              method: "get",
              key: J
            }),
            this.getData(J)),
          this.getAll = J => (this.isInitialized(),
            J ? this.values.filter(et => Object.keys(J).every(eo => rU()(et[eo], J[eo]))) : this.values),
          this.update = async (J, et) => {
            this.isInitialized(),
              this.logger.debug("Updating value"),
              this.logger.trace({
                type: "method",
                method: "update",
                key: J,
                update: et
              });
            let eo = index_es_kt(index_es_kt({}, this.getData(J)), et);
            this.map.set(J, eo),
              await this.persist()
          }
          ,
          this.delete = async (J, et) => {
            this.isInitialized(),
              this.map.has(J) && (this.logger.debug("Deleting value"),
                this.logger.trace({
                  type: "method",
                  method: "delete",
                  key: J,
                  reason: et
                }),
                this.map.delete(J),
                await this.persist())
          }
          ,
          this.logger = (0,
            rP.generateChildLogger)(et, this.name),
          this.storagePrefix = el,
          this.getKey = ec
      }
      get context() {
        return (0,
          rP.getLoggerContext)(this.logger)
      }
      get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
      }
      get length() {
        return this.map.size
      }
      get keys() {
        return Array.from(this.map.keys())
      }
      get values() {
        return Array.from(this.map.values())
      }
      async setDataStore(J) {
        await this.core.storage.setItem(this.storageKey, J)
      }
      async getDataStore() {
        return await this.core.storage.getItem(this.storageKey)
      }
      getData(J) {
        let et = this.map.get(J);
        if (!et) {
          let { message: et } = N("NO_MATCHING_KEY", `${this.name}: ${J}`);
          throw this.logger.error(et),
          Error(et)
        }
        return et
      }
      async persist() {
        await this.setDataStore(this.values)
      }
      async restore() {
        try {
          let J = await this.getDataStore();
          if (typeof J > "u" || !J.length)
            return;
          if (this.map.size) {
            let { message: J } = N("RESTORE_WILL_OVERRIDE", this.name);
            throw this.logger.error(J),
            Error(J)
          }
          this.cached = J,
            this.logger.debug(`Successfully Restored value for ${this.name}`),
            this.logger.trace({
              type: "method",
              method: "restore",
              value: this.values
            })
        } catch (J) {
          this.logger.debug(`Failed to Restore value for ${this.name}`),
            this.logger.error(J)
        }
      }
      isInitialized() {
        if (!this.initialized) {
          let { message: J } = N("NOT_INITIALIZED", this.name);
          throw Error(J)
        }
      }
    }
      ;
    let index_es_Bt = class index_es_Bt {
      constructor(J, et) {
        this.core = J,
          this.logger = et,
          this.name = "pairing",
          this.version = "0.3",
          this.events = new (e0()),
          this.initialized = !1,
          this.storagePrefix = nD,
          this.ignoredPayloadTypes = [1],
          this.registeredMethods = [],
          this.init = async () => {
            this.initialized || (await this.pairings.init(),
              await this.cleanup(),
              this.registerRelayerEvents(),
              this.registerExpirerEvents(),
              this.initialized = !0,
              this.logger.trace("Initialized"))
          }
          ,
          this.register = ({ methods: J }) => {
            this.isInitialized(),
              this.registeredMethods = [...new Set([...this.registeredMethods, ...J])]
          }
          ,
          this.create = async () => {
            var J;
            this.isInitialized();
            let et = Vn()
              , eo = await this.core.crypto.setSymKey(et)
              , el = pt(t0.FIVE_MINUTES)
              , ec = {
                protocol: "irn"
              }
              , ed = (J = {
                protocol: this.core.protocol,
                version: this.core.version,
                topic: eo,
                symKey: et,
                relay: ec
              },
                `${J.protocol}:${J.topic}@${J.version}?` + t3.stringify(St({
                  symKey: J.symKey
                }, function (J, et = "-") {
                  let eo = {};
                  return Object.keys(J).forEach(el => {
                    J[el] && (eo["relay" + et + el] = J[el])
                  }
                  ),
                    eo
                }(J.relay))));
            return await this.pairings.set(eo, {
              topic: eo,
              expiry: el,
              relay: ec,
              active: !1
            }),
              await this.core.relayer.subscribe(eo),
              this.core.expirer.set(eo, el),
            {
              topic: eo,
              uri: ed
            }
          }
          ,
          this.pair = async J => {
            this.isInitialized(),
              this.isValidPair(J);
            let { topic: et, symKey: eo, relay: el } = wt(J.uri);
            if (this.pairings.keys.includes(et) && this.pairings.get(et).active)
              throw Error(`Pairing already exists: ${et}. Please try again with a new connection URI.`);
            let ec = pt(t0.FIVE_MINUTES)
              , ed = {
                topic: et,
                relay: el,
                expiry: ec,
                active: !1
              };
            return await this.pairings.set(et, ed),
              this.core.expirer.set(et, ec),
              J.activatePairing && await this.activate({
                topic: et
              }),
              this.events.emit(nY.create, ed),
              this.core.crypto.keychain.has(et) || (await this.core.crypto.setSymKey(eo, et),
                await this.core.relayer.subscribe(et, {
                  relay: el
                })),
              ed
          }
          ,
          this.activate = async ({ topic: J }) => {
            this.isInitialized();
            let et = pt(t0.THIRTY_DAYS);
            await this.pairings.update(J, {
              active: !0,
              expiry: et
            }),
              this.core.expirer.set(J, et)
          }
          ,
          this.ping = async J => {
            this.isInitialized(),
              await this.isValidPing(J);
            let { topic: et } = J;
            if (this.pairings.keys.includes(et)) {
              let J = await this.sendRequest(et, "wc_pairingPing", {})
                , { done: eo, resolve: el, reject: ec } = at();
              this.events.once(yt("pairing_ping", J), ({ error: J }) => {
                J ? ec(J) : el()
              }
              ),
                await eo()
            }
          }
          ,
          this.updateExpiry = async ({ topic: J, expiry: et }) => {
            this.isInitialized(),
              await this.pairings.update(J, {
                expiry: et
              })
          }
          ,
          this.updateMetadata = async ({ topic: J, metadata: et }) => {
            this.isInitialized(),
              await this.pairings.update(J, {
                peerMetadata: et
              })
          }
          ,
          this.getPairings = () => (this.isInitialized(),
            this.pairings.values),
          this.disconnect = async J => {
            this.isInitialized(),
              await this.isValidDisconnect(J);
            let { topic: et } = J;
            this.pairings.keys.includes(et) && (await this.sendRequest(et, "wc_pairingDelete", index_es_U("USER_DISCONNECTED")),
              await this.deletePairing(et))
          }
          ,
          this.sendRequest = async (J, et, eo) => {
            let el = formatJsonRpcRequest(et, eo)
              , ec = await this.core.crypto.encode(J, el)
              , ed = nG[et].req;
            return this.core.history.set(J, el),
              this.core.relayer.publish(J, ec, ed),
              el.id
          }
          ,
          this.sendResult = async (J, et, eo) => {
            let el = formatJsonRpcResult(J, eo)
              , ec = await this.core.crypto.encode(et, el)
              , ed = await this.core.history.get(et, J)
              , eh = nG[ed.request.method].res;
            await this.core.relayer.publish(et, ec, eh),
              await this.core.history.resolve(el)
          }
          ,
          this.sendError = async (J, et, eo) => {
            let el = formatJsonRpcError(J, eo)
              , ec = await this.core.crypto.encode(et, el)
              , ed = await this.core.history.get(et, J)
              , eh = nG[ed.request.method] ? nG[ed.request.method].res : nG.unregistered_method.res;
            await this.core.relayer.publish(et, ec, eh),
              await this.core.history.resolve(el)
          }
          ,
          this.deletePairing = async (J, et) => {
            await this.core.relayer.unsubscribe(J),
              await Promise.all([this.pairings.delete(J, index_es_U("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(J), et ? Promise.resolve() : this.core.expirer.del(J)])
          }
          ,
          this.cleanup = async () => {
            let J = this.pairings.getAll().filter(J => mt(J.expiry));
            await Promise.all(J.map(J => this.deletePairing(J.topic)))
          }
          ,
          this.onRelayEventRequest = J => {
            let { topic: et, payload: eo } = J;
            switch (eo.method) {
              case "wc_pairingPing":
                return this.onPairingPingRequest(et, eo);
              case "wc_pairingDelete":
                return this.onPairingDeleteRequest(et, eo);
              default:
                return this.onUnknownRpcMethodRequest(et, eo)
            }
          }
          ,
          this.onRelayEventResponse = async J => {
            let { topic: et, payload: eo } = J
              , el = (await this.core.history.get(et, eo.id)).request.method;
            return "wc_pairingPing" === el ? this.onPairingPingResponse(et, eo) : this.onUnknownRpcMethodResponse(el)
          }
          ,
          this.onPairingPingRequest = async (J, et) => {
            let { id: eo } = et;
            try {
              this.isValidPing({
                topic: J
              }),
                await this.sendResult(eo, J, !0),
                this.events.emit(nY.ping, {
                  id: eo,
                  topic: J
                })
            } catch (et) {
              await this.sendError(eo, J, et),
                this.logger.error(et)
            }
          }
          ,
          this.onPairingPingResponse = (J, et) => {
            let { id: eo } = et;
            setTimeout(() => {
              isJsonRpcResult(et) ? this.events.emit(yt("pairing_ping", eo), {}) : isJsonRpcError(et) && this.events.emit(yt("pairing_ping", eo), {
                error: et.error
              })
            }
              , 500)
          }
          ,
          this.onPairingDeleteRequest = async (J, et) => {
            let { id: eo } = et;
            try {
              this.isValidDisconnect({
                topic: J
              }),
                await this.deletePairing(J),
                this.events.emit(nY.delete, {
                  id: eo,
                  topic: J
                })
            } catch (et) {
              await this.sendError(eo, J, et),
                this.logger.error(et)
            }
          }
          ,
          this.onUnknownRpcMethodRequest = async (J, et) => {
            let { id: eo, method: el } = et;
            try {
              if (this.registeredMethods.includes(el))
                return;
              let et = index_es_U("WC_METHOD_UNSUPPORTED", el);
              await this.sendError(eo, J, et),
                this.logger.error(et)
            } catch (et) {
              await this.sendError(eo, J, et),
                this.logger.error(et)
            }
          }
          ,
          this.onUnknownRpcMethodResponse = J => {
            this.registeredMethods.includes(J) || this.logger.error(index_es_U("WC_METHOD_UNSUPPORTED", J))
          }
          ,
          this.isValidPair = J => {
            var et;
            if (!Ht(J)) {
              let { message: et } = N("MISSING_OR_INVALID", `pair() params: ${J}`);
              throw Error(et)
            }
            if (!function (J) {
              if (h(J, !1))
                try {
                  return "u" > typeof new URL(J)
                } catch { }
              return !1
            }(J.uri)) {
              let { message: et } = N("MISSING_OR_INVALID", `pair() uri: ${J.uri}`);
              throw Error(et)
            }
            let eo = wt(J.uri);
            if (!(null != (et = eo?.relay) && et.protocol)) {
              let { message: J } = N("MISSING_OR_INVALID", "pair() uri#relay-protocol");
              throw Error(J)
            }
            if (!(null != eo && eo.symKey)) {
              let { message: J } = N("MISSING_OR_INVALID", "pair() uri#symKey");
              throw Error(J)
            }
          }
          ,
          this.isValidPing = async J => {
            if (!Ht(J)) {
              let { message: et } = N("MISSING_OR_INVALID", `ping() params: ${J}`);
              throw Error(et)
            }
            let { topic: et } = J;
            await this.isValidPairingTopic(et)
          }
          ,
          this.isValidDisconnect = async J => {
            if (!Ht(J)) {
              let { message: et } = N("MISSING_OR_INVALID", `disconnect() params: ${J}`);
              throw Error(et)
            }
            let { topic: et } = J;
            await this.isValidPairingTopic(et)
          }
          ,
          this.isValidPairingTopic = async J => {
            if (!h(J, !1)) {
              let { message: et } = N("MISSING_OR_INVALID", `pairing topic should be a string: ${J}`);
              throw Error(et)
            }
            if (!this.pairings.keys.includes(J)) {
              let { message: et } = N("NO_MATCHING_KEY", `pairing topic doesn't exist: ${J}`);
              throw Error(et)
            }
            if (mt(this.pairings.get(J).expiry)) {
              await this.deletePairing(J);
              let { message: et } = N("EXPIRED", `pairing topic: ${J}`);
              throw Error(et)
            }
          }
          ,
          this.core = J,
          this.logger = (0,
            rP.generateChildLogger)(et, this.name),
          this.pairings = new index_es_Kt(this.core, this.logger, this.name, this.storagePrefix)
      }
      get context() {
        return (0,
          rP.getLoggerContext)(this.logger)
      }
      isInitialized() {
        if (!this.initialized) {
          let { message: J } = N("NOT_INITIALIZED", this.name);
          throw Error(J)
        }
      }
      registerRelayerEvents() {
        this.core.relayer.on(nH.message, async J => {
          let { topic: et, message: eo } = J;
          if (!this.pairings.keys.includes(et) || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(eo)))
            return;
          let el = await this.core.crypto.decode(et, eo);
          try {
            isJsonRpcRequest(el) ? (this.core.history.set(et, el),
              this.onRelayEventRequest({
                topic: et,
                payload: el
              })) : isJsonRpcResponse(el) && (await this.core.history.resolve(el),
                await this.onRelayEventResponse({
                  topic: et,
                  payload: el
                }),
                this.core.history.delete(et, el.id))
          } catch (J) {
            this.logger.error(J)
          }
        }
        )
      }
      registerExpirerEvents() {
        this.core.expirer.on(nJ.expired, async J => {
          let { topic: et } = ft(J.target);
          et && this.pairings.keys.includes(et) && (await this.deletePairing(et, !0),
            this.events.emit(nY.expire, {
              topic: et
            }))
        }
        )
      }
    }
      ;
    let index_es_Vt = class index_es_Vt extends dist_index_es_h {
      constructor(J, et) {
        super(J, et),
          this.core = J,
          this.logger = et,
          this.records = new Map,
          this.events = new eX.EventEmitter,
          this.name = "history",
          this.version = "0.3",
          this.cached = [],
          this.initialized = !1,
          this.storagePrefix = nD,
          this.init = async () => {
            this.initialized || (this.logger.trace("Initialized"),
              await this.restore(),
              this.cached.forEach(J => this.records.set(J.id, J)),
              this.cached = [],
              this.registerEventListeners(),
              this.initialized = !0)
          }
          ,
          this.set = (J, et, eo) => {
            if (this.isInitialized(),
              this.logger.debug("Setting JSON-RPC request history record"),
              this.logger.trace({
                type: "method",
                method: "set",
                topic: J,
                request: et,
                chainId: eo
              }),
              this.records.has(et.id))
              return;
            let el = {
              id: et.id,
              topic: J,
              request: {
                method: et.method,
                params: et.params || null
              },
              chainId: eo,
              expiry: pt(t0.THIRTY_DAYS)
            };
            this.records.set(el.id, el),
              this.events.emit(nK.created, el)
          }
          ,
          this.resolve = async J => {
            if (this.isInitialized(),
              this.logger.debug("Updating JSON-RPC response history record"),
              this.logger.trace({
                type: "method",
                method: "update",
                response: J
              }),
              !this.records.has(J.id))
              return;
            let et = await this.getRecord(J.id);
            typeof et.response > "u" && (et.response = isJsonRpcError(J) ? {
              error: J.error
            } : {
              result: J.result
            },
              this.records.set(et.id, et),
              this.events.emit(nK.updated, et))
          }
          ,
          this.get = async (J, et) => (this.isInitialized(),
            this.logger.debug("Getting record"),
            this.logger.trace({
              type: "method",
              method: "get",
              topic: J,
              id: et
            }),
            await this.getRecord(et)),
          this.delete = (J, et) => {
            this.isInitialized(),
              this.logger.debug("Deleting record"),
              this.logger.trace({
                type: "method",
                method: "delete",
                id: et
              }),
              this.values.forEach(eo => {
                eo.topic !== J || "u" > typeof et && eo.id !== et || (this.records.delete(eo.id),
                  this.events.emit(nK.deleted, eo))
              }
              )
          }
          ,
          this.exists = async (J, et) => (this.isInitialized(),
            !!this.records.has(et) && (await this.getRecord(et)).topic === J),
          this.on = (J, et) => {
            this.events.on(J, et)
          }
          ,
          this.once = (J, et) => {
            this.events.once(J, et)
          }
          ,
          this.off = (J, et) => {
            this.events.off(J, et)
          }
          ,
          this.removeListener = (J, et) => {
            this.events.removeListener(J, et)
          }
          ,
          this.logger = (0,
            rP.generateChildLogger)(et, this.name)
      }
      get context() {
        return (0,
          rP.getLoggerContext)(this.logger)
      }
      get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
      }
      get size() {
        return this.records.size
      }
      get keys() {
        return Array.from(this.records.keys())
      }
      get values() {
        return Array.from(this.records.values())
      }
      get pending() {
        let J = [];
        return this.values.forEach(et => {
          if ("u" > typeof et.response)
            return;
          let eo = {
            topic: et.topic,
            request: formatJsonRpcRequest(et.request.method, et.request.params, et.id),
            chainId: et.chainId
          };
          return J.push(eo)
        }
        ),
          J
      }
      async setJsonRpcRecords(J) {
        await this.core.storage.setItem(this.storageKey, J)
      }
      async getJsonRpcRecords() {
        return await this.core.storage.getItem(this.storageKey)
      }
      getRecord(J) {
        this.isInitialized();
        let et = this.records.get(J);
        if (!et) {
          let { message: et } = N("NO_MATCHING_KEY", `${this.name}: ${J}`);
          throw Error(et)
        }
        return et
      }
      async persist() {
        await this.setJsonRpcRecords(this.values),
          this.events.emit(nK.sync)
      }
      async restore() {
        try {
          let J = await this.getJsonRpcRecords();
          if (typeof J > "u" || !J.length)
            return;
          if (this.records.size) {
            let { message: J } = N("RESTORE_WILL_OVERRIDE", this.name);
            throw this.logger.error(J),
            Error(J)
          }
          this.cached = J,
            this.logger.debug(`Successfully Restored records for ${this.name}`),
            this.logger.trace({
              type: "method",
              method: "restore",
              records: this.values
            })
        } catch (J) {
          this.logger.debug(`Failed to Restore records for ${this.name}`),
            this.logger.error(J)
        }
      }
      registerEventListeners() {
        this.events.on(nK.created, J => {
          let et = nK.created;
          this.logger.info(`Emitting ${et}`),
            this.logger.debug({
              type: "event",
              event: et,
              record: J
            }),
            this.persist()
        }
        ),
          this.events.on(nK.updated, J => {
            let et = nK.updated;
            this.logger.info(`Emitting ${et}`),
              this.logger.debug({
                type: "event",
                event: et,
                record: J
              }),
              this.persist()
          }
          ),
          this.events.on(nK.deleted, J => {
            let et = nK.deleted;
            this.logger.info(`Emitting ${et}`),
              this.logger.debug({
                type: "event",
                event: et,
                record: J
              }),
              this.persist()
          }
          ),
          this.core.heartbeat.on(rA.HEARTBEAT_EVENTS.pulse, () => {
            this.cleanup()
          }
          )
      }
      cleanup() {
        try {
          this.records.forEach(J => {
            (0,
              t0.toMiliseconds)(J.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${J.id}`),
                this.delete(J.topic, J.id))
          }
          )
        } catch (J) {
          this.logger.warn(J)
        }
      }
      isInitialized() {
        if (!this.initialized) {
          let { message: J } = N("NOT_INITIALIZED", this.name);
          throw Error(J)
        }
      }
    }
      ;
    let index_es_jt = class index_es_jt extends index_es_E {
      constructor(J, et) {
        super(J, et),
          this.core = J,
          this.logger = et,
          this.expirations = new Map,
          this.events = new eX.EventEmitter,
          this.name = "expirer",
          this.version = "0.3",
          this.cached = [],
          this.initialized = !1,
          this.storagePrefix = nD,
          this.init = async () => {
            this.initialized || (this.logger.trace("Initialized"),
              await this.restore(),
              this.cached.forEach(J => this.expirations.set(J.target, J)),
              this.cached = [],
              this.registerEventListeners(),
              this.initialized = !0)
          }
          ,
          this.has = J => {
            try {
              let et = this.formatTarget(J);
              return "u" > typeof this.getExpiration(et)
            } catch {
              return !1
            }
          }
          ,
          this.set = (J, et) => {
            this.isInitialized();
            let eo = this.formatTarget(J)
              , el = {
                target: eo,
                expiry: et
              };
            this.expirations.set(eo, el),
              this.checkExpiry(eo, el),
              this.events.emit(nJ.created, {
                target: eo,
                expiration: el
              })
          }
          ,
          this.get = J => {
            this.isInitialized();
            let et = this.formatTarget(J);
            return this.getExpiration(et)
          }
          ,
          this.del = J => {
            if (this.isInitialized(),
              this.has(J)) {
              let et = this.formatTarget(J)
                , eo = this.getExpiration(et);
              this.expirations.delete(et),
                this.events.emit(nJ.deleted, {
                  target: et,
                  expiration: eo
                })
            }
          }
          ,
          this.on = (J, et) => {
            this.events.on(J, et)
          }
          ,
          this.once = (J, et) => {
            this.events.once(J, et)
          }
          ,
          this.off = (J, et) => {
            this.events.off(J, et)
          }
          ,
          this.removeListener = (J, et) => {
            this.events.removeListener(J, et)
          }
          ,
          this.logger = (0,
            rP.generateChildLogger)(et, this.name)
      }
      get context() {
        return (0,
          rP.getLoggerContext)(this.logger)
      }
      get storageKey() {
        return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
      }
      get length() {
        return this.expirations.size
      }
      get keys() {
        return Array.from(this.expirations.keys())
      }
      get values() {
        return Array.from(this.expirations.values())
      }
      formatTarget(J) {
        if ("string" == typeof J)
          return re("topic", J);
        if ("number" == typeof J)
          return re("id", J);
        let { message: et } = N("UNKNOWN_TYPE", `Target type: ${typeof J}`);
        throw Error(et)
      }
      async setExpirations(J) {
        await this.core.storage.setItem(this.storageKey, J)
      }
      async getExpirations() {
        return await this.core.storage.getItem(this.storageKey)
      }
      async persist() {
        await this.setExpirations(this.values),
          this.events.emit(nJ.sync)
      }
      async restore() {
        try {
          let J = await this.getExpirations();
          if (typeof J > "u" || !J.length)
            return;
          if (this.expirations.size) {
            let { message: J } = N("RESTORE_WILL_OVERRIDE", this.name);
            throw this.logger.error(J),
            Error(J)
          }
          this.cached = J,
            this.logger.debug(`Successfully Restored expirations for ${this.name}`),
            this.logger.trace({
              type: "method",
              method: "restore",
              expirations: this.values
            })
        } catch (J) {
          this.logger.debug(`Failed to Restore expirations for ${this.name}`),
            this.logger.error(J)
        }
      }
      getExpiration(J) {
        let et = this.expirations.get(J);
        if (!et) {
          let { message: et } = N("NO_MATCHING_KEY", `${this.name}: ${J}`);
          throw this.logger.error(et),
          Error(et)
        }
        return et
      }
      checkExpiry(J, et) {
        let { expiry: eo } = et;
        (0,
          t0.toMiliseconds)(eo) - Date.now() <= 0 && this.expire(J, et)
      }
      expire(J, et) {
        this.expirations.delete(J),
          this.events.emit(nJ.expired, {
            target: J,
            expiration: et
          })
      }
      checkExpirations() {
        this.core.relayer.connected && this.expirations.forEach((J, et) => this.checkExpiry(et, J))
      }
      registerEventListeners() {
        this.core.heartbeat.on(rA.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()),
          this.events.on(nJ.created, J => {
            let et = nJ.created;
            this.logger.info(`Emitting ${et}`),
              this.logger.debug({
                type: "event",
                event: et,
                data: J
              }),
              this.persist()
          }
          ),
          this.events.on(nJ.expired, J => {
            let et = nJ.expired;
            this.logger.info(`Emitting ${et}`),
              this.logger.debug({
                type: "event",
                event: et,
                data: J
              }),
              this.persist()
          }
          ),
          this.events.on(nJ.deleted, J => {
            let et = nJ.deleted;
            this.logger.info(`Emitting ${et}`),
              this.logger.debug({
                type: "event",
                event: et,
                data: J
              }),
              this.persist()
          }
          )
      }
      isInitialized() {
        if (!this.initialized) {
          let { message: J } = N("NOT_INITIALIZED", this.name);
          throw Error(J)
        }
      }
    }
      ;
    let index_es_qt = class index_es_qt extends index_es_y {
      constructor(J, et) {
        super(J, et),
          this.projectId = J,
          this.logger = et,
          this.name = nQ,
          this.initialized = !1,
          this.queue = [],
          this.verifyDisabled = !1,
          this.init = async J => {
            if (this.verifyDisabled || C() || !D())
              return;
            let et = this.getVerifyUrl(J?.verifyUrl);
            this.verifyUrl !== et && this.removeIframe(),
              this.verifyUrl = et;
            try {
              await this.createIframe()
            } catch (J) {
              this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`),
                this.logger.info(J)
            }
            if (!this.initialized) {
              this.removeIframe(),
                this.verifyUrl = n0;
              try {
                await this.createIframe()
              } catch (J) {
                this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`),
                  this.logger.info(J),
                  this.verifyDisabled = !0
              }
            }
          }
          ,
          this.register = async J => {
            this.initialized ? this.sendPost(J.attestationId) : (this.addToQueue(J.attestationId),
              await this.init())
          }
          ,
          this.resolve = async J => {
            let et;
            if (this.isDevEnv)
              return "";
            let eo = this.getVerifyUrl(J?.verifyUrl);
            try {
              et = await this.fetchAttestation(J.attestationId, eo)
            } catch (el) {
              this.logger.info(`failed to resolve attestation: ${J.attestationId} from url: ${eo}`),
                this.logger.info(el),
                et = await this.fetchAttestation(J.attestationId, n0)
            }
            return et
          }
          ,
          this.fetchAttestation = async (J, et) => {
            this.logger.info(`resolving attestation: ${J} from url: ${et}`);
            let eo = this.startAbortTimer(2 * t0.ONE_SECOND)
              , el = await fetch(`${et}/attestation/${J}`, {
                signal: this.abortController.signal
              });
            return clearTimeout(eo),
              200 === el.status ? await el.json() : void 0
          }
          ,
          this.addToQueue = J => {
            this.queue.push(J)
          }
          ,
          this.processQueue = () => {
            0 !== this.queue.length && (this.queue.forEach(J => this.sendPost(J)),
              this.queue = [])
          }
          ,
          this.sendPost = J => {
            var et;
            try {
              if (!this.iframe)
                return;
              null == (et = this.iframe.contentWindow) || et.postMessage(J, "*"),
                this.logger.info(`postMessage sent: ${J} ${this.verifyUrl}`)
            } catch { }
          }
          ,
          this.createIframe = async () => {
            let J;
            let s = et => {
              "verify_ready" === et.data && (this.initialized = !0,
                this.processQueue(),
                window.removeEventListener("message", s),
                J())
            }
              ;
            await Promise.race([new Promise(et => {
              if (document.getElementById(nQ))
                return et();
              window.addEventListener("message", s);
              let eo = document.createElement("iframe");
              eo.id = nQ,
                eo.src = `${this.verifyUrl}/${this.projectId}`,
                eo.style.display = "none",
                document.body.append(eo),
                this.iframe = eo,
                J = et
            }
            ), new Promise((J, et) => setTimeout(() => {
              window.removeEventListener("message", s),
                et("verify iframe load timeout")
            }
              , (0,
                t0.toMiliseconds)(t0.FIVE_SECONDS)))])
          }
          ,
          this.removeIframe = () => {
            this.iframe && (this.iframe.remove(),
              this.iframe = void 0,
              this.initialized = !1)
          }
          ,
          this.getVerifyUrl = J => {
            let et = J || nX;
            return n1.includes(et) || (this.logger.info(`verify url: ${et}, not included in trusted list, assigning default: ${nX}`),
              et = nX),
              et
          }
          ,
          this.logger = (0,
            rP.generateChildLogger)(et, this.name),
          this.verifyUrl = nX,
          this.abortController = new AbortController,
          this.isDevEnv = te() && rV.env.IS_VITEST
      }
      get context() {
        return (0,
          rP.getLoggerContext)(this.logger)
      }
      startAbortTimer(J) {
        return this.abortController = new AbortController,
          setTimeout(() => this.abortController.abort(), (0,
            t0.toMiliseconds)(J))
      }
    }
      ;
    let index_es_Gt = class index_es_Gt extends v {
      constructor(J, et) {
        super(J, et),
          this.projectId = J,
          this.logger = et,
          this.context = "echo",
          this.registerDeviceToken = async J => {
            let { clientId: et, token: eo, notificationType: el, enableEncrypted: ec = !1 } = J
              , ed = `https://echo.walletconnect.com/${this.projectId}/clients`;
            await rH()(ed, {
              method: "POST",
              headers: {
                "Content-Type": "application/json"
              },
              body: JSON.stringify({
                client_id: et,
                type: el,
                token: eo,
                always_raw: ec
              })
            })
          }
          ,
          this.logger = (0,
            rP.generateChildLogger)(et, this.context)
      }
    }
      ;
    var ih = Object.defineProperty
      , ip = Object.getOwnPropertySymbols
      , im = Object.prototype.hasOwnProperty
      , ig = Object.prototype.propertyIsEnumerable
      , index_es_Ht = (J, et, eo) => et in J ? ih(J, et, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: eo
      }) : J[et] = eo
      , index_es_Jt = (J, et) => {
        for (var eo in et || (et = {}))
          im.call(et, eo) && index_es_Ht(J, eo, et[eo]);
        if (ip)
          for (var eo of ip(et))
            ig.call(et, eo) && index_es_Ht(J, eo, et[eo]);
        return J
      }
      ;
    let index_es_te = class index_es_te extends n {
      constructor(J) {
        super(J),
          this.protocol = "wc",
          this.version = 2,
          this.name = nM,
          this.events = new eX.EventEmitter,
          this.initialized = !1,
          this.on = (J, et) => this.events.on(J, et),
          this.once = (J, et) => this.events.once(J, et),
          this.off = (J, et) => this.events.off(J, et),
          this.removeListener = (J, et) => this.events.removeListener(J, et),
          this.projectId = J?.projectId,
          this.relayUrl = J?.relayUrl || nU,
          this.customStoragePrefix = null != J && J.customStoragePrefix ? `:${J.customStoragePrefix}` : "";
        let et = "u" > typeof J?.logger && "string" != typeof J?.logger ? J.logger : (0,
          rP.pino)((0,
            rP.getDefaultLoggerOptions)({
              level: J?.logger || nj.logger
            }));
        this.logger = (0,
          rP.generateChildLogger)(et, this.name),
          this.heartbeat = new rA.HeartBeat,
          this.crypto = new index_es_xt(this, this.logger, J?.keychain),
          this.history = new index_es_Vt(this, this.logger),
          this.expirer = new index_es_jt(this, this.logger),
          this.storage = null != J && J.storage ? J.storage : new index_es_h(index_es_Jt(index_es_Jt({}, nL), J?.storageOptions)),
          this.relayer = new index_es_Ft({
            core: this,
            logger: this.logger,
            relayUrl: this.relayUrl,
            projectId: this.projectId
          }),
          this.pairing = new index_es_Bt(this, this.logger),
          this.verify = new index_es_qt(this.projectId || "", this.logger),
          this.echoClient = new index_es_Gt(this.projectId || "", this.logger)
      }
      static async init(J) {
        let et = new index_es_te(J);
        await et.initialize();
        let eo = await et.crypto.getClientId();
        return await et.storage.setItem("WALLETCONNECT_CLIENT_ID", eo),
          et
      }
      get context() {
        return (0,
          rP.getLoggerContext)(this.logger)
      }
      async start() {
        this.initialized || await this.initialize()
      }
      async initialize() {
        this.logger.trace("Initialized");
        try {
          await this.crypto.init(),
            await this.history.init(),
            await this.expirer.init(),
            await this.relayer.init(),
            await this.heartbeat.init(),
            await this.pairing.init(),
            this.initialized = !0,
            this.logger.info("Core Initialization Success")
        } catch (J) {
          throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, J),
          this.logger.error(J.message),
          J
        }
      }
    }
      ;
    let iy = "client"
      , ib = `wc@2:${iy}:`
      , iw = {
        name: iy,
        logger: "error"
      }
      , i_ = "WALLETCONNECT_DEEPLINK_CHOICE"
      , ix = "Proposal expired"
      , iE = t0.SEVEN_DAYS
      , iC = {
        wc_sessionPropose: {
          req: {
            ttl: t0.FIVE_MINUTES,
            prompt: !0,
            tag: 1100
          },
          res: {
            ttl: t0.FIVE_MINUTES,
            prompt: !1,
            tag: 1101
          }
        },
        wc_sessionSettle: {
          req: {
            ttl: t0.FIVE_MINUTES,
            prompt: !1,
            tag: 1102
          },
          res: {
            ttl: t0.FIVE_MINUTES,
            prompt: !1,
            tag: 1103
          }
        },
        wc_sessionUpdate: {
          req: {
            ttl: t0.ONE_DAY,
            prompt: !1,
            tag: 1104
          },
          res: {
            ttl: t0.ONE_DAY,
            prompt: !1,
            tag: 1105
          }
        },
        wc_sessionExtend: {
          req: {
            ttl: t0.ONE_DAY,
            prompt: !1,
            tag: 1106
          },
          res: {
            ttl: t0.ONE_DAY,
            prompt: !1,
            tag: 1107
          }
        },
        wc_sessionRequest: {
          req: {
            ttl: t0.FIVE_MINUTES,
            prompt: !0,
            tag: 1108
          },
          res: {
            ttl: t0.FIVE_MINUTES,
            prompt: !1,
            tag: 1109
          }
        },
        wc_sessionEvent: {
          req: {
            ttl: t0.FIVE_MINUTES,
            prompt: !0,
            tag: 1110
          },
          res: {
            ttl: t0.FIVE_MINUTES,
            prompt: !1,
            tag: 1111
          }
        },
        wc_sessionDelete: {
          req: {
            ttl: t0.ONE_DAY,
            prompt: !1,
            tag: 1112
          },
          res: {
            ttl: t0.ONE_DAY,
            prompt: !1,
            tag: 1113
          }
        },
        wc_sessionPing: {
          req: {
            ttl: t0.THIRTY_SECONDS,
            prompt: !1,
            tag: 1114
          },
          res: {
            ttl: t0.THIRTY_SECONDS,
            prompt: !1,
            tag: 1115
          }
        }
      }
      , iS = {
        min: t0.FIVE_MINUTES,
        max: t0.SEVEN_DAYS
      }
      , ik = {
        idle: "IDLE",
        active: "ACTIVE"
      }
      , iT = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest"];
    var iA = Object.defineProperty
      , iP = Object.defineProperties
      , iR = Object.getOwnPropertyDescriptors
      , iI = Object.getOwnPropertySymbols
      , iO = Object.prototype.hasOwnProperty
      , iN = Object.prototype.propertyIsEnumerable
      , index_es_de = (J, et, eo) => et in J ? iA(J, et, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: eo
      }) : J[et] = eo
      , dist_index_es_g = (J, et) => {
        for (var eo in et || (et = {}))
          iO.call(et, eo) && index_es_de(J, eo, et[eo]);
        if (iI)
          for (var eo of iI(et))
            iN.call(et, eo) && index_es_de(J, eo, et[eo]);
        return J
      }
      , dist_index_es_b = (J, et) => iP(J, iR(et));
    let index_es_ds = class index_es_ds extends index_es_w {
      constructor(J) {
        super(J),
          this.name = "engine",
          this.events = new (e0()),
          this.initialized = !1,
          this.ignoredPayloadTypes = [1],
          this.requestQueue = {
            state: ik.idle,
            queue: []
          },
          this.sessionRequestQueue = {
            state: ik.idle,
            queue: []
          },
          this.requestQueueDelay = t0.ONE_SECOND,
          this.init = async () => {
            this.initialized || (await this.cleanup(),
              this.registerRelayerEvents(),
              this.registerExpirerEvents(),
              this.registerPairingEvents(),
              this.client.core.pairing.register({
                methods: Object.keys(iC)
              }),
              this.initialized = !0,
              setTimeout(() => {
                this.sessionRequestQueue.queue = this.getPendingSessionRequests(),
                  this.processSessionRequestQueue()
              }
                , (0,
                  t0.toMiliseconds)(this.requestQueueDelay)))
          }
          ,
          this.connect = async J => {
            await this.isInitialized();
            let et = dist_index_es_b(dist_index_es_g({}, J), {
              requiredNamespaces: J.requiredNamespaces || {},
              optionalNamespaces: J.optionalNamespaces || {}
            });
            await this.isValidConnect(et);
            let { pairingTopic: eo, requiredNamespaces: el, optionalNamespaces: ec, sessionProperties: ed, relays: eh } = et, ep = eo, ef, em = !1;
            if (ep && (em = this.client.core.pairing.pairings.get(ep).active),
              !ep || !em) {
              let { topic: J, uri: et } = await this.client.core.pairing.create();
              ep = J,
                ef = et
            }
            let eg = await this.client.core.crypto.generateKeyPair()
              , ey = dist_index_es_g({
                requiredNamespaces: el,
                optionalNamespaces: ec,
                relays: eh ?? [{
                  protocol: "irn"
                }],
                proposer: {
                  publicKey: eg,
                  metadata: this.client.metadata
                }
              }, ed && {
                sessionProperties: ed
              })
              , { reject: eb, resolve: ew, done: e_ } = at(t0.FIVE_MINUTES, ix);
            if (this.events.once(yt("session_connect"), async ({ error: J, session: et }) => {
              if (J)
                eb(J);
              else if (et) {
                et.self.publicKey = eg;
                let J = dist_index_es_b(dist_index_es_g({}, et), {
                  requiredNamespaces: et.requiredNamespaces,
                  optionalNamespaces: et.optionalNamespaces
                });
                await this.client.session.set(et.topic, J),
                  await this.setExpiry(et.topic, et.expiry),
                  ep && await this.client.core.pairing.updateMetadata({
                    topic: ep,
                    metadata: et.peer.metadata
                  }),
                  ew(J)
              }
            }
            ),
              !ep) {
              let { message: J } = N("NO_MATCHING_KEY", `connect() pairing topic: ${ep}`);
              throw Error(J)
            }
            let ex = await this.sendRequest({
              topic: ep,
              method: "wc_sessionPropose",
              params: ey
            })
              , eE = pt(t0.FIVE_MINUTES);
            return await this.setProposal(ex, dist_index_es_g({
              id: ex,
              expiry: eE
            }, ey)),
            {
              uri: ef,
              approval: e_
            }
          }
          ,
          this.pair = async J => (await this.isInitialized(),
            await this.client.core.pairing.pair(J)),
          this.approve = async J => {
            await this.isInitialized(),
              await this.isValidApprove(J);
            let { id: et, relayProtocol: eo, namespaces: el, sessionProperties: ec } = J
              , ed = this.client.proposal.get(et)
              , { pairingTopic: eh, proposer: ep, requiredNamespaces: ef, optionalNamespaces: em } = ed;
            eh = eh || "",
              B(ef) || (ef = function (J, et) {
                let eo = ln(J, et);
                if (eo)
                  throw Error(eo.message);
                let el = {};
                for (let [et, eo] of Object.entries(J))
                  el[et] = {
                    methods: eo.methods,
                    events: eo.events,
                    chains: eo.accounts.map(J => `${J.split(":")[0]}:${J.split(":")[1]}`)
                  };
                return el
              }(el, "approve()"));
            let eg = await this.client.core.crypto.generateKeyPair()
              , ey = ep.publicKey
              , eb = await this.client.core.crypto.generateSharedKey(eg, ey);
            eh && et && (await this.client.core.pairing.updateMetadata({
              topic: eh,
              metadata: ep.metadata
            }),
              await this.sendResult({
                id: et,
                topic: eh,
                result: {
                  relay: {
                    protocol: eo ?? "irn"
                  },
                  responderPublicKey: eg
                }
              }),
              await this.client.proposal.delete(et, index_es_U("USER_DISCONNECTED")),
              await this.client.core.pairing.activate({
                topic: eh
              }));
            let ew = dist_index_es_g({
              relay: {
                protocol: eo ?? "irn"
              },
              namespaces: el,
              requiredNamespaces: ef,
              optionalNamespaces: em,
              pairingTopic: eh,
              controller: {
                publicKey: eg,
                metadata: this.client.metadata
              },
              expiry: pt(iE)
            }, ec && {
              sessionProperties: ec
            });
            await this.client.core.relayer.subscribe(eb),
              await this.sendRequest({
                topic: eb,
                method: "wc_sessionSettle",
                params: ew,
                throwOnFailedPublish: !0
              });
            let e_ = dist_index_es_b(dist_index_es_g({}, ew), {
              topic: eb,
              pairingTopic: eh,
              acknowledged: !1,
              self: ew.controller,
              peer: {
                publicKey: ep.publicKey,
                metadata: ep.metadata
              },
              controller: eg
            });
            return await this.client.session.set(eb, e_),
              await this.setExpiry(eb, pt(iE)),
            {
              topic: eb,
              acknowledged: () => new Promise(J => setTimeout(() => J(this.client.session.get(eb)), 500))
            }
          }
          ,
          this.reject = async J => {
            await this.isInitialized(),
              await this.isValidReject(J);
            let { id: et, reason: eo } = J
              , { pairingTopic: el } = this.client.proposal.get(et);
            el && (await this.sendError(et, el, eo),
              await this.client.proposal.delete(et, index_es_U("USER_DISCONNECTED")))
          }
          ,
          this.update = async J => {
            await this.isInitialized(),
              await this.isValidUpdate(J);
            let { topic: et, namespaces: eo } = J
              , el = await this.sendRequest({
                topic: et,
                method: "wc_sessionUpdate",
                params: {
                  namespaces: eo
                }
              })
              , { done: ec, resolve: ed, reject: eh } = at();
            return this.events.once(yt("session_update", el), ({ error: J }) => {
              J ? eh(J) : ed()
            }
            ),
              await this.client.session.update(et, {
                namespaces: eo
              }),
            {
              acknowledged: ec
            }
          }
          ,
          this.extend = async J => {
            await this.isInitialized(),
              await this.isValidExtend(J);
            let { topic: et } = J
              , eo = await this.sendRequest({
                topic: et,
                method: "wc_sessionExtend",
                params: {}
              })
              , { done: el, resolve: ec, reject: ed } = at();
            return this.events.once(yt("session_extend", eo), ({ error: J }) => {
              J ? ed(J) : ec()
            }
            ),
              await this.setExpiry(et, pt(iE)),
            {
              acknowledged: el
            }
          }
          ,
          this.request = async J => {
            await this.isInitialized(),
              await this.isValidRequest(J);
            let { chainId: et, request: eo, topic: el, expiry: ec } = J
              , ed = payloadId()
              , { done: eh, resolve: ep, reject: ef } = at(ec, "Request expired. Please try again.");
            return this.events.once(yt("session_request", ed), ({ error: J, result: et }) => {
              J ? ef(J) : ep(et)
            }
            ),
              await Promise.all([new Promise(async J => {
                await this.sendRequest({
                  clientRpcId: ed,
                  topic: el,
                  method: "wc_sessionRequest",
                  params: {
                    request: eo,
                    chainId: et
                  },
                  expiry: ec,
                  throwOnFailedPublish: !0
                }).catch(J => ef(J)),
                  this.client.events.emit("session_request_sent", {
                    topic: el,
                    request: eo,
                    chainId: et,
                    id: ed
                  }),
                  J()
              }
              ), new Promise(async J => {
                let et = await gt(this.client.core.storage, i_);
                ht({
                  id: ed,
                  topic: el,
                  wcDeepLink: et
                }),
                  J()
              }
              ), eh()]).then(J => J[2])
          }
          ,
          this.respond = async J => {
            await this.isInitialized(),
              await this.isValidRespond(J);
            let { topic: et, response: eo } = J
              , { id: el } = eo;
            isJsonRpcResult(eo) ? await this.sendResult({
              id: el,
              topic: et,
              result: eo.result,
              throwOnFailedPublish: !0
            }) : isJsonRpcError(eo) && await this.sendError(el, et, eo.error),
              this.cleanupAfterResponse(J)
          }
          ,
          this.ping = async J => {
            await this.isInitialized(),
              await this.isValidPing(J);
            let { topic: et } = J;
            if (this.client.session.keys.includes(et)) {
              let J = await this.sendRequest({
                topic: et,
                method: "wc_sessionPing",
                params: {}
              })
                , { done: eo, resolve: el, reject: ec } = at();
              this.events.once(yt("session_ping", J), ({ error: J }) => {
                J ? ec(J) : el()
              }
              ),
                await eo()
            } else
              this.client.core.pairing.pairings.keys.includes(et) && await this.client.core.pairing.ping({
                topic: et
              })
          }
          ,
          this.emit = async J => {
            await this.isInitialized(),
              await this.isValidEmit(J);
            let { topic: et, event: eo, chainId: el } = J;
            await this.sendRequest({
              topic: et,
              method: "wc_sessionEvent",
              params: {
                event: eo,
                chainId: el
              }
            })
          }
          ,
          this.disconnect = async J => {
            await this.isInitialized(),
              await this.isValidDisconnect(J);
            let { topic: et } = J;
            this.client.session.keys.includes(et) ? (await this.sendRequest({
              topic: et,
              method: "wc_sessionDelete",
              params: index_es_U("USER_DISCONNECTED"),
              throwOnFailedPublish: !0
            }),
              await this.deleteSession(et)) : await this.client.core.pairing.disconnect({
                topic: et
              })
          }
          ,
          this.find = J => (this.isInitialized(),
            this.client.session.getAll().filter(et => (function (J, et) {
              let { requiredNamespaces: eo } = et
                , el = Object.keys(J.namespaces)
                , ec = Object.keys(eo)
                , ed = !0;
              return !!O(ec, el) && (el.forEach(et => {
                let { accounts: el, methods: ec, events: eh } = J.namespaces[et]
                  , ep = A(el)
                  , ef = eo[et];
                O(L(et, ef), ep) && O(ef.methods, ec) && O(ef.events, eh) || (ed = !1)
              }
              ),
                ed)
            }
            )(et, J))),
          this.getPendingSessionRequests = () => (this.isInitialized(),
            this.client.pendingRequest.getAll()),
          this.cleanupDuplicatePairings = async J => {
            if (J.pairingTopic)
              try {
                let et = this.client.core.pairing.pairings.get(J.pairingTopic)
                  , eo = this.client.core.pairing.pairings.getAll().filter(eo => {
                    var el, ec;
                    return (null == (el = eo.peerMetadata) ? void 0 : el.url) && (null == (ec = eo.peerMetadata) ? void 0 : ec.url) === J.peer.metadata.url && eo.topic && eo.topic !== et.topic
                  }
                  );
                if (0 === eo.length)
                  return;
                this.client.logger.info(`Cleaning up ${eo.length} duplicate pairing(s)`),
                  await Promise.all(eo.map(J => this.client.core.pairing.disconnect({
                    topic: J.topic
                  }))),
                  this.client.logger.info("Duplicate pairings clean up finished")
              } catch (J) {
                this.client.logger.error(J)
              }
          }
          ,
          this.deleteSession = async (J, et) => {
            let { self: eo } = this.client.session.get(J);
            await this.client.core.relayer.unsubscribe(J),
              this.client.session.delete(J, index_es_U("USER_DISCONNECTED")),
              this.client.core.crypto.keychain.has(eo.publicKey) && await this.client.core.crypto.deleteKeyPair(eo.publicKey),
              this.client.core.crypto.keychain.has(J) && await this.client.core.crypto.deleteSymKey(J),
              et || this.client.core.expirer.del(J),
              this.client.core.storage.removeItem(i_).catch(J => this.client.logger.warn(J)),
              this.getPendingSessionRequests().forEach(et => {
                et.topic === J && this.deletePendingSessionRequest(et.id, index_es_U("USER_DISCONNECTED"))
              }
              )
          }
          ,
          this.deleteProposal = async (J, et) => {
            await Promise.all([this.client.proposal.delete(J, index_es_U("USER_DISCONNECTED")), et ? Promise.resolve() : this.client.core.expirer.del(J)])
          }
          ,
          this.deletePendingSessionRequest = async (J, et, eo = !1) => {
            await Promise.all([this.client.pendingRequest.delete(J, et), eo ? Promise.resolve() : this.client.core.expirer.del(J)]),
              this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter(et => et.id !== J),
              eo && (this.sessionRequestQueue.state = ik.idle)
          }
          ,
          this.setExpiry = async (J, et) => {
            this.client.session.keys.includes(J) && await this.client.session.update(J, {
              expiry: et
            }),
              this.client.core.expirer.set(J, et)
          }
          ,
          this.setProposal = async (J, et) => {
            await this.client.proposal.set(J, et),
              this.client.core.expirer.set(J, et.expiry)
          }
          ,
          this.setPendingSessionRequest = async J => {
            let et = iC.wc_sessionRequest.req.ttl
              , { id: eo, topic: el, params: ec, verifyContext: ed } = J;
            await this.client.pendingRequest.set(eo, {
              id: eo,
              topic: el,
              params: ec,
              verifyContext: ed
            }),
              et && this.client.core.expirer.set(eo, pt(et))
          }
          ,
          this.sendRequest = async J => {
            let { topic: et, method: eo, params: el, expiry: ec, relayRpcId: ed, clientRpcId: eh, throwOnFailedPublish: ep } = J
              , ef = formatJsonRpcRequest(eo, el, eh);
            if (D() && iT.includes(eo)) {
              let J = Ln(JSON.stringify(ef));
              this.client.core.verify.register({
                attestationId: J
              })
            }
            let em = await this.client.core.crypto.encode(et, ef)
              , eg = iC[eo].req;
            return ec && (eg.ttl = ec),
              ed && (eg.id = ed),
              this.client.core.history.set(et, ef),
              ep ? (eg.internal = dist_index_es_b(dist_index_es_g({}, eg.internal), {
                throwOnFailedPublish: !0
              }),
                await this.client.core.relayer.publish(et, em, eg)) : this.client.core.relayer.publish(et, em, eg).catch(J => this.client.logger.error(J)),
              ef.id
          }
          ,
          this.sendResult = async J => {
            let { id: et, topic: eo, result: el, throwOnFailedPublish: ec } = J
              , ed = formatJsonRpcResult(et, el)
              , eh = await this.client.core.crypto.encode(eo, ed)
              , ep = await this.client.core.history.get(eo, et)
              , ef = iC[ep.request.method].res;
            ec ? (ef.internal = dist_index_es_b(dist_index_es_g({}, ef.internal), {
              throwOnFailedPublish: !0
            }),
              await this.client.core.relayer.publish(eo, eh, ef)) : this.client.core.relayer.publish(eo, eh, ef).catch(J => this.client.logger.error(J)),
              await this.client.core.history.resolve(ed)
          }
          ,
          this.sendError = async (J, et, eo) => {
            let el = formatJsonRpcError(J, eo)
              , ec = await this.client.core.crypto.encode(et, el)
              , ed = await this.client.core.history.get(et, J)
              , eh = iC[ed.request.method].res;
            this.client.core.relayer.publish(et, ec, eh),
              await this.client.core.history.resolve(el)
          }
          ,
          this.cleanup = async () => {
            let J = []
              , et = [];
            this.client.session.getAll().forEach(et => {
              mt(et.expiry) && J.push(et.topic)
            }
            ),
              this.client.proposal.getAll().forEach(J => {
                mt(J.expiry) && et.push(J.id)
              }
              ),
              await Promise.all([...J.map(J => this.deleteSession(J)), ...et.map(J => this.deleteProposal(J))])
          }
          ,
          this.onRelayEventRequest = async J => {
            this.requestQueue.queue.push(J),
              await this.processRequestsQueue()
          }
          ,
          this.processRequestsQueue = async () => {
            if (this.requestQueue.state === ik.active) {
              this.client.logger.info("Request queue already active, skipping...");
              return
            }
            for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0;) {
              this.requestQueue.state = ik.active;
              let J = this.requestQueue.queue.shift();
              if (J)
                try {
                  this.processRequest(J),
                    await new Promise(J => setTimeout(J, 300))
                } catch (J) {
                  this.client.logger.warn(J)
                }
            }
            this.requestQueue.state = ik.idle
          }
          ,
          this.processRequest = J => {
            let { topic: et, payload: eo } = J
              , el = eo.method;
            switch (el) {
              case "wc_sessionPropose":
                return this.onSessionProposeRequest(et, eo);
              case "wc_sessionSettle":
                return this.onSessionSettleRequest(et, eo);
              case "wc_sessionUpdate":
                return this.onSessionUpdateRequest(et, eo);
              case "wc_sessionExtend":
                return this.onSessionExtendRequest(et, eo);
              case "wc_sessionPing":
                return this.onSessionPingRequest(et, eo);
              case "wc_sessionDelete":
                return this.onSessionDeleteRequest(et, eo);
              case "wc_sessionRequest":
                return this.onSessionRequest(et, eo);
              case "wc_sessionEvent":
                return this.onSessionEventRequest(et, eo);
              default:
                return this.client.logger.info(`Unsupported request method ${el}`)
            }
          }
          ,
          this.onRelayEventResponse = async J => {
            let { topic: et, payload: eo } = J
              , el = (await this.client.core.history.get(et, eo.id)).request.method;
            switch (el) {
              case "wc_sessionPropose":
                return this.onSessionProposeResponse(et, eo);
              case "wc_sessionSettle":
                return this.onSessionSettleResponse(et, eo);
              case "wc_sessionUpdate":
                return this.onSessionUpdateResponse(et, eo);
              case "wc_sessionExtend":
                return this.onSessionExtendResponse(et, eo);
              case "wc_sessionPing":
                return this.onSessionPingResponse(et, eo);
              case "wc_sessionRequest":
                return this.onSessionRequestResponse(et, eo);
              default:
                return this.client.logger.info(`Unsupported response method ${el}`)
            }
          }
          ,
          this.onRelayEventUnknownPayload = J => {
            let { topic: et } = J
              , { message: eo } = N("MISSING_OR_INVALID", `Decoded payload on topic ${et} is not identifiable as a JSON-RPC request or a response.`);
            throw Error(eo)
          }
          ,
          this.onSessionProposeRequest = async (J, et) => {
            let { params: eo, id: el } = et;
            try {
              this.isValidConnect(dist_index_es_g({}, et.params));
              let ec = pt(t0.FIVE_MINUTES)
                , ed = dist_index_es_g({
                  id: el,
                  pairingTopic: J,
                  expiry: ec
                }, eo);
              await this.setProposal(el, ed);
              let eh = Ln(JSON.stringify(et))
                , ep = await this.getVerifyContext(eh, ed.proposer.metadata);
              this.client.events.emit("session_proposal", {
                id: el,
                params: ed,
                verifyContext: ep
              })
            } catch (et) {
              await this.sendError(el, J, et),
                this.client.logger.error(et)
            }
          }
          ,
          this.onSessionProposeResponse = async (J, et) => {
            let { id: eo } = et;
            if (isJsonRpcResult(et)) {
              let { result: el } = et;
              this.client.logger.trace({
                type: "method",
                method: "onSessionProposeResponse",
                result: el
              });
              let ec = this.client.proposal.get(eo);
              this.client.logger.trace({
                type: "method",
                method: "onSessionProposeResponse",
                proposal: ec
              });
              let ed = ec.proposer.publicKey;
              this.client.logger.trace({
                type: "method",
                method: "onSessionProposeResponse",
                selfPublicKey: ed
              });
              let eh = el.responderPublicKey;
              this.client.logger.trace({
                type: "method",
                method: "onSessionProposeResponse",
                peerPublicKey: eh
              });
              let ep = await this.client.core.crypto.generateSharedKey(ed, eh);
              this.client.logger.trace({
                type: "method",
                method: "onSessionProposeResponse",
                sessionTopic: ep
              });
              let ef = await this.client.core.relayer.subscribe(ep);
              this.client.logger.trace({
                type: "method",
                method: "onSessionProposeResponse",
                subscriptionId: ef
              }),
                await this.client.core.pairing.activate({
                  topic: J
                })
            } else
              isJsonRpcError(et) && (await this.client.proposal.delete(eo, index_es_U("USER_DISCONNECTED")),
                this.events.emit(yt("session_connect"), {
                  error: et.error
                }))
          }
          ,
          this.onSessionSettleRequest = async (J, et) => {
            let { id: eo, params: el } = et;
            try {
              this.isValidSessionSettleRequest(el);
              let { relay: eo, controller: ec, expiry: ed, namespaces: eh, requiredNamespaces: ep, optionalNamespaces: ef, sessionProperties: em, pairingTopic: eg } = et.params
                , ey = dist_index_es_g({
                  topic: J,
                  relay: eo,
                  expiry: ed,
                  namespaces: eh,
                  acknowledged: !0,
                  pairingTopic: eg,
                  requiredNamespaces: ep,
                  optionalNamespaces: ef,
                  controller: ec.publicKey,
                  self: {
                    publicKey: "",
                    metadata: this.client.metadata
                  },
                  peer: {
                    publicKey: ec.publicKey,
                    metadata: ec.metadata
                  }
                }, em && {
                  sessionProperties: em
                });
              await this.sendResult({
                id: et.id,
                topic: J,
                result: !0
              }),
                this.events.emit(yt("session_connect"), {
                  session: ey
                }),
                this.cleanupDuplicatePairings(ey)
            } catch (et) {
              await this.sendError(eo, J, et),
                this.client.logger.error(et)
            }
          }
          ,
          this.onSessionSettleResponse = async (J, et) => {
            let { id: eo } = et;
            isJsonRpcResult(et) ? (await this.client.session.update(J, {
              acknowledged: !0
            }),
              this.events.emit(yt("session_approve", eo), {})) : isJsonRpcError(et) && (await this.client.session.delete(J, index_es_U("USER_DISCONNECTED")),
                this.events.emit(yt("session_approve", eo), {
                  error: et.error
                }))
          }
          ,
          this.onSessionUpdateRequest = async (J, et) => {
            let { params: eo, id: el } = et;
            try {
              let et = `${J}_session_update`
                , ec = tr.get(et);
              if (ec && this.isRequestOutOfSync(ec, el)) {
                this.client.logger.info(`Discarding out of sync request - ${el}`);
                return
              }
              this.isValidUpdate(dist_index_es_g({
                topic: J
              }, eo)),
                await this.client.session.update(J, {
                  namespaces: eo.namespaces
                }),
                await this.sendResult({
                  id: el,
                  topic: J,
                  result: !0
                }),
                this.client.events.emit("session_update", {
                  id: el,
                  topic: J,
                  params: eo
                }),
                tr.set(et, el)
            } catch (et) {
              await this.sendError(el, J, et),
                this.client.logger.error(et)
            }
          }
          ,
          this.isRequestOutOfSync = (J, et) => parseInt(et.toString().slice(0, -3)) <= parseInt(J.toString().slice(0, -3)),
          this.onSessionUpdateResponse = (J, et) => {
            let { id: eo } = et;
            isJsonRpcResult(et) ? this.events.emit(yt("session_update", eo), {}) : isJsonRpcError(et) && this.events.emit(yt("session_update", eo), {
              error: et.error
            })
          }
          ,
          this.onSessionExtendRequest = async (J, et) => {
            let { id: eo } = et;
            try {
              this.isValidExtend({
                topic: J
              }),
                await this.setExpiry(J, pt(iE)),
                await this.sendResult({
                  id: eo,
                  topic: J,
                  result: !0
                }),
                this.client.events.emit("session_extend", {
                  id: eo,
                  topic: J
                })
            } catch (et) {
              await this.sendError(eo, J, et),
                this.client.logger.error(et)
            }
          }
          ,
          this.onSessionExtendResponse = (J, et) => {
            let { id: eo } = et;
            isJsonRpcResult(et) ? this.events.emit(yt("session_extend", eo), {}) : isJsonRpcError(et) && this.events.emit(yt("session_extend", eo), {
              error: et.error
            })
          }
          ,
          this.onSessionPingRequest = async (J, et) => {
            let { id: eo } = et;
            try {
              this.isValidPing({
                topic: J
              }),
                await this.sendResult({
                  id: eo,
                  topic: J,
                  result: !0
                }),
                this.client.events.emit("session_ping", {
                  id: eo,
                  topic: J
                })
            } catch (et) {
              await this.sendError(eo, J, et),
                this.client.logger.error(et)
            }
          }
          ,
          this.onSessionPingResponse = (J, et) => {
            let { id: eo } = et;
            setTimeout(() => {
              isJsonRpcResult(et) ? this.events.emit(yt("session_ping", eo), {}) : isJsonRpcError(et) && this.events.emit(yt("session_ping", eo), {
                error: et.error
              })
            }
              , 500)
          }
          ,
          this.onSessionDeleteRequest = async (J, et) => {
            let { id: eo } = et;
            try {
              this.isValidDisconnect({
                topic: J,
                reason: et.params
              }),
                await Promise.all([new Promise(et => {
                  this.client.core.relayer.once(nH.publish, async () => {
                    et(await this.deleteSession(J))
                  }
                  )
                }
                ), this.sendResult({
                  id: eo,
                  topic: J,
                  result: !0
                })]),
                this.client.events.emit("session_delete", {
                  id: eo,
                  topic: J
                })
            } catch (J) {
              this.client.logger.error(J)
            }
          }
          ,
          this.onSessionRequest = async (J, et) => {
            let { id: eo, params: el } = et;
            try {
              this.isValidRequest(dist_index_es_g({
                topic: J
              }, el));
              let et = Ln(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", el, eo)))
                , ec = this.client.session.get(J)
                , ed = await this.getVerifyContext(et, ec.peer.metadata)
                , eh = {
                  id: eo,
                  topic: J,
                  params: el,
                  verifyContext: ed
                };
              await this.setPendingSessionRequest(eh),
                this.addSessionRequestToSessionRequestQueue(eh),
                this.processSessionRequestQueue()
            } catch (et) {
              await this.sendError(eo, J, et),
                this.client.logger.error(et)
            }
          }
          ,
          this.onSessionRequestResponse = (J, et) => {
            let { id: eo } = et;
            isJsonRpcResult(et) ? this.events.emit(yt("session_request", eo), {
              result: et.result
            }) : isJsonRpcError(et) && this.events.emit(yt("session_request", eo), {
              error: et.error
            })
          }
          ,
          this.onSessionEventRequest = async (J, et) => {
            let { id: eo, params: el } = et;
            try {
              let et = `${J}_session_event_${el.event.name}`
                , ec = tr.get(et);
              if (ec && this.isRequestOutOfSync(ec, eo)) {
                this.client.logger.info(`Discarding out of sync request - ${eo}`);
                return
              }
              this.isValidEmit(dist_index_es_g({
                topic: J
              }, el)),
                this.client.events.emit("session_event", {
                  id: eo,
                  topic: J,
                  params: el
                }),
                tr.set(et, eo)
            } catch (et) {
              await this.sendError(eo, J, et),
                this.client.logger.error(et)
            }
          }
          ,
          this.addSessionRequestToSessionRequestQueue = J => {
            this.sessionRequestQueue.queue.push(J)
          }
          ,
          this.cleanupAfterResponse = J => {
            this.deletePendingSessionRequest(J.response.id, {
              message: "fulfilled",
              code: 0
            }),
              setTimeout(() => {
                this.sessionRequestQueue.state = ik.idle,
                  this.processSessionRequestQueue()
              }
                , (0,
                  t0.toMiliseconds)(this.requestQueueDelay))
          }
          ,
          this.processSessionRequestQueue = () => {
            if (this.sessionRequestQueue.state === ik.active) {
              this.client.logger.info("session request queue is already active.");
              return
            }
            let J = this.sessionRequestQueue.queue[0];
            if (!J) {
              this.client.logger.info("session request queue is empty.");
              return
            }
            try {
              this.sessionRequestQueue.state = ik.active,
                this.client.events.emit("session_request", J)
            } catch (J) {
              this.client.logger.error(J)
            }
          }
          ,
          this.onPairingCreated = J => {
            if (J.active)
              return;
            let et = this.client.proposal.getAll().find(et => et.pairingTopic === J.topic);
            et && this.onSessionProposeRequest(J.topic, formatJsonRpcRequest("wc_sessionPropose", {
              requiredNamespaces: et.requiredNamespaces,
              optionalNamespaces: et.optionalNamespaces,
              relays: et.relays,
              proposer: et.proposer,
              sessionProperties: et.sessionProperties
            }, et.id))
          }
          ,
          this.isValidConnect = async J => {
            let et;
            if (!Ht(J)) {
              let { message: et } = N("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(J)}`);
              throw Error(et)
            }
            let { pairingTopic: eo, requiredNamespaces: el, optionalNamespaces: ec, sessionProperties: ed, relays: eh } = J;
            if (w(eo) || await this.isValidPairingTopic(eo),
              et = !1,
              eh ? eh && k(eh) && eh.length && eh.forEach(J => {
                et = dn(J)
              }
              ) : et = !0,
              !et) {
              let { message: J } = N("MISSING_OR_INVALID", `connect() relays: ${eh}`);
              throw Error(J)
            }
            w(el) || 0 === B(el) || this.validateNamespaces(el, "requiredNamespaces"),
              w(ec) || 0 === B(ec) || this.validateNamespaces(ec, "optionalNamespaces"),
              w(ed) || this.validateSessionProps(ed, "sessionProperties")
          }
          ,
          this.validateNamespaces = (J, et) => {
            let eo = function (J, et, eo) {
              let el = null;
              if (J && B(J)) {
                let ec;
                let ed = ce(J, et);
                ed && (el = ed);
                let eh = (ec = null,
                  Object.entries(J).forEach(([J, el]) => {
                    var ed, eh;
                    let ep;
                    if (ec)
                      return;
                    let ef = (ed = L(J, el),
                      eh = `${et} ${eo}`,
                      ep = null,
                      k(ed) && ed.length ? ed.forEach(J => {
                        ep || V(J) || (ep = index_es_U("UNSUPPORTED_CHAINS", `${eh}, chain ${J} should be a string and conform to "namespace:chainId" format`))
                      }
                      ) : V(J) || (ep = index_es_U("UNSUPPORTED_CHAINS", `${eh}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)),
                      ep);
                    ef && (ec = ef)
                  }
                  ),
                  ec);
                eh && (el = eh)
              } else
                el = N("MISSING_OR_INVALID", `${et}, ${eo} should be an object with data`);
              return el
            }(J, "connect()", et);
            if (eo)
              throw Error(eo.message)
          }
          ,
          this.isValidApprove = async J => {
            if (!Ht(J))
              throw Error(N("MISSING_OR_INVALID", `approve() params: ${J}`).message);
            let { id: et, namespaces: eo, relayProtocol: el, sessionProperties: ec } = J;
            await this.isValidProposalId(et);
            let ed = this.client.proposal.get(et)
              , eh = ln(eo, "approve()");
            if (eh)
              throw Error(eh.message);
            let ep = fn(ed.requiredNamespaces, eo, "approve()");
            if (ep)
              throw Error(ep.message);
            if (!h(el, !0)) {
              let { message: J } = N("MISSING_OR_INVALID", `approve() relayProtocol: ${el}`);
              throw Error(J)
            }
            w(ec) || this.validateSessionProps(ec, "sessionProperties")
          }
          ,
          this.isValidReject = async J => {
            if (!Ht(J)) {
              let { message: et } = N("MISSING_OR_INVALID", `reject() params: ${J}`);
              throw Error(et)
            }
            let { id: et, reason: eo } = J;
            if (await this.isValidProposalId(et),
              !eo || "object" != typeof eo || !eo.code || !G(eo.code, !1) || !eo.message || !h(eo.message, !1)) {
              let { message: J } = N("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(eo)}`);
              throw Error(J)
            }
          }
          ,
          this.isValidSessionSettleRequest = J => {
            let et;
            if (!Ht(J)) {
              let { message: et } = N("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${J}`);
              throw Error(et)
            }
            let { relay: eo, controller: el, namespaces: ec, expiry: ed } = J;
            if (!dn(eo)) {
              let { message: J } = N("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
              throw Error(J)
            }
            let eh = (et = null,
              h(el?.publicKey, !1) || (et = N("MISSING_OR_INVALID", "onSessionSettleRequest() controller public key should be a string")),
              et);
            if (eh)
              throw Error(eh.message);
            let ep = ln(ec, "onSessionSettleRequest()");
            if (ep)
              throw Error(ep.message);
            if (mt(ed)) {
              let { message: J } = N("EXPIRED", "onSessionSettleRequest()");
              throw Error(J)
            }
          }
          ,
          this.isValidUpdate = async J => {
            if (!Ht(J)) {
              let { message: et } = N("MISSING_OR_INVALID", `update() params: ${J}`);
              throw Error(et)
            }
            let { topic: et, namespaces: eo } = J;
            await this.isValidSessionTopic(et);
            let el = this.client.session.get(et)
              , ec = ln(eo, "update()");
            if (ec)
              throw Error(ec.message);
            let ed = fn(el.requiredNamespaces, eo, "update()");
            if (ed)
              throw Error(ed.message)
          }
          ,
          this.isValidExtend = async J => {
            if (!Ht(J)) {
              let { message: et } = N("MISSING_OR_INVALID", `extend() params: ${J}`);
              throw Error(et)
            }
            let { topic: et } = J;
            await this.isValidSessionTopic(et)
          }
          ,
          this.isValidRequest = async J => {
            var et;
            if (!Ht(J)) {
              let { message: et } = N("MISSING_OR_INVALID", `request() params: ${J}`);
              throw Error(et)
            }
            let { topic: eo, request: el, chainId: ec, expiry: ed } = J;
            await this.isValidSessionTopic(eo);
            let { namespaces: eh } = this.client.session.get(eo);
            if (!zt(eh, ec)) {
              let { message: J } = N("MISSING_OR_INVALID", `request() chainId: ${ec}`);
              throw Error(J)
            }
            if (w(el) || !h(el.method, !1)) {
              let { message: J } = N("MISSING_OR_INVALID", `request() ${JSON.stringify(el)}`);
              throw Error(J)
            }
            if (!(h(et = el.method, !1) && (function (J, et) {
              let eo = [];
              return Object.values(J).forEach(J => {
                A(J.accounts).includes(et) && eo.push(...J.methods)
              }
              ),
                eo
            }
            )(eh, ec).includes(et))) {
              let { message: J } = N("MISSING_OR_INVALID", `request() method: ${el.method}`);
              throw Error(J)
            }
            if (ed && (!G(ed, !1) || !(ed <= iS.max) || !(ed >= iS.min))) {
              let { message: J } = N("MISSING_OR_INVALID", `request() expiry: ${ed}. Expiry must be a number (in seconds) between ${iS.min} and ${iS.max}`);
              throw Error(J)
            }
          }
          ,
          this.isValidRespond = async J => {
            var et;
            if (!Ht(J)) {
              let { message: et } = N("MISSING_OR_INVALID", `respond() params: ${J}`);
              throw Error(et)
            }
            let { topic: eo, response: el } = J;
            try {
              await this.isValidSessionTopic(eo)
            } catch (eo) {
              throw null != (et = J?.response) && et.id && this.cleanupAfterResponse(J),
              eo
            }
            if (w(el) || w(el.result) && w(el.error) || !G(el.id, !1) || !h(el.jsonrpc, !1)) {
              let { message: J } = N("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(el)}`);
              throw Error(J)
            }
          }
          ,
          this.isValidPing = async J => {
            if (!Ht(J)) {
              let { message: et } = N("MISSING_OR_INVALID", `ping() params: ${J}`);
              throw Error(et)
            }
            let { topic: et } = J;
            await this.isValidSessionOrPairingTopic(et)
          }
          ,
          this.isValidEmit = async J => {
            var et;
            if (!Ht(J)) {
              let { message: et } = N("MISSING_OR_INVALID", `emit() params: ${J}`);
              throw Error(et)
            }
            let { topic: eo, event: el, chainId: ec } = J;
            await this.isValidSessionTopic(eo);
            let { namespaces: ed } = this.client.session.get(eo);
            if (!zt(ed, ec)) {
              let { message: J } = N("MISSING_OR_INVALID", `emit() chainId: ${ec}`);
              throw Error(J)
            }
            if (w(el) || !h(el.name, !1)) {
              let { message: J } = N("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(el)}`);
              throw Error(J)
            }
            if (!(h(et = el.name, !1) && (function (J, et) {
              let eo = [];
              return Object.values(J).forEach(J => {
                A(J.accounts).includes(et) && eo.push(...J.events)
              }
              ),
                eo
            }
            )(ed, ec).includes(et))) {
              let { message: J } = N("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(el)}`);
              throw Error(J)
            }
          }
          ,
          this.isValidDisconnect = async J => {
            if (!Ht(J)) {
              let { message: et } = N("MISSING_OR_INVALID", `disconnect() params: ${J}`);
              throw Error(et)
            }
            let { topic: et } = J;
            await this.isValidSessionOrPairingTopic(et)
          }
          ,
          this.getVerifyContext = async (J, et) => {
            let eo = {
              verified: {
                verifyUrl: et.verifyUrl || nX,
                validation: "UNKNOWN",
                origin: et.url || ""
              }
            };
            try {
              let el = await this.client.core.verify.resolve({
                attestationId: J,
                verifyUrl: et.verifyUrl
              });
              el && (eo.verified.origin = el.origin,
                eo.verified.isScam = el.isScam,
                eo.verified.validation = el.origin === new URL(et.url).origin ? "VALID" : "INVALID")
            } catch (J) {
              this.client.logger.info(J)
            }
            return this.client.logger.info(`Verify context: ${JSON.stringify(eo)}`),
              eo
          }
          ,
          this.validateSessionProps = (J, et) => {
            Object.values(J).forEach(J => {
              if (!h(J, !1)) {
                let { message: eo } = N("MISSING_OR_INVALID", `${et} must be in Record<string, string> format. Received: ${JSON.stringify(J)}`);
                throw Error(eo)
              }
            }
            )
          }
      }
      async isInitialized() {
        if (!this.initialized) {
          let { message: J } = N("NOT_INITIALIZED", this.name);
          throw Error(J)
        }
        await this.client.core.relayer.confirmOnlineStateOrThrow()
      }
      registerRelayerEvents() {
        this.client.core.relayer.on(nH.message, async J => {
          let { topic: et, message: eo } = J;
          if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(eo)))
            return;
          let el = await this.client.core.crypto.decode(et, eo);
          try {
            isJsonRpcRequest(el) ? (this.client.core.history.set(et, el),
              this.onRelayEventRequest({
                topic: et,
                payload: el
              })) : isJsonRpcResponse(el) ? (await this.client.core.history.resolve(el),
                await this.onRelayEventResponse({
                  topic: et,
                  payload: el
                }),
                this.client.core.history.delete(et, el.id)) : this.onRelayEventUnknownPayload({
                  topic: et,
                  payload: el
                })
          } catch (J) {
            this.client.logger.error(J)
          }
        }
        )
      }
      registerExpirerEvents() {
        this.client.core.expirer.on(nJ.expired, async J => {
          let { topic: et, id: eo } = ft(J.target);
          if (eo && this.client.pendingRequest.keys.includes(eo))
            return await this.deletePendingSessionRequest(eo, N("EXPIRED"), !0);
          et ? this.client.session.keys.includes(et) && (await this.deleteSession(et, !0),
            this.client.events.emit("session_expire", {
              topic: et
            })) : eo && (await this.deleteProposal(eo, !0),
              this.client.events.emit("proposal_expire", {
                id: eo
              }))
        }
        )
      }
      registerPairingEvents() {
        this.client.core.pairing.events.on(nY.create, J => this.onPairingCreated(J))
      }
      isValidPairingTopic(J) {
        if (!h(J, !1)) {
          let { message: et } = N("MISSING_OR_INVALID", `pairing topic should be a string: ${J}`);
          throw Error(et)
        }
        if (!this.client.core.pairing.pairings.keys.includes(J)) {
          let { message: et } = N("NO_MATCHING_KEY", `pairing topic doesn't exist: ${J}`);
          throw Error(et)
        }
        if (mt(this.client.core.pairing.pairings.get(J).expiry)) {
          let { message: et } = N("EXPIRED", `pairing topic: ${J}`);
          throw Error(et)
        }
      }
      async isValidSessionTopic(J) {
        if (!h(J, !1)) {
          let { message: et } = N("MISSING_OR_INVALID", `session topic should be a string: ${J}`);
          throw Error(et)
        }
        if (!this.client.session.keys.includes(J)) {
          let { message: et } = N("NO_MATCHING_KEY", `session topic doesn't exist: ${J}`);
          throw Error(et)
        }
        if (mt(this.client.session.get(J).expiry)) {
          await this.deleteSession(J);
          let { message: et } = N("EXPIRED", `session topic: ${J}`);
          throw Error(et)
        }
      }
      async isValidSessionOrPairingTopic(J) {
        if (this.client.session.keys.includes(J))
          await this.isValidSessionTopic(J);
        else if (this.client.core.pairing.pairings.keys.includes(J))
          this.isValidPairingTopic(J);
        else if (h(J, !1)) {
          let { message: et } = N("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${J}`);
          throw Error(et)
        } else {
          let { message: et } = N("MISSING_OR_INVALID", `session or pairing topic should be a string: ${J}`);
          throw Error(et)
        }
      }
      async isValidProposalId(J) {
        if ("number" != typeof J) {
          let { message: et } = N("MISSING_OR_INVALID", `proposal id should be a number: ${J}`);
          throw Error(et)
        }
        if (!this.client.proposal.keys.includes(J)) {
          let { message: et } = N("NO_MATCHING_KEY", `proposal id doesn't exist: ${J}`);
          throw Error(et)
        }
        if (mt(this.client.proposal.get(J).expiry)) {
          await this.deleteProposal(J);
          let { message: et } = N("EXPIRED", `proposal id: ${J}`);
          throw Error(et)
        }
      }
    }
      ;
    let index_es_us = class index_es_us extends index_es_Kt {
      constructor(J, et) {
        super(J, et, "proposal", ib),
          this.core = J,
          this.logger = et
      }
    }
      ;
    let index_es_ue = class index_es_ue extends index_es_Kt {
      constructor(J, et) {
        super(J, et, "session", ib),
          this.core = J,
          this.logger = et
      }
    }
      ;
    let index_es_gs = class index_es_gs extends index_es_Kt {
      constructor(J, et) {
        super(J, et, "request", ib, J => J.id),
          this.core = J,
          this.logger = et
      }
    }
      ;
    let dist_index_es_Q = class dist_index_es_Q extends b {
      constructor(J) {
        super(J),
          this.protocol = "wc",
          this.version = 2,
          this.name = iw.name,
          this.events = new eX.EventEmitter,
          this.on = (J, et) => this.events.on(J, et),
          this.once = (J, et) => this.events.once(J, et),
          this.off = (J, et) => this.events.off(J, et),
          this.removeListener = (J, et) => this.events.removeListener(J, et),
          this.removeAllListeners = J => this.events.removeAllListeners(J),
          this.connect = async J => {
            try {
              return await this.engine.connect(J)
            } catch (J) {
              throw this.logger.error(J.message),
              J
            }
          }
          ,
          this.pair = async J => {
            try {
              return await this.engine.pair(J)
            } catch (J) {
              throw this.logger.error(J.message),
              J
            }
          }
          ,
          this.approve = async J => {
            try {
              return await this.engine.approve(J)
            } catch (J) {
              throw this.logger.error(J.message),
              J
            }
          }
          ,
          this.reject = async J => {
            try {
              return await this.engine.reject(J)
            } catch (J) {
              throw this.logger.error(J.message),
              J
            }
          }
          ,
          this.update = async J => {
            try {
              return await this.engine.update(J)
            } catch (J) {
              throw this.logger.error(J.message),
              J
            }
          }
          ,
          this.extend = async J => {
            try {
              return await this.engine.extend(J)
            } catch (J) {
              throw this.logger.error(J.message),
              J
            }
          }
          ,
          this.request = async J => {
            try {
              return await this.engine.request(J)
            } catch (J) {
              throw this.logger.error(J.message),
              J
            }
          }
          ,
          this.respond = async J => {
            try {
              return await this.engine.respond(J)
            } catch (J) {
              throw this.logger.error(J.message),
              J
            }
          }
          ,
          this.ping = async J => {
            try {
              return await this.engine.ping(J)
            } catch (J) {
              throw this.logger.error(J.message),
              J
            }
          }
          ,
          this.emit = async J => {
            try {
              return await this.engine.emit(J)
            } catch (J) {
              throw this.logger.error(J.message),
              J
            }
          }
          ,
          this.disconnect = async J => {
            try {
              return await this.engine.disconnect(J)
            } catch (J) {
              throw this.logger.error(J.message),
              J
            }
          }
          ,
          this.find = J => {
            try {
              return this.engine.find(J)
            } catch (J) {
              throw this.logger.error(J.message),
              J
            }
          }
          ,
          this.getPendingSessionRequests = () => {
            try {
              return this.engine.getPendingSessionRequests()
            } catch (J) {
              throw this.logger.error(J.message),
              J
            }
          }
          ,
          this.name = J?.name || iw.name,
          this.metadata = J?.metadata || (0,
            t2.D)() || {
            name: "",
            description: "",
            url: "",
            icons: [""]
          };
        let et = "u" > typeof J?.logger && "string" != typeof J?.logger ? J.logger : (0,
          rP.pino)((0,
            rP.getDefaultLoggerOptions)({
              level: J?.logger || iw.logger
            }));
        this.core = J?.core || new index_es_te(J),
          this.logger = (0,
            rP.generateChildLogger)(et, this.name),
          this.session = new index_es_ue(this.core, this.logger),
          this.proposal = new index_es_us(this.core, this.logger),
          this.pendingRequest = new index_es_gs(this.core, this.logger),
          this.engine = new index_es_ds(this)
      }
      static async init(J) {
        let et = new dist_index_es_Q(J);
        return await et.initialize(),
          et
      }
      get context() {
        return (0,
          rP.getLoggerContext)(this.logger)
      }
      get pairing() {
        return this.core.pairing.pairings
      }
      async initialize() {
        this.logger.trace("Initialized");
        try {
          await this.core.start(),
            await this.session.init(),
            await this.proposal.init(),
            await this.pendingRequest.init(),
            await this.engine.init(),
            this.core.verify.init({
              verifyUrl: this.metadata.verifyUrl
            }),
            this.logger.info("SignClient Initialization Success")
        } catch (J) {
          throw this.logger.info("SignClient Initialization Failure"),
          this.logger.error(J.message),
          J
        }
      }
    }
      ;
    var iM = eo(54098)
      , iD = eo.n(iM);
    let ij = {
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json"
      },
      method: "POST"
    };
    let HttpConnection = class HttpConnection {
      constructor(J, et = !1) {
        if (this.url = J,
          this.disableProviderPing = et,
          this.events = new eX.EventEmitter,
          this.isAvailable = !1,
          this.registering = !1,
          !isHttpUrl(J))
          throw Error(`Provided URL is not compatible with HTTP connection: ${J}`);
        this.url = J,
          this.disableProviderPing = et
      }
      get connected() {
        return this.isAvailable
      }
      get connecting() {
        return this.registering
      }
      on(J, et) {
        this.events.on(J, et)
      }
      once(J, et) {
        this.events.once(J, et)
      }
      off(J, et) {
        this.events.off(J, et)
      }
      removeListener(J, et) {
        this.events.removeListener(J, et)
      }
      async open(J = this.url) {
        await this.register(J)
      }
      async close() {
        if (!this.isAvailable)
          throw Error("Connection already closed");
        this.onClose()
      }
      async send(J, et) {
        this.isAvailable || await this.register();
        try {
          let et = safeJsonStringify(J)
            , eo = await iD()(this.url, Object.assign(Object.assign({}, ij), {
              body: et
            }))
            , el = await eo.json();
          this.onPayload({
            data: el
          })
        } catch (et) {
          this.onError(J.id, et)
        }
      }
      async register(J = this.url) {
        if (!isHttpUrl(J))
          throw Error(`Provided URL is not compatible with HTTP connection: ${J}`);
        if (this.registering) {
          let J = this.events.getMaxListeners();
          return (this.events.listenerCount("register_error") >= J || this.events.listenerCount("open") >= J) && this.events.setMaxListeners(J + 1),
            new Promise((J, et) => {
              this.events.once("register_error", J => {
                this.resetMaxListeners(),
                  et(J)
              }
              ),
                this.events.once("open", () => {
                  if (this.resetMaxListeners(),
                    void 0 === this.isAvailable)
                    return et(Error("HTTP connection is missing or invalid"));
                  J()
                }
                )
            }
            )
        }
        this.url = J,
          this.registering = !0;
        try {
          if (!this.disableProviderPing) {
            let et = safeJsonStringify({
              id: 1,
              jsonrpc: "2.0",
              method: "test",
              params: []
            });
            await iD()(J, Object.assign(Object.assign({}, ij), {
              body: et
            }))
          }
          this.onOpen()
        } catch (et) {
          let J = this.parseError(et);
          throw this.events.emit("register_error", J),
          this.onClose(),
          J
        }
      }
      onOpen() {
        this.isAvailable = !0,
          this.registering = !1,
          this.events.emit("open")
      }
      onClose() {
        this.isAvailable = !1,
          this.registering = !1,
          this.events.emit("close")
      }
      onPayload(J) {
        if (void 0 === J.data)
          return;
        let et = "string" == typeof J.data ? esm_safeJsonParse(J.data) : J.data;
        this.events.emit("payload", et)
      }
      onError(J, et) {
        let eo = this.parseError(et)
          , el = eo.message || eo.toString()
          , ec = formatJsonRpcError(J, el);
        this.events.emit("payload", ec)
      }
      parseError(J, et = this.url) {
        return parseConnectionError(J, et, "HTTP")
      }
      resetMaxListeners() {
        this.events.getMaxListeners() > 10 && this.events.setMaxListeners(10)
      }
    }
      ;
    let iL = "error"
      , i$ = "wc@2:universal_provider:"
      , iB = {
        DEFAULT_CHAIN_CHANGED: "default_chain_changed"
      };
    var iF = "u" > typeof globalThis ? globalThis : "u" > typeof window ? window : "u" > typeof eo.g ? eo.g : "u" > typeof self ? self : {}
      , iU = {
        exports: {}
      };
    /**
* @license
* Lodash <https://lodash.com/>
* Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
* Released under MIT license <https://lodash.com/license>
* Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
* Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
*/
    !function (J, et) {
      (function () {
        var eo, el = "Expected a function", ec = "__lodash_hash_undefined__", ed = "__lodash_placeholder__", eh = 1 / 0, ep = 0 / 0, ef = [["ary", 128], ["bind", 1], ["bindKey", 2], ["curry", 8], ["curryRight", 16], ["flip", 512], ["partial", 32], ["partialRight", 64], ["rearg", 256]], em = "[object Arguments]", eg = "[object Array]", ey = "[object Boolean]", eb = "[object Date]", ew = "[object Error]", e_ = "[object Function]", ex = "[object GeneratorFunction]", eE = "[object Map]", eC = "[object Number]", eS = "[object Object]", ek = "[object Promise]", eT = "[object RegExp]", eA = "[object Set]", eP = "[object String]", eR = "[object Symbol]", eI = "[object WeakMap]", eO = "[object ArrayBuffer]", eN = "[object DataView]", eM = "[object Float32Array]", eD = "[object Float64Array]", ej = "[object Int8Array]", eL = "[object Int16Array]", e$ = "[object Int32Array]", eB = "[object Uint8Array]", eF = "[object Uint8ClampedArray]", eU = "[object Uint16Array]", ez = "[object Uint32Array]", eH = /\b__p \+= '';/g, eV = /\b(__p \+=) '' \+/g, eW = /(__e\(.*?\)|\b__t\)) \+\n'';/g, eZ = /&(?:amp|lt|gt|quot|#39);/g, eG = /[&<>"']/g, eY = RegExp(eZ.source), eK = RegExp(eG.source), eJ = /<%-([\s\S]+?)%>/g, eQ = /<%([\s\S]+?)%>/g, eX = /<%=([\s\S]+?)%>/g, e0 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, e1 = /^\w*$/, e2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, e3 = /[\\^$.*+?()[\]{}|]/g, e5 = RegExp(e3.source), e6 = /^\s+/, e4 = /\s/, e8 = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, e7 = /\{\n\/\* \[wrapped with (.+)\] \*/, e9 = /,? & /, tn = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, to = /[()=,{}\[\]\/\s]/, ta = /\\(\\)?/g, tl = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, tc = /\w*$/, td = /^[-+]0x[0-9a-f]+$/i, th = /^0b[01]+$/i, tp = /^\[object .+?Constructor\]$/, tf = /^0o[0-7]+$/i, tm = /^(?:0|[1-9]\d*)$/, tg = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, ty = /($^)/, tb = /['\n\r\u2028\u2029\\]/g, tw = "\ud800-\udfff", t_ = "\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff", tx = "\\u2700-\\u27bf", tE = "a-z\\xdf-\\xf6\\xf8-\\xff", tC = "A-Z\\xc0-\\xd6\\xd8-\\xde", tS = "\\ufe0e\\ufe0f", tk = "\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", tT = "['’]", tA = "[" + tk + "]", tP = "[" + t_ + "]", tR = "[" + tE + "]", tI = "[^" + tw + tk + "\\d+" + tx + tE + tC + "]", tO = "\ud83c[\udffb-\udfff]", tN = "[^" + tw + "]", tM = "(?:\ud83c[\udde6-\uddff]){2}", tD = "[\ud800-\udbff][\udc00-\udfff]", tj = "[" + tC + "]", tL = "\\u200d", t$ = "(?:" + tR + "|" + tI + ")", tB = "(?:" + tT + "(?:d|ll|m|re|s|t|ve))?", tF = "(?:" + tT + "(?:D|LL|M|RE|S|T|VE))?", tU = "(?:" + tP + "|" + tO + ")?", tz = "[" + tS + "]?", tH = "(?:" + tL + "(?:" + [tN, tM, tD].join("|") + ")" + tz + tU + ")*", tV = tz + tU + tH, tW = "(?:" + ["[" + tx + "]", tM, tD].join("|") + ")" + tV, tq = "(?:" + [tN + tP + "?", tP, tM, tD, "[" + tw + "]"].join("|") + ")", tZ = RegExp(tT, "g"), tG = RegExp(tP, "g"), tY = RegExp(tO + "(?=" + tO + ")|" + tq + tV, "g"), tK = RegExp([tj + "?" + tR + "+" + tB + "(?=" + [tA, tj, "$"].join("|") + ")", "(?:" + tj + "|" + tI + ")+" + tF + "(?=" + [tA, tj + t$, "$"].join("|") + ")", tj + "?" + t$ + "+" + tB, tj + "+" + tF, "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", "\\d+", tW].join("|"), "g"), tJ = RegExp("[" + tL + tw + t_ + tS + "]"), tQ = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, tX = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"], t0 = -1, t1 = {};
        t1[eM] = t1[eD] = t1[ej] = t1[eL] = t1[e$] = t1[eB] = t1[eF] = t1[eU] = t1[ez] = !0,
          t1[em] = t1[eg] = t1[eO] = t1[ey] = t1[eN] = t1[eb] = t1[ew] = t1[e_] = t1[eE] = t1[eC] = t1[eS] = t1[eT] = t1[eA] = t1[eP] = t1[eI] = !1;
        var t2 = {};
        t2[em] = t2[eg] = t2[eO] = t2[eN] = t2[ey] = t2[eb] = t2[eM] = t2[eD] = t2[ej] = t2[eL] = t2[e$] = t2[eE] = t2[eC] = t2[eS] = t2[eT] = t2[eA] = t2[eP] = t2[eR] = t2[eB] = t2[eF] = t2[eU] = t2[ez] = !0,
          t2[ew] = t2[e_] = t2[eI] = !1;
        var t3 = {
          "\\": "\\",
          "'": "'",
          "\n": "n",
          "\r": "r",
          "\u2028": "u2028",
          "\u2029": "u2029"
        }
          , t5 = parseFloat
          , t6 = parseInt
          , t4 = "object" == typeof iF && iF && iF.Object === Object && iF
          , t8 = "object" == typeof self && self && self.Object === Object && self
          , t7 = t4 || t8 || Function("return this")()
          , t9 = et && !et.nodeType && et
          , ro = t9 && J && !J.nodeType && J
          , ra = ro && ro.exports === t9
          , rl = ra && t4.process
          , rc = function () {
            try {
              return ro && ro.require && ro.require("util").types || rl && rl.binding && rl.binding("util")
            } catch { }
          }()
          , rd = rc && rc.isArrayBuffer
          , rh = rc && rc.isDate
          , rp = rc && rc.isMap
          , rm = rc && rc.isRegExp
          , rg = rc && rc.isSet
          , ry = rc && rc.isTypedArray;
        function cn(J, et, eo) {
          switch (eo.length) {
            case 0:
              return J.call(et);
            case 1:
              return J.call(et, eo[0]);
            case 2:
              return J.call(et, eo[0], eo[1]);
            case 3:
              return J.call(et, eo[0], eo[1], eo[2])
          }
          return J.apply(et, eo)
        }
        function Vo(J, et, eo, el) {
          for (var ec = -1, ed = null == J ? 0 : J.length; ++ec < ed;) {
            var eh = J[ec];
            et(el, eh, eo(eh), J)
          }
          return el
        }
        function mn(J, et) {
          for (var eo = -1, el = null == J ? 0 : J.length; ++eo < el && !1 !== et(J[eo], eo, J);)
            ;
          return J
        }
        function As(J, et) {
          for (var eo = -1, el = null == J ? 0 : J.length; ++eo < el;)
            if (!et(J[eo], eo, J))
              return !1;
          return !0
        }
        function jn(J, et) {
          for (var eo = -1, el = null == J ? 0 : J.length, ec = 0, ed = []; ++eo < el;) {
            var eh = J[eo];
            et(eh, eo, J) && (ed[ec++] = eh)
          }
          return ed
        }
        function Ee(J, et) {
          return !!(null == J ? 0 : J.length) && Tt(J, et, 0) > -1
        }
        function Dr(J, et, eo) {
          for (var el = -1, ec = null == J ? 0 : J.length; ++el < ec;)
            if (eo(et, J[el]))
              return !0;
          return !1
        }
        function G(J, et) {
          for (var eo = -1, el = null == J ? 0 : J.length, ec = Array(el); ++eo < el;)
            ec[eo] = et(J[eo], eo, J);
          return ec
        }
        function nt(J, et) {
          for (var eo = -1, el = et.length, ec = J.length; ++eo < el;)
            J[ec + eo] = et[eo];
          return J
        }
        function Hr(J, et, eo, el) {
          var ec = -1
            , ed = null == J ? 0 : J.length;
          for (el && ed && (eo = J[++ec]); ++ec < ed;)
            eo = et(eo, J[ec], ec, J);
          return eo
        }
        function jo(J, et, eo, el) {
          var ec = null == J ? 0 : J.length;
          for (el && ec && (eo = J[--ec]); ec--;)
            eo = et(eo, J[ec], ec, J);
          return eo
        }
        function Nr(J, et) {
          for (var eo = -1, el = null == J ? 0 : J.length; ++eo < el;)
            if (et(J[eo], eo, J))
              return !0;
          return !1
        }
        var rb = $r("length");
        function Cs(J, et, eo) {
          var el;
          return eo(J, function (J, eo, ec) {
            if (et(J, eo, ec))
              return el = eo,
                !1
          }),
            el
        }
        function ye(J, et, eo, el) {
          for (var ec = J.length, ed = eo + (el ? 1 : -1); el ? ed-- : ++ed < ec;)
            if (et(J[ed], ed, J))
              return ed;
          return -1
        }
        function Tt(J, et, eo) {
          return et == et ? function (J, et, eo) {
            for (var el = eo - 1, ec = J.length; ++el < ec;)
              if (J[el] === et)
                return el;
            return -1
          }(J, et, eo) : ye(J, Is, eo)
        }
        function rf(J, et, eo, el) {
          for (var ec = eo - 1, ed = J.length; ++ec < ed;)
            if (el(J[ec], et))
              return ec;
          return -1
        }
        function Is(J) {
          return J != J
        }
        function xs(J, et) {
          var eo = null == J ? 0 : J.length;
          return eo ? Wr(J, et) / eo : ep
        }
        function $r(J) {
          return function (et) {
            return null == et ? eo : et[J]
          }
        }
        function Ur(J) {
          return function (et) {
            return null == J ? eo : J[et]
          }
        }
        function Es(J, et, eo, el, ec) {
          return ec(J, function (J, ec, ed) {
            eo = el ? (el = !1,
              J) : et(eo, J, ec, ed)
          }),
            eo
        }
        function Wr(J, et) {
          for (var el, ec = -1, ed = J.length; ++ec < ed;) {
            var eh = et(J[ec]);
            eh !== eo && (el = el === eo ? eh : el + eh)
          }
          return el
        }
        function Fr(J, et) {
          for (var eo = -1, el = Array(J); ++eo < J;)
            el[eo] = et(eo);
          return el
        }
        function ys(J) {
          return J && J.slice(0, bs(J) + 1).replace(e6, "")
        }
        function hn(J) {
          return function (et) {
            return J(et)
          }
        }
        function Mr(J, et) {
          return G(et, function (et) {
            return J[et]
          })
        }
        function jt(J, et) {
          return J.has(et)
        }
        function Ss(J, et) {
          for (var eo = -1, el = J.length; ++eo < el && Tt(et, J[eo], 0) > -1;)
            ;
          return eo
        }
        function Os(J, et) {
          for (var eo = J.length; eo-- && Tt(et, J[eo], 0) > -1;)
            ;
          return eo
        }
        var rw = Ur({
          À: "A",
          Á: "A",
          Â: "A",
          Ã: "A",
          Ä: "A",
          Å: "A",
          à: "a",
          á: "a",
          â: "a",
          ã: "a",
          ä: "a",
          å: "a",
          Ç: "C",
          ç: "c",
          Ð: "D",
          ð: "d",
          È: "E",
          É: "E",
          Ê: "E",
          Ë: "E",
          è: "e",
          é: "e",
          ê: "e",
          ë: "e",
          Ì: "I",
          Í: "I",
          Î: "I",
          Ï: "I",
          ì: "i",
          í: "i",
          î: "i",
          ï: "i",
          Ñ: "N",
          ñ: "n",
          Ò: "O",
          Ó: "O",
          Ô: "O",
          Õ: "O",
          Ö: "O",
          Ø: "O",
          ò: "o",
          ó: "o",
          ô: "o",
          õ: "o",
          ö: "o",
          ø: "o",
          Ù: "U",
          Ú: "U",
          Û: "U",
          Ü: "U",
          ù: "u",
          ú: "u",
          û: "u",
          ü: "u",
          Ý: "Y",
          ý: "y",
          ÿ: "y",
          Æ: "Ae",
          æ: "ae",
          Þ: "Th",
          þ: "th",
          ß: "ss",
          Ā: "A",
          Ă: "A",
          Ą: "A",
          ā: "a",
          ă: "a",
          ą: "a",
          Ć: "C",
          Ĉ: "C",
          Ċ: "C",
          Č: "C",
          ć: "c",
          ĉ: "c",
          ċ: "c",
          č: "c",
          Ď: "D",
          Đ: "D",
          ď: "d",
          đ: "d",
          Ē: "E",
          Ĕ: "E",
          Ė: "E",
          Ę: "E",
          Ě: "E",
          ē: "e",
          ĕ: "e",
          ė: "e",
          ę: "e",
          ě: "e",
          Ĝ: "G",
          Ğ: "G",
          Ġ: "G",
          Ģ: "G",
          ĝ: "g",
          ğ: "g",
          ġ: "g",
          ģ: "g",
          Ĥ: "H",
          Ħ: "H",
          ĥ: "h",
          ħ: "h",
          Ĩ: "I",
          Ī: "I",
          Ĭ: "I",
          Į: "I",
          İ: "I",
          ĩ: "i",
          ī: "i",
          ĭ: "i",
          į: "i",
          ı: "i",
          Ĵ: "J",
          ĵ: "j",
          Ķ: "K",
          ķ: "k",
          ĸ: "k",
          Ĺ: "L",
          Ļ: "L",
          Ľ: "L",
          Ŀ: "L",
          Ł: "L",
          ĺ: "l",
          ļ: "l",
          ľ: "l",
          ŀ: "l",
          ł: "l",
          Ń: "N",
          Ņ: "N",
          Ň: "N",
          Ŋ: "N",
          ń: "n",
          ņ: "n",
          ň: "n",
          ŋ: "n",
          Ō: "O",
          Ŏ: "O",
          Ő: "O",
          ō: "o",
          ŏ: "o",
          ő: "o",
          Ŕ: "R",
          Ŗ: "R",
          Ř: "R",
          ŕ: "r",
          ŗ: "r",
          ř: "r",
          Ś: "S",
          Ŝ: "S",
          Ş: "S",
          Š: "S",
          ś: "s",
          ŝ: "s",
          ş: "s",
          š: "s",
          Ţ: "T",
          Ť: "T",
          Ŧ: "T",
          ţ: "t",
          ť: "t",
          ŧ: "t",
          Ũ: "U",
          Ū: "U",
          Ŭ: "U",
          Ů: "U",
          Ű: "U",
          Ų: "U",
          ũ: "u",
          ū: "u",
          ŭ: "u",
          ů: "u",
          ű: "u",
          ų: "u",
          Ŵ: "W",
          ŵ: "w",
          Ŷ: "Y",
          ŷ: "y",
          Ÿ: "Y",
          Ź: "Z",
          Ż: "Z",
          Ž: "Z",
          ź: "z",
          ż: "z",
          ž: "z",
          Ĳ: "IJ",
          ĳ: "ij",
          Œ: "Oe",
          œ: "oe",
          ŉ: "'n",
          ſ: "s"
        })
          , r_ = Ur({
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#39;"
          });
        function cf(J) {
          return "\\" + t3[J]
        }
        function Lt(J) {
          return tJ.test(J)
        }
        function qr(J) {
          var et = -1
            , eo = Array(J.size);
          return J.forEach(function (J, el) {
            eo[++et] = [el, J]
          }),
            eo
        }
        function Rs(J, et) {
          return function (eo) {
            return J(et(eo))
          }
        }
        function tt(J, et) {
          for (var eo = -1, el = J.length, ec = 0, eh = []; ++eo < el;) {
            var ep = J[eo];
            (ep === et || ep === ed) && (J[eo] = ed,
              eh[ec++] = eo)
          }
          return eh
        }
        function Se(J) {
          var et = -1
            , eo = Array(J.size);
          return J.forEach(function (J) {
            eo[++et] = J
          }),
            eo
        }
        function Dt(J) {
          return Lt(J) ? function (J) {
            for (var et = tY.lastIndex = 0; tY.test(J);)
              ++et;
            return et
          }(J) : rb(J)
        }
        function On(J) {
          return Lt(J) ? J.match(tY) || [] : J.split("")
        }
        function bs(J) {
          for (var et = J.length; et-- && e4.test(J.charAt(et));)
            ;
          return et
        }
        var rx = Ur({
          "&amp;": "&",
          "&lt;": "<",
          "&gt;": ">",
          "&quot;": '"',
          "&#39;": "'"
        })
          , rE = function h(J) {
            var et, e4, tw, t_, tx = (J = null == J ? t7 : rE.defaults(t7.Object(), J, rE.pick(t7, tX))).Array, tE = J.Date, tC = J.Error, tS = J.Function, tk = J.Math, tT = J.Object, tA = J.RegExp, tP = J.String, tR = J.TypeError, tI = tx.prototype, tO = tS.prototype, tN = tT.prototype, tM = J["__core-js_shared__"], tD = tO.toString, tj = tN.hasOwnProperty, tL = 0, t$ = (et = /[^.]+$/.exec(tM && tM.keys && tM.keys.IE_PROTO || "")) ? "Symbol(src)_1." + et : "", tB = tN.toString, tF = tD.call(tT), tU = t7._, tz = tA("^" + tD.call(tj).replace(e3, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), tH = ra ? J.Buffer : eo, tV = J.Symbol, tW = J.Uint8Array, tq = tH ? tH.allocUnsafe : eo, tY = Rs(tT.getPrototypeOf, tT), tJ = tT.create, t3 = tN.propertyIsEnumerable, t4 = tI.splice, t8 = tV ? tV.isConcatSpreadable : eo, t9 = tV ? tV.iterator : eo, ro = tV ? tV.toStringTag : eo, rl = function () {
              try {
                var J = mt(tT, "defineProperty");
                return J({}, "", {}),
                  J
              } catch { }
            }(), rc = J.clearTimeout !== t7.clearTimeout && J.clearTimeout, rb = tE && tE.now !== t7.Date.now && tE.now, rC = J.setTimeout !== t7.setTimeout && J.setTimeout, rS = tk.ceil, rk = tk.floor, rT = tT.getOwnPropertySymbols, rA = tH ? tH.isBuffer : eo, rP = J.isFinite, rR = tI.join, rI = Rs(tT.keys, tT), rO = tk.max, rN = tk.min, rM = tE.now, rD = J.parseInt, rj = tk.random, rL = tI.reverse, r$ = mt(J, "DataView"), rB = mt(J, "Map"), rF = mt(J, "Promise"), rU = mt(J, "Set"), rz = mt(J, "WeakMap"), rH = mt(tT, "create"), rV = rz && new rz, rW = {}, rq = wt(r$), rZ = wt(rB), rG = wt(rF), rY = wt(rU), rK = wt(rz), rJ = tV ? tV.prototype : eo, rQ = rJ ? rJ.valueOf : eo, rX = rJ ? rJ.toString : eo;
            function a(J) {
              if (Y(J) && !nX(J) && !(J instanceof H)) {
                if (J instanceof Pn)
                  return J;
                if (tj.call(J, "__wrapped__"))
                  return Fu(J)
              }
              return new Pn(J)
            }
            var r0 = function () {
              function n() { }
              return function (J) {
                if (!K(J))
                  return {};
                if (tJ)
                  return tJ(J);
                n.prototype = J;
                var et = new n;
                return n.prototype = eo,
                  et
              }
            }();
            function qe() { }
            function Pn(J, et) {
              this.__wrapped__ = J,
                this.__actions__ = [],
                this.__chain__ = !!et,
                this.__index__ = 0,
                this.__values__ = eo
            }
            function H(J) {
              this.__wrapped__ = J,
                this.__actions__ = [],
                this.__dir__ = 1,
                this.__filtered__ = !1,
                this.__iteratees__ = [],
                this.__takeCount__ = 4294967295,
                this.__views__ = []
            }
            function dt(J) {
              var et = -1
                , eo = null == J ? 0 : J.length;
              for (this.clear(); ++et < eo;) {
                var el = J[et];
                this.set(el[0], el[1])
              }
            }
            function Bn(J) {
              var et = -1
                , eo = null == J ? 0 : J.length;
              for (this.clear(); ++et < eo;) {
                var el = J[et];
                this.set(el[0], el[1])
              }
            }
            function Gn(J) {
              var et = -1
                , eo = null == J ? 0 : J.length;
              for (this.clear(); ++et < eo;) {
                var el = J[et];
                this.set(el[0], el[1])
              }
            }
            function gt(J) {
              var et = -1
                , eo = null == J ? 0 : J.length;
              for (this.__data__ = new Gn; ++et < eo;)
                this.add(J[et])
            }
            function Rn(J) {
              var et = this.__data__ = new Bn(J);
              this.size = et.size
            }
            function Fs(J, et) {
              var eo = nX(J)
                , el = !eo && nQ(J)
                , ec = !eo && !el && n1(J)
                , ed = !eo && !el && !ec && n4(J)
                , eh = eo || el || ec || ed
                , ep = eh ? Fr(J.length, tP) : []
                , ef = ep.length;
              for (var em in J)
                (et || tj.call(J, em)) && !(eh && ("length" == em || ec && ("offset" == em || "parent" == em) || ed && ("buffer" == em || "byteLength" == em || "byteOffset" == em) || Zn(em, ef))) && ep.push(em);
              return ep
            }
            function Ms(J) {
              var et = J.length;
              return et ? J[ei(0, et - 1)] : eo
            }
            function Yr(J, et, el) {
              (el === eo || bn(J[et], el)) && (el !== eo || et in J) || zn(J, et, el)
            }
            function se(J, et, el) {
              var ec = J[et];
              tj.call(J, et) && bn(ec, el) && (el !== eo || et in J) || zn(J, et, el)
            }
            function Be(J, et) {
              for (var eo = J.length; eo--;)
                if (bn(J[eo][0], et))
                  return eo;
              return -1
            }
            function gc(J, et, eo, el) {
              return r1(J, function (J, ec, ed) {
                et(el, J, eo(J), ed)
              }),
                el
            }
            function qs(J, et) {
              return J && Un(et, V(et), J)
            }
            function zn(J, et, eo) {
              "__proto__" == et && rl ? rl(J, et, {
                configurable: !0,
                enumerable: !0,
                value: eo,
                writable: !0
              }) : J[et] = eo
            }
            function Zr(J, et) {
              for (var el = -1, ec = et.length, ed = tx(ec), eh = null == J; ++el < ec;)
                ed[el] = eh ? eo : Si(J, et[el]);
              return ed
            }
            function vt(J, et, el) {
              return J == J && (el !== eo && (J = J <= el ? J : el),
                et !== eo && (J = J >= et ? J : et)),
                J
            }
            function An(J, et, el, ec, ed, eh) {
              var ep, ef = 1 & et, eg = 2 & et, ew = 4 & et;
              if (el && (ep = ed ? el(J, ec, ed, eh) : el(J)),
                ep !== eo)
                return ep;
              if (!K(J))
                return J;
              var ek = nX(J);
              if (ek) {
                if (eI = J.length,
                  eH = new J.constructor(eI),
                  eI && "string" == typeof J[0] && tj.call(J, "index") && (eH.index = J.index,
                    eH.input = J.input),
                  ep = eH,
                  !ef)
                  return un(J, ep)
              } else {
                var eI, eH, eV, eW, eZ, eG = no(J), eY = eG == e_ || eG == ex;
                if (n1(J))
                  return hu(J, ef);
                if (eG == eS || eG == em || eY && !ed) {
                  if (ep = eg || eY ? {} : bu(J),
                    !ef)
                    return eg ? (eV = (eZ = ep) && Un(J, on(J), eZ),
                      Un(J, ns(J), eV)) : (eW = qs(ep, J),
                        Un(J, nn(J), eW))
                } else {
                  if (!t2[eG])
                    return ed ? J : {};
                  ep = function (J, et, eo) {
                    var el, ec, ed = J.constructor;
                    switch (et) {
                      case eO:
                        return fi(J);
                      case ey:
                      case eb:
                        return new ed(+J);
                      case eN:
                        return el = eo ? fi(J.buffer) : J.buffer,
                          new J.constructor(el, J.byteOffset, J.byteLength);
                      case eM:
                      case eD:
                      case ej:
                      case eL:
                      case e$:
                      case eB:
                      case eF:
                      case eU:
                      case ez:
                        return lu(J, eo);
                      case eE:
                        return new ed;
                      case eC:
                      case eP:
                        return new ed(J);
                      case eT:
                        return (ec = new J.constructor(J.source, tc.exec(J))).lastIndex = J.lastIndex,
                          ec;
                      case eA:
                        return new ed;
                      case eR:
                        return rQ ? tT(rQ.call(J)) : {}
                    }
                  }(J, eG, ef)
                }
              }
              eh || (eh = new Rn);
              var eK = eh.get(J);
              if (eK)
                return eK;
              eh.set(J, ep),
                n6(J) ? J.forEach(function (eo) {
                  ep.add(An(eo, et, el, eo, J, eh))
                }) : n3(J) && J.forEach(function (eo, ec) {
                  ep.set(ec, An(eo, et, el, ec, J, eh))
                });
              var eJ = ew ? eg ? pi : li : eg ? on : V
                , eQ = ek ? eo : eJ(J);
              return mn(eQ || J, function (eo, ec) {
                eQ && (eo = J[ec = eo]),
                  se(ep, ec, An(eo, et, el, ec, J, eh))
              }),
                ep
            }
            function Bs(J, et, el) {
              var ec = el.length;
              if (null == J)
                return !ec;
              for (J = tT(J); ec--;) {
                var ed = el[ec]
                  , eh = et[ed]
                  , ep = J[ed];
                if (ep === eo && !(ed in J) || !eh(ep))
                  return !1
              }
              return !0
            }
            function Gs(J, et, ec) {
              if ("function" != typeof J)
                throw new tR(el);
              return nd(function () {
                J.apply(eo, ec)
              }, et)
            }
            function ue(J, et, eo, el) {
              var ec = -1
                , ed = Ee
                , eh = !0
                , ep = J.length
                , ef = []
                , em = et.length;
              if (!ep)
                return ef;
              eo && (et = G(et, hn(eo))),
                el ? (ed = Dr,
                  eh = !1) : et.length >= 200 && (ed = jt,
                    eh = !1,
                    et = new gt(et));
              e: for (; ++ec < ep;) {
                var eg = J[ec]
                  , ey = null == eo ? eg : eo(eg);
                if (eg = el || 0 !== eg ? eg : 0,
                  eh && ey == ey) {
                  for (var eb = em; eb--;)
                    if (et[eb] === ey)
                      continue e;
                  ef.push(eg)
                } else
                  ed(et, ey, el) || ef.push(eg)
              }
              return ef
            }
            a.templateSettings = {
              escape: eJ,
              evaluate: eQ,
              interpolate: eX,
              variable: "",
              imports: {
                _: a
              }
            },
              a.prototype = qe.prototype,
              a.prototype.constructor = a,
              Pn.prototype = r0(qe.prototype),
              Pn.prototype.constructor = Pn,
              H.prototype = r0(qe.prototype),
              H.prototype.constructor = H,
              dt.prototype.clear = function () {
                this.__data__ = rH ? rH(null) : {},
                  this.size = 0
              }
              ,
              dt.prototype.delete = function (J) {
                var et = this.has(J) && delete this.__data__[J];
                return this.size -= et ? 1 : 0,
                  et
              }
              ,
              dt.prototype.get = function (J) {
                var et = this.__data__;
                if (rH) {
                  var el = et[J];
                  return el === ec ? eo : el
                }
                return tj.call(et, J) ? et[J] : eo
              }
              ,
              dt.prototype.has = function (J) {
                var et = this.__data__;
                return rH ? et[J] !== eo : tj.call(et, J)
              }
              ,
              dt.prototype.set = function (J, et) {
                var el = this.__data__;
                return this.size += this.has(J) ? 0 : 1,
                  el[J] = rH && et === eo ? ec : et,
                  this
              }
              ,
              Bn.prototype.clear = function () {
                this.__data__ = [],
                  this.size = 0
              }
              ,
              Bn.prototype.delete = function (J) {
                var et = this.__data__
                  , eo = Be(et, J);
                return !(eo < 0) && (eo == et.length - 1 ? et.pop() : t4.call(et, eo, 1),
                  --this.size,
                  !0)
              }
              ,
              Bn.prototype.get = function (J) {
                var et = this.__data__
                  , el = Be(et, J);
                return el < 0 ? eo : et[el][1]
              }
              ,
              Bn.prototype.has = function (J) {
                return Be(this.__data__, J) > -1
              }
              ,
              Bn.prototype.set = function (J, et) {
                var eo = this.__data__
                  , el = Be(eo, J);
                return el < 0 ? (++this.size,
                  eo.push([J, et])) : eo[el][1] = et,
                  this
              }
              ,
              Gn.prototype.clear = function () {
                this.size = 0,
                  this.__data__ = {
                    hash: new dt,
                    map: new (rB || Bn),
                    string: new dt
                  }
              }
              ,
              Gn.prototype.delete = function (J) {
                var et = nr(this, J).delete(J);
                return this.size -= et ? 1 : 0,
                  et
              }
              ,
              Gn.prototype.get = function (J) {
                return nr(this, J).get(J)
              }
              ,
              Gn.prototype.has = function (J) {
                return nr(this, J).has(J)
              }
              ,
              Gn.prototype.set = function (J, et) {
                var eo = nr(this, J)
                  , el = eo.size;
                return eo.set(J, et),
                  this.size += eo.size == el ? 0 : 1,
                  this
              }
              ,
              gt.prototype.add = gt.prototype.push = function (J) {
                return this.__data__.set(J, ec),
                  this
              }
              ,
              gt.prototype.has = function (J) {
                return this.__data__.has(J)
              }
              ,
              Rn.prototype.clear = function () {
                this.__data__ = new Bn,
                  this.size = 0
              }
              ,
              Rn.prototype.delete = function (J) {
                var et = this.__data__
                  , eo = et.delete(J);
                return this.size = et.size,
                  eo
              }
              ,
              Rn.prototype.get = function (J) {
                return this.__data__.get(J)
              }
              ,
              Rn.prototype.has = function (J) {
                return this.__data__.has(J)
              }
              ,
              Rn.prototype.set = function (J, et) {
                var eo = this.__data__;
                if (eo instanceof Bn) {
                  var el = eo.__data__;
                  if (!rB || el.length < 199)
                    return el.push([J, et]),
                      this.size = ++eo.size,
                      this;
                  eo = this.__data__ = new Gn(el)
                }
                return eo.set(J, et),
                  this.size = eo.size,
                  this
              }
              ;
            var r1 = vu($n)
              , r2 = vu(Xr, !0);
            function mc(J, et) {
              var eo = !0;
              return r1(J, function (J, el, ec) {
                return eo = !!et(J, el, ec)
              }),
                eo
            }
            function Ge(J, et, el) {
              for (var ec = -1, ed = J.length; ++ec < ed;) {
                var eh = J[ec]
                  , ep = et(eh);
                if (null != ep && (ef === eo ? ep == ep && !pn(ep) : el(ep, ef)))
                  var ef = ep
                    , em = eh
              }
              return em
            }
            function Ks(J, et) {
              var eo = [];
              return r1(J, function (J, el, ec) {
                et(J, el, ec) && eo.push(J)
              }),
                eo
            }
            function j(J, et, eo, el, ec) {
              var ed = -1
                , eh = J.length;
              for (eo || (eo = ah),
                ec || (ec = []); ++ed < eh;) {
                var ep = J[ed];
                et > 0 && eo(ep) ? et > 1 ? j(ep, et - 1, eo, el, ec) : nt(ec, ep) : el || (ec[ec.length] = ep)
              }
              return ec
            }
            var r3 = _u()
              , r5 = _u(!0);
            function $n(J, et) {
              return J && r3(J, et, V)
            }
            function Xr(J, et) {
              return J && r5(J, et, V)
            }
            function ze(J, et) {
              return jn(et, function (et) {
                return Jn(J[et])
              })
            }
            function _t(J, et) {
              et = st(et, J);
              for (var el = 0, ec = et.length; null != J && el < ec;)
                J = J[Wn(et[el++])];
              return el && el == ec ? J : eo
            }
            function Zs(J, et, eo) {
              var el = et(J);
              return nX(J) ? el : nt(el, eo(J))
            }
            function en(J) {
              return null == J ? J === eo ? "[object Undefined]" : "[object Null]" : ro && ro in tT(J) ? function (J) {
                var et = tj.call(J, ro)
                  , el = J[ro];
                try {
                  J[ro] = eo;
                  var ec = !0
                } catch { }
                var ed = tB.call(J);
                return ec && (et ? J[ro] = el : delete J[ro]),
                  ed
              }(J) : tB.call(J)
            }
            function Qr(J, et) {
              return J > et
            }
            function Pc(J, et) {
              return null != J && tj.call(J, et)
            }
            function Ac(J, et) {
              return null != J && et in tT(J)
            }
            function Vr(J, et, el) {
              for (var ec = el ? Dr : Ee, ed = J[0].length, eh = J.length, ep = eh, ef = tx(eh), em = 1 / 0, eg = []; ep--;) {
                var ey = J[ep];
                ep && et && (ey = G(ey, hn(et))),
                  em = rN(ey.length, em),
                  ef[ep] = !el && (et || ed >= 120 && ey.length >= 120) ? new gt(ep && ey) : eo
              }
              ey = J[0];
              var eb = -1
                , ew = ef[0];
              e: for (; ++eb < ed && eg.length < em;) {
                var e_ = ey[eb]
                  , ex = et ? et(e_) : e_;
                if (e_ = el || 0 !== e_ ? e_ : 0,
                  !(ew ? jt(ew, ex) : ec(eg, ex, el))) {
                  for (ep = eh; --ep;) {
                    var eE = ef[ep];
                    if (!(eE ? jt(eE, ex) : ec(J[ep], ex, el)))
                      continue e
                  }
                  ew && ew.push(ex),
                    eg.push(e_)
                }
              }
              return eg
            }
            function ae(J, et, el) {
              et = st(et, J);
              var ec = null == (J = Hu(J, et)) ? J : J[Wn(In(et))];
              return null == ec ? eo : cn(ec, J, el)
            }
            function Js(J) {
              return Y(J) && en(J) == em
            }
            function oe(J, et, el, ec, ed) {
              return J === et || (null != J && null != et && (Y(J) || Y(et)) ? function (J, et, el, ec, ed, eh) {
                var ep = nX(J)
                  , ef = nX(et)
                  , e_ = ep ? eg : no(J)
                  , ex = ef ? eg : no(et);
                e_ = e_ == em ? eS : e_,
                  ex = ex == em ? eS : ex;
                var ek = e_ == eS
                  , eI = ex == eS
                  , eM = e_ == ex;
                if (eM && n1(J)) {
                  if (!n1(et))
                    return !1;
                  ep = !0,
                    ek = !1
                }
                if (eM && !ek)
                  return eh || (eh = new Rn),
                    ep || n4(J) ? Su(J, et, el, ec, ed, eh) : function (J, et, eo, el, ec, ed, eh) {
                      switch (eo) {
                        case eN:
                          if (J.byteLength != et.byteLength || J.byteOffset != et.byteOffset)
                            break;
                          J = J.buffer,
                            et = et.buffer;
                        case eO:
                          return !(J.byteLength != et.byteLength || !ed(new tW(J), new tW(et)));
                        case ey:
                        case eb:
                        case eC:
                          return bn(+J, +et);
                        case ew:
                          return J.name == et.name && J.message == et.message;
                        case eT:
                        case eP:
                          return J == et + "";
                        case eE:
                          var ep = qr;
                        case eA:
                          var ef = 1 & el;
                          if (ep || (ep = Se),
                            J.size != et.size && !ef)
                            break;
                          var em = eh.get(J);
                          if (em)
                            return em == et;
                          el |= 2,
                            eh.set(J, et);
                          var eg = Su(ep(J), ep(et), el, ec, ed, eh);
                          return eh.delete(J),
                            eg;
                        case eR:
                          if (rQ)
                            return rQ.call(J) == rQ.call(et)
                      }
                      return !1
                    }(J, et, e_, el, ec, ed, eh);
                if (!(1 & el)) {
                  var eD = ek && tj.call(J, "__wrapped__")
                    , ej = eI && tj.call(et, "__wrapped__");
                  if (eD || ej) {
                    var eL = eD ? J.value() : J
                      , e$ = ej ? et.value() : et;
                    return eh || (eh = new Rn),
                      ed(eL, e$, el, ec, eh)
                  }
                }
                return !!eM && (eh || (eh = new Rn),
                  function (J, et, el, ec, ed, eh) {
                    var ep = 1 & el
                      , ef = li(J)
                      , em = ef.length;
                    if (em != li(et).length && !ep)
                      return !1;
                    for (var eg = em; eg--;) {
                      var ey = ef[eg];
                      if (!(ep ? ey in et : tj.call(et, ey)))
                        return !1
                    }
                    var eb = eh.get(J)
                      , ew = eh.get(et);
                    if (eb && ew)
                      return eb == et && ew == J;
                    var e_ = !0;
                    eh.set(J, et),
                      eh.set(et, J);
                    for (var ex = ep; ++eg < em;) {
                      var eE = J[ey = ef[eg]]
                        , eC = et[ey];
                      if (ec)
                        var eS = ep ? ec(eC, eE, ey, et, J, eh) : ec(eE, eC, ey, J, et, eh);
                      if (!(eS === eo ? eE === eC || ed(eE, eC, el, ec, eh) : eS)) {
                        e_ = !1;
                        break
                      }
                      ex || (ex = "constructor" == ey)
                    }
                    if (e_ && !ex) {
                      var ek = J.constructor
                        , eT = et.constructor;
                      ek != eT && "constructor" in J && "constructor" in et && !("function" == typeof ek && ek instanceof ek && "function" == typeof eT && eT instanceof eT) && (e_ = !1)
                    }
                    return eh.delete(J),
                      eh.delete(et),
                      e_
                  }(J, et, el, ec, ed, eh))
              }(J, et, el, ec, oe, ed) : J != J && et != et)
            }
            function kr(J, et, el, ec) {
              var ed = el.length
                , eh = ed
                , ep = !ec;
              if (null == J)
                return !eh;
              for (J = tT(J); ed--;) {
                var ef = el[ed];
                if (ep && ef[2] ? ef[1] !== J[ef[0]] : !(ef[0] in J))
                  return !1
              }
              for (; ++ed < eh;) {
                var em = (ef = el[ed])[0]
                  , eg = J[em]
                  , ey = ef[1];
                if (ep && ef[2]) {
                  if (eg === eo && !(em in J))
                    return !1
                } else {
                  var eb = new Rn;
                  if (ec)
                    var ew = ec(eg, ey, em, J, et, eb);
                  if (!(ew === eo ? oe(ey, eg, 3, ec, eb) : ew))
                    return !1
                }
              }
              return !0
            }
            function Xs(J) {
              return !(!K(J) || t$ && t$ in J) && (Jn(J) ? tz : tp).test(wt(J))
            }
            function Qs(J) {
              return "function" == typeof J ? J : null == J ? fn : "object" == typeof J ? nX(J) ? js(J[0], J[1]) : ks(J) : ma(J)
            }
            function jr(J) {
              if (!he(J))
                return rI(J);
              var et = [];
              for (var eo in tT(J))
                tj.call(J, eo) && "constructor" != eo && et.push(eo);
              return et
            }
            function ni(J, et) {
              return J < et
            }
            function Vs(J, et) {
              var eo = -1
                , el = an(J) ? tx(J.length) : [];
              return r1(J, function (J, ec, ed) {
                el[++eo] = et(J, ec, ed)
              }),
                el
            }
            function ks(J) {
              var et = gi(J);
              return 1 == et.length && et[0][2] ? Lu(et[0][0], et[0][1]) : function (eo) {
                return eo === J || kr(eo, J, et)
              }
            }
            function js(J, et) {
              var el;
              return _i(J) && (el = et) == el && !K(el) ? Lu(Wn(J), et) : function (el) {
                var ec = Si(el, J);
                return ec === eo && ec === et ? Oi(el, J) : oe(et, ec, 3)
              }
            }
            function Ke(J, et, el, ec, ed) {
              J !== et && r3(et, function (eh, ep) {
                if (ed || (ed = new Rn),
                  K(eh))
                  !function (J, et, el, ec, ed, eh, ep) {
                    var ef = wi(J, el)
                      , em = wi(et, el)
                      , eg = ep.get(em);
                    if (eg) {
                      Yr(J, el, eg);
                      return
                    }
                    var ey = eh ? eh(ef, em, el + "", J, et, ep) : eo
                      , eb = ey === eo;
                    if (eb) {
                      var ew = nX(em)
                        , e_ = !ew && n1(em)
                        , ex = !ew && !e_ && n4(em);
                      ey = em,
                        ew || e_ || ex ? nX(ef) ? ey = ef : Z(ef) ? ey = un(ef) : e_ ? (eb = !1,
                          ey = hu(em, !0)) : ex ? (eb = !1,
                            ey = lu(em, !0)) : ey = [] : pe(em) || nQ(em) ? (ey = ef,
                              nQ(ef) ? ey = oa(ef) : (!K(ef) || Jn(ef)) && (ey = bu(em))) : eb = !1
                    }
                    eb && (ep.set(em, ey),
                      ed(ey, em, ec, eh, ep),
                      ep.delete(em)),
                      Yr(J, el, ey)
                  }(J, et, ep, el, Ke, ec, ed);
                else {
                  var ef = ec ? ec(wi(J, ep), eh, ep + "", J, et, ed) : eo;
                  ef === eo && (ef = eh),
                    Yr(J, ep, ef)
                }
              }, on)
            }
            function nu(J, et) {
              var el = J.length;
              if (el)
                return Zn(et += et < 0 ? el : 0, el) ? J[et] : eo
            }
            function tu(J, et, eo) {
              et = et.length ? G(et, function (J) {
                return nX(J) ? function (et) {
                  return _t(et, 1 === J.length ? J[0] : J)
                }
                  : J
              }) : [fn];
              var el = -1;
              return et = G(et, hn(x())),
                function (J, et) {
                  var eo = J.length;
                  for (J.sort(et); eo--;)
                    J[eo] = J[eo].value;
                  return J
                }(Vs(J, function (J, eo, ec) {
                  return {
                    criteria: G(et, function (et) {
                      return et(J)
                    }),
                    index: ++el,
                    value: J
                  }
                }), function (J, et) {
                  return function (J, et, eo) {
                    for (var el = -1, ec = J.criteria, ed = et.criteria, eh = ec.length, ep = eo.length; ++el < eh;) {
                      var ef = pu(ec[el], ed[el]);
                      if (ef) {
                        if (el >= ep)
                          return ef;
                        return ef * ("desc" == eo[el] ? -1 : 1)
                      }
                    }
                    return J.index - et.index
                  }(J, et, eo)
                })
            }
            function eu(J, et, eo) {
              for (var el = -1, ec = et.length, ed = {}; ++el < ec;) {
                var eh = et[el]
                  , ep = _t(J, eh);
                eo(ep, eh) && fe(ed, st(eh, J), ep)
              }
              return ed
            }
            function ti(J, et, eo, el) {
              var ec = el ? rf : Tt
                , ed = -1
                , eh = et.length
                , ep = J;
              for (J === et && (et = un(et)),
                eo && (ep = G(J, hn(eo))); ++ed < eh;)
                for (var ef = 0, em = et[ed], eg = eo ? eo(em) : em; (ef = ec(ep, eg, ef, el)) > -1;)
                  ep !== J && t4.call(ep, ef, 1),
                    t4.call(J, ef, 1);
              return J
            }
            function ru(J, et) {
              for (var eo = J ? et.length : 0, el = eo - 1; eo--;) {
                var ec = et[eo];
                if (eo == el || ec !== ed) {
                  var ed = ec;
                  Zn(ec) ? t4.call(J, ec, 1) : si(J, ec)
                }
              }
              return J
            }
            function ei(J, et) {
              return J + rk(rj() * (et - J + 1))
            }
            function ri(J, et) {
              var eo = "";
              if (!J || et < 1 || et > 9007199254740991)
                return eo;
              do
                et % 2 && (eo += J),
                  (et = rk(et / 2)) && (J += J);
              while (et);
              return eo
            }
            function L(J, et) {
              return nh(Du(J, et, fn), J + "")
            }
            function fe(J, et, el, ec) {
              if (!K(J))
                return J;
              et = st(et, J);
              for (var ed = -1, eh = et.length, ep = eh - 1, ef = J; null != ef && ++ed < eh;) {
                var em = Wn(et[ed])
                  , eg = el;
                if ("__proto__" === em || "constructor" === em || "prototype" === em)
                  break;
                if (ed != ep) {
                  var ey = ef[em];
                  (eg = ec ? ec(ey, em, ef) : eo) === eo && (eg = K(ey) ? ey : Zn(et[ed + 1]) ? [] : {})
                }
                se(ef, em, eg),
                  ef = ef[em]
              }
              return J
            }
            var r6 = rV ? function (J, et) {
              return rV.set(J, et),
                J
            }
              : fn
              , r4 = rl ? function (J, et) {
                return rl(J, "toString", {
                  configurable: !0,
                  enumerable: !1,
                  value: bi(et),
                  writable: !0
                })
              }
                : fn;
            function Cn(J, et, eo) {
              var el = -1
                , ec = J.length;
              et < 0 && (et = -et > ec ? 0 : ec + et),
                (eo = eo > ec ? ec : eo) < 0 && (eo += ec),
                ec = et > eo ? 0 : eo - et >>> 0,
                et >>>= 0;
              for (var ed = tx(ec); ++el < ec;)
                ed[el] = J[el + et];
              return ed
            }
            function Mc(J, et) {
              var eo;
              return r1(J, function (J, el, ec) {
                return !(eo = et(J, el, ec))
              }),
                !!eo
            }
            function Ye(J, et, eo) {
              var el = 0
                , ec = null == J ? el : J.length;
              if ("number" == typeof et && et == et && ec <= 2147483647) {
                for (; el < ec;) {
                  var ed = el + ec >>> 1
                    , eh = J[ed];
                  null !== eh && !pn(eh) && (eo ? eh <= et : eh < et) ? el = ed + 1 : ec = ed
                }
                return ec
              }
              return ii(J, et, fn, eo)
            }
            function ii(J, et, el, ec) {
              var ed = 0
                , eh = null == J ? 0 : J.length;
              if (0 === eh)
                return 0;
              et = el(et);
              for (var ep = et != et, ef = null === et, em = pn(et), eg = et === eo; ed < eh;) {
                var ey = rk((ed + eh) / 2)
                  , eb = el(J[ey])
                  , ew = eb !== eo
                  , e_ = null === eb
                  , ex = eb == eb
                  , eE = pn(eb);
                if (ep)
                  var eC = ec || ex;
                else
                  eC = eg ? ex && (ec || ew) : ef ? ex && ew && (ec || !e_) : em ? ex && ew && !e_ && (ec || !eE) : !e_ && !eE && (ec ? eb <= et : eb < et);
                eC ? ed = ey + 1 : eh = ey
              }
              return rN(eh, 4294967294)
            }
            function su(J, et) {
              for (var eo = -1, el = J.length, ec = 0, ed = []; ++eo < el;) {
                var eh = J[eo]
                  , ep = et ? et(eh) : eh;
                if (!eo || !bn(ep, ef)) {
                  var ef = ep;
                  ed[ec++] = 0 === eh ? 0 : eh
                }
              }
              return ed
            }
            function uu(J) {
              return "number" == typeof J ? J : pn(J) ? ep : +J
            }
            function ln(J) {
              if ("string" == typeof J)
                return J;
              if (nX(J))
                return G(J, ln) + "";
              if (pn(J))
                return rX ? rX.call(J) : "";
              var et = J + "";
              return "0" == et && 1 / J == -eh ? "-0" : et
            }
            function it(J, et, eo) {
              var el = -1
                , ec = Ee
                , ed = J.length
                , eh = !0
                , ep = []
                , ef = ep;
              if (eo)
                eh = !1,
                  ec = Dr;
              else if (ed >= 200) {
                var em = et ? null : r7(J);
                if (em)
                  return Se(em);
                eh = !1,
                  ec = jt,
                  ef = new gt
              } else
                ef = et ? [] : ep;
              e: for (; ++el < ed;) {
                var eg = J[el]
                  , ey = et ? et(eg) : eg;
                if (eg = eo || 0 !== eg ? eg : 0,
                  eh && ey == ey) {
                  for (var eb = ef.length; eb--;)
                    if (ef[eb] === ey)
                      continue e;
                  et && ef.push(ey),
                    ep.push(eg)
                } else
                  ec(ef, ey, eo) || (ef !== ep && ef.push(ey),
                    ep.push(eg))
              }
              return ep
            }
            function si(J, et) {
              return et = st(et, J),
                null == (J = Hu(J, et)) || delete J[Wn(In(et))]
            }
            function au(J, et, eo, el) {
              return fe(J, et, eo(_t(J, et)), el)
            }
            function Ze(J, et, eo, el) {
              for (var ec = J.length, ed = el ? ec : -1; (el ? ed-- : ++ed < ec) && et(J[ed], ed, J);)
                ;
              return eo ? Cn(J, el ? 0 : ed, el ? ed + 1 : ec) : Cn(J, el ? ed + 1 : 0, el ? ec : ed)
            }
            function ou(J, et) {
              var eo = J;
              return eo instanceof H && (eo = eo.value()),
                Hr(et, function (J, et) {
                  return et.func.apply(et.thisArg, nt([J], et.args))
                }, eo)
            }
            function ui(J, et, eo) {
              var el = J.length;
              if (el < 2)
                return el ? it(J[0]) : [];
              for (var ec = -1, ed = tx(el); ++ec < el;)
                for (var eh = J[ec], ep = -1; ++ep < el;)
                  ep != ec && (ed[ec] = ue(ed[ec] || eh, J[ep], et, eo));
              return it(j(ed, 1), et, eo)
            }
            function fu(J, et, el) {
              for (var ec = -1, ed = J.length, eh = et.length, ep = {}; ++ec < ed;) {
                var ef = ec < eh ? et[ec] : eo;
                el(ep, J[ec], ef)
              }
              return ep
            }
            function ai(J) {
              return Z(J) ? J : []
            }
            function oi(J) {
              return "function" == typeof J ? J : fn
            }
            function st(J, et) {
              return nX(J) ? J : _i(J, et) ? [J] : np(W(J))
            }
            function ut(J, et, el) {
              var ec = J.length;
              return el = el === eo ? ec : el,
                !et && el >= ec ? J : Cn(J, et, el)
            }
            var r8 = rc || function (J) {
              return t7.clearTimeout(J)
            }
              ;
            function hu(J, et) {
              if (et)
                return J.slice();
              var eo = J.length
                , el = tq ? tq(eo) : new J.constructor(eo);
              return J.copy(el),
                el
            }
            function fi(J) {
              var et = new J.constructor(J.byteLength);
              return new tW(et).set(new tW(J)),
                et
            }
            function lu(J, et) {
              var eo = et ? fi(J.buffer) : J.buffer;
              return new J.constructor(eo, J.byteOffset, J.length)
            }
            function pu(J, et) {
              if (J !== et) {
                var el = J !== eo
                  , ec = null === J
                  , ed = J == J
                  , eh = pn(J)
                  , ep = et !== eo
                  , ef = null === et
                  , em = et == et
                  , eg = pn(et);
                if (!ef && !eg && !eh && J > et || eh && ep && em && !ef && !eg || ec && ep && em || !el && em || !ed)
                  return 1;
                if (!ec && !eh && !eg && J < et || eg && el && ed && !ec && !eh || ef && el && ed || !ep && ed || !em)
                  return -1
              }
              return 0
            }
            function du(J, et, eo, el) {
              for (var ec = -1, ed = J.length, eh = eo.length, ep = -1, ef = et.length, em = rO(ed - eh, 0), eg = tx(ef + em), ey = !el; ++ep < ef;)
                eg[ep] = et[ep];
              for (; ++ec < eh;)
                (ey || ec < ed) && (eg[eo[ec]] = J[ec]);
              for (; em--;)
                eg[ep++] = J[ec++];
              return eg
            }
            function gu(J, et, eo, el) {
              for (var ec = -1, ed = J.length, eh = -1, ep = eo.length, ef = -1, em = et.length, eg = rO(ed - ep, 0), ey = tx(eg + em), eb = !el; ++ec < eg;)
                ey[ec] = J[ec];
              for (var ew = ec; ++ef < em;)
                ey[ew + ef] = et[ef];
              for (; ++eh < ep;)
                (eb || ec < ed) && (ey[ew + eo[eh]] = J[ec++]);
              return ey
            }
            function un(J, et) {
              var eo = -1
                , el = J.length;
              for (et || (et = tx(el)); ++eo < el;)
                et[eo] = J[eo];
              return et
            }
            function Un(J, et, el, ec) {
              var ed = !el;
              el || (el = {});
              for (var eh = -1, ep = et.length; ++eh < ep;) {
                var ef = et[eh]
                  , em = ec ? ec(el[ef], J[ef], ef, el, J) : eo;
                em === eo && (em = J[ef]),
                  ed ? zn(el, ef, em) : se(el, ef, em)
              }
              return el
            }
            function Je(J, et) {
              return function (eo, el) {
                var ec = nX(eo) ? Vo : gc
                  , ed = et ? et() : {};
                return ec(eo, J, x(el, 2), ed)
              }
            }
            function Ft(J) {
              return L(function (et, el) {
                var ec = -1
                  , ed = el.length
                  , eh = ed > 1 ? el[ed - 1] : eo
                  , ep = ed > 2 ? el[2] : eo;
                for (eh = J.length > 3 && "function" == typeof eh ? (ed--,
                  eh) : eo,
                  ep && rn(el[0], el[1], ep) && (eh = ed < 3 ? eo : eh,
                    ed = 1),
                  et = tT(et); ++ec < ed;) {
                  var ef = el[ec];
                  ef && J(et, ef, ec, eh)
                }
                return et
              })
            }
            function vu(J, et) {
              return function (eo, el) {
                if (null == eo)
                  return eo;
                if (!an(eo))
                  return J(eo, el);
                for (var ec = eo.length, ed = et ? ec : -1, eh = tT(eo); (et ? ed-- : ++ed < ec) && !1 !== el(eh[ed], ed, eh);)
                  ;
                return eo
              }
            }
            function _u(J) {
              return function (et, eo, el) {
                for (var ec = -1, ed = tT(et), eh = el(et), ep = eh.length; ep--;) {
                  var ef = eh[J ? ep : ++ec];
                  if (!1 === eo(ed[ef], ef, ed))
                    break
                }
                return et
              }
            }
            function mu(J) {
              return function (et) {
                var el = Lt(et = W(et)) ? On(et) : eo
                  , ec = el ? el[0] : et.charAt(0)
                  , ed = el ? ut(el, 1).join("") : et.slice(1);
                return ec[J]() + ed
              }
            }
            function Mt(J) {
              return function (et) {
                return Hr(va(ga(et).replace(tZ, "")), J, "")
              }
            }
            function ce(J) {
              return function () {
                var et = arguments;
                switch (et.length) {
                  case 0:
                    return new J;
                  case 1:
                    return new J(et[0]);
                  case 2:
                    return new J(et[0], et[1]);
                  case 3:
                    return new J(et[0], et[1], et[2]);
                  case 4:
                    return new J(et[0], et[1], et[2], et[3]);
                  case 5:
                    return new J(et[0], et[1], et[2], et[3], et[4]);
                  case 6:
                    return new J(et[0], et[1], et[2], et[3], et[4], et[5]);
                  case 7:
                    return new J(et[0], et[1], et[2], et[3], et[4], et[5], et[6])
                }
                var eo = r0(J.prototype)
                  , el = J.apply(eo, et);
                return K(el) ? el : eo
              }
            }
            function wu(J) {
              return function (et, el, ec) {
                var ed = tT(et);
                if (!an(et)) {
                  var eh = x(el, 3);
                  et = V(et),
                    el = function (J) {
                      return eh(ed[J], J, ed)
                    }
                }
                var ep = J(et, el, ec);
                return ep > -1 ? ed[eh ? et[ep] : ep] : eo
              }
            }
            function Pu(J) {
              return Yn(function (et) {
                var ec = et.length
                  , ed = ec
                  , eh = Pn.prototype.thru;
                for (J && et.reverse(); ed--;) {
                  var ep = et[ed];
                  if ("function" != typeof ep)
                    throw new tR(el);
                  if (eh && !ef && "wrapper" == je(ep))
                    var ef = new Pn([], !0)
                }
                for (ed = ef ? ed : ec; ++ed < ec;) {
                  var em = je(ep = et[ed])
                    , eg = "wrapper" == em ? r9(ep) : eo;
                  ef = eg && mi(eg[0]) && 424 == eg[1] && !eg[4].length && 1 == eg[9] ? ef[je(eg[0])].apply(ef, eg[3]) : 1 == ep.length && mi(ep) ? ef[em]() : ef.thru(ep)
                }
                return function () {
                  var J = arguments
                    , eo = J[0];
                  if (ef && 1 == J.length && nX(eo))
                    return ef.plant(eo).value();
                  for (var el = 0, ed = ec ? et[el].apply(this, J) : eo; ++el < ec;)
                    ed = et[el].call(this, ed);
                  return ed
                }
              })
            }
            function Xe(J, et, el, ec, ed, eh, ep, ef, em, eg) {
              var ey = 128 & et
                , eb = 1 & et
                , ew = 2 & et
                , e_ = 24 & et
                , ex = 512 & et
                , eE = ew ? eo : ce(J);
              return function y() {
                for (var eC = arguments.length, eS = tx(eC), ek = eC; ek--;)
                  eS[ek] = arguments[ek];
                if (e_)
                  var eT = qt(y)
                    , eA = function (J, et) {
                      for (var eo = J.length, el = 0; eo--;)
                        J[eo] === et && ++el;
                      return el
                    }(eS, eT);
                if (ec && (eS = du(eS, ec, ed, e_)),
                  eh && (eS = gu(eS, eh, ep, e_)),
                  eC -= eA,
                  e_ && eC < eg) {
                  var eP = tt(eS, eT);
                  return Iu(J, et, Xe, y.placeholder, el, eS, eP, ef, em, eg - eC)
                }
                var eR = eb ? el : this
                  , eI = ew ? eR[J] : J;
                return eC = eS.length,
                  ef ? eS = function (J, et) {
                    for (var el = J.length, ec = rN(et.length, el), ed = un(J); ec--;) {
                      var eh = et[ec];
                      J[ec] = Zn(eh, el) ? ed[eh] : eo
                    }
                    return J
                  }(eS, ef) : ex && eC > 1 && eS.reverse(),
                  ey && em < eC && (eS.length = em),
                  this && this !== t7 && this instanceof y && (eI = eE || ce(eI)),
                  eI.apply(eR, eS)
              }
            }
            function Au(J, et) {
              return function (eo, el) {
                var ec, ed;
                return ec = et(el),
                  ed = {},
                  $n(eo, function (et, eo, el) {
                    J(ed, ec(et), eo, el)
                  }),
                  ed
              }
            }
            function Qe(J, et) {
              return function (el, ec) {
                var ed;
                if (el === eo && ec === eo)
                  return et;
                if (el !== eo && (ed = el),
                  ec !== eo) {
                  if (ed === eo)
                    return ec;
                  "string" == typeof el || "string" == typeof ec ? (el = ln(el),
                    ec = ln(ec)) : (el = uu(el),
                      ec = uu(ec)),
                    ed = J(el, ec)
                }
                return ed
              }
            }
            function ci(J) {
              return Yn(function (et) {
                return et = G(et, hn(x())),
                  L(function (eo) {
                    var el = this;
                    return J(et, function (J) {
                      return cn(J, el, eo)
                    })
                  })
              })
            }
            function Ve(J, et) {
              var el = (et = et === eo ? " " : ln(et)).length;
              if (el < 2)
                return el ? ri(et, J) : et;
              var ec = ri(et, rS(J / Dt(et)));
              return Lt(et) ? ut(On(ec), 0, J).join("") : ec.slice(0, J)
            }
            function Cu(J) {
              return function (et, el, ec) {
                return ec && "number" != typeof ec && rn(et, el, ec) && (el = ec = eo),
                  et = Xn(et),
                  el === eo ? (el = et,
                    et = 0) : el = Xn(el),
                  ec = ec === eo ? et < el ? 1 : -1 : Xn(ec),
                  function (J, et, eo, el) {
                    for (var ec = -1, ed = rO(rS((et - J) / (eo || 1)), 0), eh = tx(ed); ed--;)
                      eh[el ? ed : ++ec] = J,
                        J += eo;
                    return eh
                  }(et, el, ec, J)
              }
            }
            function ke(J) {
              return function (et, eo) {
                return "string" == typeof et && "string" == typeof eo || (et = xn(et),
                  eo = xn(eo)),
                  J(et, eo)
              }
            }
            function Iu(J, et, el, ec, ed, eh, ep, ef, em, eg) {
              var ey = 8 & et
                , eb = ey ? ep : eo
                , ew = ey ? eo : ep
                , e_ = ey ? eh : eo
                , ex = ey ? eo : eh;
              et |= ey ? 32 : 64,
                4 & (et &= ~(ey ? 64 : 32)) || (et &= -4);
              var eE = [J, et, ed, e_, eb, ex, ew, ef, em, eg]
                , eC = el.apply(eo, eE);
              return mi(J) && nc(eC, eE),
                eC.placeholder = ec,
                $u(eC, J, et)
            }
            function hi(J) {
              var et = tk[J];
              return function (J, eo) {
                if (J = xn(J),
                  (eo = null == eo ? 0 : rN(b(eo), 292)) && rP(J)) {
                  var el = (W(J) + "e").split("e");
                  return +((el = (W(et(el[0] + "e" + (+el[1] + eo))) + "e").split("e"))[0] + "e" + (+el[1] - eo))
                }
                return et(J)
              }
            }
            var r7 = rU && 1 / Se(new rU([, -0]))[1] == eh ? function (J) {
              return new rU(J)
            }
              : Di;
            function xu(J) {
              return function (et) {
                var eo, el, ec = no(et);
                return ec == eE ? qr(et) : ec == eA ? (eo = -1,
                  el = Array(et.size),
                  et.forEach(function (J) {
                    el[++eo] = [J, J]
                  }),
                  el) : G(J(et), function (J) {
                    return [J, et[J]]
                  })
              }
            }
            function Kn(J, et, ec, eh, ep, ef, em, eg) {
              var ey = 2 & et;
              if (!ey && "function" != typeof J)
                throw new tR(el);
              var eb = eh ? eh.length : 0;
              if (eb || (et &= -97,
                eh = ep = eo),
                em = em === eo ? em : rO(b(em), 0),
                eg = eg === eo ? eg : b(eg),
                eb -= ep ? ep.length : 0,
                64 & et) {
                var ew = eh
                  , e_ = ep;
                eh = ep = eo
              }
              var ex = ey ? eo : r9(J)
                , eE = [J, et, ec, eh, ep, ew, e_, ef, em, eg];
              if (ex && function (J, et) {
                var eo = J[1]
                  , el = et[1]
                  , ec = eo | el
                  , eh = ec < 131
                  , ep = 128 == el && 8 == eo || 128 == el && 256 == eo && J[7].length <= et[8] || 384 == el && et[7].length <= et[8] && 8 == eo;
                if (eh || ep) {
                  1 & el && (J[2] = et[2],
                    ec |= 1 & eo ? 0 : 4);
                  var ef = et[3];
                  if (ef) {
                    var em = J[3];
                    J[3] = em ? du(em, ef, et[4]) : ef,
                      J[4] = em ? tt(J[3], ed) : et[4]
                  }
                  (ef = et[5]) && (em = J[5],
                    J[5] = em ? gu(em, ef, et[6]) : ef,
                    J[6] = em ? tt(J[5], ed) : et[6]),
                    (ef = et[7]) && (J[7] = ef),
                    128 & el && (J[8] = null == J[8] ? et[8] : rN(J[8], et[8])),
                    null == J[9] && (J[9] = et[9]),
                    J[0] = et[0],
                    J[1] = ec
                }
              }(eE, ex),
                J = eE[0],
                et = eE[1],
                ec = eE[2],
                eh = eE[3],
                ep = eE[4],
                (eg = eE[9] = eE[9] === eo ? ey ? 0 : J.length : rO(eE[9] - eb, 0)) || !(24 & et) || (et &= -25),
                et && 1 != et)
                8 == et || 16 == et ? (eC = J,
                  eS = et,
                  ek = eg,
                  eT = ce(eC),
                  eB = function s() {
                    for (var J = arguments.length, et = tx(J), el = J, ec = qt(s); el--;)
                      et[el] = arguments[el];
                    var ed = J < 3 && et[0] !== ec && et[J - 1] !== ec ? [] : tt(et, ec);
                    return (J -= ed.length) < ek ? Iu(eC, eS, Xe, s.placeholder, eo, et, ed, eo, eo, ek - J) : cn(this && this !== t7 && this instanceof s ? eT : eC, this, et)
                  }
                ) : 32 != et && 33 != et || ep.length ? eB = Xe.apply(eo, eE) : (eA = J,
                  eP = et,
                  eR = ec,
                  eI = eh,
                  eO = 1 & eP,
                  eN = ce(eA),
                  eB = function f() {
                    for (var J = -1, et = arguments.length, eo = -1, el = eI.length, ec = tx(el + et), ed = this && this !== t7 && this instanceof f ? eN : eA; ++eo < el;)
                      ec[eo] = eI[eo];
                    for (; et--;)
                      ec[eo++] = arguments[++J];
                    return cn(ed, eO ? eR : this, ec)
                  }
                );
              else
                var eC, eS, ek, eT, eA, eP, eR, eI, eO, eN, eM, eD, ej, eL, e$, eB = (eM = J,
                  eD = et,
                  ej = ec,
                  eL = 1 & eD,
                  e$ = ce(eM),
                  function o() {
                    return (this && this !== t7 && this instanceof o ? e$ : eM).apply(eL ? ej : this, arguments)
                  }
                );
              return $u((ex ? r6 : nc)(eB, eE), J, et)
            }
            function Eu(J, et, el, ec) {
              return J === eo || bn(J, tN[el]) && !tj.call(ec, el) ? et : J
            }
            function yu(J, et, el, ec, ed, eh) {
              return K(J) && K(et) && (eh.set(et, J),
                Ke(J, et, eo, yu, eh),
                eh.delete(et)),
                J
            }
            function kc(J) {
              return pe(J) ? eo : J
            }
            function Su(J, et, el, ec, ed, eh) {
              var ep = 1 & el
                , ef = J.length
                , em = et.length;
              if (ef != em && !(ep && em > ef))
                return !1;
              var eg = eh.get(J)
                , ey = eh.get(et);
              if (eg && ey)
                return eg == et && ey == J;
              var eb = -1
                , ew = !0
                , e_ = 2 & el ? new gt : eo;
              for (eh.set(J, et),
                eh.set(et, J); ++eb < ef;) {
                var ex = J[eb]
                  , eE = et[eb];
                if (ec)
                  var eC = ep ? ec(eE, ex, eb, et, J, eh) : ec(ex, eE, eb, J, et, eh);
                if (eC !== eo) {
                  if (eC)
                    continue;
                  ew = !1;
                  break
                }
                if (e_) {
                  if (!Nr(et, function (J, et) {
                    if (!jt(e_, et) && (ex === J || ed(ex, J, el, ec, eh)))
                      return e_.push(et)
                  })) {
                    ew = !1;
                    break
                  }
                } else if (!(ex === eE || ed(ex, eE, el, ec, eh))) {
                  ew = !1;
                  break
                }
              }
              return eh.delete(J),
                eh.delete(et),
                ew
            }
            function Yn(J) {
              return nh(Du(J, eo, Bu), J + "")
            }
            function li(J) {
              return Zs(J, V, nn)
            }
            function pi(J) {
              return Zs(J, on, ns)
            }
            var r9 = rV ? function (J) {
              return rV.get(J)
            }
              : Di;
            function je(J) {
              for (var et = J.name + "", eo = rW[et], el = tj.call(rW, et) ? eo.length : 0; el--;) {
                var ec = eo[el]
                  , ed = ec.func;
                if (null == ed || ed == J)
                  return ec.name
              }
              return et
            }
            function qt(J) {
              return (tj.call(a, "placeholder") ? a : J).placeholder
            }
            function x() {
              var J = a.iteratee || Ti;
              return J = J === Ti ? Qs : J,
                arguments.length ? J(arguments[0], arguments[1]) : J
            }
            function nr(J, et) {
              var eo, el = J.__data__;
              return ("string" == (eo = typeof et) || "number" == eo || "symbol" == eo || "boolean" == eo ? "__proto__" !== et : null === et) ? el["string" == typeof et ? "string" : "hash"] : el.map
            }
            function gi(J) {
              for (var et = V(J), eo = et.length; eo--;) {
                var el = et[eo]
                  , ec = J[el];
                et[eo] = [el, ec, ec == ec && !K(ec)]
              }
              return et
            }
            function mt(J, et) {
              var el = null == J ? eo : J[et];
              return Xs(el) ? el : eo
            }
            var nn = rT ? function (J) {
              return null == J ? [] : jn(rT(J = tT(J)), function (et) {
                return t3.call(J, et)
              })
            }
              : Hi
              , ns = rT ? function (J) {
                for (var et = []; J;)
                  nt(et, nn(J)),
                    J = tY(J);
                return et
              }
                : Hi
              , no = en;
            function Ru(J, et, eo) {
              et = st(et, J);
              for (var el = -1, ec = et.length, ed = !1; ++el < ec;) {
                var eh = Wn(et[el]);
                if (!(ed = null != J && eo(J, eh)))
                  break;
                J = J[eh]
              }
              return ed || ++el != ec ? ed : !!(ec = null == J ? 0 : J.length) && ar(ec) && Zn(eh, ec) && (nX(J) || nQ(J))
            }
            function bu(J) {
              return "function" != typeof J.constructor || he(J) ? {} : r0(tY(J))
            }
            function ah(J) {
              return nX(J) || nQ(J) || !!(t8 && J && J[t8])
            }
            function Zn(J, et) {
              var eo = typeof J;
              return !!(et = et ?? 9007199254740991) && ("number" == eo || "symbol" != eo && tm.test(J)) && J > -1 && J % 1 == 0 && J < et
            }
            function rn(J, et, eo) {
              if (!K(eo))
                return !1;
              var el = typeof et;
              return ("number" == el ? !!(an(eo) && Zn(et, eo.length)) : "string" == el && et in eo) && bn(eo[et], J)
            }
            function _i(J, et) {
              if (nX(J))
                return !1;
              var eo = typeof J;
              return !!("number" == eo || "symbol" == eo || "boolean" == eo || null == J || pn(J)) || e1.test(J) || !e0.test(J) || null != et && J in tT(et)
            }
            function mi(J) {
              var et = je(J)
                , eo = a[et];
              if ("function" != typeof eo || !(et in H.prototype))
                return !1;
              if (J === eo)
                return !0;
              var el = r9(eo);
              return !!el && J === el[0]
            }
            (r$ && no(new r$(new ArrayBuffer(1))) != eN || rB && no(new rB) != eE || rF && no(rF.resolve()) != ek || rU && no(new rU) != eA || rz && no(new rz) != eI) && (no = function (J) {
              var et = en(J)
                , el = et == eS ? J.constructor : eo
                , ec = el ? wt(el) : "";
              if (ec)
                switch (ec) {
                  case rq:
                    return eN;
                  case rZ:
                    return eE;
                  case rG:
                    return ek;
                  case rY:
                    return eA;
                  case rK:
                    return eI
                }
              return et
            }
            );
            var nl = tM ? Jn : Ni;
            function he(J) {
              var et = J && J.constructor;
              return J === ("function" == typeof et && et.prototype || tN)
            }
            function Lu(J, et) {
              return function (el) {
                return null != el && el[J] === et && (et !== eo || J in tT(el))
              }
            }
            function Du(J, et, el) {
              return et = rO(et === eo ? J.length - 1 : et, 0),
                function () {
                  for (var eo = arguments, ec = -1, ed = rO(eo.length - et, 0), eh = tx(ed); ++ec < ed;)
                    eh[ec] = eo[et + ec];
                  ec = -1;
                  for (var ep = tx(et + 1); ++ec < et;)
                    ep[ec] = eo[ec];
                  return ep[et] = el(eh),
                    cn(J, this, ep)
                }
            }
            function Hu(J, et) {
              return et.length < 2 ? J : _t(J, Cn(et, 0, -1))
            }
            function wi(J, et) {
              if (!("constructor" === et && "function" == typeof J[et]) && "__proto__" != et)
                return J[et]
            }
            var nc = Uu(r6)
              , nd = rC || function (J, et) {
                return t7.setTimeout(J, et)
              }
              , nh = Uu(r4);
            function $u(J, et, eo) {
              var el, ec, ed = et + "";
              return nh(J, function (J, et) {
                var eo = et.length;
                if (!eo)
                  return J;
                var el = eo - 1;
                return et[el] = (eo > 1 ? "& " : "") + et[el],
                  et = et.join(eo > 2 ? ", " : " "),
                  J.replace(e8, `{
/* [wrapped with ` + et + `] */
`)
              }(ed, (el = (ec = ed.match(e7)) ? ec[1].split(e9) : [],
                mn(ef, function (J) {
                  var et = "_." + J[0];
                  eo & J[1] && !Ee(el, et) && el.push(et)
                }),
                el.sort())))
            }
            function Uu(J) {
              var et = 0
                , el = 0;
              return function () {
                var ec = rM()
                  , ed = 16 - (ec - el);
                if (el = ec,
                  ed > 0) {
                  if (++et >= 800)
                    return arguments[0]
                } else
                  et = 0;
                return J.apply(eo, arguments)
              }
            }
            function tr(J, et) {
              var el = -1
                , ec = J.length
                , ed = ec - 1;
              for (et = et === eo ? ec : et; ++el < et;) {
                var eh = ei(el, ed)
                  , ep = J[eh];
                J[eh] = J[el],
                  J[el] = ep
              }
              return J.length = et,
                J
            }
            var np = (tw = (e4 = sr(function (J) {
              var et = [];
              return 46 === J.charCodeAt(0) && et.push(""),
                J.replace(e2, function (J, eo, el, ec) {
                  et.push(el ? ec.replace(ta, "$1") : eo || J)
                }),
                et
            }, function (J) {
              return 500 === tw.size && tw.clear(),
                J
            })).cache,
              e4);
            function Wn(J) {
              if ("string" == typeof J || pn(J))
                return J;
              var et = J + "";
              return "0" == et && 1 / J == -eh ? "-0" : et
            }
            function wt(J) {
              if (null != J) {
                try {
                  return tD.call(J)
                } catch { }
                try {
                  return J + ""
                } catch { }
              }
              return ""
            }
            function Fu(J) {
              if (J instanceof H)
                return J.clone();
              var et = new Pn(J.__wrapped__, J.__chain__);
              return et.__actions__ = un(J.__actions__),
                et.__index__ = J.__index__,
                et.__values__ = J.__values__,
                et
            }
            var nf = L(function (J, et) {
              return Z(J) ? ue(J, j(et, 1, Z, !0)) : []
            })
              , nm = L(function (J, et) {
                var el = In(et);
                return Z(el) && (el = eo),
                  Z(J) ? ue(J, j(et, 1, Z, !0), x(el, 2)) : []
              })
              , ng = L(function (J, et) {
                var el = In(et);
                return Z(el) && (el = eo),
                  Z(J) ? ue(J, j(et, 1, Z, !0), eo, el) : []
              });
            function Mu(J, et, eo) {
              var el = null == J ? 0 : J.length;
              if (!el)
                return -1;
              var ec = null == eo ? 0 : b(eo);
              return ec < 0 && (ec = rO(el + ec, 0)),
                ye(J, x(et, 3), ec)
            }
            function qu(J, et, el) {
              var ec = null == J ? 0 : J.length;
              if (!ec)
                return -1;
              var ed = ec - 1;
              return el !== eo && (ed = b(el),
                ed = el < 0 ? rO(ec + ed, 0) : rN(ed, ec - 1)),
                ye(J, x(et, 3), ed, !0)
            }
            function Bu(J) {
              return (null == J ? 0 : J.length) ? j(J, 1) : []
            }
            function Gu(J) {
              return J && J.length ? J[0] : eo
            }
            var ny = L(function (J) {
              var et = G(J, ai);
              return et.length && et[0] === J[0] ? Vr(et) : []
            })
              , nb = L(function (J) {
                var et = In(J)
                  , el = G(J, ai);
                return et === In(el) ? et = eo : el.pop(),
                  el.length && el[0] === J[0] ? Vr(el, x(et, 2)) : []
              })
              , nw = L(function (J) {
                var et = In(J)
                  , el = G(J, ai);
                return (et = "function" == typeof et ? et : eo) && el.pop(),
                  el.length && el[0] === J[0] ? Vr(el, eo, et) : []
              });
            function In(J) {
              var et = null == J ? 0 : J.length;
              return et ? J[et - 1] : eo
            }
            var n_ = L(zu);
            function zu(J, et) {
              return J && J.length && et && et.length ? ti(J, et) : J
            }
            var nx = Yn(function (J, et) {
              var eo = null == J ? 0 : J.length
                , el = Zr(J, et);
              return ru(J, G(et, function (J) {
                return Zn(J, eo) ? +J : J
              }).sort(pu)),
                el
            });
            function Ai(J) {
              return null == J ? J : rL.call(J)
            }
            var nE = L(function (J) {
              return it(j(J, 1, Z, !0))
            })
              , nC = L(function (J) {
                var et = In(J);
                return Z(et) && (et = eo),
                  it(j(J, 1, Z, !0), x(et, 2))
              })
              , nS = L(function (J) {
                var et = In(J);
                return et = "function" == typeof et ? et : eo,
                  it(j(J, 1, Z, !0), eo, et)
              });
            function Ci(J) {
              if (!(J && J.length))
                return [];
              var et = 0;
              return J = jn(J, function (J) {
                if (Z(J))
                  return et = rO(J.length, et),
                    !0
              }),
                Fr(et, function (et) {
                  return G(J, $r(et))
                })
            }
            function Ku(J, et) {
              if (!(J && J.length))
                return [];
              var el = Ci(J);
              return null == et ? el : G(el, function (J) {
                return cn(et, eo, J)
              })
            }
            var nk = L(function (J, et) {
              return Z(J) ? ue(J, et) : []
            })
              , nT = L(function (J) {
                return ui(jn(J, Z))
              })
              , nA = L(function (J) {
                var et = In(J);
                return Z(et) && (et = eo),
                  ui(jn(J, Z), x(et, 2))
              })
              , nP = L(function (J) {
                var et = In(J);
                return et = "function" == typeof et ? et : eo,
                  ui(jn(J, Z), eo, et)
              })
              , nR = L(Ci)
              , nI = L(function (J) {
                var et = J.length
                  , el = et > 1 ? J[et - 1] : eo;
                return el = "function" == typeof el ? (J.pop(),
                  el) : eo,
                  Ku(J, el)
              });
            function Yu(J) {
              var et = a(J);
              return et.__chain__ = !0,
                et
            }
            function er(J, et) {
              return et(J)
            }
            var nO = Yn(function (J) {
              var et = J.length
                , el = et ? J[0] : 0
                , ec = this.__wrapped__
                , s = function (et) {
                  return Zr(et, J)
                };
              return !(et > 1) && !this.__actions__.length && ec instanceof H && Zn(el) ? ((ec = ec.slice(el, +el + (et ? 1 : 0))).__actions__.push({
                func: er,
                args: [s],
                thisArg: eo
              }),
                new Pn(ec, this.__chain__).thru(function (J) {
                  return et && !J.length && J.push(eo),
                    J
                })) : this.thru(s)
            })
              , nN = Je(function (J, et, eo) {
                tj.call(J, eo) ? ++J[eo] : zn(J, eo, 1)
              })
              , nM = wu(Mu)
              , nD = wu(qu);
            function Zu(J, et) {
              return (nX(J) ? mn : r1)(J, x(et, 3))
            }
            function Ju(J, et) {
              return (nX(J) ? function (J, et) {
                for (var eo = null == J ? 0 : J.length; eo-- && !1 !== et(J[eo], eo, J);)
                  ;
                return J
              }
                : r2)(J, x(et, 3))
            }
            var nj = Je(function (J, et, eo) {
              tj.call(J, eo) ? J[eo].push(et) : zn(J, eo, [et])
            })
              , nL = L(function (J, et, eo) {
                var el = -1
                  , ec = "function" == typeof et
                  , ed = an(J) ? tx(J.length) : [];
                return r1(J, function (J) {
                  ed[++el] = ec ? cn(et, J, eo) : ae(J, et, eo)
                }),
                  ed
              })
              , n$ = Je(function (J, et, eo) {
                zn(J, eo, et)
              });
            function rr(J, et) {
              return (nX(J) ? G : Vs)(J, x(et, 3))
            }
            var nB = Je(function (J, et, eo) {
              J[eo ? 0 : 1].push(et)
            }, function () {
              return [[], []]
            })
              , nF = L(function (J, et) {
                if (null == J)
                  return [];
                var eo = et.length;
                return eo > 1 && rn(J, et[0], et[1]) ? et = [] : eo > 2 && rn(et[0], et[1], et[2]) && (et = [et[0]]),
                  tu(J, j(et, 1), [])
              })
              , nU = rb || function () {
                return t7.Date.now()
              }
              ;
            function Xu(J, et, el) {
              return et = el ? eo : et,
                et = J && null == et ? J.length : et,
                Kn(J, 128, eo, eo, eo, eo, et)
            }
            function Qu(J, et) {
              var ec;
              if ("function" != typeof et)
                throw new tR(el);
              return J = b(J),
                function () {
                  return --J > 0 && (ec = et.apply(this, arguments)),
                    J <= 1 && (et = eo),
                    ec
                }
            }
            var nz = L(function (J, et, eo) {
              var el = 1;
              if (eo.length) {
                var ec = tt(eo, qt(nz));
                el |= 32
              }
              return Kn(J, el, et, eo, ec)
            })
              , nH = L(function (J, et, eo) {
                var el = 3;
                if (eo.length) {
                  var ec = tt(eo, qt(nH));
                  el |= 32
                }
                return Kn(et, el, J, eo, ec)
              });
            function na(J, et, ec) {
              var ed, eh, ep, ef, em, eg, ey = 0, eb = !1, ew = !1, e_ = !0;
              if ("function" != typeof J)
                throw new tR(el);
              function I(et) {
                var el = ed
                  , ec = eh;
                return ed = eh = eo,
                  ey = et,
                  ef = J.apply(ec, el)
              }
              function y(J) {
                var el = J - eg
                  , ec = J - ey;
                return eg === eo || el >= et || el < 0 || ew && ec >= ep
              }
              function D() {
                var J, eo, el, ec = nU();
                if (y(ec))
                  return N(ec);
                em = nd(D, (J = ec - eg,
                  eo = ec - ey,
                  el = et - J,
                  ew ? rN(el, ep - eo) : el))
              }
              function N(J) {
                return em = eo,
                  e_ && ed ? I(J) : (ed = eh = eo,
                    ef)
              }
              function gn() {
                var J, el = nU(), ec = y(el);
                if (ed = arguments,
                  eh = this,
                  eg = el,
                  ec) {
                  if (em === eo)
                    return ey = J = eg,
                      em = nd(D, et),
                      eb ? I(J) : ef;
                  if (ew)
                    return r8(em),
                      em = nd(D, et),
                      I(eg)
                }
                return em === eo && (em = nd(D, et)),
                  ef
              }
              return et = xn(et) || 0,
                K(ec) && (eb = !!ec.leading,
                  ep = (ew = "maxWait" in ec) ? rO(xn(ec.maxWait) || 0, et) : ep,
                  e_ = "trailing" in ec ? !!ec.trailing : e_),
                gn.cancel = function () {
                  em !== eo && r8(em),
                    ey = 0,
                    ed = eg = eh = em = eo
                }
                ,
                gn.flush = function () {
                  return em === eo ? ef : N(nU())
                }
                ,
                gn
            }
            var nV = L(function (J, et) {
              return Gs(J, 1, et)
            })
              , nW = L(function (J, et, eo) {
                return Gs(J, xn(et) || 0, eo)
              });
            function sr(J, et) {
              if ("function" != typeof J || null != et && "function" != typeof et)
                throw new tR(el);
              var e = function () {
                var eo = arguments
                  , el = et ? et.apply(this, eo) : eo[0]
                  , ec = e.cache;
                if (ec.has(el))
                  return ec.get(el);
                var ed = J.apply(this, eo);
                return e.cache = ec.set(el, ed) || ec,
                  ed
              };
              return e.cache = new (sr.Cache || Gn),
                e
            }
            function ur(J) {
              if ("function" != typeof J)
                throw new tR(el);
              return function () {
                var et = arguments;
                switch (et.length) {
                  case 0:
                    return !J.call(this);
                  case 1:
                    return !J.call(this, et[0]);
                  case 2:
                    return !J.call(this, et[0], et[1]);
                  case 3:
                    return !J.call(this, et[0], et[1], et[2])
                }
                return !J.apply(this, et)
              }
            }
            sr.Cache = Gn;
            var nq = L(function (J, et) {
              var eo = (et = 1 == et.length && nX(et[0]) ? G(et[0], hn(x())) : G(j(et, 1), hn(x()))).length;
              return L(function (el) {
                for (var ec = -1, ed = rN(el.length, eo); ++ec < ed;)
                  el[ec] = et[ec].call(this, el[ec]);
                return cn(J, this, el)
              })
            })
              , nZ = L(function (J, et) {
                var el = tt(et, qt(nZ));
                return Kn(J, 32, eo, et, el)
              })
              , nG = L(function (J, et) {
                var el = tt(et, qt(nG));
                return Kn(J, 64, eo, et, el)
              })
              , nY = Yn(function (J, et) {
                return Kn(J, 256, eo, eo, eo, et)
              });
            function bn(J, et) {
              return J === et || J != J && et != et
            }
            var nK = ke(Qr)
              , nJ = ke(function (J, et) {
                return J >= et
              })
              , nQ = Js(function () {
                return arguments
              }()) ? Js : function (J) {
                return Y(J) && tj.call(J, "callee") && !t3.call(J, "callee")
              }
              , nX = tx.isArray
              , n0 = rd ? hn(rd) : function (J) {
                return Y(J) && en(J) == eO
              }
              ;
            function an(J) {
              return null != J && ar(J.length) && !Jn(J)
            }
            function Z(J) {
              return Y(J) && an(J)
            }
            var n1 = rA || Ni
              , n2 = rh ? hn(rh) : function (J) {
                return Y(J) && en(J) == eb
              }
              ;
            function Ei(J) {
              if (!Y(J))
                return !1;
              var et = en(J);
              return et == ew || "[object DOMException]" == et || "string" == typeof J.message && "string" == typeof J.name && !pe(J)
            }
            function Jn(J) {
              if (!K(J))
                return !1;
              var et = en(J);
              return et == e_ || et == ex || "[object AsyncFunction]" == et || "[object Proxy]" == et
            }
            function ea(J) {
              return "number" == typeof J && J == b(J)
            }
            function ar(J) {
              return "number" == typeof J && J > -1 && J % 1 == 0 && J <= 9007199254740991
            }
            function K(J) {
              var et = typeof J;
              return null != J && ("object" == et || "function" == et)
            }
            function Y(J) {
              return null != J && "object" == typeof J
            }
            var n3 = rp ? hn(rp) : function (J) {
              return Y(J) && no(J) == eE
            }
              ;
            function ia(J) {
              return "number" == typeof J || Y(J) && en(J) == eC
            }
            function pe(J) {
              if (!Y(J) || en(J) != eS)
                return !1;
              var et = tY(J);
              if (null === et)
                return !0;
              var eo = tj.call(et, "constructor") && et.constructor;
              return "function" == typeof eo && eo instanceof eo && tD.call(eo) == tF
            }
            var n5 = rm ? hn(rm) : function (J) {
              return Y(J) && en(J) == eT
            }
              , n6 = rg ? hn(rg) : function (J) {
                return Y(J) && no(J) == eA
              }
              ;
            function or(J) {
              return "string" == typeof J || !nX(J) && Y(J) && en(J) == eP
            }
            function pn(J) {
              return "symbol" == typeof J || Y(J) && en(J) == eR
            }
            var n4 = ry ? hn(ry) : function (J) {
              return Y(J) && ar(J.length) && !!t1[en(J)]
            }
              , n8 = ke(ni)
              , n7 = ke(function (J, et) {
                return J <= et
              });
            function ua(J) {
              if (!J)
                return [];
              if (an(J))
                return or(J) ? On(J) : un(J);
              if (t9 && J[t9])
                return function (J) {
                  for (var et, eo = []; !(et = J.next()).done;)
                    eo.push(et.value);
                  return eo
                }(J[t9]());
              var et = no(J);
              return (et == eE ? qr : et == eA ? Se : Gt)(J)
            }
            function Xn(J) {
              return J ? (J = xn(J)) === eh || J === -eh ? (J < 0 ? -1 : 1) * 17976931348623157e292 : J == J ? J : 0 : 0 === J ? J : 0
            }
            function b(J) {
              var et = Xn(J)
                , eo = et % 1;
              return et == et ? eo ? et - eo : et : 0
            }
            function aa(J) {
              return J ? vt(b(J), 0, 4294967295) : 0
            }
            function xn(J) {
              if ("number" == typeof J)
                return J;
              if (pn(J))
                return ep;
              if (K(J)) {
                var et = "function" == typeof J.valueOf ? J.valueOf() : J;
                J = K(et) ? et + "" : et
              }
              if ("string" != typeof J)
                return 0 === J ? J : +J;
              J = ys(J);
              var eo = th.test(J);
              return eo || tf.test(J) ? t6(J.slice(2), eo ? 2 : 8) : td.test(J) ? ep : +J
            }
            function oa(J) {
              return Un(J, on(J))
            }
            function W(J) {
              return null == J ? "" : ln(J)
            }
            var n9 = Ft(function (J, et) {
              if (he(et) || an(et)) {
                Un(et, V(et), J);
                return
              }
              for (var eo in et)
                tj.call(et, eo) && se(J, eo, et[eo])
            })
              , ir = Ft(function (J, et) {
                Un(et, on(et), J)
              })
              , io = Ft(function (J, et, eo, el) {
                Un(et, on(et), J, el)
              })
              , il = Ft(function (J, et, eo, el) {
                Un(et, V(et), J, el)
              })
              , ic = Yn(Zr)
              , iu = L(function (J, et) {
                J = tT(J);
                var el = -1
                  , ec = et.length
                  , ed = ec > 2 ? et[2] : eo;
                for (ed && rn(et[0], et[1], ed) && (ec = 1); ++el < ec;)
                  for (var eh = et[el], ep = on(eh), ef = -1, em = ep.length; ++ef < em;) {
                    var eg = ep[ef]
                      , ey = J[eg];
                    (ey === eo || bn(ey, tN[eg]) && !tj.call(J, eg)) && (J[eg] = eh[eg])
                  }
                return J
              })
              , id = L(function (J) {
                return J.push(eo, yu),
                  cn(iy, eo, J)
              });
            function Si(J, et, el) {
              var ec = null == J ? eo : _t(J, et);
              return ec === eo ? el : ec
            }
            function Oi(J, et) {
              return null != J && Ru(J, et, Ac)
            }
            var ih = Au(function (J, et, eo) {
              null != et && "function" != typeof et.toString && (et = tB.call(et)),
                J[et] = eo
            }, bi(fn))
              , ip = Au(function (J, et, eo) {
                null != et && "function" != typeof et.toString && (et = tB.call(et)),
                  tj.call(J, et) ? J[et].push(eo) : J[et] = [eo]
              }, x)
              , im = L(ae);
            function V(J) {
              return an(J) ? Fs(J) : jr(J)
            }
            function on(J) {
              return an(J) ? Fs(J, !0) : function (J) {
                if (!K(J))
                  return function (J) {
                    var et = [];
                    if (null != J)
                      for (var eo in tT(J))
                        et.push(eo);
                    return et
                  }(J);
                var et = he(J)
                  , eo = [];
                for (var el in J)
                  "constructor" == el && (et || !tj.call(J, el)) || eo.push(el);
                return eo
              }(J)
            }
            var ig = Ft(function (J, et, eo) {
              Ke(J, et, eo)
            })
              , iy = Ft(function (J, et, eo, el) {
                Ke(J, et, eo, el)
              })
              , ib = Yn(function (J, et) {
                var eo = {};
                if (null == J)
                  return eo;
                var el = !1;
                et = G(et, function (et) {
                  return et = st(et, J),
                    el || (el = et.length > 1),
                    et
                }),
                  Un(J, pi(J), eo),
                  el && (eo = An(eo, 7, kc));
                for (var ec = et.length; ec--;)
                  si(eo, et[ec]);
                return eo
              })
              , iw = Yn(function (J, et) {
                return null == J ? {} : eu(J, et, function (et, eo) {
                  return Oi(J, eo)
                })
              });
            function ha(J, et) {
              if (null == J)
                return {};
              var eo = G(pi(J), function (J) {
                return [J]
              });
              return et = x(et),
                eu(J, eo, function (J, eo) {
                  return et(J, eo[0])
                })
            }
            var i_ = xu(V)
              , ix = xu(on);
            function Gt(J) {
              return null == J ? [] : Mr(J, V(J))
            }
            var iE = Mt(function (J, et, eo) {
              return et = et.toLowerCase(),
                J + (eo ? da(et) : et)
            });
            function da(J) {
              return iR(W(J).toLowerCase())
            }
            function ga(J) {
              return (J = W(J)) && J.replace(tg, rw).replace(tG, "")
            }
            var iC = Mt(function (J, et, eo) {
              return J + (eo ? "-" : "") + et.toLowerCase()
            })
              , iS = Mt(function (J, et, eo) {
                return J + (eo ? " " : "") + et.toLowerCase()
              })
              , ik = mu("toLowerCase")
              , iT = Mt(function (J, et, eo) {
                return J + (eo ? "_" : "") + et.toLowerCase()
              })
              , iA = Mt(function (J, et, eo) {
                return J + (eo ? " " : "") + iR(et)
              })
              , iP = Mt(function (J, et, eo) {
                return J + (eo ? " " : "") + et.toUpperCase()
              })
              , iR = mu("toUpperCase");
            function va(J, et, el) {
              var ec;
              return J = W(J),
                (et = el ? eo : et) === eo ? (ec = J,
                  tQ.test(ec)) ? J.match(tK) || [] : J.match(tn) || [] : J.match(et) || []
            }
            var iI = L(function (J, et) {
              try {
                return cn(J, eo, et)
              } catch (J) {
                return Ei(J) ? J : new tC(J)
              }
            })
              , iO = Yn(function (J, et) {
                return mn(et, function (et) {
                  zn(J, et = Wn(et), nz(J[et], J))
                }),
                  J
              });
            function bi(J) {
              return function () {
                return J
              }
            }
            var iN = Pu()
              , iM = Pu(!0);
            function fn(J) {
              return J
            }
            function Ti(J) {
              return Qs("function" == typeof J ? J : An(J, 1))
            }
            var iD = L(function (J, et) {
              return function (eo) {
                return ae(eo, J, et)
              }
            })
              , ij = L(function (J, et) {
                return function (eo) {
                  return ae(J, eo, et)
                }
              });
            function Li(J, et, eo) {
              var el = V(et)
                , ec = ze(et, el);
              null != eo || K(et) && (ec.length || !el.length) || (eo = et,
                et = J,
                J = this,
                ec = ze(et, V(et)));
              var ed = !(K(eo) && "chain" in eo) || !!eo.chain
                , eh = Jn(J);
              return mn(ec, function (eo) {
                var el = et[eo];
                J[eo] = el,
                  eh && (J.prototype[eo] = function () {
                    var et = this.__chain__;
                    if (ed || et) {
                      var eo = J(this.__wrapped__);
                      return (eo.__actions__ = un(this.__actions__)).push({
                        func: el,
                        args: arguments,
                        thisArg: J
                      }),
                        eo.__chain__ = et,
                        eo
                    }
                    return el.apply(J, nt([this.value()], arguments))
                  }
                  )
              }),
                J
            }
            function Di() { }
            var iL = ci(G)
              , i$ = ci(As)
              , iB = ci(Nr);
            function ma(J) {
              return _i(J) ? $r(Wn(J)) : function (et) {
                return _t(et, J)
              }
            }
            var iF = Cu()
              , iU = Cu(!0);
            function Hi() {
              return []
            }
            function Ni() {
              return !1
            }
            var iz = Qe(function (J, et) {
              return J + et
            }, 0)
              , iH = hi("ceil")
              , iV = Qe(function (J, et) {
                return J / et
              }, 1)
              , iW = hi("floor")
              , iq = Qe(function (J, et) {
                return J * et
              }, 1)
              , iZ = hi("round")
              , iG = Qe(function (J, et) {
                return J - et
              }, 0);
            return a.after = function (J, et) {
              if ("function" != typeof et)
                throw new tR(el);
              return J = b(J),
                function () {
                  if (--J < 1)
                    return et.apply(this, arguments)
                }
            }
              ,
              a.ary = Xu,
              a.assign = n9,
              a.assignIn = ir,
              a.assignInWith = io,
              a.assignWith = il,
              a.at = ic,
              a.before = Qu,
              a.bind = nz,
              a.bindAll = iO,
              a.bindKey = nH,
              a.castArray = function () {
                if (!arguments.length)
                  return [];
                var J = arguments[0];
                return nX(J) ? J : [J]
              }
              ,
              a.chain = Yu,
              a.chunk = function (J, et, el) {
                et = (el ? rn(J, et, el) : et === eo) ? 1 : rO(b(et), 0);
                var ec = null == J ? 0 : J.length;
                if (!ec || et < 1)
                  return [];
                for (var ed = 0, eh = 0, ep = tx(rS(ec / et)); ed < ec;)
                  ep[eh++] = Cn(J, ed, ed += et);
                return ep
              }
              ,
              a.compact = function (J) {
                for (var et = -1, eo = null == J ? 0 : J.length, el = 0, ec = []; ++et < eo;) {
                  var ed = J[et];
                  ed && (ec[el++] = ed)
                }
                return ec
              }
              ,
              a.concat = function () {
                var J = arguments.length;
                if (!J)
                  return [];
                for (var et = tx(J - 1), eo = arguments[0], el = J; el--;)
                  et[el - 1] = arguments[el];
                return nt(nX(eo) ? un(eo) : [eo], j(et, 1))
              }
              ,
              a.cond = function (J) {
                var et = null == J ? 0 : J.length
                  , eo = x();
                return J = et ? G(J, function (J) {
                  if ("function" != typeof J[1])
                    throw new tR(el);
                  return [eo(J[0]), J[1]]
                }) : [],
                  L(function (eo) {
                    for (var el = -1; ++el < et;) {
                      var ec = J[el];
                      if (cn(ec[0], this, eo))
                        return cn(ec[1], this, eo)
                    }
                  })
              }
              ,
              a.conforms = function (J) {
                var et, eo;
                return eo = V(et = An(J, 1)),
                  function (J) {
                    return Bs(J, et, eo)
                  }
              }
              ,
              a.constant = bi,
              a.countBy = nN,
              a.create = function (J, et) {
                var eo = r0(J);
                return null == et ? eo : qs(eo, et)
              }
              ,
              a.curry = function ku(J, et, el) {
                et = el ? eo : et;
                var ec = Kn(J, 8, eo, eo, eo, eo, eo, et);
                return ec.placeholder = ku.placeholder,
                  ec
              }
              ,
              a.curryRight = function ju(J, et, el) {
                et = el ? eo : et;
                var ec = Kn(J, 16, eo, eo, eo, eo, eo, et);
                return ec.placeholder = ju.placeholder,
                  ec
              }
              ,
              a.debounce = na,
              a.defaults = iu,
              a.defaultsDeep = id,
              a.defer = nV,
              a.delay = nW,
              a.difference = nf,
              a.differenceBy = nm,
              a.differenceWith = ng,
              a.drop = function (J, et, el) {
                var ec = null == J ? 0 : J.length;
                return ec ? Cn(J, (et = el || et === eo ? 1 : b(et)) < 0 ? 0 : et, ec) : []
              }
              ,
              a.dropRight = function (J, et, el) {
                var ec = null == J ? 0 : J.length;
                return ec ? Cn(J, 0, (et = ec - (et = el || et === eo ? 1 : b(et))) < 0 ? 0 : et) : []
              }
              ,
              a.dropRightWhile = function (J, et) {
                return J && J.length ? Ze(J, x(et, 3), !0, !0) : []
              }
              ,
              a.dropWhile = function (J, et) {
                return J && J.length ? Ze(J, x(et, 3), !0) : []
              }
              ,
              a.fill = function (J, et, el, ec) {
                var ed = null == J ? 0 : J.length;
                return ed ? (el && "number" != typeof el && rn(J, et, el) && (el = 0,
                  ec = ed),
                  function (J, et, el, ec) {
                    var ed = J.length;
                    for ((el = b(el)) < 0 && (el = -el > ed ? 0 : ed + el),
                      (ec = ec === eo || ec > ed ? ed : b(ec)) < 0 && (ec += ed),
                      ec = el > ec ? 0 : aa(ec); el < ec;)
                      J[el++] = et;
                    return J
                  }(J, et, el, ec)) : []
              }
              ,
              a.filter = function (J, et) {
                return (nX(J) ? jn : Ks)(J, x(et, 3))
              }
              ,
              a.flatMap = function (J, et) {
                return j(rr(J, et), 1)
              }
              ,
              a.flatMapDeep = function (J, et) {
                return j(rr(J, et), eh)
              }
              ,
              a.flatMapDepth = function (J, et, el) {
                return el = el === eo ? 1 : b(el),
                  j(rr(J, et), el)
              }
              ,
              a.flatten = Bu,
              a.flattenDeep = function (J) {
                return (null == J ? 0 : J.length) ? j(J, eh) : []
              }
              ,
              a.flattenDepth = function (J, et) {
                return (null == J ? 0 : J.length) ? j(J, et = et === eo ? 1 : b(et)) : []
              }
              ,
              a.flip = function (J) {
                return Kn(J, 512)
              }
              ,
              a.flow = iN,
              a.flowRight = iM,
              a.fromPairs = function (J) {
                for (var et = -1, eo = null == J ? 0 : J.length, el = {}; ++et < eo;) {
                  var ec = J[et];
                  el[ec[0]] = ec[1]
                }
                return el
              }
              ,
              a.functions = function (J) {
                return null == J ? [] : ze(J, V(J))
              }
              ,
              a.functionsIn = function (J) {
                return null == J ? [] : ze(J, on(J))
              }
              ,
              a.groupBy = nj,
              a.initial = function (J) {
                return (null == J ? 0 : J.length) ? Cn(J, 0, -1) : []
              }
              ,
              a.intersection = ny,
              a.intersectionBy = nb,
              a.intersectionWith = nw,
              a.invert = ih,
              a.invertBy = ip,
              a.invokeMap = nL,
              a.iteratee = Ti,
              a.keyBy = n$,
              a.keys = V,
              a.keysIn = on,
              a.map = rr,
              a.mapKeys = function (J, et) {
                var eo = {};
                return et = x(et, 3),
                  $n(J, function (J, el, ec) {
                    zn(eo, et(J, el, ec), J)
                  }),
                  eo
              }
              ,
              a.mapValues = function (J, et) {
                var eo = {};
                return et = x(et, 3),
                  $n(J, function (J, el, ec) {
                    zn(eo, el, et(J, el, ec))
                  }),
                  eo
              }
              ,
              a.matches = function (J) {
                return ks(An(J, 1))
              }
              ,
              a.matchesProperty = function (J, et) {
                return js(J, An(et, 1))
              }
              ,
              a.memoize = sr,
              a.merge = ig,
              a.mergeWith = iy,
              a.method = iD,
              a.methodOf = ij,
              a.mixin = Li,
              a.negate = ur,
              a.nthArg = function (J) {
                return J = b(J),
                  L(function (et) {
                    return nu(et, J)
                  })
              }
              ,
              a.omit = ib,
              a.omitBy = function (J, et) {
                return ha(J, ur(x(et)))
              }
              ,
              a.once = function (J) {
                return Qu(2, J)
              }
              ,
              a.orderBy = function (J, et, el, ec) {
                return null == J ? [] : (nX(et) || (et = null == et ? [] : [et]),
                  nX(el = ec ? eo : el) || (el = null == el ? [] : [el]),
                  tu(J, et, el))
              }
              ,
              a.over = iL,
              a.overArgs = nq,
              a.overEvery = i$,
              a.overSome = iB,
              a.partial = nZ,
              a.partialRight = nG,
              a.partition = nB,
              a.pick = iw,
              a.pickBy = ha,
              a.property = ma,
              a.propertyOf = function (J) {
                return function (et) {
                  return null == J ? eo : _t(J, et)
                }
              }
              ,
              a.pull = n_,
              a.pullAll = zu,
              a.pullAllBy = function (J, et, eo) {
                return J && J.length && et && et.length ? ti(J, et, x(eo, 2)) : J
              }
              ,
              a.pullAllWith = function (J, et, el) {
                return J && J.length && et && et.length ? ti(J, et, eo, el) : J
              }
              ,
              a.pullAt = nx,
              a.range = iF,
              a.rangeRight = iU,
              a.rearg = nY,
              a.reject = function (J, et) {
                return (nX(J) ? jn : Ks)(J, ur(x(et, 3)))
              }
              ,
              a.remove = function (J, et) {
                var eo = [];
                if (!(J && J.length))
                  return eo;
                var el = -1
                  , ec = []
                  , ed = J.length;
                for (et = x(et, 3); ++el < ed;) {
                  var eh = J[el];
                  et(eh, el, J) && (eo.push(eh),
                    ec.push(el))
                }
                return ru(J, ec),
                  eo
              }
              ,
              a.rest = function (J, et) {
                if ("function" != typeof J)
                  throw new tR(el);
                return L(J, et = et === eo ? et : b(et))
              }
              ,
              a.reverse = Ai,
              a.sampleSize = function (J, et, el) {
                return et = (el ? rn(J, et, el) : et === eo) ? 1 : b(et),
                  (nX(J) ? function (J, et) {
                    return tr(un(J), vt(et, 0, J.length))
                  }
                    : function (J, et) {
                      var eo = Gt(J);
                      return tr(eo, vt(et, 0, eo.length))
                    }
                  )(J, et)
              }
              ,
              a.set = function (J, et, eo) {
                return null == J ? J : fe(J, et, eo)
              }
              ,
              a.setWith = function (J, et, el, ec) {
                return ec = "function" == typeof ec ? ec : eo,
                  null == J ? J : fe(J, et, el, ec)
              }
              ,
              a.shuffle = function (J) {
                return (nX(J) ? function (J) {
                  return tr(un(J))
                }
                  : function (J) {
                    return tr(Gt(J))
                  }
                )(J)
              }
              ,
              a.slice = function (J, et, el) {
                var ec = null == J ? 0 : J.length;
                return ec ? (el && "number" != typeof el && rn(J, et, el) ? (et = 0,
                  el = ec) : (et = null == et ? 0 : b(et),
                    el = el === eo ? ec : b(el)),
                  Cn(J, et, el)) : []
              }
              ,
              a.sortBy = nF,
              a.sortedUniq = function (J) {
                return J && J.length ? su(J) : []
              }
              ,
              a.sortedUniqBy = function (J, et) {
                return J && J.length ? su(J, x(et, 2)) : []
              }
              ,
              a.split = function (J, et, el) {
                return el && "number" != typeof el && rn(J, et, el) && (et = el = eo),
                  (el = el === eo ? 4294967295 : el >>> 0) ? (J = W(J)) && ("string" == typeof et || null != et && !n5(et)) && !(et = ln(et)) && Lt(J) ? ut(On(J), 0, el) : J.split(et, el) : []
              }
              ,
              a.spread = function (J, et) {
                if ("function" != typeof J)
                  throw new tR(el);
                return et = null == et ? 0 : rO(b(et), 0),
                  L(function (eo) {
                    var el = eo[et]
                      , ec = ut(eo, 0, et);
                    return el && nt(ec, el),
                      cn(J, this, ec)
                  })
              }
              ,
              a.tail = function (J) {
                var et = null == J ? 0 : J.length;
                return et ? Cn(J, 1, et) : []
              }
              ,
              a.take = function (J, et, el) {
                return J && J.length ? Cn(J, 0, (et = el || et === eo ? 1 : b(et)) < 0 ? 0 : et) : []
              }
              ,
              a.takeRight = function (J, et, el) {
                var ec = null == J ? 0 : J.length;
                return ec ? Cn(J, (et = ec - (et = el || et === eo ? 1 : b(et))) < 0 ? 0 : et, ec) : []
              }
              ,
              a.takeRightWhile = function (J, et) {
                return J && J.length ? Ze(J, x(et, 3), !1, !0) : []
              }
              ,
              a.takeWhile = function (J, et) {
                return J && J.length ? Ze(J, x(et, 3)) : []
              }
              ,
              a.tap = function (J, et) {
                return et(J),
                  J
              }
              ,
              a.throttle = function (J, et, eo) {
                var ec = !0
                  , ed = !0;
                if ("function" != typeof J)
                  throw new tR(el);
                return K(eo) && (ec = "leading" in eo ? !!eo.leading : ec,
                  ed = "trailing" in eo ? !!eo.trailing : ed),
                  na(J, et, {
                    leading: ec,
                    maxWait: et,
                    trailing: ed
                  })
              }
              ,
              a.thru = er,
              a.toArray = ua,
              a.toPairs = i_,
              a.toPairsIn = ix,
              a.toPath = function (J) {
                return nX(J) ? G(J, Wn) : pn(J) ? [J] : un(np(W(J)))
              }
              ,
              a.toPlainObject = oa,
              a.transform = function (J, et, eo) {
                var el = nX(J)
                  , ec = el || n1(J) || n4(J);
                if (et = x(et, 4),
                  null == eo) {
                  var ed = J && J.constructor;
                  eo = ec ? el ? new ed : [] : K(J) && Jn(ed) ? r0(tY(J)) : {}
                }
                return (ec ? mn : $n)(J, function (J, el, ec) {
                  return et(eo, J, el, ec)
                }),
                  eo
              }
              ,
              a.unary = function (J) {
                return Xu(J, 1)
              }
              ,
              a.union = nE,
              a.unionBy = nC,
              a.unionWith = nS,
              a.uniq = function (J) {
                return J && J.length ? it(J) : []
              }
              ,
              a.uniqBy = function (J, et) {
                return J && J.length ? it(J, x(et, 2)) : []
              }
              ,
              a.uniqWith = function (J, et) {
                return et = "function" == typeof et ? et : eo,
                  J && J.length ? it(J, eo, et) : []
              }
              ,
              a.unset = function (J, et) {
                return null == J || si(J, et)
              }
              ,
              a.unzip = Ci,
              a.unzipWith = Ku,
              a.update = function (J, et, eo) {
                return null == J ? J : au(J, et, oi(eo))
              }
              ,
              a.updateWith = function (J, et, el, ec) {
                return ec = "function" == typeof ec ? ec : eo,
                  null == J ? J : au(J, et, oi(el), ec)
              }
              ,
              a.values = Gt,
              a.valuesIn = function (J) {
                return null == J ? [] : Mr(J, on(J))
              }
              ,
              a.without = nk,
              a.words = va,
              a.wrap = function (J, et) {
                return nZ(oi(et), J)
              }
              ,
              a.xor = nT,
              a.xorBy = nA,
              a.xorWith = nP,
              a.zip = nR,
              a.zipObject = function (J, et) {
                return fu(J || [], et || [], se)
              }
              ,
              a.zipObjectDeep = function (J, et) {
                return fu(J || [], et || [], fe)
              }
              ,
              a.zipWith = nI,
              a.entries = i_,
              a.entriesIn = ix,
              a.extend = ir,
              a.extendWith = io,
              Li(a, a),
              a.add = iz,
              a.attempt = iI,
              a.camelCase = iE,
              a.capitalize = da,
              a.ceil = iH,
              a.clamp = function (J, et, el) {
                return el === eo && (el = et,
                  et = eo),
                  el !== eo && (el = (el = xn(el)) == el ? el : 0),
                  et !== eo && (et = (et = xn(et)) == et ? et : 0),
                  vt(xn(J), et, el)
              }
              ,
              a.clone = function (J) {
                return An(J, 4)
              }
              ,
              a.cloneDeep = function (J) {
                return An(J, 5)
              }
              ,
              a.cloneDeepWith = function (J, et) {
                return An(J, 5, et = "function" == typeof et ? et : eo)
              }
              ,
              a.cloneWith = function (J, et) {
                return An(J, 4, et = "function" == typeof et ? et : eo)
              }
              ,
              a.conformsTo = function (J, et) {
                return null == et || Bs(J, et, V(et))
              }
              ,
              a.deburr = ga,
              a.defaultTo = function (J, et) {
                return null == J || J != J ? et : J
              }
              ,
              a.divide = iV,
              a.endsWith = function (J, et, el) {
                J = W(J),
                  et = ln(et);
                var ec = J.length
                  , ed = el = el === eo ? ec : vt(b(el), 0, ec);
                return (el -= et.length) >= 0 && J.slice(el, ed) == et
              }
              ,
              a.eq = bn,
              a.escape = function (J) {
                return (J = W(J)) && eK.test(J) ? J.replace(eG, r_) : J
              }
              ,
              a.escapeRegExp = function (J) {
                return (J = W(J)) && e5.test(J) ? J.replace(e3, "\\$&") : J
              }
              ,
              a.every = function (J, et, el) {
                var ec = nX(J) ? As : mc;
                return el && rn(J, et, el) && (et = eo),
                  ec(J, x(et, 3))
              }
              ,
              a.find = nM,
              a.findIndex = Mu,
              a.findKey = function (J, et) {
                return Cs(J, x(et, 3), $n)
              }
              ,
              a.findLast = nD,
              a.findLastIndex = qu,
              a.findLastKey = function (J, et) {
                return Cs(J, x(et, 3), Xr)
              }
              ,
              a.floor = iW,
              a.forEach = Zu,
              a.forEachRight = Ju,
              a.forIn = function (J, et) {
                return null == J ? J : r3(J, x(et, 3), on)
              }
              ,
              a.forInRight = function (J, et) {
                return null == J ? J : r5(J, x(et, 3), on)
              }
              ,
              a.forOwn = function (J, et) {
                return J && $n(J, x(et, 3))
              }
              ,
              a.forOwnRight = function (J, et) {
                return J && Xr(J, x(et, 3))
              }
              ,
              a.get = Si,
              a.gt = nK,
              a.gte = nJ,
              a.has = function (J, et) {
                return null != J && Ru(J, et, Pc)
              }
              ,
              a.hasIn = Oi,
              a.head = Gu,
              a.identity = fn,
              a.includes = function (J, et, eo, el) {
                J = an(J) ? J : Gt(J),
                  eo = eo && !el ? b(eo) : 0;
                var ec = J.length;
                return eo < 0 && (eo = rO(ec + eo, 0)),
                  or(J) ? eo <= ec && J.indexOf(et, eo) > -1 : !!ec && Tt(J, et, eo) > -1
              }
              ,
              a.indexOf = function (J, et, eo) {
                var el = null == J ? 0 : J.length;
                if (!el)
                  return -1;
                var ec = null == eo ? 0 : b(eo);
                return ec < 0 && (ec = rO(el + ec, 0)),
                  Tt(J, et, ec)
              }
              ,
              a.inRange = function (J, et, el) {
                var ec, ed, eh;
                return et = Xn(et),
                  el === eo ? (el = et,
                    et = 0) : el = Xn(el),
                  (ec = J = xn(J)) >= rN(ed = et, eh = el) && ec < rO(ed, eh)
              }
              ,
              a.invoke = im,
              a.isArguments = nQ,
              a.isArray = nX,
              a.isArrayBuffer = n0,
              a.isArrayLike = an,
              a.isArrayLikeObject = Z,
              a.isBoolean = function (J) {
                return !0 === J || !1 === J || Y(J) && en(J) == ey
              }
              ,
              a.isBuffer = n1,
              a.isDate = n2,
              a.isElement = function (J) {
                return Y(J) && 1 === J.nodeType && !pe(J)
              }
              ,
              a.isEmpty = function (J) {
                if (null == J)
                  return !0;
                if (an(J) && (nX(J) || "string" == typeof J || "function" == typeof J.splice || n1(J) || n4(J) || nQ(J)))
                  return !J.length;
                var et = no(J);
                if (et == eE || et == eA)
                  return !J.size;
                if (he(J))
                  return !jr(J).length;
                for (var eo in J)
                  if (tj.call(J, eo))
                    return !1;
                return !0
              }
              ,
              a.isEqual = function (J, et) {
                return oe(J, et)
              }
              ,
              a.isEqualWith = function (J, et, el) {
                var ec = (el = "function" == typeof el ? el : eo) ? el(J, et) : eo;
                return ec === eo ? oe(J, et, eo, el) : !!ec
              }
              ,
              a.isError = Ei,
              a.isFinite = function (J) {
                return "number" == typeof J && rP(J)
              }
              ,
              a.isFunction = Jn,
              a.isInteger = ea,
              a.isLength = ar,
              a.isMap = n3,
              a.isMatch = function (J, et) {
                return J === et || kr(J, et, gi(et))
              }
              ,
              a.isMatchWith = function (J, et, el) {
                return el = "function" == typeof el ? el : eo,
                  kr(J, et, gi(et), el)
              }
              ,
              a.isNaN = function (J) {
                return ia(J) && J != +J
              }
              ,
              a.isNative = function (J) {
                if (nl(J))
                  throw new tC("Unsupported core-js use. Try https://npms.io/search?q=ponyfill.");
                return Xs(J)
              }
              ,
              a.isNil = function (J) {
                return null == J
              }
              ,
              a.isNull = function (J) {
                return null === J
              }
              ,
              a.isNumber = ia,
              a.isObject = K,
              a.isObjectLike = Y,
              a.isPlainObject = pe,
              a.isRegExp = n5,
              a.isSafeInteger = function (J) {
                return ea(J) && J >= -9007199254740991 && J <= 9007199254740991
              }
              ,
              a.isSet = n6,
              a.isString = or,
              a.isSymbol = pn,
              a.isTypedArray = n4,
              a.isUndefined = function (J) {
                return J === eo
              }
              ,
              a.isWeakMap = function (J) {
                return Y(J) && no(J) == eI
              }
              ,
              a.isWeakSet = function (J) {
                return Y(J) && "[object WeakSet]" == en(J)
              }
              ,
              a.join = function (J, et) {
                return null == J ? "" : rR.call(J, et)
              }
              ,
              a.kebabCase = iC,
              a.last = In,
              a.lastIndexOf = function (J, et, el) {
                var ec = null == J ? 0 : J.length;
                if (!ec)
                  return -1;
                var ed = ec;
                return el !== eo && (ed = (ed = b(el)) < 0 ? rO(ec + ed, 0) : rN(ed, ec - 1)),
                  et == et ? function (J, et, eo) {
                    for (var el = eo + 1; el-- && J[el] !== et;)
                      ;
                    return el
                  }(J, et, ed) : ye(J, Is, ed, !0)
              }
              ,
              a.lowerCase = iS,
              a.lowerFirst = ik,
              a.lt = n8,
              a.lte = n7,
              a.max = function (J) {
                return J && J.length ? Ge(J, fn, Qr) : eo
              }
              ,
              a.maxBy = function (J, et) {
                return J && J.length ? Ge(J, x(et, 2), Qr) : eo
              }
              ,
              a.mean = function (J) {
                return xs(J, fn)
              }
              ,
              a.meanBy = function (J, et) {
                return xs(J, x(et, 2))
              }
              ,
              a.min = function (J) {
                return J && J.length ? Ge(J, fn, ni) : eo
              }
              ,
              a.minBy = function (J, et) {
                return J && J.length ? Ge(J, x(et, 2), ni) : eo
              }
              ,
              a.stubArray = Hi,
              a.stubFalse = Ni,
              a.stubObject = function () {
                return {}
              }
              ,
              a.stubString = function () {
                return ""
              }
              ,
              a.stubTrue = function () {
                return !0
              }
              ,
              a.multiply = iq,
              a.nth = function (J, et) {
                return J && J.length ? nu(J, b(et)) : eo
              }
              ,
              a.noConflict = function () {
                return t7._ === this && (t7._ = tU),
                  this
              }
              ,
              a.noop = Di,
              a.now = nU,
              a.pad = function (J, et, eo) {
                J = W(J);
                var el = (et = b(et)) ? Dt(J) : 0;
                if (!et || el >= et)
                  return J;
                var ec = (et - el) / 2;
                return Ve(rk(ec), eo) + J + Ve(rS(ec), eo)
              }
              ,
              a.padEnd = function (J, et, eo) {
                J = W(J);
                var el = (et = b(et)) ? Dt(J) : 0;
                return et && el < et ? J + Ve(et - el, eo) : J
              }
              ,
              a.padStart = function (J, et, eo) {
                J = W(J);
                var el = (et = b(et)) ? Dt(J) : 0;
                return et && el < et ? Ve(et - el, eo) + J : J
              }
              ,
              a.parseInt = function (J, et, eo) {
                return eo || null == et ? et = 0 : et && (et = +et),
                  rD(W(J).replace(e6, ""), et || 0)
              }
              ,
              a.random = function (J, et, el) {
                if (el && "boolean" != typeof el && rn(J, et, el) && (et = el = eo),
                  el === eo && ("boolean" == typeof et ? (el = et,
                    et = eo) : "boolean" == typeof J && (el = J,
                      J = eo)),
                  J === eo && et === eo ? (J = 0,
                    et = 1) : (J = Xn(J),
                      et === eo ? (et = J,
                        J = 0) : et = Xn(et)),
                  J > et) {
                  var ec = J;
                  J = et,
                    et = ec
                }
                if (el || J % 1 || et % 1) {
                  var ed = rj();
                  return rN(J + ed * (et - J + t5("1e-" + ((ed + "").length - 1))), et)
                }
                return ei(J, et)
              }
              ,
              a.reduce = function (J, et, eo) {
                var el = nX(J) ? Hr : Es
                  , ec = arguments.length < 3;
                return el(J, x(et, 4), eo, ec, r1)
              }
              ,
              a.reduceRight = function (J, et, eo) {
                var el = nX(J) ? jo : Es
                  , ec = arguments.length < 3;
                return el(J, x(et, 4), eo, ec, r2)
              }
              ,
              a.repeat = function (J, et, el) {
                return et = (el ? rn(J, et, el) : et === eo) ? 1 : b(et),
                  ri(W(J), et)
              }
              ,
              a.replace = function () {
                var J = arguments
                  , et = W(J[0]);
                return J.length < 3 ? et : et.replace(J[1], J[2])
              }
              ,
              a.result = function (J, et, el) {
                et = st(et, J);
                var ec = -1
                  , ed = et.length;
                for (ed || (ed = 1,
                  J = eo); ++ec < ed;) {
                  var eh = null == J ? eo : J[Wn(et[ec])];
                  eh === eo && (ec = ed,
                    eh = el),
                    J = Jn(eh) ? eh.call(J) : eh
                }
                return J
              }
              ,
              a.round = iZ,
              a.runInContext = h,
              a.sample = function (J) {
                return (nX(J) ? Ms : function (J) {
                  return Ms(Gt(J))
                }
                )(J)
              }
              ,
              a.size = function (J) {
                if (null == J)
                  return 0;
                if (an(J))
                  return or(J) ? Dt(J) : J.length;
                var et = no(J);
                return et == eE || et == eA ? J.size : jr(J).length
              }
              ,
              a.snakeCase = iT,
              a.some = function (J, et, el) {
                var ec = nX(J) ? Nr : Mc;
                return el && rn(J, et, el) && (et = eo),
                  ec(J, x(et, 3))
              }
              ,
              a.sortedIndex = function (J, et) {
                return Ye(J, et)
              }
              ,
              a.sortedIndexBy = function (J, et, eo) {
                return ii(J, et, x(eo, 2))
              }
              ,
              a.sortedIndexOf = function (J, et) {
                var eo = null == J ? 0 : J.length;
                if (eo) {
                  var el = Ye(J, et);
                  if (el < eo && bn(J[el], et))
                    return el
                }
                return -1
              }
              ,
              a.sortedLastIndex = function (J, et) {
                return Ye(J, et, !0)
              }
              ,
              a.sortedLastIndexBy = function (J, et, eo) {
                return ii(J, et, x(eo, 2), !0)
              }
              ,
              a.sortedLastIndexOf = function (J, et) {
                if (null == J ? 0 : J.length) {
                  var eo = Ye(J, et, !0) - 1;
                  if (bn(J[eo], et))
                    return eo
                }
                return -1
              }
              ,
              a.startCase = iA,
              a.startsWith = function (J, et, eo) {
                return J = W(J),
                  eo = null == eo ? 0 : vt(b(eo), 0, J.length),
                  et = ln(et),
                  J.slice(eo, eo + et.length) == et
              }
              ,
              a.subtract = iG,
              a.sum = function (J) {
                return J && J.length ? Wr(J, fn) : 0
              }
              ,
              a.sumBy = function (J, et) {
                return J && J.length ? Wr(J, x(et, 2)) : 0
              }
              ,
              a.template = function (J, et, el) {
                var ec = a.templateSettings;
                el && rn(J, et, el) && (et = eo),
                  J = W(J),
                  et = io({}, et, ec, Eu);
                var ed, eh, ep = io({}, et.imports, ec.imports, Eu), ef = V(ep), em = Mr(ep, ef), eg = 0, ey = et.interpolate || ty, eb = "__p += '", ew = tA((et.escape || ty).source + "|" + ey.source + "|" + (ey === eX ? tl : ty).source + "|" + (et.evaluate || ty).source + "|$", "g"), e_ = "//# sourceURL=" + (tj.call(et, "sourceURL") ? (et.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++t0 + "]") + `
`;
                J.replace(ew, function (et, eo, el, ec, ep, ef) {
                  return el || (el = ec),
                    eb += J.slice(eg, ef).replace(tb, cf),
                    eo && (ed = !0,
                      eb += `' +
__e(` + eo + `) +
'`),
                    ep && (eh = !0,
                      eb += `';
` + ep + `;
__p += '`),
                    el && (eb += `' +
((__t = (` + el + `)) == null ? '' : __t) +
'`),
                    eg = ef + et.length,
                    et
                }),
                  eb += `';
`;
                var ex = tj.call(et, "variable") && et.variable;
                if (ex) {
                  if (to.test(ex))
                    throw new tC("Invalid `variable` option passed into `_.template`")
                } else
                  eb = `with (obj) {
` + eb + `
}
`;
                eb = (eh ? eb.replace(eH, "") : eb).replace(eV, "$1").replace(eW, "$1;"),
                  eb = "function(" + (ex || "obj") + `) {
` + (ex ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (ed ? ", __e = _.escape" : "") + (eh ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + eb + `return __p
}`;
                var eE = iI(function () {
                  return tS(ef, e_ + "return " + eb).apply(eo, em)
                });
                if (eE.source = eb,
                  Ei(eE))
                  throw eE;
                return eE
              }
              ,
              a.times = function (J, et) {
                if ((J = b(J)) < 1 || J > 9007199254740991)
                  return [];
                var eo = 4294967295
                  , el = rN(J, 4294967295);
                et = x(et),
                  J -= 4294967295;
                for (var ec = Fr(el, et); ++eo < J;)
                  et(eo);
                return ec
              }
              ,
              a.toFinite = Xn,
              a.toInteger = b,
              a.toLength = aa,
              a.toLower = function (J) {
                return W(J).toLowerCase()
              }
              ,
              a.toNumber = xn,
              a.toSafeInteger = function (J) {
                return J ? vt(b(J), -9007199254740991, 9007199254740991) : 0 === J ? J : 0
              }
              ,
              a.toString = W,
              a.toUpper = function (J) {
                return W(J).toUpperCase()
              }
              ,
              a.trim = function (J, et, el) {
                if ((J = W(J)) && (el || et === eo))
                  return ys(J);
                if (!J || !(et = ln(et)))
                  return J;
                var ec = On(J)
                  , ed = On(et)
                  , eh = Ss(ec, ed)
                  , ep = Os(ec, ed) + 1;
                return ut(ec, eh, ep).join("")
              }
              ,
              a.trimEnd = function (J, et, el) {
                if ((J = W(J)) && (el || et === eo))
                  return J.slice(0, bs(J) + 1);
                if (!J || !(et = ln(et)))
                  return J;
                var ec = On(J)
                  , ed = Os(ec, On(et)) + 1;
                return ut(ec, 0, ed).join("")
              }
              ,
              a.trimStart = function (J, et, el) {
                if ((J = W(J)) && (el || et === eo))
                  return J.replace(e6, "");
                if (!J || !(et = ln(et)))
                  return J;
                var ec = On(J)
                  , ed = Ss(ec, On(et));
                return ut(ec, ed).join("")
              }
              ,
              a.truncate = function (J, et) {
                var el = 30
                  , ec = "...";
                if (K(et)) {
                  var ed = "separator" in et ? et.separator : ed;
                  el = "length" in et ? b(et.length) : el,
                    ec = "omission" in et ? ln(et.omission) : ec
                }
                var eh = (J = W(J)).length;
                if (Lt(J)) {
                  var ep = On(J);
                  eh = ep.length
                }
                if (el >= eh)
                  return J;
                var ef = el - Dt(ec);
                if (ef < 1)
                  return ec;
                var em = ep ? ut(ep, 0, ef).join("") : J.slice(0, ef);
                if (ed === eo)
                  return em + ec;
                if (ep && (ef += em.length - ef),
                  n5(ed)) {
                  if (J.slice(ef).search(ed)) {
                    var eg, ey = em;
                    for (ed.global || (ed = tA(ed.source, W(tc.exec(ed)) + "g")),
                      ed.lastIndex = 0; eg = ed.exec(ey);)
                      var eb = eg.index;
                    em = em.slice(0, eb === eo ? ef : eb)
                  }
                } else if (J.indexOf(ln(ed), ef) != ef) {
                  var ew = em.lastIndexOf(ed);
                  ew > -1 && (em = em.slice(0, ew))
                }
                return em + ec
              }
              ,
              a.unescape = function (J) {
                return (J = W(J)) && eY.test(J) ? J.replace(eZ, rx) : J
              }
              ,
              a.uniqueId = function (J) {
                var et = ++tL;
                return W(J) + et
              }
              ,
              a.upperCase = iP,
              a.upperFirst = iR,
              a.each = Zu,
              a.eachRight = Ju,
              a.first = Gu,
              Li(a, (t_ = {},
                $n(a, function (J, et) {
                  tj.call(a.prototype, et) || (t_[et] = J)
                }),
                t_), {
                chain: !1
              }),
              a.VERSION = "4.17.21",
              mn(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function (J) {
                a[J].placeholder = a
              }),
              mn(["drop", "take"], function (J, et) {
                H.prototype[J] = function (el) {
                  el = el === eo ? 1 : rO(b(el), 0);
                  var ec = this.__filtered__ && !et ? new H(this) : this.clone();
                  return ec.__filtered__ ? ec.__takeCount__ = rN(el, ec.__takeCount__) : ec.__views__.push({
                    size: rN(el, 4294967295),
                    type: J + (ec.__dir__ < 0 ? "Right" : "")
                  }),
                    ec
                }
                  ,
                  H.prototype[J + "Right"] = function (et) {
                    return this.reverse()[J](et).reverse()
                  }
              }),
              mn(["filter", "map", "takeWhile"], function (J, et) {
                var eo = et + 1
                  , el = 1 == eo || 3 == eo;
                H.prototype[J] = function (J) {
                  var et = this.clone();
                  return et.__iteratees__.push({
                    iteratee: x(J, 3),
                    type: eo
                  }),
                    et.__filtered__ = et.__filtered__ || el,
                    et
                }
              }),
              mn(["head", "last"], function (J, et) {
                var eo = "take" + (et ? "Right" : "");
                H.prototype[J] = function () {
                  return this[eo](1).value()[0]
                }
              }),
              mn(["initial", "tail"], function (J, et) {
                var eo = "drop" + (et ? "" : "Right");
                H.prototype[J] = function () {
                  return this.__filtered__ ? new H(this) : this[eo](1)
                }
              }),
              H.prototype.compact = function () {
                return this.filter(fn)
              }
              ,
              H.prototype.find = function (J) {
                return this.filter(J).head()
              }
              ,
              H.prototype.findLast = function (J) {
                return this.reverse().find(J)
              }
              ,
              H.prototype.invokeMap = L(function (J, et) {
                return "function" == typeof J ? new H(this) : this.map(function (eo) {
                  return ae(eo, J, et)
                })
              }),
              H.prototype.reject = function (J) {
                return this.filter(ur(x(J)))
              }
              ,
              H.prototype.slice = function (J, et) {
                J = b(J);
                var el = this;
                return el.__filtered__ && (J > 0 || et < 0) ? new H(el) : (J < 0 ? el = el.takeRight(-J) : J && (el = el.drop(J)),
                  et !== eo && (el = (et = b(et)) < 0 ? el.dropRight(-et) : el.take(et - J)),
                  el)
              }
              ,
              H.prototype.takeRightWhile = function (J) {
                return this.reverse().takeWhile(J).reverse()
              }
              ,
              H.prototype.toArray = function () {
                return this.take(4294967295)
              }
              ,
              $n(H.prototype, function (J, et) {
                var el = /^(?:filter|find|map|reject)|While$/.test(et)
                  , ec = /^(?:head|last)$/.test(et)
                  , ed = a[ec ? "take" + ("last" == et ? "Right" : "") : et]
                  , eh = ec || /^find/.test(et);
                ed && (a.prototype[et] = function () {
                  var et = this.__wrapped__
                    , ep = ec ? [1] : arguments
                    , ef = et instanceof H
                    , em = ep[0]
                    , eg = ef || nX(et)
                    , m = function (J) {
                      var et = ed.apply(a, nt([J], ep));
                      return ec && ey ? et[0] : et
                    };
                  eg && el && "function" == typeof em && 1 != em.length && (ef = eg = !1);
                  var ey = this.__chain__
                    , eb = !!this.__actions__.length
                    , ew = eh && !ey
                    , e_ = ef && !eb;
                  if (!eh && eg) {
                    et = e_ ? et : new H(this);
                    var ex = J.apply(et, ep);
                    return ex.__actions__.push({
                      func: er,
                      args: [m],
                      thisArg: eo
                    }),
                      new Pn(ex, ey)
                  }
                  return ew && e_ ? J.apply(this, ep) : (ex = this.thru(m),
                    ew ? ec ? ex.value()[0] : ex.value() : ex)
                }
                )
              }),
              mn(["pop", "push", "shift", "sort", "splice", "unshift"], function (J) {
                var et = tI[J]
                  , eo = /^(?:push|sort|unshift)$/.test(J) ? "tap" : "thru"
                  , el = /^(?:pop|shift)$/.test(J);
                a.prototype[J] = function () {
                  var J = arguments;
                  if (el && !this.__chain__) {
                    var ec = this.value();
                    return et.apply(nX(ec) ? ec : [], J)
                  }
                  return this[eo](function (eo) {
                    return et.apply(nX(eo) ? eo : [], J)
                  })
                }
              }),
              $n(H.prototype, function (J, et) {
                var eo = a[et];
                if (eo) {
                  var el = eo.name + "";
                  tj.call(rW, el) || (rW[el] = []),
                    rW[el].push({
                      name: et,
                      func: eo
                    })
                }
              }),
              rW[Xe(eo, 2).name] = [{
                name: "wrapper",
                func: eo
              }],
              H.prototype.clone = function () {
                var J = new H(this.__wrapped__);
                return J.__actions__ = un(this.__actions__),
                  J.__dir__ = this.__dir__,
                  J.__filtered__ = this.__filtered__,
                  J.__iteratees__ = un(this.__iteratees__),
                  J.__takeCount__ = this.__takeCount__,
                  J.__views__ = un(this.__views__),
                  J
              }
              ,
              H.prototype.reverse = function () {
                if (this.__filtered__) {
                  var J = new H(this);
                  J.__dir__ = -1,
                    J.__filtered__ = !0
                } else
                  J = this.clone(),
                    J.__dir__ *= -1;
                return J
              }
              ,
              H.prototype.value = function () {
                var J = this.__wrapped__.value()
                  , et = this.__dir__
                  , eo = nX(J)
                  , el = et < 0
                  , ec = eo ? J.length : 0
                  , ed = function (J, et, eo) {
                    for (var el = -1, ec = eo.length; ++el < ec;) {
                      var ed = eo[el]
                        , eh = ed.size;
                      switch (ed.type) {
                        case "drop":
                          J += eh;
                          break;
                        case "dropRight":
                          et -= eh;
                          break;
                        case "take":
                          et = rN(et, J + eh);
                          break;
                        case "takeRight":
                          J = rO(J, et - eh)
                      }
                    }
                    return {
                      start: J,
                      end: et
                    }
                  }(0, ec, this.__views__)
                  , eh = ed.start
                  , ep = ed.end
                  , ef = ep - eh
                  , em = el ? ep : eh - 1
                  , eg = this.__iteratees__
                  , ey = eg.length
                  , eb = 0
                  , ew = rN(ef, this.__takeCount__);
                if (!eo || !el && ec == ef && ew == ef)
                  return ou(J, this.__actions__);
                var e_ = [];
                e: for (; ef-- && eb < ew;) {
                  em += et;
                  for (var ex = -1, eE = J[em]; ++ex < ey;) {
                    var eC = eg[ex]
                      , eS = eC.iteratee
                      , ek = eC.type
                      , eT = eS(eE);
                    if (2 == ek)
                      eE = eT;
                    else if (!eT) {
                      if (1 == ek)
                        continue e;
                      break e
                    }
                  }
                  e_[eb++] = eE
                }
                return e_
              }
              ,
              a.prototype.at = nO,
              a.prototype.chain = function () {
                return Yu(this)
              }
              ,
              a.prototype.commit = function () {
                return new Pn(this.value(), this.__chain__)
              }
              ,
              a.prototype.next = function () {
                this.__values__ === eo && (this.__values__ = ua(this.value()));
                var J = this.__index__ >= this.__values__.length
                  , et = J ? eo : this.__values__[this.__index__++];
                return {
                  done: J,
                  value: et
                }
              }
              ,
              a.prototype.plant = function (J) {
                for (var et, el = this; el instanceof qe;) {
                  var ec = Fu(el);
                  ec.__index__ = 0,
                    ec.__values__ = eo,
                    et ? ed.__wrapped__ = ec : et = ec;
                  var ed = ec;
                  el = el.__wrapped__
                }
                return ed.__wrapped__ = J,
                  et
              }
              ,
              a.prototype.reverse = function () {
                var J = this.__wrapped__;
                if (J instanceof H) {
                  var et = J;
                  return this.__actions__.length && (et = new H(this)),
                    (et = et.reverse()).__actions__.push({
                      func: er,
                      args: [Ai],
                      thisArg: eo
                    }),
                    new Pn(et, this.__chain__)
                }
                return this.thru(Ai)
              }
              ,
              a.prototype.toJSON = a.prototype.valueOf = a.prototype.value = function () {
                return ou(this.__wrapped__, this.__actions__)
              }
              ,
              a.prototype.first = a.prototype.head,
              t9 && (a.prototype[t9] = function () {
                return this
              }
              ),
              a
          }();
        ro ? ((ro.exports = rE)._ = rE,
          t9._ = rE) : t7._ = rE
      }
      ).call(iF)
    }(iU, iU.exports);
    var iz = Object.defineProperty
      , iH = Object.defineProperties
      , iV = Object.getOwnPropertyDescriptors
      , iW = Object.getOwnPropertySymbols
      , iq = Object.prototype.hasOwnProperty
      , iZ = Object.prototype.propertyIsEnumerable
      , ya = (J, et, eo) => et in J ? iz(J, et, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: eo
      }) : J[et] = eo
      , index_es_cr = (J, et) => {
        for (var eo in et || (et = {}))
          iq.call(et, eo) && ya(J, eo, et[eo]);
        if (iW)
          for (var eo of iW(et))
            iZ.call(et, eo) && ya(J, eo, et[eo]);
        return J
      }
      , Zg = (J, et) => iH(J, iV(et));
    function dist_index_es_ft(J, et, eo) {
      var el;
      let ec = function (J) {
        let [et, eo] = J.split(":");
        return {
          namespace: et,
          reference: eo
        }
      }(J);
      return (null == (el = et.rpcMap) ? void 0 : el[ec.reference]) || `https://rpc.walletconnect.com/v1/?chainId=${ec.namespace}:${ec.reference}&projectId=${eo}`
    }
    function dist_index_es_Ct(J) {
      return J.includes(":") ? J.split(":")[1] : J
    }
    function Sa(J) {
      return J.map(J => `${J.split(":")[0]}:${J.split(":")[1]}`)
    }
    function Oa(J) {
      var et, eo, el, ec;
      let ed = {};
      if (!B(J))
        return ed;
      for (let [eh, ep] of Object.entries(J)) {
        let J = oe(eh) ? [eh] : ep.chains
          , ef = ep.methods || []
          , em = ep.events || []
          , eg = ep.rpcMap || {}
          , ey = en(eh);
        ed[ey] = Zg(index_es_cr(index_es_cr({}, ed[ey]), ep), {
          chains: S(J, null == (et = ed[ey]) ? void 0 : et.chains),
          methods: S(ef, null == (eo = ed[ey]) ? void 0 : eo.methods),
          events: S(em, null == (el = ed[ey]) ? void 0 : el.events),
          rpcMap: index_es_cr(index_es_cr({}, eg), null == (ec = ed[ey]) ? void 0 : ec.rpcMap)
        })
      }
      return ed
    }
    function Qg(J) {
      return J.includes(":") ? J.split(":")[2] : J
    }
    function index_es_Wi(J) {
      return "number" == typeof J ? J : J.includes("0x") ? parseInt(J, 16) : J.includes(":") ? Number(J.split(":")[1]) : Number(J)
    }
    let iG = {}
      , dist_index_es_z = J => iG[J]
      , Fi = (J, et) => {
        iG[J] = et
      }
      ;
    let kg = class kg {
      constructor(J) {
        this.name = "polkadot",
          this.namespace = J.namespace,
          this.events = dist_index_es_z("events"),
          this.client = dist_index_es_z("client"),
          this.chainId = this.getDefaultChain(),
          this.httpProviders = this.createHttpProviders()
      }
      updateNamespace(J) {
        this.namespace = Object.assign(this.namespace, J)
      }
      requestAccounts() {
        return this.getAccounts()
      }
      getDefaultChain() {
        if (this.chainId)
          return this.chainId;
        if (this.namespace.defaultChain)
          return this.namespace.defaultChain;
        let J = this.namespace.chains[0];
        if (!J)
          throw Error("ChainId not found");
        return J.split(":")[1]
      }
      request(J) {
        return this.namespace.methods.includes(J.request.method) ? this.client.request(J) : this.getHttpProvider().request(J.request)
      }
      setDefaultChain(J, et) {
        this.httpProviders[J] || this.setHttpProvider(J, et),
          this.chainId = J,
          this.events.emit(iB.DEFAULT_CHAIN_CHANGED, `${this.name}:${J}`)
      }
      getAccounts() {
        let J = this.namespace.accounts;
        return J && J.filter(J => J.split(":")[1] === this.chainId.toString()).map(J => J.split(":")[2]) || []
      }
      createHttpProviders() {
        let J = {};
        return this.namespace.chains.forEach(et => {
          var eo;
          let el = dist_index_es_Ct(et);
          J[el] = this.createHttpProvider(el, null == (eo = this.namespace.rpcMap) ? void 0 : eo[et])
        }
        ),
          J
      }
      getHttpProvider() {
        let J = `${this.name}:${this.chainId}`
          , et = this.httpProviders[J];
        if (typeof et > "u")
          throw Error(`JSON-RPC provider for ${J} not found`);
        return et
      }
      setHttpProvider(J, et) {
        let eo = this.createHttpProvider(J, et);
        eo && (this.httpProviders[J] = eo)
      }
      createHttpProvider(J, et) {
        let eo = et || dist_index_es_ft(J, this.namespace, this.client.core.projectId);
        if (!eo)
          throw Error(`No RPC url provided for chainId: ${J}`);
        return new JsonRpcProvider(new HttpConnection(eo, dist_index_es_z("disableProviderPing")))
      }
    }
      ;
    let jg = class jg {
      constructor(J) {
        this.name = "eip155",
          this.namespace = J.namespace,
          this.events = dist_index_es_z("events"),
          this.client = dist_index_es_z("client"),
          this.httpProviders = this.createHttpProviders(),
          this.chainId = parseInt(this.getDefaultChain())
      }
      async request(J) {
        switch (J.request.method) {
          case "eth_requestAccounts":
          case "eth_accounts":
            return this.getAccounts();
          case "wallet_switchEthereumChain":
            return await this.handleSwitchChain(J);
          case "eth_chainId":
            return parseInt(this.getDefaultChain())
        }
        return this.namespace.methods.includes(J.request.method) ? await this.client.request(J) : this.getHttpProvider().request(J.request)
      }
      updateNamespace(J) {
        this.namespace = Object.assign(this.namespace, J)
      }
      setDefaultChain(J, et) {
        this.httpProviders[J] || this.setHttpProvider(parseInt(J), et),
          this.chainId = parseInt(J),
          this.events.emit(iB.DEFAULT_CHAIN_CHANGED, `${this.name}:${J}`)
      }
      requestAccounts() {
        return this.getAccounts()
      }
      getDefaultChain() {
        if (this.chainId)
          return this.chainId.toString();
        if (this.namespace.defaultChain)
          return this.namespace.defaultChain;
        let J = this.namespace.chains[0];
        if (!J)
          throw Error("ChainId not found");
        return J.split(":")[1]
      }
      createHttpProvider(J, et) {
        let eo = et || dist_index_es_ft(`${this.name}:${J}`, this.namespace, this.client.core.projectId);
        if (!eo)
          throw Error(`No RPC url provided for chainId: ${J}`);
        return new JsonRpcProvider(new HttpConnection(eo, dist_index_es_z("disableProviderPing")))
      }
      setHttpProvider(J, et) {
        let eo = this.createHttpProvider(J, et);
        eo && (this.httpProviders[J] = eo)
      }
      createHttpProviders() {
        let J = {};
        return this.namespace.chains.forEach(et => {
          var eo;
          let el = parseInt(dist_index_es_Ct(et));
          J[el] = this.createHttpProvider(el, null == (eo = this.namespace.rpcMap) ? void 0 : eo[et])
        }
        ),
          J
      }
      getAccounts() {
        let J = this.namespace.accounts;
        return J ? [...new Set(J.filter(J => J.split(":")[1] === this.chainId.toString()).map(J => J.split(":")[2]))] : []
      }
      getHttpProvider() {
        let J = this.chainId
          , et = this.httpProviders[J];
        if (typeof et > "u")
          throw Error(`JSON-RPC provider for ${J} not found`);
        return et
      }
      async handleSwitchChain(J) {
        var et, eo;
        let el = J.request.params ? null == (et = J.request.params[0]) ? void 0 : et.chainId : "0x0";
        el = el.startsWith("0x") ? el : `0x${el}`;
        let ec = parseInt(el, 16);
        if (this.isChainApproved(ec))
          this.setDefaultChain(`${ec}`);
        else if (this.namespace.methods.includes("wallet_switchEthereumChain"))
          await this.client.request({
            topic: J.topic,
            request: {
              method: J.request.method,
              params: [{
                chainId: el
              }]
            },
            chainId: null == (eo = this.namespace.chains) ? void 0 : eo[0]
          }),
            this.setDefaultChain(`${ec}`);
        else
          throw Error(`Failed to switch to chain 'eip155:${ec}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
        return null
      }
      isChainApproved(J) {
        return this.namespace.chains.includes(`${this.name}:${J}`)
      }
    }
      ;
    let nv = class nv {
      constructor(J) {
        this.name = "solana",
          this.namespace = J.namespace,
          this.events = dist_index_es_z("events"),
          this.client = dist_index_es_z("client"),
          this.chainId = this.getDefaultChain(),
          this.httpProviders = this.createHttpProviders()
      }
      updateNamespace(J) {
        this.namespace = Object.assign(this.namespace, J)
      }
      requestAccounts() {
        return this.getAccounts()
      }
      request(J) {
        return this.namespace.methods.includes(J.request.method) ? this.client.request(J) : this.getHttpProvider().request(J.request)
      }
      setDefaultChain(J, et) {
        this.httpProviders[J] || this.setHttpProvider(J, et),
          this.chainId = J,
          this.events.emit(iB.DEFAULT_CHAIN_CHANGED, `${this.name}:${J}`)
      }
      getDefaultChain() {
        if (this.chainId)
          return this.chainId;
        if (this.namespace.defaultChain)
          return this.namespace.defaultChain;
        let J = this.namespace.chains[0];
        if (!J)
          throw Error("ChainId not found");
        return J.split(":")[1]
      }
      getAccounts() {
        let J = this.namespace.accounts;
        return J ? [...new Set(J.filter(J => J.split(":")[1] === this.chainId.toString()).map(J => J.split(":")[2]))] : []
      }
      createHttpProviders() {
        let J = {};
        return this.namespace.chains.forEach(et => {
          var eo;
          let el = dist_index_es_Ct(et);
          J[el] = this.createHttpProvider(el, null == (eo = this.namespace.rpcMap) ? void 0 : eo[et])
        }
        ),
          J
      }
      getHttpProvider() {
        let J = `${this.name}:${this.chainId}`
          , et = this.httpProviders[J];
        if (typeof et > "u")
          throw Error(`JSON-RPC provider for ${J} not found`);
        return et
      }
      setHttpProvider(J, et) {
        let eo = this.createHttpProvider(J, et);
        eo && (this.httpProviders[J] = eo)
      }
      createHttpProvider(J, et) {
        let eo = et || dist_index_es_ft(J, this.namespace, this.client.core.projectId);
        if (!eo)
          throw Error(`No RPC url provided for chainId: ${J}`);
        return new JsonRpcProvider(new HttpConnection(eo, dist_index_es_z("disableProviderPing")))
      }
    }
      ;
    let tv = class tv {
      constructor(J) {
        this.name = "cosmos",
          this.namespace = J.namespace,
          this.events = dist_index_es_z("events"),
          this.client = dist_index_es_z("client"),
          this.chainId = this.getDefaultChain(),
          this.httpProviders = this.createHttpProviders()
      }
      updateNamespace(J) {
        this.namespace = Object.assign(this.namespace, J)
      }
      requestAccounts() {
        return this.getAccounts()
      }
      getDefaultChain() {
        if (this.chainId)
          return this.chainId;
        if (this.namespace.defaultChain)
          return this.namespace.defaultChain;
        let J = this.namespace.chains[0];
        if (!J)
          throw Error("ChainId not found");
        return J.split(":")[1]
      }
      request(J) {
        return this.namespace.methods.includes(J.request.method) ? this.client.request(J) : this.getHttpProvider().request(J.request)
      }
      setDefaultChain(J, et) {
        this.httpProviders[J] || this.setHttpProvider(J, et),
          this.chainId = J,
          this.events.emit(iB.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
      }
      getAccounts() {
        let J = this.namespace.accounts;
        return J ? [...new Set(J.filter(J => J.split(":")[1] === this.chainId.toString()).map(J => J.split(":")[2]))] : []
      }
      createHttpProviders() {
        let J = {};
        return this.namespace.chains.forEach(et => {
          var eo;
          let el = dist_index_es_Ct(et);
          J[el] = this.createHttpProvider(el, null == (eo = this.namespace.rpcMap) ? void 0 : eo[et])
        }
        ),
          J
      }
      getHttpProvider() {
        let J = `${this.name}:${this.chainId}`
          , et = this.httpProviders[J];
        if (typeof et > "u")
          throw Error(`JSON-RPC provider for ${J} not found`);
        return et
      }
      setHttpProvider(J, et) {
        let eo = this.createHttpProvider(J, et);
        eo && (this.httpProviders[J] = eo)
      }
      createHttpProvider(J, et) {
        let eo = et || dist_index_es_ft(J, this.namespace, this.client.core.projectId);
        if (!eo)
          throw Error(`No RPC url provided for chainId: ${J}`);
        return new JsonRpcProvider(new HttpConnection(eo, dist_index_es_z("disableProviderPing")))
      }
    }
      ;
    let ev = class ev {
      constructor(J) {
        this.name = "cip34",
          this.namespace = J.namespace,
          this.events = dist_index_es_z("events"),
          this.client = dist_index_es_z("client"),
          this.chainId = this.getDefaultChain(),
          this.httpProviders = this.createHttpProviders()
      }
      updateNamespace(J) {
        this.namespace = Object.assign(this.namespace, J)
      }
      requestAccounts() {
        return this.getAccounts()
      }
      getDefaultChain() {
        if (this.chainId)
          return this.chainId;
        if (this.namespace.defaultChain)
          return this.namespace.defaultChain;
        let J = this.namespace.chains[0];
        if (!J)
          throw Error("ChainId not found");
        return J.split(":")[1]
      }
      request(J) {
        return this.namespace.methods.includes(J.request.method) ? this.client.request(J) : this.getHttpProvider().request(J.request)
      }
      setDefaultChain(J, et) {
        this.httpProviders[J] || this.setHttpProvider(J, et),
          this.chainId = J,
          this.events.emit(iB.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
      }
      getAccounts() {
        let J = this.namespace.accounts;
        return J ? [...new Set(J.filter(J => J.split(":")[1] === this.chainId.toString()).map(J => J.split(":")[2]))] : []
      }
      createHttpProviders() {
        let J = {};
        return this.namespace.chains.forEach(et => {
          let eo = this.getCardanoRPCUrl(et)
            , el = dist_index_es_Ct(et);
          J[el] = this.createHttpProvider(el, eo)
        }
        ),
          J
      }
      getHttpProvider() {
        let J = `${this.name}:${this.chainId}`
          , et = this.httpProviders[J];
        if (typeof et > "u")
          throw Error(`JSON-RPC provider for ${J} not found`);
        return et
      }
      getCardanoRPCUrl(J) {
        let et = this.namespace.rpcMap;
        if (et)
          return et[J]
      }
      setHttpProvider(J, et) {
        let eo = this.createHttpProvider(J, et);
        eo && (this.httpProviders[J] = eo)
      }
      createHttpProvider(J, et) {
        let eo = et || this.getCardanoRPCUrl(J);
        if (!eo)
          throw Error(`No RPC url provided for chainId: ${J}`);
        return new JsonRpcProvider(new HttpConnection(eo, dist_index_es_z("disableProviderPing")))
      }
    }
      ;
    let rv = class rv {
      constructor(J) {
        this.name = "elrond",
          this.namespace = J.namespace,
          this.events = dist_index_es_z("events"),
          this.client = dist_index_es_z("client"),
          this.chainId = this.getDefaultChain(),
          this.httpProviders = this.createHttpProviders()
      }
      updateNamespace(J) {
        this.namespace = Object.assign(this.namespace, J)
      }
      requestAccounts() {
        return this.getAccounts()
      }
      request(J) {
        return this.namespace.methods.includes(J.request.method) ? this.client.request(J) : this.getHttpProvider().request(J.request)
      }
      setDefaultChain(J, et) {
        this.httpProviders[J] || this.setHttpProvider(J, et),
          this.chainId = J,
          this.events.emit(iB.DEFAULT_CHAIN_CHANGED, `${this.name}:${J}`)
      }
      getDefaultChain() {
        if (this.chainId)
          return this.chainId;
        if (this.namespace.defaultChain)
          return this.namespace.defaultChain;
        let J = this.namespace.chains[0];
        if (!J)
          throw Error("ChainId not found");
        return J.split(":")[1]
      }
      getAccounts() {
        let J = this.namespace.accounts;
        return J ? [...new Set(J.filter(J => J.split(":")[1] === this.chainId.toString()).map(J => J.split(":")[2]))] : []
      }
      createHttpProviders() {
        let J = {};
        return this.namespace.chains.forEach(et => {
          var eo;
          let el = dist_index_es_Ct(et);
          J[el] = this.createHttpProvider(el, null == (eo = this.namespace.rpcMap) ? void 0 : eo[et])
        }
        ),
          J
      }
      getHttpProvider() {
        let J = `${this.name}:${this.chainId}`
          , et = this.httpProviders[J];
        if (typeof et > "u")
          throw Error(`JSON-RPC provider for ${J} not found`);
        return et
      }
      setHttpProvider(J, et) {
        let eo = this.createHttpProvider(J, et);
        eo && (this.httpProviders[J] = eo)
      }
      createHttpProvider(J, et) {
        let eo = et || dist_index_es_ft(J, this.namespace, this.client.core.projectId);
        if (!eo)
          throw Error(`No RPC url provided for chainId: ${J}`);
        return new JsonRpcProvider(new HttpConnection(eo, dist_index_es_z("disableProviderPing")))
      }
    }
      ;
    let iv = class iv {
      constructor(J) {
        this.name = "multiversx",
          this.namespace = J.namespace,
          this.events = dist_index_es_z("events"),
          this.client = dist_index_es_z("client"),
          this.chainId = this.getDefaultChain(),
          this.httpProviders = this.createHttpProviders()
      }
      updateNamespace(J) {
        this.namespace = Object.assign(this.namespace, J)
      }
      requestAccounts() {
        return this.getAccounts()
      }
      request(J) {
        return this.namespace.methods.includes(J.request.method) ? this.client.request(J) : this.getHttpProvider().request(J.request)
      }
      setDefaultChain(J, et) {
        this.httpProviders[J] || this.setHttpProvider(J, et),
          this.chainId = J,
          this.events.emit(iB.DEFAULT_CHAIN_CHANGED, `${this.name}:${J}`)
      }
      getDefaultChain() {
        if (this.chainId)
          return this.chainId;
        if (this.namespace.defaultChain)
          return this.namespace.defaultChain;
        let J = this.namespace.chains[0];
        if (!J)
          throw Error("ChainId not found");
        return J.split(":")[1]
      }
      getAccounts() {
        let J = this.namespace.accounts;
        return J ? [...new Set(J.filter(J => J.split(":")[1] === this.chainId.toString()).map(J => J.split(":")[2]))] : []
      }
      createHttpProviders() {
        let J = {};
        return this.namespace.chains.forEach(et => {
          var eo;
          let el = dist_index_es_Ct(et);
          J[el] = this.createHttpProvider(el, null == (eo = this.namespace.rpcMap) ? void 0 : eo[et])
        }
        ),
          J
      }
      getHttpProvider() {
        let J = `${this.name}:${this.chainId}`
          , et = this.httpProviders[J];
        if (typeof et > "u")
          throw Error(`JSON-RPC provider for ${J} not found`);
        return et
      }
      setHttpProvider(J, et) {
        let eo = this.createHttpProvider(J, et);
        eo && (this.httpProviders[J] = eo)
      }
      createHttpProvider(J, et) {
        let eo = et || dist_index_es_ft(J, this.namespace, this.client.core.projectId);
        if (!eo)
          throw Error(`No RPC url provided for chainId: ${J}`);
        return new JsonRpcProvider(new HttpConnection(eo, dist_index_es_z("disableProviderPing")))
      }
    }
      ;
    let sv = class sv {
      constructor(J) {
        this.name = "near",
          this.namespace = J.namespace,
          this.events = dist_index_es_z("events"),
          this.client = dist_index_es_z("client"),
          this.chainId = this.getDefaultChain(),
          this.httpProviders = this.createHttpProviders()
      }
      updateNamespace(J) {
        this.namespace = Object.assign(this.namespace, J)
      }
      requestAccounts() {
        return this.getAccounts()
      }
      getDefaultChain() {
        if (this.chainId)
          return this.chainId;
        if (this.namespace.defaultChain)
          return this.namespace.defaultChain;
        let J = this.namespace.chains[0];
        if (!J)
          throw Error("ChainId not found");
        return J.split(":")[1]
      }
      request(J) {
        return this.namespace.methods.includes(J.request.method) ? this.client.request(J) : this.getHttpProvider().request(J.request)
      }
      setDefaultChain(J, et) {
        if (this.chainId = J,
          !this.httpProviders[J]) {
          let eo = et || dist_index_es_ft(`${this.name}:${J}`, this.namespace);
          if (!eo)
            throw Error(`No RPC url provided for chainId: ${J}`);
          this.setHttpProvider(J, eo)
        }
        this.events.emit(iB.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
      }
      getAccounts() {
        let J = this.namespace.accounts;
        return J && J.filter(J => J.split(":")[1] === this.chainId.toString()).map(J => J.split(":")[2]) || []
      }
      createHttpProviders() {
        let J = {};
        return this.namespace.chains.forEach(et => {
          var eo;
          J[et] = this.createHttpProvider(et, null == (eo = this.namespace.rpcMap) ? void 0 : eo[et])
        }
        ),
          J
      }
      getHttpProvider() {
        let J = `${this.name}:${this.chainId}`
          , et = this.httpProviders[J];
        if (typeof et > "u")
          throw Error(`JSON-RPC provider for ${J} not found`);
        return et
      }
      setHttpProvider(J, et) {
        let eo = this.createHttpProvider(J, et);
        eo && (this.httpProviders[J] = eo)
      }
      createHttpProvider(J, et) {
        let eo = et || dist_index_es_ft(J, this.namespace);
        return typeof eo > "u" ? void 0 : new JsonRpcProvider(new HttpConnection(eo, dist_index_es_z("disableProviderPing")))
      }
    }
      ;
    var iY = Object.defineProperty
      , iK = Object.defineProperties
      , iJ = Object.getOwnPropertyDescriptors
      , iQ = Object.getOwnPropertySymbols
      , iX = Object.prototype.hasOwnProperty
      , i0 = Object.prototype.propertyIsEnumerable
      , Ta = (J, et, eo) => et in J ? iY(J, et, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: eo
      }) : J[et] = eo
      , index_es_hr = (J, et) => {
        for (var eo in et || (et = {}))
          iX.call(et, eo) && Ta(J, eo, et[eo]);
        if (iQ)
          for (var eo of iQ(et))
            i0.call(et, eo) && Ta(J, eo, et[eo]);
        return J
      }
      , Mi = (J, et) => iK(J, iJ(et));
    let index_es_lr = class index_es_lr {
      constructor(J) {
        this.events = new (e0()),
          this.rpcProviders = {},
          this.shouldAbortPairingAttempt = !1,
          this.maxPairingAttempts = 10,
          this.disableProviderPing = !1,
          this.providerOpts = J,
          this.logger = "u" > typeof J?.logger && "string" != typeof J?.logger ? J.logger : (0,
            rP.pino)((0,
              rP.getDefaultLoggerOptions)({
                level: J?.logger || iL
              })),
          this.disableProviderPing = J?.disableProviderPing || !1
      }
      static async init(J) {
        let et = new index_es_lr(J);
        return await et.initialize(),
          et
      }
      async request(J, et) {
        let [eo, el] = this.validateChain(et);
        if (!this.session)
          throw Error("Please call connect() before request()");
        return await this.getProvider(eo).request({
          request: index_es_hr({}, J),
          chainId: `${eo}:${el}`,
          topic: this.session.topic
        })
      }
      sendAsync(J, et, eo) {
        let el = new Date().getTime();
        this.request(J, eo).then(J => et(null, formatJsonRpcResult(el, J))).catch(J => et(J, void 0))
      }
      async enable() {
        if (!this.client)
          throw Error("Sign Client not initialized");
        return this.session || await this.connect({
          namespaces: this.namespaces,
          optionalNamespaces: this.optionalNamespaces,
          sessionProperties: this.sessionProperties
        }),
          await this.requestAccounts()
      }
      async disconnect() {
        var J;
        if (!this.session)
          throw Error("Please call connect() before enable()");
        await this.client.disconnect({
          topic: null == (J = this.session) ? void 0 : J.topic,
          reason: index_es_U("USER_DISCONNECTED")
        }),
          await this.cleanup()
      }
      async connect(J) {
        if (!this.client)
          throw Error("Sign Client not initialized");
        if (this.setNamespaces(J),
          await this.cleanupPendingPairings(),
          !J.skipPairing)
          return await this.pair(J.pairingTopic)
      }
      on(J, et) {
        this.events.on(J, et)
      }
      once(J, et) {
        this.events.once(J, et)
      }
      removeListener(J, et) {
        this.events.removeListener(J, et)
      }
      off(J, et) {
        this.events.off(J, et)
      }
      get isWalletConnect() {
        return !0
      }
      async pair(J) {
        this.shouldAbortPairingAttempt = !1;
        let et = 0;
        do {
          if (this.shouldAbortPairingAttempt)
            throw Error("Pairing aborted");
          if (et >= this.maxPairingAttempts)
            throw Error("Max auto pairing attempts reached");
          let { uri: eo, approval: el } = await this.client.connect({
            pairingTopic: J,
            requiredNamespaces: this.namespaces,
            optionalNamespaces: this.optionalNamespaces,
            sessionProperties: this.sessionProperties
          });
          eo && (this.uri = eo,
            this.events.emit("display_uri", eo)),
            await el().then(J => {
              this.session = J,
                this.namespaces || (this.namespaces = function (J) {
                  let et = {};
                  for (let [eo, el] of Object.entries(J)) {
                    let J = el.methods || []
                      , ec = el.events || []
                      , ed = el.accounts || []
                      , eh = oe(eo) ? [eo] : el.chains ? el.chains : Sa(el.accounts);
                    et[eo] = {
                      chains: eh,
                      methods: J,
                      events: ec,
                      accounts: ed
                    }
                  }
                  return et
                }(J.namespaces),
                  this.persist("namespaces", this.namespaces))
            }
            ).catch(J => {
              if (J.message !== ix)
                throw J;
              et++
            }
            )
        } while (!this.session);
        return this.onConnect(),
          this.session
      }
      setDefaultChain(J, et) {
        try {
          if (!this.session)
            return;
          let [eo, el] = this.validateChain(J);
          this.getProvider(eo).setDefaultChain(el, et)
        } catch (J) {
          if (!/Please call connect/.test(J.message))
            throw J
        }
      }
      async cleanupPendingPairings(J = {}) {
        this.logger.info("Cleaning up inactive pairings...");
        let et = this.client.pairing.getAll();
        if (k(et)) {
          for (let eo of et)
            J.deletePairings ? this.client.core.expirer.set(eo.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(eo.topic);
          this.logger.info(`Inactive pairings cleared: ${et.length}`)
        }
      }
      abortPairingAttempt() {
        this.shouldAbortPairingAttempt = !0
      }
      async checkStorage() {
        if (this.namespaces = await this.getFromStore("namespaces"),
          this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {},
          this.client.session.length) {
          let J = this.client.session.keys.length - 1;
          this.session = this.client.session.get(this.client.session.keys[J]),
            this.createProviders()
        }
      }
      async initialize() {
        this.logger.trace("Initialized"),
          await this.createClient(),
          await this.checkStorage(),
          this.registerEventListeners()
      }
      async createClient() {
        this.client = this.providerOpts.client || await dist_index_es_Q.init({
          logger: this.providerOpts.logger || iL,
          relayUrl: this.providerOpts.relayUrl || "wss://relay.walletconnect.com",
          projectId: this.providerOpts.projectId,
          metadata: this.providerOpts.metadata,
          storageOptions: this.providerOpts.storageOptions,
          storage: this.providerOpts.storage,
          name: this.providerOpts.name
        }),
          this.logger.trace("SignClient Initialized")
      }
      createProviders() {
        if (!this.client)
          throw Error("Sign Client not initialized");
        if (!this.session)
          throw Error("Session not initialized. Please call connect() before enable()");
        let J = [...new Set(Object.keys(this.session.namespaces).map(J => en(J)))];
        Fi("client", this.client),
          Fi("events", this.events),
          Fi("disableProviderPing", this.disableProviderPing),
          J.forEach(J => {
            if (!this.session)
              return;
            let et = function (J, et) {
              let eo = Object.keys(et.namespaces).filter(et => et.includes(J));
              if (!eo.length)
                return [];
              let el = [];
              return eo.forEach(J => {
                let eo = et.namespaces[J].accounts;
                el.push(...eo)
              }
              ),
                el
            }(J, this.session)
              , eo = Sa(et)
              , el = function (J = {}, et = {}) {
                let eo = Oa(J)
                  , el = Oa(et);
                return iU.exports.merge(eo, el)
              }(this.namespaces, this.optionalNamespaces)
              , ec = Mi(index_es_hr({}, el[J]), {
                accounts: et,
                chains: eo
              });
            switch (J) {
              case "eip155":
                this.rpcProviders[J] = new jg({
                  namespace: ec
                });
                break;
              case "solana":
                this.rpcProviders[J] = new nv({
                  namespace: ec
                });
                break;
              case "cosmos":
                this.rpcProviders[J] = new tv({
                  namespace: ec
                });
                break;
              case "polkadot":
                this.rpcProviders[J] = new kg({
                  namespace: ec
                });
                break;
              case "cip34":
                this.rpcProviders[J] = new ev({
                  namespace: ec
                });
                break;
              case "elrond":
                this.rpcProviders[J] = new rv({
                  namespace: ec
                });
                break;
              case "multiversx":
                this.rpcProviders[J] = new iv({
                  namespace: ec
                });
                break;
              case "near":
                this.rpcProviders[J] = new sv({
                  namespace: ec
                })
            }
          }
          )
      }
      registerEventListeners() {
        if (typeof this.client > "u")
          throw Error("Sign Client is not initialized");
        this.client.on("session_ping", J => {
          this.events.emit("session_ping", J)
        }
        ),
          this.client.on("session_event", J => {
            let { params: et } = J
              , { event: eo } = et;
            if ("accountsChanged" === eo.name) {
              let J = eo.data;
              J && k(J) && this.events.emit("accountsChanged", J.map(Qg))
            } else if ("chainChanged" === eo.name) {
              let J = et.chainId
                , eo = et.event.data
                , el = en(J)
                , ec = index_es_Wi(J) !== index_es_Wi(eo) ? `${el}:${index_es_Wi(eo)}` : J;
              this.onChainChanged(ec)
            } else
              this.events.emit(eo.name, eo.data);
            this.events.emit("session_event", J)
          }
          ),
          this.client.on("session_update", ({ topic: J, params: et }) => {
            var eo;
            let { namespaces: el } = et
              , ec = null == (eo = this.client) ? void 0 : eo.session.get(J);
            this.session = Mi(index_es_hr({}, ec), {
              namespaces: el
            }),
              this.onSessionUpdate(),
              this.events.emit("session_update", {
                topic: J,
                params: et
              })
          }
          ),
          this.client.on("session_delete", async J => {
            await this.cleanup(),
              this.events.emit("session_delete", J),
              this.events.emit("disconnect", Mi(index_es_hr({}, index_es_U("USER_DISCONNECTED")), {
                data: J.topic
              }))
          }
          ),
          this.on(iB.DEFAULT_CHAIN_CHANGED, J => {
            this.onChainChanged(J, !0)
          }
          )
      }
      getProvider(J) {
        if (!this.rpcProviders[J])
          throw Error(`Provider not found: ${J}`);
        return this.rpcProviders[J]
      }
      onSessionUpdate() {
        Object.keys(this.rpcProviders).forEach(J => {
          var et;
          this.getProvider(J).updateNamespace(null == (et = this.session) ? void 0 : et.namespaces[J])
        }
        )
      }
      setNamespaces(J) {
        let { namespaces: et, optionalNamespaces: eo, sessionProperties: el } = J;
        et && Object.keys(et).length && (this.namespaces = et),
          eo && Object.keys(eo).length && (this.optionalNamespaces = eo),
          this.sessionProperties = el,
          this.persist("namespaces", et),
          this.persist("optionalNamespaces", eo)
      }
      validateChain(J) {
        let [et, eo] = J?.split(":") || ["", ""];
        if (!this.namespaces || !Object.keys(this.namespaces).length)
          return [et, eo];
        if (et && !Object.keys(this.namespaces || {}).map(J => en(J)).includes(et))
          throw Error(`Namespace '${et}' is not configured. Please call connect() first with namespace config.`);
        if (et && eo)
          return [et, eo];
        let el = en(Object.keys(this.namespaces)[0])
          , ec = this.rpcProviders[el].getDefaultChain();
        return [el, ec]
      }
      async requestAccounts() {
        let [J] = this.validateChain();
        return await this.getProvider(J).requestAccounts()
      }
      onChainChanged(J, et = !1) {
        var eo;
        if (!this.namespaces)
          return;
        let [el, ec] = this.validateChain(J);
        et || this.getProvider(el).setDefaultChain(ec),
          (null != (eo = this.namespaces[el]) ? eo : this.namespaces[`${el}:${ec}`]).defaultChain = ec,
          this.persist("namespaces", this.namespaces),
          this.events.emit("chainChanged", ec)
      }
      onConnect() {
        this.createProviders(),
          this.events.emit("connect", {
            session: this.session
          })
      }
      async cleanup() {
        this.session = void 0,
          this.namespaces = void 0,
          this.optionalNamespaces = void 0,
          this.sessionProperties = void 0,
          this.persist("namespaces", void 0),
          this.persist("optionalNamespaces", void 0),
          this.persist("sessionProperties", void 0),
          await this.cleanupPendingPairings({
            deletePairings: !0
          })
      }
      persist(J, et) {
        this.client.core.storage.setItem(`${i$}/${J}`, et)
      }
      async getFromStore(J) {
        return await this.client.core.storage.getItem(`${i$}/${J}`)
      }
    }
      ;
    let i1 = ["eth_sendTransaction", "personal_sign"]
      , i2 = ["eth_accounts", "eth_requestAccounts", "eth_sendRawTransaction", "eth_sign", "eth_signTransaction", "eth_signTypedData", "eth_signTypedData_v3", "eth_signTypedData_v4", "eth_sendTransaction", "personal_sign", "wallet_switchEthereumChain", "wallet_addEthereumChain", "wallet_getPermissions", "wallet_requestPermissions", "wallet_registerOnboarding", "wallet_watchAsset", "wallet_scanQRCode"]
      , i3 = ["chainChanged", "accountsChanged"]
      , i5 = ["chainChanged", "accountsChanged", "message", "disconnect", "connect"];
    var i6 = Object.defineProperty
      , i4 = Object.defineProperties
      , i8 = Object.getOwnPropertyDescriptors
      , i7 = Object.getOwnPropertySymbols
      , i9 = Object.prototype.hasOwnProperty
      , sn = Object.prototype.propertyIsEnumerable
      , ethereum_provider_dist_index_es_O = (J, et, eo) => et in J ? i6(J, et, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: eo
      }) : J[et] = eo
      , dist_index_es_p = (J, et) => {
        for (var eo in et || (et = {}))
          i9.call(et, eo) && ethereum_provider_dist_index_es_O(J, eo, et[eo]);
        if (i7)
          for (var eo of i7(et))
            sn.call(et, eo) && ethereum_provider_dist_index_es_O(J, eo, et[eo]);
        return J
      }
      , index_es_M = (J, et) => i4(J, i8(et));
    function ethereum_provider_dist_index_es_g(J) {
      return Number(J[0].split(":")[1])
    }
    function index_es_f(J) {
      return `0x${J.toString(16)}`
    }
    let dist_index_es_v = class dist_index_es_v {
      constructor() {
        this.events = new eX.EventEmitter,
          this.namespace = "eip155",
          this.accounts = [],
          this.chainId = 1,
          this.STORAGE_KEY = "wc@2:ethereum_provider:",
          this.on = (J, et) => (this.events.on(J, et),
            this),
          this.once = (J, et) => (this.events.once(J, et),
            this),
          this.removeListener = (J, et) => (this.events.removeListener(J, et),
            this),
          this.off = (J, et) => (this.events.off(J, et),
            this),
          this.parseAccount = J => this.isCompatibleChainId(J) ? this.parseAccountId(J).address : J,
          this.signer = {},
          this.rpc = {}
      }
      static async init(J) {
        let et = new dist_index_es_v;
        return await et.initialize(J),
          et
      }
      async request(J) {
        return await this.signer.request(J, this.formatChainId(this.chainId))
      }
      sendAsync(J, et) {
        this.signer.sendAsync(J, et, this.formatChainId(this.chainId))
      }
      get connected() {
        return !!this.signer.client && this.signer.client.core.relayer.connected
      }
      get connecting() {
        return !!this.signer.client && this.signer.client.core.relayer.connecting
      }
      async enable() {
        return this.session || await this.connect(),
          await this.request({
            method: "eth_requestAccounts"
          })
      }
      async connect(J) {
        if (!this.signer.client)
          throw Error("Provider not initialized. Call init() first");
        this.loadConnectOpts(J);
        let { required: et, optional: eo } = function (J) {
          let { chains: et, optionalChains: eo, methods: el, optionalMethods: ec, events: ed, optionalEvents: eh, rpcMap: ep } = J;
          if (!k(et))
            throw Error("Invalid chains");
          let ef = {
            chains: et,
            methods: el || i1,
            events: ed || i3,
            rpcMap: dist_index_es_p({}, et.length ? {
              [ethereum_provider_dist_index_es_g(et)]: ep[ethereum_provider_dist_index_es_g(et)]
            } : {})
          }
            , em = ed?.filter(J => !i3.includes(J))
            , eg = el?.filter(J => !i1.includes(J));
          if (!eo && !eh && !ec && !(null != em && em.length) && !(null != eg && eg.length))
            return {
              required: et.length ? ef : void 0
            };
          let ey = em?.length && eg?.length || !eo
            , eb = {
              chains: [...new Set(ey ? ef.chains.concat(eo || []) : eo)],
              methods: [...new Set(ef.methods.concat(null != ec && ec.length ? ec : i2))],
              events: [...new Set(ef.events.concat(null != eh && eh.length ? eh : i5))],
              rpcMap: ep
            };
          return {
            required: et.length ? ef : void 0,
            optional: eo.length ? eb : void 0
          }
        }(this.rpc);
        try {
          let el = await new Promise(async (el, ec) => {
            var ed;
            this.rpc.showQrModal && (null == (ed = this.modal) || ed.subscribeModal(J => {
              J.open || this.signer.session || (this.signer.abortPairingAttempt(),
                ec(Error("Connection request reset. Please try again.")))
            }
            )),
              await this.signer.connect(index_es_M(dist_index_es_p({
                namespaces: dist_index_es_p({}, et && {
                  [this.namespace]: et
                })
              }, eo && {
                optionalNamespaces: {
                  [this.namespace]: eo
                }
              }), {
                pairingTopic: J?.pairingTopic
              })).then(J => {
                el(J)
              }
              ).catch(J => {
                ec(Error(J.message))
              }
              )
          }
          );
          if (!el)
            return;
          let ec = function (J, et = []) {
            let eo = [];
            return Object.keys(J).forEach(el => {
              if (et.length && !et.includes(el))
                return;
              let ec = J[el];
              eo.push(...ec.accounts)
            }
            ),
              eo
          }(el.namespaces, [this.namespace]);
          this.setChainIds(this.rpc.chains.length ? this.rpc.chains : ec),
            this.setAccounts(ec),
            this.events.emit("connect", {
              chainId: index_es_f(this.chainId)
            })
        } catch (J) {
          throw this.signer.logger.error(J),
          J
        } finally {
          this.modal && this.modal.closeModal()
        }
      }
      async disconnect() {
        this.session && await this.signer.disconnect(),
          this.reset()
      }
      get isWalletConnect() {
        return !0
      }
      get session() {
        return this.signer.session
      }
      registerEventListeners() {
        this.signer.on("session_event", J => {
          let { params: et } = J
            , { event: eo } = et;
          "accountsChanged" === eo.name ? (this.accounts = this.parseAccounts(eo.data),
            this.events.emit("accountsChanged", this.accounts)) : "chainChanged" === eo.name ? this.setChainId(this.formatChainId(eo.data)) : this.events.emit(eo.name, eo.data),
            this.events.emit("session_event", J)
        }
        ),
          this.signer.on("chainChanged", J => {
            let et = parseInt(J);
            this.chainId = et,
              this.events.emit("chainChanged", index_es_f(this.chainId)),
              this.persist()
          }
          ),
          this.signer.on("session_update", J => {
            this.events.emit("session_update", J)
          }
          ),
          this.signer.on("session_delete", J => {
            this.reset(),
              this.events.emit("session_delete", J),
              this.events.emit("disconnect", index_es_M(dist_index_es_p({}, index_es_U("USER_DISCONNECTED")), {
                data: J.topic,
                name: "USER_DISCONNECTED"
              }))
          }
          ),
          this.signer.on("display_uri", J => {
            var et, eo;
            this.rpc.showQrModal && (null == (et = this.modal) || et.closeModal(),
              null == (eo = this.modal) || eo.openModal({
                uri: J
              })),
              this.events.emit("display_uri", J)
          }
          )
      }
      switchEthereumChain(J) {
        this.request({
          method: "wallet_switchEthereumChain",
          params: [{
            chainId: J.toString(16)
          }]
        })
      }
      isCompatibleChainId(J) {
        return "string" == typeof J && J.startsWith(`${this.namespace}:`)
      }
      formatChainId(J) {
        return `${this.namespace}:${J}`
      }
      parseChainId(J) {
        return Number(J.split(":")[1])
      }
      setChainIds(J) {
        let et = J.filter(J => this.isCompatibleChainId(J)).map(J => this.parseChainId(J));
        et.length && (this.chainId = et[0],
          this.events.emit("chainChanged", index_es_f(this.chainId)),
          this.persist())
      }
      setChainId(J) {
        if (this.isCompatibleChainId(J)) {
          let et = this.parseChainId(J);
          this.chainId = et,
            this.switchEthereumChain(et)
        }
      }
      parseAccountId(J) {
        let [et, eo, el] = J.split(":");
        return {
          chainId: `${et}:${eo}`,
          address: el
        }
      }
      setAccounts(J) {
        this.accounts = J.filter(J => this.parseChainId(this.parseAccountId(J).chainId) === this.chainId).map(J => this.parseAccountId(J).address),
          this.events.emit("accountsChanged", this.accounts)
      }
      getRpcConfig(J) {
        var et, eo;
        let el = null != (et = J?.chains) ? et : []
          , ec = null != (eo = J?.optionalChains) ? eo : []
          , ed = el.concat(ec);
        if (!ed.length)
          throw Error("No chains specified in either `chains` or `optionalChains`");
        let eh = el.length ? J?.methods || i1 : []
          , ep = el.length ? J?.events || i3 : []
          , ef = J?.optionalMethods || []
          , em = J?.optionalEvents || []
          , eg = J?.rpcMap || this.buildRpcMap(ed, J.projectId)
          , ey = J?.qrModalOptions || void 0;
        return {
          chains: el?.map(J => this.formatChainId(J)),
          optionalChains: ec.map(J => this.formatChainId(J)),
          methods: eh,
          events: ep,
          optionalMethods: ef,
          optionalEvents: em,
          rpcMap: eg,
          showQrModal: !!(null != J && J.showQrModal),
          qrModalOptions: ey,
          projectId: J.projectId,
          metadata: J.metadata
        }
      }
      buildRpcMap(J, et) {
        let eo = {};
        return J.forEach(J => {
          eo[J] = this.getRpcUrl(J, et)
        }
        ),
          eo
      }
      async initialize(J) {
        if (this.rpc = this.getRpcConfig(J),
          this.chainId = this.rpc.chains.length ? ethereum_provider_dist_index_es_g(this.rpc.chains) : ethereum_provider_dist_index_es_g(this.rpc.optionalChains),
          this.signer = await index_es_lr.init({
            projectId: this.rpc.projectId,
            metadata: this.rpc.metadata,
            disableProviderPing: J.disableProviderPing,
            relayUrl: J.relayUrl,
            storageOptions: J.storageOptions
          }),
          this.registerEventListeners(),
          await this.loadPersistedSession(),
          this.rpc.showQrModal) {
          let J;
          try {
            let { WalletConnectModal: et } = await eo.e(343).then(eo.bind(eo, 59343));
            J = et
          } catch {
            throw Error("To use QR modal, please install @walletconnect/modal package")
          }
          if (J)
            try {
              this.modal = new J(dist_index_es_p({
                projectId: this.rpc.projectId
              }, this.rpc.qrModalOptions))
            } catch (J) {
              throw this.signer.logger.error(J),
              Error("Could not generate WalletConnectModal Instance")
            }
        }
      }
      loadConnectOpts(J) {
        if (!J)
          return;
        let { chains: et, optionalChains: eo, rpcMap: el } = J;
        et && k(et) && (this.rpc.chains = et.map(J => this.formatChainId(J)),
          et.forEach(J => {
            this.rpc.rpcMap[J] = el?.[J] || this.getRpcUrl(J)
          }
          )),
          eo && k(eo) && (this.rpc.optionalChains = [],
            this.rpc.optionalChains = eo?.map(J => this.formatChainId(J)),
            eo.forEach(J => {
              this.rpc.rpcMap[J] = el?.[J] || this.getRpcUrl(J)
            }
            ))
      }
      getRpcUrl(J, et) {
        var eo;
        return (null == (eo = this.rpc.rpcMap) ? void 0 : eo[J]) || `https://rpc.walletconnect.com/v1/?chainId=eip155:${J}&projectId=${et || this.rpc.projectId}`
      }
      async loadPersistedSession() {
        if (!this.session)
          return;
        let J = await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`)
          , et = this.session.namespaces[`${this.namespace}:${J}`] ? this.session.namespaces[`${this.namespace}:${J}`] : this.session.namespaces[this.namespace];
        this.setChainIds(J ? [this.formatChainId(J)] : et?.accounts),
          this.setAccounts(et?.accounts)
      }
      reset() {
        this.chainId = 1,
          this.accounts = []
      }
      persist() {
        this.session && this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`, this.chainId)
      }
      parseAccounts(J) {
        return "string" == typeof J || J instanceof String ? [this.parseAccount(J)] : J.map(J => this.parseAccount(J))
      }
    }
      ;
    function walletConnect(J) {
      let et, eo;
      let el = J.isNewChainsStale ?? !0
        , ec = "eip155";
      return ed => ({
        id: "walletConnect",
        name: "WalletConnect",
        type: walletConnect.type,
        async setup() {
          let J = await this.getProvider().catch(() => null);
          J && (J.on("connect", this.onConnect.bind(this)),
            J.on("session_delete", this.onSessionDelete.bind(this)))
        },
        async connect({ chainId: J, ...et } = {}) {
          try {
            let eo = await this.getProvider();
            if (!eo)
              throw new ProviderNotFoundError;
            eo.on("display_uri", this.onDisplayUri);
            let el = J;
            if (!el) {
              let J = await ed.storage?.getItem("state") ?? {}
                , et = ed.chains.some(et => et.id === J.chainId);
              el = et ? J.chainId : ed.chains[0]?.id
            }
            if (!el)
              throw Error("No chains found on connector.");
            let ec = await this.isChainsStale();
            if (eo.session && ec && await eo.disconnect(),
              !eo.session || ec) {
              let J = ed.chains.filter(J => J.id !== el).map(J => J.id);
              await eo.connect({
                optionalChains: [el, ...J],
                ..."pairingTopic" in et ? {
                  pairingTopic: et.pairingTopic
                } : {}
              }),
                this.setRequestedChainsIds(ed.chains.map(J => J.id))
            }
            let eh = (await eo.enable()).map(J => (0,
              eU.K)(J))
              , ep = await this.getChainId();
            return eo.removeListener("display_uri", this.onDisplayUri),
              eo.removeListener("connect", this.onConnect.bind(this)),
              eo.on("accountsChanged", this.onAccountsChanged.bind(this)),
              eo.on("chainChanged", this.onChainChanged),
              eo.on("disconnect", this.onDisconnect.bind(this)),
              eo.on("session_delete", this.onSessionDelete.bind(this)),
            {
              accounts: eh,
              chainId: ep
            }
          } catch (J) {
            if (/(user rejected|connection request reset)/i.test(J?.message))
              throw new ez.ab(J);
            throw J
          }
        },
        async disconnect() {
          let J = await this.getProvider();
          try {
            await J?.disconnect()
          } catch (J) {
            if (!/No matching key/i.test(J.message))
              throw J
          } finally {
            J?.removeListener("accountsChanged", this.onAccountsChanged.bind(this)),
              J?.removeListener("chainChanged", this.onChainChanged),
              J?.removeListener("disconnect", this.onDisconnect.bind(this)),
              J?.removeListener("session_delete", this.onSessionDelete.bind(this)),
              J?.on("connect", this.onConnect.bind(this)),
              this.setRequestedChainsIds([])
          }
        },
        async getAccounts() {
          let J = await this.getProvider();
          return J.accounts.map(J => (0,
            eU.K)(J))
        },
        async getProvider({ chainId: el } = {}) {
          async function initProvider() {
            let et = ed.chains.map(J => J.id);
            if (et.length)
              return await dist_index_es_v.init({
                ...J,
                disableProviderPing: !0,
                optionalChains: et,
                projectId: J.projectId,
                rpcMap: Object.fromEntries(ed.chains.map(J => [J.id, J.rpcUrls.default.http[0]])),
                showQrModal: J.showQrModal ?? !0
              })
          }
          return et || (eo || (eo = initProvider()),
            et = await eo,
            et?.events.setMaxListeners(1 / 0)),
            el && await this.switchChain?.({
              chainId: el
            }),
            et
        },
        async getChainId() {
          let J = await this.getProvider();
          return J.chainId
        },
        async isAuthorized() {
          try {
            let [J, et] = await Promise.all([this.getAccounts(), this.getProvider()]);
            if (!J.length)
              return !1;
            let eo = await this.isChainsStale();
            if (eo && et.session)
              return await et.disconnect().catch(() => { }
              ),
                !1;
            return !0
          } catch {
            return !1
          }
        },
        async switchChain({ chainId: J }) {
          let et = ed.chains.find(et => et.id === J);
          if (!et)
            throw new ez.x3(new eW.X4);
          try {
            let eo = await this.getProvider()
              , el = this.getNamespaceChainsIds()
              , ec = this.getNamespaceMethods()
              , ed = el.includes(J);
            if (!ed && ec.includes("wallet_addEthereumChain")) {
              await eo.request({
                method: "wallet_addEthereumChain",
                params: [{
                  chainId: (0,
                    eV.eC)(et.id),
                  blockExplorerUrls: [et.blockExplorers?.default.url],
                  chainName: et.name,
                  nativeCurrency: et.nativeCurrency,
                  rpcUrls: [...et.rpcUrls.default.http]
                }]
              });
              let el = await this.getRequestedChainsIds();
              this.setRequestedChainsIds([...el, J])
            }
            return await eo.request({
              method: "wallet_switchEthereumChain",
              params: [{
                chainId: (0,
                  eV.eC)(J)
              }]
            }),
              et
          } catch (et) {
            let J = "string" == typeof et ? et : et?.message;
            if (/user rejected request/i.test(J))
              throw new ez.ab(et);
            throw new ez.x3(et)
          }
        },
        onAccountsChanged(J) {
          0 === J.length ? this.onDisconnect() : ed.emitter.emit("change", {
            accounts: J.map(J => (0,
              eU.K)(J))
          })
        },
        onChainChanged(J) {
          let et = normalizeChainId(J);
          ed.emitter.emit("change", {
            chainId: et
          })
        },
        async onConnect(J) {
          let et = normalizeChainId(J.chainId)
            , eo = await this.getAccounts();
          ed.emitter.emit("connect", {
            accounts: eo,
            chainId: et
          })
        },
        async onDisconnect(J) {
          this.setRequestedChainsIds([]),
            ed.emitter.emit("disconnect");
          let et = await this.getProvider();
          et.removeListener("accountsChanged", this.onAccountsChanged.bind(this)),
            et.removeListener("chainChanged", this.onChainChanged),
            et.removeListener("disconnect", this.onDisconnect.bind(this)),
            et.removeListener("session_delete", this.onSessionDelete.bind(this)),
            et.on("connect", this.onConnect.bind(this))
        },
        onDisplayUri(J) {
          ed.emitter.emit("message", {
            type: "display_uri",
            data: J
          })
        },
        onSessionDelete() {
          this.onDisconnect()
        },
        getNamespaceChainsIds() {
          if (!et)
            return [];
          let J = et.session?.namespaces[ec]?.chains?.map(J => parseInt(J.split(":")[1] || ""));
          return J ?? []
        },
        getNamespaceMethods() {
          if (!et)
            return [];
          let J = et.session?.namespaces[ec]?.methods;
          return J ?? []
        },
        async getRequestedChainsIds() {
          return await ed.storage?.getItem(this.requestedChainsStorageKey) ?? []
        },
        async isChainsStale() {
          let J = this.getNamespaceMethods();
          if (J.includes("wallet_addEthereumChain") || !el)
            return !1;
          let et = ed.chains.map(J => J.id)
            , eo = this.getNamespaceChainsIds();
          if (eo.length && !eo.some(J => et.includes(J)))
            return !1;
          let ec = await this.getRequestedChainsIds();
          return !et.every(J => ec.includes(J))
        },
        async setRequestedChainsIds(J) {
          await ed.storage?.setItem(this.requestedChainsStorageKey, J)
        },
        get requestedChainsStorageKey() {
          return `${this.id}.requestedChains`
        }
      })
    }
    walletConnect.type = "walletConnect";
    var so = eo(45811);
    function coinbaseWallet(J) {
      let et, eo;
      return el => ({
        id: "coinbaseWalletSDK",
        name: "Coinbase Wallet",
        type: coinbaseWallet.type,
        async connect({ chainId: J } = {}) {
          try {
            let et = await this.getProvider()
              , eo = (await et.request({
                method: "eth_requestAccounts"
              })).map(J => (0,
                eU.K)(J));
            et.on("accountsChanged", this.onAccountsChanged),
              et.on("chainChanged", this.onChainChanged),
              et.on("disconnect", this.onDisconnect.bind(this));
            let el = await this.getChainId();
            if (J && el !== J) {
              let et = await this.switchChain({
                chainId: J
              }).catch(J => {
                if (J.code === ez.ab.code)
                  throw J;
                return {
                  id: el
                }
              }
              );
              el = et?.id ?? el
            }
            return {
              accounts: eo,
              chainId: el
            }
          } catch (J) {
            if (/(user closed modal|accounts received is empty|user denied account)/i.test(J.message))
              throw new ez.ab(J);
            throw J
          }
        },
        async disconnect() {
          let J = await this.getProvider();
          J.removeListener("accountsChanged", this.onAccountsChanged),
            J.removeListener("chainChanged", this.onChainChanged),
            J.removeListener("disconnect", this.onDisconnect.bind(this)),
            J.disconnect(),
            J.close()
        },
        async getAccounts() {
          let J = await this.getProvider();
          return (await J.request({
            method: "eth_accounts"
          })).map(J => (0,
            eU.K)(J))
        },
        async getChainId() {
          let J = await this.getProvider();
          return normalizeChainId(J.chainId)
        },
        async getProvider() {
          if (!eo) {
            et = new so.jp({
              reloadOnDisconnect: !1,
              ...J
            });
            let ec = et.walletExtension?.getChainId()
              , ed = el.chains.find(et => J.chainId ? et.id === J.chainId : et.id === ec) || el.chains[0]
              , eh = J.chainId || ed?.id
              , ep = J.jsonRpcUrl || ed?.rpcUrls.default.http[0];
            eo = et.makeWeb3Provider(ep, eh)
          }
          return eo
        },
        async isAuthorized() {
          try {
            let J = await this.getAccounts();
            return !!J.length
          } catch {
            return !1
          }
        },
        async switchChain({ chainId: J }) {
          let et = el.chains.find(et => et.id === J);
          if (!et)
            throw new ez.x3(new eW.X4);
          let eo = await this.getProvider()
            , ec = (0,
              eV.eC)(et.id);
          try {
            return await eo.request({
              method: "wallet_switchEthereumChain",
              params: [{
                chainId: ec
              }]
            }),
              et
          } catch (J) {
            if (4902 === J.code)
              try {
                return await eo.request({
                  method: "wallet_addEthereumChain",
                  params: [{
                    chainId: ec,
                    chainName: et.name,
                    nativeCurrency: et.nativeCurrency,
                    rpcUrls: [et.rpcUrls.default?.http[0] ?? ""],
                    blockExplorerUrls: [et.blockExplorers?.default.url]
                  }]
                }),
                  et
              } catch (J) {
                throw new ez.ab(J)
              }
            throw new ez.x3(J)
          }
        },
        onAccountsChanged(J) {
          0 === J.length ? el.emitter.emit("disconnect") : el.emitter.emit("change", {
            accounts: J.map(J => (0,
              eU.K)(J))
          })
        },
        onChainChanged(J) {
          let et = normalizeChainId(J);
          el.emitter.emit("change", {
            chainId: et
          })
        },
        async onDisconnect(J) {
          el.emitter.emit("disconnect");
          let et = await this.getProvider();
          et.removeListener("accountsChanged", this.onAccountsChanged),
            et.removeListener("chainChanged", this.onChainChanged),
            et.removeListener("disconnect", this.onDisconnect.bind(this))
        }
      })
    }
    function normalizeChainId_normalizeChainId(J) {
      if ("string" == typeof J)
        return Number.parseInt(J, "0x" === J.trim().substring(0, 2) ? 16 : 10);
      if ("bigint" == typeof J)
        return Number(J);
      if ("number" == typeof J)
        return J;
      throw Error(`Cannot normalize chainId "${J}" of type "${typeof J}"`)
    }
    coinbaseWallet.type = "coinbaseWallet";
    var sa = eo(89481)
      , sl = eo(52408)
      , sc = eo(92611)
      , sd = eo(186)
      , sh = eo(30202)
      , sp = eo(62914)
      , sf = eo(45651)
      , sm = eo(84465)
      , sg = eo(67694)
      , sy = eo(87462);
    eo(8679);
    var clamp = function (J, et, eo) {
      return J = (J = J <= eo ? J : eo) >= et ? J : et
    }
      , createQueue = function () {
        var J = !1
          , et = []
          , next = function next() {
            J = !0;
            var eo = et.shift();
            if (eo)
              return eo(next);
            J = !1
          };
        return {
          clear: function () {
            J = !1,
              et = []
          },
          enqueue: function (eo) {
            et.push(eo),
              J || 1 !== et.length || next()
          }
        }
      }
      , createTimeout = function () {
        var J;
        return {
          cancel: function () {
            J && window.cancelAnimationFrame(J)
          },
          schedule: function (et, eo) {
            var el;
            J = window.requestAnimationFrame(function frame(ec) {
              if (el = el || ec,
                ec - el > eo) {
                et();
                return
              }
              J = window.requestAnimationFrame(frame)
            })
          }
        }
      }
      , increment = function (J) {
        var et = 0;
        return J >= 0 && J < .2 ? et = .1 : J >= .2 && J < .5 ? et = .04 : J >= .5 && J < .8 ? et = .02 : J >= .8 && J < .99 && (et = .005),
          clamp(J + et, 0, .994)
      }
      , useEffectOnce = function (J) {
        (0,
          eA.useEffect)(J, [])
      }
      , incrementParameter = function (J) {
        return ++J % 1e6
      }
      , useUpdate = function () {
        var J = (0,
          eA.useState)(0)[1];
        return (0,
          eA.useCallback)(function () {
            return J(incrementParameter)
          }, [])
      }
      , useGetSetState = function (J) {
        void 0 === J && (J = {});
        var et = useUpdate()
          , eo = (0,
            eA.useRef)((0,
              sy.Z)({}, J));
        return [(0,
          eA.useCallback)(function () {
            return eo.current
          }, []), (0,
            eA.useCallback)(function (J) {
              J && (Object.assign(eo.current, J),
                et())
            }, [])]
      }
      , useFirstMountState = function () {
        var J = (0,
          eA.useRef)(!0);
        return J.current ? (J.current = !1,
          !0) : J.current
      }
      , useUpdateEffect = function (J, et) {
        var eo = useFirstMountState();
        (0,
          eA.useEffect)(function () {
            if (!eo)
              return J()
          }, et)
      }
      , noop = function () { }
      , sb = {
        isFinished: !0,
        progress: 0,
        sideEffect: noop
      }
      , useNProgress = function (J) {
        var et = void 0 === J ? {} : J
          , eo = et.animationDuration
          , el = void 0 === eo ? 200 : eo
          , ec = et.incrementDuration
          , ed = void 0 === ec ? 800 : ec
          , eh = et.isAnimating
          , ep = void 0 !== eh && eh
          , ef = et.minimum
          , em = void 0 === ef ? .08 : ef
          , eg = useGetSetState(sb)
          , ey = eg[0]
          , eb = eg[1]
          , ew = (0,
            eA.useRef)(null)
          , e_ = (0,
            eA.useRef)(null);
        useEffectOnce(function () {
          ew.current = createQueue(),
            e_.current = createTimeout()
        });
        var ex = (0,
          eA.useCallback)(function () {
            var J, et;
            null == (J = e_.current) || J.cancel(),
              null == (et = ew.current) || et.clear()
          }, [])
          , eE = (0,
            eA.useCallback)(function (J) {
              var et, eo, ec;
              if (1 === (J = clamp(J, em, 1))) {
                ex(),
                  null == (eo = ew.current) || eo.enqueue(function (et) {
                    eb({
                      progress: J,
                      sideEffect: function () {
                        var J;
                        return null == (J = e_.current) ? void 0 : J.schedule(et, el)
                      }
                    })
                  }),
                  null == (ec = ew.current) || ec.enqueue(function () {
                    eb({
                      isFinished: !0,
                      sideEffect: ex
                    })
                  });
                return
              }
              null == (et = ew.current) || et.enqueue(function (et) {
                eb({
                  isFinished: !1,
                  progress: J,
                  sideEffect: function () {
                    var J;
                    return null == (J = e_.current) ? void 0 : J.schedule(et, el)
                  }
                })
              })
            }, [el, ex, em, ew, eb, e_])
          , eC = (0,
            eA.useCallback)(function () {
              eE(increment(ey().progress))
            }, [ey, eE])
          , eS = (0,
            eA.useCallback)(function () {
              !function work() {
                var J;
                eC(),
                  null == (J = ew.current) || J.enqueue(function (J) {
                    var et;
                    null == (et = e_.current) || et.schedule(function () {
                      work(),
                        J()
                    }, ed)
                  })
              }()
            }, [ed, ew, e_, eC])
          , ek = (0,
            eA.useRef)(noop)
          , eT = ey().sideEffect;
        return (0,
          eA.useEffect)(function () {
            ek.current = eC
          }),
          useEffectOnce(function () {
            return ep && eS(),
              ex
          }),
          useUpdateEffect(function () {
            ey().sideEffect()
          }, [ey, eT]),
          useUpdateEffect(function () {
            ep ? eb((0,
              sy.Z)({}, sb, {
                sideEffect: eS
              })) : eE(1)
          }, [ep, eE, eb, eS]),
        {
          animationDuration: el,
          isFinished: ey().isFinished,
          progress: ey().progress
        }
      }
      , sw = eo(99306)
      , s_ = eo.n(sw);
    let Bar = J => {
      let { animationDuration: et, progress: eo } = J;
      return (0,
        eT.jsx)("div", {
          className: s_().bar,
          style: {
            marginLeft: "".concat((-1 + eo) * 100, "%"),
            transition: "margin-left ".concat(et, "ms linear")
          }
        })
    }
      , Container = J => {
        let { animationDuration: et, children: eo, isFinished: el } = J;
        return (0,
          eT.jsx)("div", {
            className: s_().container,
            style: {
              opacity: el ? 0 : 1,
              transition: "opacity ".concat(et, "ms linear")
            },
            children: eo
          })
      }
      , Progress = J => {
        let { isAnimating: et } = J
          , { animationDuration: eo, isFinished: el, progress: ec } = useNProgress({
            isAnimating: et
          });
        return (0,
          eT.jsx)(Container, {
            animationDuration: eo,
            isFinished: el,
            children: (0,
              eT.jsx)(Bar, {
                animationDuration: eo,
                progress: ec
              })
          })
      }
      ;
    var sx = eo(64529);
    let sE = (0,
      sx.Ue)(J => ({
        isAnimating: !1,
        setIsAnimating: et => J(() => ({
          isAnimating: et
        }))
      }));
    var sC = eo(85665)
      , sS = eo(9192)
      , sk = eo(24139)
      , sT = eo(27037)
      , sA = eo(72008)
      , sP = eo(48907)
      , sR = class extends sP.F {
        constructor(J) {
          super(),
            this.#e = !1,
            this.#t = J.defaultOptions,
            this.#r(J.options),
            this.#n = [],
            this.#i = J.cache,
            this.queryKey = J.queryKey,
            this.queryHash = J.queryHash,
            this.#s = J.state || function (J) {
              let et = "function" == typeof J.initialData ? J.initialData() : J.initialData
                , eo = void 0 !== et
                , el = eo ? "function" == typeof J.initialDataUpdatedAt ? J.initialDataUpdatedAt() : J.initialDataUpdatedAt : 0;
              return {
                data: et,
                dataUpdateCount: 0,
                dataUpdatedAt: eo ? el ?? Date.now() : 0,
                error: null,
                errorUpdateCount: 0,
                errorUpdatedAt: 0,
                fetchFailureCount: 0,
                fetchFailureReason: null,
                fetchMeta: null,
                isInvalidated: !1,
                status: eo ? "success" : "pending",
                fetchStatus: "idle"
              }
            }(this.options),
            this.state = this.#s,
            this.scheduleGc()
        }
        #s;
        #o;
        #i;
        #a;
        #l;
        #n;
        #t;
        #e;
        get meta() {
          return this.options.meta
        }
        #r(J) {
          this.options = {
            ...this.#t,
            ...J
          },
            this.updateGcTime(this.options.gcTime)
        }
        optionalRemove() {
          this.#n.length || "idle" !== this.state.fetchStatus || this.#i.remove(this)
        }
        setData(J, et) {
          let eo = (0,
            sk.oE)(this.state.data, J, this.options);
          return this.#c({
            data: eo,
            type: "success",
            dataUpdatedAt: et?.updatedAt,
            manual: et?.manual
          }),
            eo
        }
        setState(J, et) {
          this.#c({
            type: "setState",
            state: J,
            setStateOptions: et
          })
        }
        cancel(J) {
          let et = this.#a;
          return this.#l?.cancel(J),
            et ? et.then(sk.ZT).catch(sk.ZT) : Promise.resolve()
        }
        destroy() {
          super.destroy(),
            this.cancel({
              silent: !0
            })
        }
        reset() {
          this.destroy(),
            this.setState(this.#s)
        }
        isActive() {
          return this.#n.some(J => !1 !== J.options.enabled)
        }
        isDisabled() {
          return this.getObserversCount() > 0 && !this.isActive()
        }
        isStale() {
          return this.state.isInvalidated || !this.state.dataUpdatedAt || this.#n.some(J => J.getCurrentResult().isStale)
        }
        isStaleByTime(J = 0) {
          return this.state.isInvalidated || !this.state.dataUpdatedAt || !(0,
            sk.Kp)(this.state.dataUpdatedAt, J)
        }
        onFocus() {
          let J = this.#n.find(J => J.shouldFetchOnWindowFocus());
          J?.refetch({
            cancelRefetch: !1
          }),
            this.#l?.continue()
        }
        onOnline() {
          let J = this.#n.find(J => J.shouldFetchOnReconnect());
          J?.refetch({
            cancelRefetch: !1
          }),
            this.#l?.continue()
        }
        addObserver(J) {
          this.#n.includes(J) || (this.#n.push(J),
            this.clearGcTimeout(),
            this.#i.notify({
              type: "observerAdded",
              query: this,
              observer: J
            }))
        }
        removeObserver(J) {
          this.#n.includes(J) && (this.#n = this.#n.filter(et => et !== J),
            this.#n.length || (this.#l && (this.#e ? this.#l.cancel({
              revert: !0
            }) : this.#l.cancelRetry()),
              this.scheduleGc()),
            this.#i.notify({
              type: "observerRemoved",
              query: this,
              observer: J
            }))
        }
        getObserversCount() {
          return this.#n.length
        }
        invalidate() {
          this.state.isInvalidated || this.#c({
            type: "invalidate"
          })
        }
        fetch(J, et) {
          if ("idle" !== this.state.fetchStatus) {
            if (this.state.dataUpdatedAt && et?.cancelRefetch)
              this.cancel({
                silent: !0
              });
            else if (this.#a)
              return this.#l?.continueRetry(),
                this.#a
          }
          if (J && this.#r(J),
            !this.options.queryFn) {
            let J = this.#n.find(J => J.options.queryFn);
            J && this.#r(J.options)
          }
          let eo = new AbortController
            , el = {
              queryKey: this.queryKey,
              meta: this.meta
            }
            , addSignalProperty = J => {
              Object.defineProperty(J, "signal", {
                enumerable: !0,
                get: () => (this.#e = !0,
                  eo.signal)
              })
            }
            ;
          addSignalProperty(el);
          let ec = {
            fetchOptions: et,
            options: this.options,
            queryKey: this.queryKey,
            state: this.state,
            fetchFn: () => this.options.queryFn ? (this.#e = !1,
              this.options.persister) ? this.options.persister(this.options.queryFn, el, this) : this.options.queryFn(el) : Promise.reject(Error(`Missing queryFn: '${this.options.queryHash}'`))
          };
          addSignalProperty(ec),
            this.options.behavior?.onFetch(ec, this),
            this.#o = this.state,
            ("idle" === this.state.fetchStatus || this.state.fetchMeta !== ec.fetchOptions?.meta) && this.#c({
              type: "fetch",
              meta: ec.fetchOptions?.meta
            });
          let onError = J => {
            (0,
              sA.DV)(J) && J.silent || this.#c({
                type: "error",
                error: J
              }),
              (0,
                sA.DV)(J) || (this.#i.config.onError?.(J, this),
                  this.#i.config.onSettled?.(this.state.data, J, this)),
              this.isFetchingOptimistic || this.scheduleGc(),
              this.isFetchingOptimistic = !1
          }
            ;
          return this.#l = (0,
            sA.Mz)({
              fn: ec.fetchFn,
              abort: eo.abort.bind(eo),
              onSuccess: J => {
                if (void 0 === J) {
                  onError(Error(`${this.queryHash} data is undefined`));
                  return
                }
                this.setData(J),
                  this.#i.config.onSuccess?.(J, this),
                  this.#i.config.onSettled?.(J, this.state.error, this),
                  this.isFetchingOptimistic || this.scheduleGc(),
                  this.isFetchingOptimistic = !1
              }
              ,
              onError,
              onFail: (J, et) => {
                this.#c({
                  type: "failed",
                  failureCount: J,
                  error: et
                })
              }
              ,
              onPause: () => {
                this.#c({
                  type: "pause"
                })
              }
              ,
              onContinue: () => {
                this.#c({
                  type: "continue"
                })
              }
              ,
              retry: ec.options.retry,
              retryDelay: ec.options.retryDelay,
              networkMode: ec.options.networkMode
            }),
            this.#a = this.#l.promise,
            this.#a
        }
        #c(J) {
          this.state = (et => {
            switch (J.type) {
              case "failed":
                return {
                  ...et,
                  fetchFailureCount: J.failureCount,
                  fetchFailureReason: J.error
                };
              case "pause":
                return {
                  ...et,
                  fetchStatus: "paused"
                };
              case "continue":
                return {
                  ...et,
                  fetchStatus: "fetching"
                };
              case "fetch":
                return {
                  ...et,
                  fetchFailureCount: 0,
                  fetchFailureReason: null,
                  fetchMeta: J.meta ?? null,
                  fetchStatus: (0,
                    sA.Kw)(this.options.networkMode) ? "fetching" : "paused",
                  ...!et.dataUpdatedAt && {
                    error: null,
                    status: "pending"
                  }
                };
              case "success":
                return {
                  ...et,
                  data: J.data,
                  dataUpdateCount: et.dataUpdateCount + 1,
                  dataUpdatedAt: J.dataUpdatedAt ?? Date.now(),
                  error: null,
                  isInvalidated: !1,
                  status: "success",
                  ...!J.manual && {
                    fetchStatus: "idle",
                    fetchFailureCount: 0,
                    fetchFailureReason: null
                  }
                };
              case "error":
                let eo = J.error;
                if ((0,
                  sA.DV)(eo) && eo.revert && this.#o)
                  return {
                    ...this.#o,
                    fetchStatus: "idle"
                  };
                return {
                  ...et,
                  error: eo,
                  errorUpdateCount: et.errorUpdateCount + 1,
                  errorUpdatedAt: Date.now(),
                  fetchFailureCount: et.fetchFailureCount + 1,
                  fetchFailureReason: eo,
                  fetchStatus: "idle",
                  status: "error"
                };
              case "invalidate":
                return {
                  ...et,
                  isInvalidated: !0
                };
              case "setState":
                return {
                  ...et,
                  ...J.state
                }
            }
          }
          )(this.state),
            sT.V.batch(() => {
              this.#n.forEach(J => {
                J.onQueryUpdate()
              }
              ),
                this.#i.notify({
                  query: this,
                  type: "updated",
                  action: J
                })
            }
            )
        }
      }
      , sI = eo(7506)
      , sO = class extends sI.l {
        constructor(J = {}) {
          super(),
            this.config = J,
            this.#u = new Map
        }
        #u;
        build(J, et, eo) {
          let el = et.queryKey
            , ec = et.queryHash ?? (0,
              sk.Rm)(el, et)
            , ed = this.get(ec);
          return ed || (ed = new sR({
            cache: this,
            queryKey: el,
            queryHash: ec,
            options: J.defaultQueryOptions(et),
            state: eo,
            defaultOptions: J.getQueryDefaults(el)
          }),
            this.add(ed)),
            ed
        }
        add(J) {
          this.#u.has(J.queryHash) || (this.#u.set(J.queryHash, J),
            this.notify({
              type: "added",
              query: J
            }))
        }
        remove(J) {
          let et = this.#u.get(J.queryHash);
          et && (J.destroy(),
            et === J && this.#u.delete(J.queryHash),
            this.notify({
              type: "removed",
              query: J
            }))
        }
        clear() {
          sT.V.batch(() => {
            this.getAll().forEach(J => {
              this.remove(J)
            }
            )
          }
          )
        }
        get(J) {
          return this.#u.get(J)
        }
        getAll() {
          return [...this.#u.values()]
        }
        find(J) {
          let et = {
            exact: !0,
            ...J
          };
          return this.getAll().find(J => (0,
            sk._x)(et, J))
        }
        findAll(J = {}) {
          let et = this.getAll();
          return Object.keys(J).length > 0 ? et.filter(et => (0,
            sk._x)(J, et)) : et
        }
        notify(J) {
          sT.V.batch(() => {
            this.listeners.forEach(et => {
              et(J)
            }
            )
          }
          )
        }
        onFocus() {
          sT.V.batch(() => {
            this.getAll().forEach(J => {
              J.onFocus()
            }
            )
          }
          )
        }
        onOnline() {
          sT.V.batch(() => {
            this.getAll().forEach(J => {
              J.onOnline()
            }
            )
          }
          )
        }
      }
      , sN = eo(59289)
      , sM = class extends sI.l {
        constructor(J = {}) {
          super(),
            this.config = J,
            this.#d = [],
            this.#h = 0
        }
        #d;
        #h;
        #p;
        build(J, et, eo) {
          let el = new sN.m({
            mutationCache: this,
            mutationId: ++this.#h,
            options: J.defaultMutationOptions(et),
            state: eo
          });
          return this.add(el),
            el
        }
        add(J) {
          this.#d.push(J),
            this.notify({
              type: "added",
              mutation: J
            })
        }
        remove(J) {
          this.#d = this.#d.filter(et => et !== J),
            this.notify({
              type: "removed",
              mutation: J
            })
        }
        clear() {
          sT.V.batch(() => {
            this.#d.forEach(J => {
              this.remove(J)
            }
            )
          }
          )
        }
        getAll() {
          return this.#d
        }
        find(J) {
          let et = {
            exact: !0,
            ...J
          };
          return this.#d.find(J => (0,
            sk.X7)(et, J))
        }
        findAll(J = {}) {
          return this.#d.filter(et => (0,
            sk.X7)(J, et))
        }
        notify(J) {
          sT.V.batch(() => {
            this.listeners.forEach(et => {
              et(J)
            }
            )
          }
          )
        }
        resumePausedMutations() {
          return this.#p = (this.#p ?? Promise.resolve()).then(() => {
            let J = this.#d.filter(J => J.state.isPaused);
            return sT.V.batch(() => J.reduce((J, et) => J.then(() => et.continue().catch(sk.ZT)), Promise.resolve()))
          }
          ).then(() => {
            this.#p = void 0
          }
          ),
            this.#p
        }
      }
      , sD = eo(66474)
      , sj = eo(14304);
    function getNextPageParam(J, { pages: et, pageParams: eo }) {
      let el = et.length - 1;
      return J.getNextPageParam(et[el], et, eo[el], eo)
    }
    function getPreviousPageParam(J, { pages: et, pageParams: eo }) {
      return J.getPreviousPageParam?.(et[0], et, eo[0], eo)
    }
    var sL = class {
      #f;
      #m;
      #t;
      #g;
      #y;
      #v;
      #b;
      #w;
      constructor(J = {}) {
        this.#f = J.queryCache || new sO,
          this.#m = J.mutationCache || new sM,
          this.#t = J.defaultOptions || {},
          this.#g = new Map,
          this.#y = new Map,
          this.#v = 0
      }
      mount() {
        this.#v++,
          1 === this.#v && (this.#b = sD.j.subscribe(() => {
            sD.j.isFocused() && (this.resumePausedMutations(),
              this.#f.onFocus())
          }
          ),
            this.#w = sj.N.subscribe(() => {
              sj.N.isOnline() && (this.resumePausedMutations(),
                this.#f.onOnline())
            }
            ))
      }
      unmount() {
        this.#v--,
          0 === this.#v && (this.#b?.(),
            this.#b = void 0,
            this.#w?.(),
            this.#w = void 0)
      }
      isFetching(J) {
        return this.#f.findAll({
          ...J,
          fetchStatus: "fetching"
        }).length
      }
      isMutating(J) {
        return this.#m.findAll({
          ...J,
          status: "pending"
        }).length
      }
      getQueryData(J) {
        return this.#f.find({
          queryKey: J
        })?.state.data
      }
      ensureQueryData(J) {
        let et = this.getQueryData(J.queryKey);
        return void 0 !== et ? Promise.resolve(et) : this.fetchQuery(J)
      }
      getQueriesData(J) {
        return this.getQueryCache().findAll(J).map(({ queryKey: J, state: et }) => {
          let eo = et.data;
          return [J, eo]
        }
        )
      }
      setQueryData(J, et, eo) {
        let el = this.#f.find({
          queryKey: J
        })
          , ec = el?.state.data
          , ed = (0,
            sk.SE)(et, ec);
        if (void 0 === ed)
          return;
        let eh = this.defaultQueryOptions({
          queryKey: J
        });
        return this.#f.build(this, eh).setData(ed, {
          ...eo,
          manual: !0
        })
      }
      setQueriesData(J, et, eo) {
        return sT.V.batch(() => this.getQueryCache().findAll(J).map(({ queryKey: J }) => [J, this.setQueryData(J, et, eo)]))
      }
      getQueryState(J) {
        return this.#f.find({
          queryKey: J
        })?.state
      }
      removeQueries(J) {
        let et = this.#f;
        sT.V.batch(() => {
          et.findAll(J).forEach(J => {
            et.remove(J)
          }
          )
        }
        )
      }
      resetQueries(J, et) {
        let eo = this.#f
          , el = {
            type: "active",
            ...J
          };
        return sT.V.batch(() => (eo.findAll(J).forEach(J => {
          J.reset()
        }
        ),
          this.refetchQueries(el, et)))
      }
      cancelQueries(J = {}, et = {}) {
        let eo = {
          revert: !0,
          ...et
        }
          , el = sT.V.batch(() => this.#f.findAll(J).map(J => J.cancel(eo)));
        return Promise.all(el).then(sk.ZT).catch(sk.ZT)
      }
      invalidateQueries(J = {}, et = {}) {
        return sT.V.batch(() => {
          if (this.#f.findAll(J).forEach(J => {
            J.invalidate()
          }
          ),
            "none" === J.refetchType)
            return Promise.resolve();
          let eo = {
            ...J,
            type: J.refetchType ?? J.type ?? "active"
          };
          return this.refetchQueries(eo, et)
        }
        )
      }
      refetchQueries(J = {}, et) {
        let eo = {
          ...et,
          cancelRefetch: et?.cancelRefetch ?? !0
        }
          , el = sT.V.batch(() => this.#f.findAll(J).filter(J => !J.isDisabled()).map(J => {
            let et = J.fetch(void 0, eo);
            return eo.throwOnError || (et = et.catch(sk.ZT)),
              "paused" === J.state.fetchStatus ? Promise.resolve() : et
          }
          ));
        return Promise.all(el).then(sk.ZT)
      }
      fetchQuery(J) {
        let et = this.defaultQueryOptions(J);
        void 0 === et.retry && (et.retry = !1);
        let eo = this.#f.build(this, et);
        return eo.isStaleByTime(et.staleTime) ? eo.fetch(et) : Promise.resolve(eo.state.data)
      }
      prefetchQuery(J) {
        return this.fetchQuery(J).then(sk.ZT).catch(sk.ZT)
      }
      fetchInfiniteQuery(J) {
        var et;
        return J.behavior = (et = J.pages,
        {
          onFetch: (J, eo) => {
            let fetchFn = async () => {
              let eo;
              let el = J.options
                , ec = J.fetchOptions?.meta?.fetchMore?.direction
                , ed = J.state.data?.pages || []
                , eh = J.state.data?.pageParams || []
                , ep = !1
                , addSignalProperty = et => {
                  Object.defineProperty(et, "signal", {
                    enumerable: !0,
                    get: () => (J.signal.aborted ? ep = !0 : J.signal.addEventListener("abort", () => {
                      ep = !0
                    }
                    ),
                      J.signal)
                  })
                }
                , ef = J.options.queryFn || (() => Promise.reject(Error(`Missing queryFn: '${J.options.queryHash}'`)))
                , fetchPage = async (et, eo, el) => {
                  if (ep)
                    return Promise.reject();
                  if (null == eo && et.pages.length)
                    return Promise.resolve(et);
                  let ec = {
                    queryKey: J.queryKey,
                    pageParam: eo,
                    direction: el ? "backward" : "forward",
                    meta: J.options.meta
                  };
                  addSignalProperty(ec);
                  let ed = await ef(ec)
                    , { maxPages: eh } = J.options
                    , em = el ? sk.Ht : sk.VX;
                  return {
                    pages: em(et.pages, ed, eh),
                    pageParams: em(et.pageParams, eo, eh)
                  }
                }
                ;
              if (ec && ed.length) {
                let J = "backward" === ec
                  , et = J ? getPreviousPageParam : getNextPageParam
                  , ep = {
                    pages: ed,
                    pageParams: eh
                  }
                  , ef = et(el, ep);
                eo = await fetchPage(ep, ef, J)
              } else {
                eo = await fetchPage({
                  pages: [],
                  pageParams: []
                }, eh[0] ?? el.initialPageParam);
                let J = et ?? ed.length;
                for (let et = 1; et < J; et++) {
                  let J = getNextPageParam(el, eo);
                  eo = await fetchPage(eo, J)
                }
              }
              return eo
            }
              ;
            J.options.persister ? J.fetchFn = () => J.options.persister?.(fetchFn, {
              queryKey: J.queryKey,
              meta: J.options.meta,
              signal: J.signal
            }, eo) : J.fetchFn = fetchFn
          }
        }),
          this.fetchQuery(J)
      }
      prefetchInfiniteQuery(J) {
        return this.fetchInfiniteQuery(J).then(sk.ZT).catch(sk.ZT)
      }
      resumePausedMutations() {
        return this.#m.resumePausedMutations()
      }
      getQueryCache() {
        return this.#f
      }
      getMutationCache() {
        return this.#m
      }
      getDefaultOptions() {
        return this.#t
      }
      setDefaultOptions(J) {
        this.#t = J
      }
      setQueryDefaults(J, et) {
        this.#g.set((0,
          sk.Ym)(J), {
          queryKey: J,
          defaultOptions: et
        })
      }
      getQueryDefaults(J) {
        let et = [...this.#g.values()]
          , eo = {};
        return et.forEach(et => {
          (0,
            sk.to)(J, et.queryKey) && (eo = {
              ...eo,
              ...et.defaultOptions
            })
        }
        ),
          eo
      }
      setMutationDefaults(J, et) {
        this.#y.set((0,
          sk.Ym)(J), {
          mutationKey: J,
          defaultOptions: et
        })
      }
      getMutationDefaults(J) {
        let et = [...this.#y.values()]
          , eo = {};
        return et.forEach(et => {
          (0,
            sk.to)(J, et.mutationKey) && (eo = {
              ...eo,
              ...et.defaultOptions
            })
        }
        ),
          eo
      }
      defaultQueryOptions(J) {
        if (J?._defaulted)
          return J;
        let et = {
          ...this.#t.queries,
          ...J?.queryKey && this.getQueryDefaults(J.queryKey),
          ...J,
          _defaulted: !0
        };
        return et.queryHash || (et.queryHash = (0,
          sk.Rm)(et.queryKey, et)),
          void 0 === et.refetchOnReconnect && (et.refetchOnReconnect = "always" !== et.networkMode),
          void 0 === et.throwOnError && (et.throwOnError = !!et.suspense),
          void 0 === et.networkMode && et.persister && (et.networkMode = "offlineFirst"),
          et
      }
      defaultMutationOptions(J) {
        return J?._defaulted ? J : {
          ...this.#t.mutations,
          ...J?.mutationKey && this.getMutationDefaults(J.mutationKey),
          ...J,
          _defaulted: !0
        }
      }
      clear() {
        this.#f.clear(),
          this.#m.clear()
      }
    }
      ;
    let s$ = new sL({
      defaultOptions: {
        queries: {
          retry: !1,
          staleTime: 3e5,
          refetchOnWindowFocus: !1
        }
      }
    });
    var sB = eo(66237)
      , sF = eo(75991)
      , sU = eo(86164);
    let sz = (0,
      sU.a)({
        id: 5,
        name: "Goerli",
        nativeCurrency: {
          name: "Goerli Ether",
          symbol: "ETH",
          decimals: 18
        },
        rpcUrls: {
          default: {
            http: ["https://rpc.ankr.com/eth_goerli"]
          }
        },
        blockExplorers: {
          default: {
            name: "Etherscan",
            url: "https://goerli.etherscan.io",
            apiUrl: "https://api-goerli.etherscan.io/api"
          }
        },
        contracts: {
          ensRegistry: {
            address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
          },
          ensUniversalResolver: {
            address: "0xfc4AC75C46C914aF5892d6d3eFFcebD7917293F1",
            blockCreated: 10339206
          },
          multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 6507670
          }
        },
        testnet: !0
      })
      , sH = (0,
        sU.a)({
          id: 1,
          name: "Ethereum",
          nativeCurrency: {
            name: "Ether",
            symbol: "ETH",
            decimals: 18
          },
          rpcUrls: {
            default: {
              http: ["https://omniscient-warmhearted-isle.quiknode.pro/58770851301a97313dd0b2342bb788e71c76e317", "https://cloudflare-eth.com"]
            }
          },
          blockExplorers: {
            default: {
              name: "Etherscan",
              url: "https://etherscan.io",
              apiUrl: "https://api.etherscan.io/api"
            }
          },
          contracts: {
            ensRegistry: {
              address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
            },
            ensUniversalResolver: {
              address: "0x8cab227b1162f03b8338331adaad7aadc83b895e",
              blockCreated: 18958930
            },
            multicall3: {
              address: "0xca11bde05977b3631167028862be2a173976ca11",
              blockCreated: 14353601
            }
          }
        })
      , sV = (0,
        sU.a)({
          id: 11155111,
          name: "Sepolia",
          nativeCurrency: {
            name: "Sepolia Ether",
            symbol: "SEP",
            decimals: 18
          },
          rpcUrls: {
            default: {
              http: ["https://rpc.sepolia.org"]
            }
          },
          blockExplorers: {
            default: {
              name: "Etherscan",
              url: "https://sepolia.etherscan.io",
              apiUrl: "https://api-sepolia.etherscan.io/api"
            }
          },
          contracts: {
            multicall3: {
              address: "0xca11bde05977b3631167028862be2a173976ca11",
              blockCreated: 751532
            },
            ensRegistry: {
              address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
            },
            ensUniversalResolver: {
              address: "0xBaBC7678D7A63104f1658c11D6AE9A21cdA09725",
              blockCreated: 5043334
            }
          },
          testnet: !0
        })
      , sW = (0,
        sU.a)({
          id: 195,
          name: "X1 testnet",
          network: "x1-testnet",
          nativeCurrency: {
            decimals: 18,
            name: "OKB",
            symbol: "OKB"
          },
          rpcUrls: {
            default: {
              http: ["https://x1-testnet.blockpi.network/v1/rpc/public", "https://x1-testnet.rpc.thirdweb.com"]
            }
          },
          blockExplorers: {
            default: {
              name: "X1(Test)",
              url: "https://www.okx.com/explorer/x1-test"
            }
          }
        })
      , sq = function () {
        let J = Number(1);
        return 1 === J ? sH : 195 === J ? sW : 11155111 === J ? sV : 5 === J ? sz : sH
      }()
      , sZ = [sq]
      , sG = function ({ projectId: J, chains: et, metadata: eo, enableInjected: ec, enableCoinbase: ed, enableEmail: eh, enableWalletConnect: ep, enableEIP6963: ef, ...em }) {
        var eg;
        let ey = []
          , eb = et.map(J => [J.id, http()])
          , ew = Object.fromEntries(eb);
        return !1 !== ep && ey.push(walletConnect({
          projectId: J,
          metadata: eo,
          showQrModal: !1
        })),
          !1 !== ec && ey.push(injected({
            shimDisconnect: !0
          })),
          !1 !== ed && ey.push(coinbaseWallet({
            appName: eo?.name ?? "Unknown",
            appLogoUrl: eo?.icons[0] ?? "Unknown"
          })),
          !0 === eh && ey.push((eg = {
            chains: [...et],
            options: {
              projectId: J
            }
          },
            J => ({
              id: sl.bq.EMAIL_CONNECTOR_ID,
              name: "Web3Modal Email",
              type: "w3mEmail",
              async connect(J = {}) {
                let et = await this.getProvider()
                  , { address: eo, chainId: el } = await et.connect({
                    chainId: J.chainId
                  });
                return {
                  accounts: [eo],
                  account: eo,
                  chainId: el,
                  chain: {
                    id: el,
                    unsuported: !1
                  }
                }
              },
              async disconnect() {
                let J = await this.getProvider();
                await J.disconnect()
              },
              async getAccounts() {
                let J = await this.getProvider()
                  , { address: et } = await J.connect();
                return [et]
              },
              async getProvider() {
                return this.provider || (this.provider = new sa.Sd(eg.options.projectId)),
                  Promise.resolve(this.provider)
              },
              async getChainId() {
                let J = await this.getProvider()
                  , { chainId: et } = await J.getChainId();
                return et
              },
              async isAuthorized() {
                let J = await this.getProvider()
                  , { isConnected: et } = await J.isConnected();
                return et
              },
              async switchChain({ chainId: et }) {
                try {
                  let eo = J.chains.find(J => J.id === et);
                  if (!eo)
                    throw new ez.x3(Error("chain not found on connector."));
                  let el = await this.getProvider();
                  return await el.switchNetwork(et),
                    J.emitter.emit("change", {
                      chainId: normalizeChainId_normalizeChainId(et)
                    }),
                    eo
                } catch (J) {
                  if (J instanceof Error)
                    throw new ez.x3(J);
                  throw J
                }
              },
              onAccountsChanged(et) {
                0 === et.length ? this.onDisconnect() : J.emitter.emit("change", {
                  accounts: et.map(eU.K)
                })
              },
              onChainChanged(et) {
                let eo = normalizeChainId_normalizeChainId(et);
                J.emitter.emit("change", {
                  chainId: eo
                })
              },
              async onConnect(et) {
                let eo = normalizeChainId_normalizeChainId(et.chainId)
                  , el = await this.getAccounts();
                J.emitter.emit("connect", {
                  accounts: el,
                  chainId: eo
                })
              },
              async onDisconnect(J) {
                let et = await this.getProvider();
                await et.disconnect()
              }
            }))),
          function (J) {
            let et;
            let { chains: eo, multiInjectedProviderDiscovery: ec = !0, storage: ed = function (J) {
              let { deserialize: et = deserialize_deserialize, key: eo = "wagmi", serialize: el = serialize_serialize, storage: ec = eK } = J;
              function unwrap(J) {
                return J instanceof Promise ? J.then(J => J).catch(() => null) : J
              }
              return {
                ...ec,
                key: eo,
                async getItem(J, el) {
                  let ed = ec.getItem(`${eo}.${J}`)
                    , eh = await unwrap(ed);
                  return eh ? et(eh) ?? null : el ?? null
                },
                async setItem(J, et) {
                  let ed = `${eo}.${J}`;
                  null === et ? await unwrap(ec.removeItem(ed)) : await unwrap(ec.setItem(ed, el(et)))
                },
                async removeItem(J) {
                  await unwrap(ec.removeItem(`${eo}.${J}`))
                }
              }
            }({
              storage: "undefined" != typeof window && window.localStorage ? window.localStorage : eK
            }), syncConnectedChain: eh = !0, ssr: ep, ...ef } = J
              , em = "undefined" != typeof window && ec ? function () {
                let J = new Set
                  , et = []
                  , request = () => (function (J) {
                    let handler = et => J(et.detail);
                    return window.addEventListener("eip6963:announceProvider", handler),
                      window.dispatchEvent(new CustomEvent("eip6963:requestProvider")),
                      () => window.removeEventListener("eip6963:announceProvider", handler)
                  }
                  )(eo => {
                    et.some(({ info: J }) => J.uuid === eo.info.uuid) || (et = [...et, eo],
                      J.forEach(J => J(et, {
                        added: [eo]
                      })))
                  }
                  )
                  , eo = request();
                return {
                  _listeners: () => J,
                  clear() {
                    J.forEach(J => J([], {
                      removed: [...et]
                    })),
                      et = []
                  },
                  destroy() {
                    this.clear(),
                      J.clear(),
                      eo()
                  },
                  findProvider: ({ rdns: J }) => et.find(et => et.info.rdns === J),
                  getProviders: () => et,
                  reset() {
                    this.clear(),
                      eo(),
                      eo = request()
                  },
                  subscribe: (eo, { emitImmediately: el } = {}) => (J.add(eo),
                    el && eo(et, {
                      added: et
                    }),
                    () => J.delete(eo))
                }
              }() : void 0
              , eg = vanilla_createStore(() => [...ef.connectors ?? [], ...ep ? [] : em?.getProviders().map(providerDetailToConnector) ?? []].map(setup));
            function setup(J) {
              var et;
              let ec = (et = function (J = 11) {
                if (!el || eJ + J > 512) {
                  el = "",
                    eJ = 0;
                  for (let J = 0; J < 256; J++)
                    el += (256 + 256 * Math.random() | 0).toString(16).substring(1)
                }
                return el.substring(eJ, eJ++ + J)
              }(),
                new Emitter(et))
                , eh = {
                  ...J({
                    emitter: ec,
                    chains: eo,
                    storage: ed
                  }),
                  emitter: ec,
                  uid: ec.uid
                };
              return ec.on("connect", connect),
                eh.setup?.(),
                eh
            }
            function providerDetailToConnector(J) {
              let { info: et } = J
                , eo = J.provider;
              return injected({
                target: {
                  ...et,
                  id: et.rdns,
                  provider: eo
                }
              })
            }
            let ey = new Map
              , eb = {
                chainId: eo[0].id,
                connections: new Map,
                current: void 0,
                status: "disconnected"
              }
              , ew = "0.0.0-canary-";
            et = eQ.i.startsWith(ew) ? parseInt(eQ.i.replace(ew, "")) : parseInt(eQ.i.split(".")[0] ?? "0");
            let e_ = vanilla_createStore(subscribeWithSelector(ed ? persist(() => eb, {
              migrate(J, eo) {
                if (eo === et)
                  return J;
                let el = J && "object" == typeof J && "chainId" in J && "number" == typeof J.chainId ? J.chainId : eb.chainId;
                return {
                  ...eb,
                  chainId: el
                }
              },
              name: "store",
              partialize: J => ({
                connections: {
                  __type: "Map",
                  value: Array.from(J.connections.entries()).map(([J, et]) => {
                    let { id: eo, name: el, type: ec, uid: ed } = et.connector;
                    return [J, {
                      ...et,
                      connector: {
                        id: eo,
                        name: el,
                        type: ec,
                        uid: ed
                      }
                    }]
                  }
                  )
                },
                chainId: J.chainId,
                current: J.current
              }),
              skipHydration: ep,
              storage: ed,
              version: et
            }) : () => eb));
            function change(J) {
              e_.setState(et => {
                let eo = et.connections.get(J.uid);
                return {
                  ...et,
                  connections: new Map(et.connections).set(J.uid, {
                    accounts: J.accounts ?? eo.accounts,
                    chainId: J.chainId ?? eo.chainId,
                    connector: eo.connector
                  })
                }
              }
              )
            }
            function connect(J) {
              "connecting" !== e_.getState().status && "reconnecting" !== e_.getState().status && e_.setState(et => {
                let eo = eg.getState().find(et => et.uid === J.uid);
                return eo ? {
                  ...et,
                  connections: new Map(et.connections).set(J.uid, {
                    accounts: J.accounts,
                    chainId: J.chainId,
                    connector: eo
                  }),
                  current: J.uid,
                  status: "connected"
                } : et
              }
              )
            }
            return eh && e_.subscribe(({ connections: J, current: et }) => et ? J.get(et)?.chainId : void 0, J => {
              let et = eo.some(et => et.id === J);
              if (et)
                return e_.setState(et => ({
                  ...et,
                  chainId: J ?? et.chainId
                }))
            }
            ),
              em?.subscribe(J => {
                let et = new Map;
                for (let J of eg.getState())
                  et.set(J.id, !0);
                let eo = [];
                for (let el of J) {
                  let J = setup(providerDetailToConnector(el));
                  et.has(J.id) || eo.push(J)
                }
                eg.setState(J => [...J, ...eo], !0)
              }
              ),
            {
              chains: eo,
              get connectors() {
                return eg.getState()
              },
              storage: ed,
              getClient: function (J = {}) {
                let et;
                let el = J.chainId ?? e_.getState().chainId
                  , ec = eo.find(J => J.id === el);
                if (J.chainId && !ec)
                  throw new eW.X4;
                {
                  let J = ey.get(e_.getState().chainId);
                  if (J && !ec)
                    return J;
                  if (!ec)
                    throw new eW.X4
                }
                {
                  let J = ey.get(el);
                  if (J)
                    return J
                }
                if (ef.client)
                  et = ef.client({
                    chain: ec
                  });
                else {
                  let J = ec.id
                    , eo = {}
                    , el = Object.entries(ef);
                  for (let [et, ec] of el)
                    "client" !== et && "connectors" !== et && "transports" !== et && ("object" == typeof ec ? eo[et] = ec[J] : eo[et] = ec);
                  et = (0,
                    eF.e)({
                      ...eo,
                      chain: ec,
                      batch: eo.batch ?? {
                        multicall: !0
                      },
                      transport: et => ef.transports[J]({
                        ...et,
                        connectors: eg
                      })
                    })
                }
                return ey.set(el, et),
                  et
              },
              get state() {
                return e_.getState()
              },
              setState(J) {
                let et;
                "object" != typeof (et = "function" == typeof J ? J(e_.getState()) : J) && (et = eb);
                let eo = Object.keys(eb).some(J => !(J in et));
                eo && (et = eb),
                  e_.setState(et, !0)
              },
              subscribe: (J, et, eo) => e_.subscribe(J, et, eo ? {
                ...eo,
                fireImmediately: eo.emitImmediately
              } : void 0),
              _internal: {
                mipd: em,
                store: e_,
                ssr: !!ep,
                syncConnectedChain: eh,
                transports: ef.transports,
                connectors: {
                  providerDetailToConnector,
                  setup,
                  setState: J => eg.setState("function" == typeof J ? J(eg.getState()) : J, !0),
                  subscribe: J => eg.subscribe(J)
                },
                events: {
                  change,
                  connect,
                  disconnect: function disconnect(J) {
                    e_.setState(et => {
                      let eo = et.connections.get(J.uid);
                      if (eo && (eo.connector.emitter.off("change", change),
                        eo.connector.emitter.off("disconnect", disconnect),
                        eo.connector.emitter.on("connect", connect)),
                        et.connections.delete(J.uid),
                        0 === et.connections.size)
                        return {
                          ...et,
                          connections: new Map,
                          current: void 0,
                          status: "disconnected"
                        };
                      let el = et.connections.values().next().value;
                      return {
                        ...et,
                        connections: new Map(et.connections),
                        current: el.connector.uid
                      }
                    }
                    )
                  }
                }
              }
            }
          }({
            chains: et,
            multiInjectedProviderDiscovery: !1 !== ef,
            transports: ew,
            ...em,
            connectors: ey
          })
      }({
        chains: sZ,
        projectId: sS.Sx,
        metadata: {
          name: "Moby",
          description: "Moby",
          url: "https://www.launchmoby.com",
          icons: ["https://avatars.githubusercontent.com/u/37784886"]
        },
        ssr: !0,
        transports: {
          [sq.id]: function (J, et = {}) {
            let { key: eo = "fallback", name: el = "Fallback", rank: ec = !1, retryCount: ed, retryDelay: eh } = et;
            return ({ chain: et, pollingInterval: ep = 4e3, timeout: ef, ...em }) => {
              let eg = J
                , onResponse = () => { }
                , ey = (0,
                  eB.q)({
                    key: eo,
                    name: el,
                    async request({ method: J, params: eo }) {
                      let fetch = async (el = 0) => {
                        let ec = eg[el]({
                          ...em,
                          chain: et,
                          retryCount: 0,
                          timeout: ef
                        });
                        try {
                          let et = await ec.request({
                            method: J,
                            params: eo
                          });
                          return onResponse({
                            method: J,
                            params: eo,
                            response: et,
                            transport: ec,
                            status: "success"
                          }),
                            et
                        } catch (et) {
                          if (onResponse({
                            error: et,
                            method: J,
                            params: eo,
                            transport: ec,
                            status: "error"
                          }),
                            "code" in et && "number" == typeof et.code && (et.code === ez.KB.code || et.code === ez.ab.code || 5e3 === et.code) || el === eg.length - 1)
                            throw et;
                          return fetch(el + 1)
                        }
                      }
                        ;
                      return fetch()
                    },
                    retryCount: ed,
                    retryDelay: eh,
                    type: "fallback"
                  }, {
                    onResponse: J => onResponse = J,
                    transports: eg.map(J => J({
                      chain: et,
                      retryCount: 0
                    }))
                  });
              if (ec) {
                let J = "object" == typeof ec ? ec : {};
                !function ({ chain: J, interval: et = 4e3, onTransports: eo, sampleCount: el = 10, timeout: ec = 1e3, transports: ed, weights: eh = {} }) {
                  let { stability: ep = .7, latency: ef = .3 } = eh
                    , em = []
                    , rankTransports_ = async () => {
                      let eh = await Promise.all(ed.map(async et => {
                        let eo, el;
                        let ed = et({
                          chain: J,
                          retryCount: 0,
                          timeout: ec
                        })
                          , eh = Date.now();
                        try {
                          await ed.request({
                            method: "net_listening"
                          }),
                            el = 1
                        } catch {
                          el = 0
                        } finally {
                          eo = Date.now()
                        }
                        let ep = eo - eh;
                        return {
                          latency: ep,
                          success: el
                        }
                      }
                      ));
                      em.push(eh),
                        em.length > el && em.shift();
                      let eg = Math.max(...em.map(J => Math.max(...J.map(({ latency: J }) => J))))
                        , ey = ed.map((J, et) => {
                          let eo = em.map(J => J[et].latency)
                            , el = eo.reduce((J, et) => J + et, 0) / eo.length
                            , ec = em.map(J => J[et].success)
                            , ed = ec.reduce((J, et) => J + et, 0) / ec.length;
                          return 0 === ed ? [0, et] : [ef * (1 - el / eg) + ep * ed, et]
                        }
                        ).sort((J, et) => et[0] - J[0]);
                      eo(ey.map(([, J]) => ed[J])),
                        await (0,
                          sp.D)(et),
                        rankTransports_()
                    }
                    ;
                  rankTransports_()
                }({
                  chain: et,
                  interval: J.interval ?? ep,
                  onTransports: J => eg = J,
                  sampleCount: J.sampleCount,
                  timeout: J.timeout,
                  transports: eg,
                  weights: J.weights
                })
              }
              return ey
            }
          }(sq.rpcUrls.default.http.map(J => http(J)))
        }
      });
    (0,
      eO.OY)({
        wagmiConfig: sG,
        projectId: sS.Sx,
        chains: sZ,
        featuredWalletIds: ["c57ca95b47569778a828d19178114f4db188b89b763c899ba0be274e97267d96", "971e689d0a5be527bac79629b4ee9b925e82208e5168b733496a09c0faed0709"]
      });
    var _app = function (J) {
      let { Component: et, pageProps: { session: eo, ...el } } = J
        , ec = sE(J => !!(null == J ? void 0 : J.setIsAnimating))
        , ed = sE(J => !!(null == J ? void 0 : J.isAnimating))
        , eh = (0,
          eP.useRouter)();
      return (0,
        eA.useEffect)(() => {
          let handleStart = () => {
            ec(!0)
          }
            , handleStop = () => {
              ec(!1)
            }
            ;
          return eh.events.on("routeChangeStart", handleStart),
            eh.events.on("routeChangeComplete", handleStop),
            eh.events.on("routeChangeError", handleStop),
            () => {
              eh.events.off("routeChangeStart", handleStart),
                eh.events.off("routeChangeComplete", handleStop),
                eh.events.off("routeChangeError", handleStop)
            }
        }
          , [eh]),
        (0,
          eT.jsx)(eT.Fragment, {
            children: (0,
              eT.jsx)(sd.f6, {
                theme: eI(),
                children: (0,
                  eT.jsx)(sc.F, {
                    config: sG,
                    children: (0,
                      eT.jsxs)(sh.aH, {
                        client: s$,
                        children: [(0,
                          eT.jsx)(Progress, {
                            isAnimating: ed
                          }), (0,
                            eT.jsx)(sg.default, {
                              children: (0,
                                eT.jsx)(sF.Z, {
                                  children: (0,
                                    eT.jsx)(sC.N, {
                                      children: (0,
                                        eT.jsx)(sB.Z, {
                                          children: (0,
                                            eT.jsx)(sf.Z, {
                                              children: (0,
                                                eT.jsx)(sm.Z, {
                                                  children: (0,
                                                    eT.jsx)(et, {
                                                      ...el
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            })]
                      })
                  })
              })
          })
    }
  },
  63720: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      Y: function () {
        return setCommonContract
      }
    });
    var el = eo(64529);
    let ec = (0,
      el.Ue)(() => ({
        stage: 0,
        isLoadingStage: !0,
        isCorrectNetwork: !0,
        totalPurchaseAmount: 0
      }));
    function setCommonContract(J) {
      ec.setState(J)
    }
    et.Z = ec
  },
  93222: function (J, et, eo) {
    "use strict";
    var el = eo(64529);
    let ec = (0,
      el.Ue)(() => ({
        priceHardcapPurchased: 0
      }));
    et.Z = ec
  },
  36752: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      V: function () {
        return setHardCap
      }
    });
    var el = eo(64529);
    let ec = (0,
      el.Ue)(() => ({
        isPurchased: !1,
        dataConfig: void 0,
        totalPurchaseAmount: 3800,
        totalPaymentPurchased: 3799.955533982111
      }));
    function setHardCap(J) {
      ec.setState(J)
    }
    et.Z = ec
  },
  42816: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      N: function () {
        return setSoftLaunch
      }
    });
    var el = eo(64529);
    let ec = (0,
      el.Ue)(() => ({
        isPurchased: !1,
        dataConfig: void 0,
        totalPurchaseAmount: 1200
      }));
    function setSoftLaunch(J) {
      ec.setState(J)
    }
    et.Z = ec
  },
  8484: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      W: function () {
        return setStoreUser
      }
    });
    var el = eo(64529);
    let ec = (0,
      el.Ue)(() => ({
        userToken: ""
      }));
    function setStoreUser(J) {
      ec.setState(J)
    }
    et.Z = ec
  },
  86394: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      cn: function () {
        return cn
      },
      v9: function () {
        return handleListColor
      },
      Lj: function () {
        return handleWidthCss
      }
    });
    var el = eo(86010);
    let ec = /^\[(.+)\]$/;
    function getPart(J, et) {
      let eo = J;
      return et.split("-").forEach(J => {
        eo.nextPart.has(J) || eo.nextPart.set(J, {
          nextPart: new Map,
          validators: []
        }),
          eo = eo.nextPart.get(J)
      }
      ),
        eo
    }
    let ed = /\s+/;
    function twJoin() {
      let J, et, eo = 0, el = "";
      for (; eo < arguments.length;)
        (J = arguments[eo++]) && (et = function toValue(J) {
          let et;
          if ("string" == typeof J)
            return J;
          let eo = "";
          for (let el = 0; el < J.length; el++)
            J[el] && (et = toValue(J[el])) && (eo && (eo += " "),
              eo += et);
          return eo
        }(J)) && (el && (el += " "),
          el += et);
      return el
    }
    function fromTheme(J) {
      let themeGetter = et => et[J] || [];
      return themeGetter.isThemeGetter = !0,
        themeGetter
    }
    let eh = /^\[(?:([a-z-]+):)?(.+)\]$/i
      , ep = /^\d+\/\d+$/
      , ef = new Set(["px", "full", "screen"])
      , em = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/
      , eg = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/
      , ey = /^-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/
      , eb = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
    function isLength(J) {
      return isNumber(J) || ef.has(J) || ep.test(J)
    }
    function isArbitraryLength(J) {
      return getIsArbitraryValue(J, "length", isLengthOnly)
    }
    function isNumber(J) {
      return !!J && !Number.isNaN(Number(J))
    }
    function isArbitraryNumber(J) {
      return getIsArbitraryValue(J, "number", isNumber)
    }
    function isInteger(J) {
      return !!J && Number.isInteger(Number(J))
    }
    function isPercent(J) {
      return J.endsWith("%") && isNumber(J.slice(0, -1))
    }
    function isArbitraryValue(J) {
      return eh.test(J)
    }
    function isTshirtSize(J) {
      return em.test(J)
    }
    let ew = new Set(["length", "size", "percentage"]);
    function isArbitrarySize(J) {
      return getIsArbitraryValue(J, ew, isNever)
    }
    function isArbitraryPosition(J) {
      return getIsArbitraryValue(J, "position", isNever)
    }
    let e_ = new Set(["image", "url"]);
    function isArbitraryImage(J) {
      return getIsArbitraryValue(J, e_, isImage)
    }
    function isArbitraryShadow(J) {
      return getIsArbitraryValue(J, "", isShadow)
    }
    function isAny() {
      return !0
    }
    function getIsArbitraryValue(J, et, eo) {
      let el = eh.exec(J);
      return !!el && (el[1] ? "string" == typeof et ? el[1] === et : et.has(el[1]) : eo(el[2]))
    }
    function isLengthOnly(J) {
      return eg.test(J)
    }
    function isNever() {
      return !1
    }
    function isShadow(J) {
      return ey.test(J)
    }
    function isImage(J) {
      return eb.test(J)
    }
    let ex = function (J) {
      let et, eo, el;
      let functionToCall = function (ed) {
        let eh = [].reduce((J, et) => et(J), J());
        return eo = (et = {
          cache: function (J) {
            if (J < 1)
              return {
                get: () => void 0,
                set: () => { }
              };
            let et = 0
              , eo = new Map
              , el = new Map;
            function update(ec, ed) {
              eo.set(ec, ed),
                ++et > J && (et = 0,
                  el = eo,
                  eo = new Map)
            }
            return {
              get(J) {
                let et = eo.get(J);
                return void 0 !== et ? et : void 0 !== (et = el.get(J)) ? (update(J, et),
                  et) : void 0
              },
              set(J, et) {
                eo.has(J) ? eo.set(J, et) : update(J, et)
              }
            }
          }(eh.cacheSize),
          splitModifiers: function (J) {
            let et = J.separator
              , eo = 1 === et.length
              , el = et[0]
              , ec = et.length;
            return function (J) {
              let ed;
              let eh = []
                , ep = 0
                , ef = 0;
              for (let em = 0; em < J.length; em++) {
                let eg = J[em];
                if (0 === ep) {
                  if (eg === el && (eo || J.slice(em, em + ec) === et)) {
                    eh.push(J.slice(ef, em)),
                      ef = em + ec;
                    continue
                  }
                  if ("/" === eg) {
                    ed = em;
                    continue
                  }
                }
                "[" === eg ? ep++ : "]" === eg && ep--
              }
              let em = 0 === eh.length ? J : J.substring(ef)
                , eg = em.startsWith("!")
                , ey = eg ? em.substring(1) : em
                , eb = ed && ed > ef ? ed - ef : void 0;
              return {
                modifiers: eh,
                hasImportantModifier: eg,
                baseClassName: ey,
                maybePostfixModifierPosition: eb
              }
            }
          }(eh),
          ...function (J) {
            let et = function (J) {
              var et;
              let { theme: eo, prefix: el } = J
                , ec = {
                  nextPart: new Map,
                  validators: []
                }
                , ed = (et = Object.entries(J.classGroups),
                  el ? et.map(([J, et]) => {
                    let eo = et.map(J => "string" == typeof J ? el + J : "object" == typeof J ? Object.fromEntries(Object.entries(J).map(([J, et]) => [el + J, et])) : J);
                    return [J, eo]
                  }
                  ) : et);
              return ed.forEach(([J, et]) => {
                (function processClassesRecursively(J, et, eo, el) {
                  J.forEach(J => {
                    if ("string" == typeof J) {
                      let el = "" === J ? et : getPart(et, J);
                      el.classGroupId = eo;
                      return
                    }
                    if ("function" == typeof J) {
                      if (J.isThemeGetter) {
                        processClassesRecursively(J(el), et, eo, el);
                        return
                      }
                      et.validators.push({
                        validator: J,
                        classGroupId: eo
                      });
                      return
                    }
                    Object.entries(J).forEach(([J, ec]) => {
                      processClassesRecursively(ec, getPart(et, J), eo, el)
                    }
                    )
                  }
                  )
                }
                )(et, ec, J, eo)
              }
              ),
                ec
            }(J)
              , { conflictingClassGroups: eo, conflictingClassGroupModifiers: el } = J;
            return {
              getClassGroupId: function (J) {
                let eo = J.split("-");
                return "" === eo[0] && 1 !== eo.length && eo.shift(),
                  function getGroupRecursive(J, et) {
                    if (0 === J.length)
                      return et.classGroupId;
                    let eo = J[0]
                      , el = et.nextPart.get(eo)
                      , ec = el ? getGroupRecursive(J.slice(1), el) : void 0;
                    if (ec)
                      return ec;
                    if (0 === et.validators.length)
                      return;
                    let ed = J.join("-");
                    return et.validators.find(({ validator: J }) => J(ed))?.classGroupId
                  }(eo, et) || function (J) {
                    if (ec.test(J)) {
                      let et = ec.exec(J)[1]
                        , eo = et?.substring(0, et.indexOf(":"));
                      if (eo)
                        return "arbitrary.." + eo
                    }
                  }(J)
              },
              getConflictingClassGroupIds: function (J, et) {
                let ec = eo[J] || [];
                return et && el[J] ? [...ec, ...el[J]] : ec
              }
            }
          }(eh)
        }).cache.get,
          el = et.cache.set,
          functionToCall = tailwindMerge,
          tailwindMerge(ed)
      };
      function tailwindMerge(J) {
        let ec = eo(J);
        if (ec)
          return ec;
        let eh = function (J, et) {
          let { splitModifiers: eo, getClassGroupId: el, getConflictingClassGroupIds: ec } = et
            , eh = new Set;
          return J.trim().split(ed).map(J => {
            let { modifiers: et, hasImportantModifier: ec, baseClassName: ed, maybePostfixModifierPosition: eh } = eo(J)
              , ep = el(eh ? ed.substring(0, eh) : ed)
              , ef = !!eh;
            if (!ep) {
              if (!eh || !(ep = el(ed)))
                return {
                  isTailwindClass: !1,
                  originalClassName: J
                };
              ef = !1
            }
            let em = (function (J) {
              if (J.length <= 1)
                return J;
              let et = []
                , eo = [];
              return J.forEach(J => {
                let el = "[" === J[0];
                el ? (et.push(...eo.sort(), J),
                  eo = []) : eo.push(J)
              }
              ),
                et.push(...eo.sort()),
                et
            }
            )(et).join(":");
            return {
              isTailwindClass: !0,
              modifierId: ec ? em + "!" : em,
              classGroupId: ep,
              originalClassName: J,
              hasPostfixModifier: ef
            }
          }
          ).reverse().filter(J => {
            if (!J.isTailwindClass)
              return !0;
            let { modifierId: et, classGroupId: eo, hasPostfixModifier: el } = J
              , ed = et + eo;
            return !eh.has(ed) && (eh.add(ed),
              ec(eo, el).forEach(J => eh.add(et + J)),
              !0)
          }
          ).reverse().map(J => J.originalClassName).join(" ")
        }(J, et);
        return el(J, eh),
          eh
      }
      return function () {
        return functionToCall(twJoin.apply(null, arguments))
      }
    }(function () {
      let J = fromTheme("colors")
        , et = fromTheme("spacing")
        , eo = fromTheme("blur")
        , el = fromTheme("brightness")
        , ec = fromTheme("borderColor")
        , ed = fromTheme("borderRadius")
        , eh = fromTheme("borderSpacing")
        , ep = fromTheme("borderWidth")
        , ef = fromTheme("contrast")
        , em = fromTheme("grayscale")
        , eg = fromTheme("hueRotate")
        , ey = fromTheme("invert")
        , eb = fromTheme("gap")
        , ew = fromTheme("gradientColorStops")
        , e_ = fromTheme("gradientColorStopPositions")
        , ex = fromTheme("inset")
        , eE = fromTheme("margin")
        , eC = fromTheme("opacity")
        , eS = fromTheme("padding")
        , ek = fromTheme("saturate")
        , eT = fromTheme("scale")
        , eA = fromTheme("sepia")
        , eP = fromTheme("skew")
        , eR = fromTheme("space")
        , eI = fromTheme("translate")
        , getOverscroll = () => ["auto", "contain", "none"]
        , getOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"]
        , getSpacingWithAutoAndArbitrary = () => ["auto", isArbitraryValue, et]
        , getSpacingWithArbitrary = () => [isArbitraryValue, et]
        , getLengthWithEmptyAndArbitrary = () => ["", isLength, isArbitraryLength]
        , getNumberWithAutoAndArbitrary = () => ["auto", isNumber, isArbitraryValue]
        , getPositions = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"]
        , getLineStyles = () => ["solid", "dashed", "dotted", "double", "none"]
        , getBlendModes = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity", "plus-lighter"]
        , getAlign = () => ["start", "end", "center", "between", "around", "evenly", "stretch"]
        , getZeroAndEmpty = () => ["", "0", isArbitraryValue]
        , getBreaks = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"]
        , getNumber = () => [isNumber, isArbitraryNumber]
        , getNumberAndArbitrary = () => [isNumber, isArbitraryValue];
      return {
        cacheSize: 500,
        separator: ":",
        theme: {
          colors: [isAny],
          spacing: [isLength, isArbitraryLength],
          blur: ["none", "", isTshirtSize, isArbitraryValue],
          brightness: getNumber(),
          borderColor: [J],
          borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
          borderSpacing: getSpacingWithArbitrary(),
          borderWidth: getLengthWithEmptyAndArbitrary(),
          contrast: getNumber(),
          grayscale: getZeroAndEmpty(),
          hueRotate: getNumberAndArbitrary(),
          invert: getZeroAndEmpty(),
          gap: getSpacingWithArbitrary(),
          gradientColorStops: [J],
          gradientColorStopPositions: [isPercent, isArbitraryLength],
          inset: getSpacingWithAutoAndArbitrary(),
          margin: getSpacingWithAutoAndArbitrary(),
          opacity: getNumber(),
          padding: getSpacingWithArbitrary(),
          saturate: getNumber(),
          scale: getNumber(),
          sepia: getZeroAndEmpty(),
          skew: getNumberAndArbitrary(),
          space: getSpacingWithArbitrary(),
          translate: getSpacingWithArbitrary()
        },
        classGroups: {
          aspect: [{
            aspect: ["auto", "square", "video", isArbitraryValue]
          }],
          container: ["container"],
          columns: [{
            columns: [isTshirtSize]
          }],
          "break-after": [{
            "break-after": getBreaks()
          }],
          "break-before": [{
            "break-before": getBreaks()
          }],
          "break-inside": [{
            "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
          }],
          "box-decoration": [{
            "box-decoration": ["slice", "clone"]
          }],
          box: [{
            box: ["border", "content"]
          }],
          display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
          float: [{
            float: ["right", "left", "none"]
          }],
          clear: [{
            clear: ["left", "right", "both", "none"]
          }],
          isolation: ["isolate", "isolation-auto"],
          "object-fit": [{
            object: ["contain", "cover", "fill", "none", "scale-down"]
          }],
          "object-position": [{
            object: [...getPositions(), isArbitraryValue]
          }],
          overflow: [{
            overflow: getOverflow()
          }],
          "overflow-x": [{
            "overflow-x": getOverflow()
          }],
          "overflow-y": [{
            "overflow-y": getOverflow()
          }],
          overscroll: [{
            overscroll: getOverscroll()
          }],
          "overscroll-x": [{
            "overscroll-x": getOverscroll()
          }],
          "overscroll-y": [{
            "overscroll-y": getOverscroll()
          }],
          position: ["static", "fixed", "absolute", "relative", "sticky"],
          inset: [{
            inset: [ex]
          }],
          "inset-x": [{
            "inset-x": [ex]
          }],
          "inset-y": [{
            "inset-y": [ex]
          }],
          start: [{
            start: [ex]
          }],
          end: [{
            end: [ex]
          }],
          top: [{
            top: [ex]
          }],
          right: [{
            right: [ex]
          }],
          bottom: [{
            bottom: [ex]
          }],
          left: [{
            left: [ex]
          }],
          visibility: ["visible", "invisible", "collapse"],
          z: [{
            z: ["auto", isInteger, isArbitraryValue]
          }],
          basis: [{
            basis: getSpacingWithAutoAndArbitrary()
          }],
          "flex-direction": [{
            flex: ["row", "row-reverse", "col", "col-reverse"]
          }],
          "flex-wrap": [{
            flex: ["wrap", "wrap-reverse", "nowrap"]
          }],
          flex: [{
            flex: ["1", "auto", "initial", "none", isArbitraryValue]
          }],
          grow: [{
            grow: getZeroAndEmpty()
          }],
          shrink: [{
            shrink: getZeroAndEmpty()
          }],
          order: [{
            order: ["first", "last", "none", isInteger, isArbitraryValue]
          }],
          "grid-cols": [{
            "grid-cols": [isAny]
          }],
          "col-start-end": [{
            col: ["auto", {
              span: ["full", isInteger, isArbitraryValue]
            }, isArbitraryValue]
          }],
          "col-start": [{
            "col-start": getNumberWithAutoAndArbitrary()
          }],
          "col-end": [{
            "col-end": getNumberWithAutoAndArbitrary()
          }],
          "grid-rows": [{
            "grid-rows": [isAny]
          }],
          "row-start-end": [{
            row: ["auto", {
              span: [isInteger, isArbitraryValue]
            }, isArbitraryValue]
          }],
          "row-start": [{
            "row-start": getNumberWithAutoAndArbitrary()
          }],
          "row-end": [{
            "row-end": getNumberWithAutoAndArbitrary()
          }],
          "grid-flow": [{
            "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
          }],
          "auto-cols": [{
            "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
          }],
          "auto-rows": [{
            "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
          }],
          gap: [{
            gap: [eb]
          }],
          "gap-x": [{
            "gap-x": [eb]
          }],
          "gap-y": [{
            "gap-y": [eb]
          }],
          "justify-content": [{
            justify: ["normal", ...getAlign()]
          }],
          "justify-items": [{
            "justify-items": ["start", "end", "center", "stretch"]
          }],
          "justify-self": [{
            "justify-self": ["auto", "start", "end", "center", "stretch"]
          }],
          "align-content": [{
            content: ["normal", ...getAlign(), "baseline"]
          }],
          "align-items": [{
            items: ["start", "end", "center", "baseline", "stretch"]
          }],
          "align-self": [{
            self: ["auto", "start", "end", "center", "stretch", "baseline"]
          }],
          "place-content": [{
            "place-content": [...getAlign(), "baseline"]
          }],
          "place-items": [{
            "place-items": ["start", "end", "center", "baseline", "stretch"]
          }],
          "place-self": [{
            "place-self": ["auto", "start", "end", "center", "stretch"]
          }],
          p: [{
            p: [eS]
          }],
          px: [{
            px: [eS]
          }],
          py: [{
            py: [eS]
          }],
          ps: [{
            ps: [eS]
          }],
          pe: [{
            pe: [eS]
          }],
          pt: [{
            pt: [eS]
          }],
          pr: [{
            pr: [eS]
          }],
          pb: [{
            pb: [eS]
          }],
          pl: [{
            pl: [eS]
          }],
          m: [{
            m: [eE]
          }],
          mx: [{
            mx: [eE]
          }],
          my: [{
            my: [eE]
          }],
          ms: [{
            ms: [eE]
          }],
          me: [{
            me: [eE]
          }],
          mt: [{
            mt: [eE]
          }],
          mr: [{
            mr: [eE]
          }],
          mb: [{
            mb: [eE]
          }],
          ml: [{
            ml: [eE]
          }],
          "space-x": [{
            "space-x": [eR]
          }],
          "space-x-reverse": ["space-x-reverse"],
          "space-y": [{
            "space-y": [eR]
          }],
          "space-y-reverse": ["space-y-reverse"],
          w: [{
            w: ["auto", "min", "max", "fit", isArbitraryValue, et]
          }],
          "min-w": [{
            "min-w": ["min", "max", "fit", isArbitraryValue, isLength]
          }],
          "max-w": [{
            "max-w": ["0", "none", "full", "min", "max", "fit", "prose", {
              screen: [isTshirtSize]
            }, isTshirtSize, isArbitraryValue]
          }],
          h: [{
            h: [isArbitraryValue, et, "auto", "min", "max", "fit"]
          }],
          "min-h": [{
            "min-h": ["min", "max", "fit", isLength, isArbitraryValue]
          }],
          "max-h": [{
            "max-h": [isArbitraryValue, et, "min", "max", "fit"]
          }],
          "font-size": [{
            text: ["base", isTshirtSize, isArbitraryLength]
          }],
          "font-smoothing": ["antialiased", "subpixel-antialiased"],
          "font-style": ["italic", "not-italic"],
          "font-weight": [{
            font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
          }],
          "font-family": [{
            font: [isAny]
          }],
          "fvn-normal": ["normal-nums"],
          "fvn-ordinal": ["ordinal"],
          "fvn-slashed-zero": ["slashed-zero"],
          "fvn-figure": ["lining-nums", "oldstyle-nums"],
          "fvn-spacing": ["proportional-nums", "tabular-nums"],
          "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
          tracking: [{
            tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue]
          }],
          "line-clamp": [{
            "line-clamp": ["none", isNumber, isArbitraryNumber]
          }],
          leading: [{
            leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isLength, isArbitraryValue]
          }],
          "list-image": [{
            "list-image": ["none", isArbitraryValue]
          }],
          "list-style-type": [{
            list: ["none", "disc", "decimal", isArbitraryValue]
          }],
          "list-style-position": [{
            list: ["inside", "outside"]
          }],
          "placeholder-color": [{
            placeholder: [J]
          }],
          "placeholder-opacity": [{
            "placeholder-opacity": [eC]
          }],
          "text-alignment": [{
            text: ["left", "center", "right", "justify", "start", "end"]
          }],
          "text-color": [{
            text: [J]
          }],
          "text-opacity": [{
            "text-opacity": [eC]
          }],
          "text-decoration": ["underline", "overline", "line-through", "no-underline"],
          "text-decoration-style": [{
            decoration: [...getLineStyles(), "wavy"]
          }],
          "text-decoration-thickness": [{
            decoration: ["auto", "from-font", isLength, isArbitraryLength]
          }],
          "underline-offset": [{
            "underline-offset": ["auto", isLength, isArbitraryValue]
          }],
          "text-decoration-color": [{
            decoration: [J]
          }],
          "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
          "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
          indent: [{
            indent: getSpacingWithArbitrary()
          }],
          "vertical-align": [{
            align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue]
          }],
          whitespace: [{
            whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
          }],
          break: [{
            break: ["normal", "words", "all", "keep"]
          }],
          hyphens: [{
            hyphens: ["none", "manual", "auto"]
          }],
          content: [{
            content: ["none", isArbitraryValue]
          }],
          "bg-attachment": [{
            bg: ["fixed", "local", "scroll"]
          }],
          "bg-clip": [{
            "bg-clip": ["border", "padding", "content", "text"]
          }],
          "bg-opacity": [{
            "bg-opacity": [eC]
          }],
          "bg-origin": [{
            "bg-origin": ["border", "padding", "content"]
          }],
          "bg-position": [{
            bg: [...getPositions(), isArbitraryPosition]
          }],
          "bg-repeat": [{
            bg: ["no-repeat", {
              repeat: ["", "x", "y", "round", "space"]
            }]
          }],
          "bg-size": [{
            bg: ["auto", "cover", "contain", isArbitrarySize]
          }],
          "bg-image": [{
            bg: ["none", {
              "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
            }, isArbitraryImage]
          }],
          "bg-color": [{
            bg: [J]
          }],
          "gradient-from-pos": [{
            from: [e_]
          }],
          "gradient-via-pos": [{
            via: [e_]
          }],
          "gradient-to-pos": [{
            to: [e_]
          }],
          "gradient-from": [{
            from: [ew]
          }],
          "gradient-via": [{
            via: [ew]
          }],
          "gradient-to": [{
            to: [ew]
          }],
          rounded: [{
            rounded: [ed]
          }],
          "rounded-s": [{
            "rounded-s": [ed]
          }],
          "rounded-e": [{
            "rounded-e": [ed]
          }],
          "rounded-t": [{
            "rounded-t": [ed]
          }],
          "rounded-r": [{
            "rounded-r": [ed]
          }],
          "rounded-b": [{
            "rounded-b": [ed]
          }],
          "rounded-l": [{
            "rounded-l": [ed]
          }],
          "rounded-ss": [{
            "rounded-ss": [ed]
          }],
          "rounded-se": [{
            "rounded-se": [ed]
          }],
          "rounded-ee": [{
            "rounded-ee": [ed]
          }],
          "rounded-es": [{
            "rounded-es": [ed]
          }],
          "rounded-tl": [{
            "rounded-tl": [ed]
          }],
          "rounded-tr": [{
            "rounded-tr": [ed]
          }],
          "rounded-br": [{
            "rounded-br": [ed]
          }],
          "rounded-bl": [{
            "rounded-bl": [ed]
          }],
          "border-w": [{
            border: [ep]
          }],
          "border-w-x": [{
            "border-x": [ep]
          }],
          "border-w-y": [{
            "border-y": [ep]
          }],
          "border-w-s": [{
            "border-s": [ep]
          }],
          "border-w-e": [{
            "border-e": [ep]
          }],
          "border-w-t": [{
            "border-t": [ep]
          }],
          "border-w-r": [{
            "border-r": [ep]
          }],
          "border-w-b": [{
            "border-b": [ep]
          }],
          "border-w-l": [{
            "border-l": [ep]
          }],
          "border-opacity": [{
            "border-opacity": [eC]
          }],
          "border-style": [{
            border: [...getLineStyles(), "hidden"]
          }],
          "divide-x": [{
            "divide-x": [ep]
          }],
          "divide-x-reverse": ["divide-x-reverse"],
          "divide-y": [{
            "divide-y": [ep]
          }],
          "divide-y-reverse": ["divide-y-reverse"],
          "divide-opacity": [{
            "divide-opacity": [eC]
          }],
          "divide-style": [{
            divide: getLineStyles()
          }],
          "border-color": [{
            border: [ec]
          }],
          "border-color-x": [{
            "border-x": [ec]
          }],
          "border-color-y": [{
            "border-y": [ec]
          }],
          "border-color-t": [{
            "border-t": [ec]
          }],
          "border-color-r": [{
            "border-r": [ec]
          }],
          "border-color-b": [{
            "border-b": [ec]
          }],
          "border-color-l": [{
            "border-l": [ec]
          }],
          "divide-color": [{
            divide: [ec]
          }],
          "outline-style": [{
            outline: ["", ...getLineStyles()]
          }],
          "outline-offset": [{
            "outline-offset": [isLength, isArbitraryValue]
          }],
          "outline-w": [{
            outline: [isLength, isArbitraryLength]
          }],
          "outline-color": [{
            outline: [J]
          }],
          "ring-w": [{
            ring: getLengthWithEmptyAndArbitrary()
          }],
          "ring-w-inset": ["ring-inset"],
          "ring-color": [{
            ring: [J]
          }],
          "ring-opacity": [{
            "ring-opacity": [eC]
          }],
          "ring-offset-w": [{
            "ring-offset": [isLength, isArbitraryLength]
          }],
          "ring-offset-color": [{
            "ring-offset": [J]
          }],
          shadow: [{
            shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
          }],
          "shadow-color": [{
            shadow: [isAny]
          }],
          opacity: [{
            opacity: [eC]
          }],
          "mix-blend": [{
            "mix-blend": getBlendModes()
          }],
          "bg-blend": [{
            "bg-blend": getBlendModes()
          }],
          filter: [{
            filter: ["", "none"]
          }],
          blur: [{
            blur: [eo]
          }],
          brightness: [{
            brightness: [el]
          }],
          contrast: [{
            contrast: [ef]
          }],
          "drop-shadow": [{
            "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
          }],
          grayscale: [{
            grayscale: [em]
          }],
          "hue-rotate": [{
            "hue-rotate": [eg]
          }],
          invert: [{
            invert: [ey]
          }],
          saturate: [{
            saturate: [ek]
          }],
          sepia: [{
            sepia: [eA]
          }],
          "backdrop-filter": [{
            "backdrop-filter": ["", "none"]
          }],
          "backdrop-blur": [{
            "backdrop-blur": [eo]
          }],
          "backdrop-brightness": [{
            "backdrop-brightness": [el]
          }],
          "backdrop-contrast": [{
            "backdrop-contrast": [ef]
          }],
          "backdrop-grayscale": [{
            "backdrop-grayscale": [em]
          }],
          "backdrop-hue-rotate": [{
            "backdrop-hue-rotate": [eg]
          }],
          "backdrop-invert": [{
            "backdrop-invert": [ey]
          }],
          "backdrop-opacity": [{
            "backdrop-opacity": [eC]
          }],
          "backdrop-saturate": [{
            "backdrop-saturate": [ek]
          }],
          "backdrop-sepia": [{
            "backdrop-sepia": [eA]
          }],
          "border-collapse": [{
            border: ["collapse", "separate"]
          }],
          "border-spacing": [{
            "border-spacing": [eh]
          }],
          "border-spacing-x": [{
            "border-spacing-x": [eh]
          }],
          "border-spacing-y": [{
            "border-spacing-y": [eh]
          }],
          "table-layout": [{
            table: ["auto", "fixed"]
          }],
          caption: [{
            caption: ["top", "bottom"]
          }],
          transition: [{
            transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
          }],
          duration: [{
            duration: getNumberAndArbitrary()
          }],
          ease: [{
            ease: ["linear", "in", "out", "in-out", isArbitraryValue]
          }],
          delay: [{
            delay: getNumberAndArbitrary()
          }],
          animate: [{
            animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
          }],
          transform: [{
            transform: ["", "gpu", "none"]
          }],
          scale: [{
            scale: [eT]
          }],
          "scale-x": [{
            "scale-x": [eT]
          }],
          "scale-y": [{
            "scale-y": [eT]
          }],
          rotate: [{
            rotate: [isInteger, isArbitraryValue]
          }],
          "translate-x": [{
            "translate-x": [eI]
          }],
          "translate-y": [{
            "translate-y": [eI]
          }],
          "skew-x": [{
            "skew-x": [eP]
          }],
          "skew-y": [{
            "skew-y": [eP]
          }],
          "transform-origin": [{
            origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
          }],
          accent: [{
            accent: ["auto", J]
          }],
          appearance: ["appearance-none"],
          cursor: [{
            cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
          }],
          "caret-color": [{
            caret: [J]
          }],
          "pointer-events": [{
            "pointer-events": ["none", "auto"]
          }],
          resize: [{
            resize: ["none", "y", "x", ""]
          }],
          "scroll-behavior": [{
            scroll: ["auto", "smooth"]
          }],
          "scroll-m": [{
            "scroll-m": getSpacingWithArbitrary()
          }],
          "scroll-mx": [{
            "scroll-mx": getSpacingWithArbitrary()
          }],
          "scroll-my": [{
            "scroll-my": getSpacingWithArbitrary()
          }],
          "scroll-ms": [{
            "scroll-ms": getSpacingWithArbitrary()
          }],
          "scroll-me": [{
            "scroll-me": getSpacingWithArbitrary()
          }],
          "scroll-mt": [{
            "scroll-mt": getSpacingWithArbitrary()
          }],
          "scroll-mr": [{
            "scroll-mr": getSpacingWithArbitrary()
          }],
          "scroll-mb": [{
            "scroll-mb": getSpacingWithArbitrary()
          }],
          "scroll-ml": [{
            "scroll-ml": getSpacingWithArbitrary()
          }],
          "scroll-p": [{
            "scroll-p": getSpacingWithArbitrary()
          }],
          "scroll-px": [{
            "scroll-px": getSpacingWithArbitrary()
          }],
          "scroll-py": [{
            "scroll-py": getSpacingWithArbitrary()
          }],
          "scroll-ps": [{
            "scroll-ps": getSpacingWithArbitrary()
          }],
          "scroll-pe": [{
            "scroll-pe": getSpacingWithArbitrary()
          }],
          "scroll-pt": [{
            "scroll-pt": getSpacingWithArbitrary()
          }],
          "scroll-pr": [{
            "scroll-pr": getSpacingWithArbitrary()
          }],
          "scroll-pb": [{
            "scroll-pb": getSpacingWithArbitrary()
          }],
          "scroll-pl": [{
            "scroll-pl": getSpacingWithArbitrary()
          }],
          "snap-align": [{
            snap: ["start", "end", "center", "align-none"]
          }],
          "snap-stop": [{
            snap: ["normal", "always"]
          }],
          "snap-type": [{
            snap: ["none", "x", "y", "both"]
          }],
          "snap-strictness": [{
            snap: ["mandatory", "proximity"]
          }],
          touch: [{
            touch: ["auto", "none", "manipulation"]
          }],
          "touch-x": [{
            "touch-pan": ["x", "left", "right"]
          }],
          "touch-y": [{
            "touch-pan": ["y", "up", "down"]
          }],
          "touch-pz": ["touch-pinch-zoom"],
          select: [{
            select: ["none", "text", "all", "auto"]
          }],
          "will-change": [{
            "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
          }],
          fill: [{
            fill: [J, "none"]
          }],
          "stroke-w": [{
            stroke: [isLength, isArbitraryLength, isArbitraryNumber]
          }],
          stroke: [{
            stroke: [J, "none"]
          }],
          sr: ["sr-only", "not-sr-only"]
        },
        conflictingClassGroups: {
          overflow: ["overflow-x", "overflow-y"],
          overscroll: ["overscroll-x", "overscroll-y"],
          inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
          "inset-x": ["right", "left"],
          "inset-y": ["top", "bottom"],
          flex: ["basis", "grow", "shrink"],
          gap: ["gap-x", "gap-y"],
          p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
          px: ["pr", "pl"],
          py: ["pt", "pb"],
          m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
          mx: ["mr", "ml"],
          my: ["mt", "mb"],
          "font-size": ["leading"],
          "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
          "fvn-ordinal": ["fvn-normal"],
          "fvn-slashed-zero": ["fvn-normal"],
          "fvn-figure": ["fvn-normal"],
          "fvn-spacing": ["fvn-normal"],
          "fvn-fraction": ["fvn-normal"],
          "line-clamp": ["display", "overflow"],
          rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
          "rounded-s": ["rounded-ss", "rounded-es"],
          "rounded-e": ["rounded-se", "rounded-ee"],
          "rounded-t": ["rounded-tl", "rounded-tr"],
          "rounded-r": ["rounded-tr", "rounded-br"],
          "rounded-b": ["rounded-br", "rounded-bl"],
          "rounded-l": ["rounded-tl", "rounded-bl"],
          "border-spacing": ["border-spacing-x", "border-spacing-y"],
          "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
          "border-w-x": ["border-w-r", "border-w-l"],
          "border-w-y": ["border-w-t", "border-w-b"],
          "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"],
          "border-color-x": ["border-color-r", "border-color-l"],
          "border-color-y": ["border-color-t", "border-color-b"],
          "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
          "scroll-mx": ["scroll-mr", "scroll-ml"],
          "scroll-my": ["scroll-mt", "scroll-mb"],
          "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
          "scroll-px": ["scroll-pr", "scroll-pl"],
          "scroll-py": ["scroll-pt", "scroll-pb"],
          touch: ["touch-x", "touch-y", "touch-pz"],
          "touch-x": ["touch"],
          "touch-y": ["touch"],
          "touch-pz": ["touch"]
        },
        conflictingClassGroupModifiers: {
          "font-size": ["leading"]
        }
      }
    });
    function handleWidthCss(J) {
      return +J.slice(0, -2)
    }
    function cn() {
      for (var J = arguments.length, et = Array(J), eo = 0; eo < J; eo++)
        et[eo] = arguments[eo];
      return ex((0,
        el.default)(et))
    }
    function handleListColor(J) {
      let et = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "background";
      return null == J ? void 0 : J.map((J, eo) => {
        if ("background" === et || "text" === et) {
          if ("string" != typeof J) {
            let eo = "background" === et ? null == J ? void 0 : J.backgroundColor : null == J ? void 0 : J.color;
            return eo
          }
          return J
        }
        return "string" == typeof J ? {
          backgroundColor: J,
          color: J
        } : J
      }
      )
    }
  },
  83055: function (J, et, eo) {
    "use strict";
    function formatNumber(J) {
      let et = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 10;
      if (1e-6 > Number(J))
        return "0";
      var eo = Number(J).toString().split(".");
      if (eo[0] = eo[0].replace(/\B(?=(\d{3})+(?!\d))/g, ","),
        eo.join("").length > et) {
        var el, ec, ed = et - eo[0].length;
        ed < 0 && (ed = 0),
          eo[1] = null === (ec = eo[1]) || void 0 === ec ? void 0 : null === (el = ec.substring) || void 0 === el ? void 0 : el.call(ec, 0, ed).replace(/([1-9])0+/g, "$1")
      }
      var eh = /^0+$/.test(eo[1]) ? eo[0] : eo.join(".");
      return eh.endsWith(".") && (eh = eh.slice(0, -1)),
        eh
    }
    function roundSignificantFigures(J) {
      let et = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4
        , eo = J.toString().search(/[^0\.]/);
      return Number(Number(J).toFixed(eo + et - 2))
    }
    function formatBalance() {
      let J = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
        , et = J.toString();
      if (-1 !== et.indexOf("-")) {
        let J = et.split("-")
          , eo = J[0].replace("e", "").split(".");
        return "0.".concat("0".repeat(Number(J[1]) - 1)).concat(eo[0]).concat(eo.length > 1 ? eo[1] : "")
      }
      if (-1 === et.indexOf("+"))
        return et;
      {
        var eo, el;
        let J = et.split("+")
          , ec = J[0].replace("e", "")
          , ed = ec.split(".");
        return "".concat(Number(ec) * 10 ** (null !== (eo = null == ed ? void 0 : ed[1]) && void 0 !== eo ? eo : ed[0]).length).concat("0".repeat(Number(J[1]) - (null !== (el = null == ed ? void 0 : ed[1]) && void 0 !== el ? el : ed[0]).length))
      }
    }
    eo.d(et, {
      az: function () {
        return formatBalance
      },
      oY: function () {
        return roundSignificantFigures
      },
      uf: function () {
        return formatNumber
      }
    })
  },
  31686: function (J, et, eo) {
    "use strict";
    function shortAddress(J) {
      let et = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 7
        , eo = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 4;
      return J && J.length > et && J.length - eo > 0 ? "".concat(J.slice(0, et), "....").concat(J.slice(J.length - eo)) : ""
    }
    function convertCamelCaseToTitleCase(J) {
      var et = J.split(/(?=[A-Z])/).join(" ");
      return et.charAt(0).toUpperCase() + et.slice(1)
    }
    function formatLengthNumber(J) {
      let et = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2
        , eo = J.toString()
        , el = eo.padStart(et, "0");
      return el
    }
    eo.d(et, {
      Mq: function () {
        return convertCamelCaseToTitleCase
      },
      O1: function () {
        return formatLengthNumber
      },
      sC: function () {
        return shortAddress
      }
    })
  },
  55715: function () { },
  99306: function (J) {
    J.exports = {
      winicon: "styles_winicon__gRG3u",
      "winicon-text": "styles_winicon-text__P23Fy",
      "hin-winicon": "styles_hin-winicon__0OrNX",
      "winicon-img": "styles_winicon-img__iiz6V",
      "text-pink-shadow": "styles_text-pink-shadow__FxsS_",
      "text-disabled-shadow": "styles_text-disabled-shadow__iKGRD",
      "font-easvhs": "styles_font-easvhs__coU__",
      "highlight-docs": "styles_highlight-docs__S3Qhm",
      "shadow-frame-inside": "styles_shadow-frame-inside__bIvCH",
      "custom-checkbox": "styles_custom-checkbox__QMGkw",
      "font-w95fa": "styles_font-w95fa__EV9qT",
      "text-input": "styles_text-input__hR9dq",
      "text-input-description": "styles_text-input-description__0Wr3H",
      "text-input-link": "styles_text-input-link__7218G",
      "token-selector": "styles_token-selector__3G_1i",
      "ant-select-selector": "styles_ant-select-selector__BYpkO",
      "number-input": "styles_number-input__zHp23",
      "text-input-distribution": "styles_text-input-distribution__SMj4X",
      "flat-border": "styles_flat-border__Qkikr",
      "sc-cOFTSb": "styles_sc-cOFTSb__FNP7o",
      "sc-iTONeN": "styles_sc-iTONeN__Rc3Ly",
      "glud-range": "styles_glud-range__gKBow",
      col: "styles_col__vA5d4",
      "row-cols": "styles_row-cols__ydBBn",
      "col-1": "styles_col-1__GhKd9",
      "col-2": "styles_col-2__F_8AH",
      "col-3": "styles_col-3__ZNFsF",
      "col-4": "styles_col-4__PetI1",
      "col-5": "styles_col-5__ifuRE",
      "col-6": "styles_col-6__G83__",
      "col-7": "styles_col-7__KpNLJ",
      "col-8": "styles_col-8__O6CuE",
      "col-9": "styles_col-9__1ObHb",
      "col-10": "styles_col-10__0VD1W",
      "col-11": "styles_col-11__I9gg2",
      "col-12": "styles_col-12__3C1b_",
      "row-cols-1": "styles_row-cols-1__Ce5FL",
      "row-cols-2": "styles_row-cols-2__ei8ZV",
      "row-cols-3": "styles_row-cols-3__h37wA",
      "row-cols-4": "styles_row-cols-4__GRrse",
      "row-cols-5": "styles_row-cols-5__Wq4U6",
      "row-cols-6": "styles_row-cols-6__mYugm",
      container: "styles_container__1sErC",
      "!item": "styles___item__HXxYt",
      item: "styles_item__9jGNY",
      "tree-view": "styles_tree-view__9Bx5e",
      bar: "styles_bar__LauY2"
    }
  },
  42305: function (J) {
    J.exports = {
      winicon: "styles_winicon__eq5Nb",
      "winicon-text": "styles_winicon-text__h5tig",
      "hin-winicon": "styles_hin-winicon__T_SN_",
      "winicon-img": "styles_winicon-img__ccsQx",
      "text-pink-shadow": "styles_text-pink-shadow__RHtoo",
      "text-disabled-shadow": "styles_text-disabled-shadow__QXUkZ",
      "font-easvhs": "styles_font-easvhs___SJbw",
      "highlight-docs": "styles_highlight-docs__2hr7_",
      "shadow-frame-inside": "styles_shadow-frame-inside__hirIV",
      "custom-checkbox": "styles_custom-checkbox__2pyxx",
      "font-w95fa": "styles_font-w95fa__0QxLe",
      "text-input": "styles_text-input__CQxeH",
      "text-input-description": "styles_text-input-description__wlgNi",
      "text-input-link": "styles_text-input-link__v4wG6",
      "token-selector": "styles_token-selector__HZi23",
      "ant-select-selector": "styles_ant-select-selector__kdbGL",
      "number-input": "styles_number-input__05DaH",
      "text-input-distribution": "styles_text-input-distribution__VWbCR",
      "flat-border": "styles_flat-border__scUQw",
      "sc-cOFTSb": "styles_sc-cOFTSb__Rds5s",
      "sc-iTONeN": "styles_sc-iTONeN__77R5c",
      "glud-range": "styles_glud-range__eiqv_",
      col: "styles_col__cAlrB",
      "row-cols": "styles_row-cols__BBGKw",
      "col-1": "styles_col-1__cs38J",
      "col-2": "styles_col-2__Acl7q",
      "col-3": "styles_col-3__RWxBO",
      "col-4": "styles_col-4__yzfRf",
      "col-5": "styles_col-5__44zv_",
      "col-6": "styles_col-6__HKQhx",
      "col-7": "styles_col-7__GmrpK",
      "col-8": "styles_col-8__gMglU",
      "col-9": "styles_col-9__fm6cy",
      "col-10": "styles_col-10__dkLxl",
      "col-11": "styles_col-11__YjrKG",
      "col-12": "styles_col-12__lO372",
      "row-cols-1": "styles_row-cols-1__GIEOI",
      "row-cols-2": "styles_row-cols-2__4Ttnf",
      "row-cols-3": "styles_row-cols-3__0JdKB",
      "row-cols-4": "styles_row-cols-4__q1P0I",
      "row-cols-5": "styles_row-cols-5__DaQek",
      "row-cols-6": "styles_row-cols-6__D8nSg",
      container: "styles_container__bDbP6",
      "!item": "styles___item__Kn_qH",
      item: "styles_item__5Rw2I",
      "tree-view": "styles_tree-view__bty0q",
      font: "styles_font__QuU0j"
    }
  },
  77663: function (J) {
    !function () {
      var et = {
        229: function (J) {
          var et, eo, el, ec = J.exports = {};
          function defaultSetTimout() {
            throw Error("setTimeout has not been defined")
          }
          function defaultClearTimeout() {
            throw Error("clearTimeout has not been defined")
          }
          function runTimeout(J) {
            if (et === setTimeout)
              return setTimeout(J, 0);
            if ((et === defaultSetTimout || !et) && setTimeout)
              return et = setTimeout,
                setTimeout(J, 0);
            try {
              return et(J, 0)
            } catch (eo) {
              try {
                return et.call(null, J, 0)
              } catch (eo) {
                return et.call(this, J, 0)
              }
            }
          }
          !function () {
            try {
              et = "function" == typeof setTimeout ? setTimeout : defaultSetTimout
            } catch (J) {
              et = defaultSetTimout
            }
            try {
              eo = "function" == typeof clearTimeout ? clearTimeout : defaultClearTimeout
            } catch (J) {
              eo = defaultClearTimeout
            }
          }();
          var ed = []
            , eh = !1
            , ep = -1;
          function cleanUpNextTick() {
            eh && el && (eh = !1,
              el.length ? ed = el.concat(ed) : ep = -1,
              ed.length && drainQueue())
          }
          function drainQueue() {
            if (!eh) {
              var J = runTimeout(cleanUpNextTick);
              eh = !0;
              for (var et = ed.length; et;) {
                for (el = ed,
                  ed = []; ++ep < et;)
                  el && el[ep].run();
                ep = -1,
                  et = ed.length
              }
              el = null,
                eh = !1,
                function (J) {
                  if (eo === clearTimeout)
                    return clearTimeout(J);
                  if ((eo === defaultClearTimeout || !eo) && clearTimeout)
                    return eo = clearTimeout,
                      clearTimeout(J);
                  try {
                    eo(J)
                  } catch (et) {
                    try {
                      return eo.call(null, J)
                    } catch (et) {
                      return eo.call(this, J)
                    }
                  }
                }(J)
            }
          }
          function Item(J, et) {
            this.fun = J,
              this.array = et
          }
          function noop() { }
          ec.nextTick = function (J) {
            var et = Array(arguments.length - 1);
            if (arguments.length > 1)
              for (var eo = 1; eo < arguments.length; eo++)
                et[eo - 1] = arguments[eo];
            ed.push(new Item(J, et)),
              1 !== ed.length || eh || runTimeout(drainQueue)
          }
            ,
            Item.prototype.run = function () {
              this.fun.apply(null, this.array)
            }
            ,
            ec.title = "browser",
            ec.browser = !0,
            ec.env = {},
            ec.argv = [],
            ec.version = "",
            ec.versions = {},
            ec.on = noop,
            ec.addListener = noop,
            ec.once = noop,
            ec.off = noop,
            ec.removeListener = noop,
            ec.removeAllListeners = noop,
            ec.emit = noop,
            ec.prependListener = noop,
            ec.prependOnceListener = noop,
            ec.listeners = function (J) {
              return []
            }
            ,
            ec.binding = function (J) {
              throw Error("process.binding is not supported")
            }
            ,
            ec.cwd = function () {
              return "/"
            }
            ,
            ec.chdir = function (J) {
              throw Error("process.chdir is not supported")
            }
            ,
            ec.umask = function () {
              return 0
            }
        }
      }
        , eo = {};
      function __nccwpck_require__(J) {
        var el = eo[J];
        if (void 0 !== el)
          return el.exports;
        var ec = eo[J] = {
          exports: {}
        }
          , ed = !0;
        try {
          et[J](ec, ec.exports, __nccwpck_require__),
            ed = !1
        } finally {
          ed && delete eo[J]
        }
        return ec.exports
      }
      __nccwpck_require__.ab = "//";
      var el = __nccwpck_require__(229);
      J.exports = el
    }()
  },
  25675: function (J, et, eo) {
    J.exports = eo(645)
  },
  41664: function (J, et, eo) {
    J.exports = eo(65170)
  },
  11163: function (J, et, eo) {
    J.exports = eo(59974)
  },
  92592: function (J, et, eo) {
    let el = eo(47138)
      , ec = eo(95115)
      , ed = eo(6907)
      , eh = eo(93776);
    function renderCanvas(J, et, eo, ed, eh) {
      let ep = [].slice.call(arguments, 1)
        , ef = ep.length
        , em = "function" == typeof ep[ef - 1];
      if (!em && !el())
        throw Error("Callback required as last argument");
      if (em) {
        if (ef < 2)
          throw Error("Too few arguments provided");
        2 === ef ? (eh = eo,
          eo = et,
          et = ed = void 0) : 3 === ef && (et.getContext && void 0 === eh ? (eh = ed,
            ed = void 0) : (eh = ed,
              ed = eo,
              eo = et,
              et = void 0))
      } else {
        if (ef < 1)
          throw Error("Too few arguments provided");
        return 1 === ef ? (eo = et,
          et = ed = void 0) : 2 !== ef || et.getContext || (ed = eo,
            eo = et,
            et = void 0),
          new Promise(function (el, eh) {
            try {
              let eh = ec.create(eo, ed);
              el(J(eh, et, ed))
            } catch (J) {
              eh(J)
            }
          }
          )
      }
      try {
        let el = ec.create(eo, ed);
        eh(null, J(el, et, ed))
      } catch (J) {
        eh(J)
      }
    }
    et.create = ec.create,
      et.toCanvas = renderCanvas.bind(null, ed.render),
      et.toDataURL = renderCanvas.bind(null, ed.renderToDataURL),
      et.toString = renderCanvas.bind(null, function (J, et, eo) {
        return eh.render(J, eo)
      })
  },
  47138: function (J) {
    J.exports = function () {
      return "function" == typeof Promise && Promise.prototype && Promise.prototype.then
    }
  },
  21845: function (J, et, eo) {
    let el = eo(10242).getSymbolSize;
    et.getRowColCoords = function (J) {
      if (1 === J)
        return [];
      let et = Math.floor(J / 7) + 2
        , eo = el(J)
        , ec = 145 === eo ? 26 : 2 * Math.ceil((eo - 13) / (2 * et - 2))
        , ed = [eo - 7];
      for (let J = 1; J < et - 1; J++)
        ed[J] = ed[J - 1] - ec;
      return ed.push(6),
        ed.reverse()
    }
      ,
      et.getPositions = function (J) {
        let eo = []
          , el = et.getRowColCoords(J)
          , ec = el.length;
        for (let J = 0; J < ec; J++)
          for (let et = 0; et < ec; et++)
            (0 !== J || 0 !== et) && (0 !== J || et !== ec - 1) && (J !== ec - 1 || 0 !== et) && eo.push([el[J], el[et]]);
        return eo
      }
  },
  8260: function (J, et, eo) {
    let el = eo(76910)
      , ec = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", " ", "$", "%", "*", "+", "-", ".", "/", ":"];
    function AlphanumericData(J) {
      this.mode = el.ALPHANUMERIC,
        this.data = J
    }
    AlphanumericData.getBitsLength = function (J) {
      return 11 * Math.floor(J / 2) + 6 * (J % 2)
    }
      ,
      AlphanumericData.prototype.getLength = function () {
        return this.data.length
      }
      ,
      AlphanumericData.prototype.getBitsLength = function () {
        return AlphanumericData.getBitsLength(this.data.length)
      }
      ,
      AlphanumericData.prototype.write = function (J) {
        let et;
        for (et = 0; et + 2 <= this.data.length; et += 2) {
          let eo = 45 * ec.indexOf(this.data[et]);
          eo += ec.indexOf(this.data[et + 1]),
            J.put(eo, 11)
        }
        this.data.length % 2 && J.put(ec.indexOf(this.data[et]), 6)
      }
      ,
      J.exports = AlphanumericData
  },
  97245: function (J) {
    function BitBuffer() {
      this.buffer = [],
        this.length = 0
    }
    BitBuffer.prototype = {
      get: function (J) {
        let et = Math.floor(J / 8);
        return (this.buffer[et] >>> 7 - J % 8 & 1) == 1
      },
      put: function (J, et) {
        for (let eo = 0; eo < et; eo++)
          this.putBit((J >>> et - eo - 1 & 1) == 1)
      },
      getLengthInBits: function () {
        return this.length
      },
      putBit: function (J) {
        let et = Math.floor(this.length / 8);
        this.buffer.length <= et && this.buffer.push(0),
          J && (this.buffer[et] |= 128 >>> this.length % 8),
          this.length++
      }
    },
      J.exports = BitBuffer
  },
  73280: function (J) {
    function BitMatrix(J) {
      if (!J || J < 1)
        throw Error("BitMatrix size must be defined and greater than 0");
      this.size = J,
        this.data = new Uint8Array(J * J),
        this.reservedBit = new Uint8Array(J * J)
    }
    BitMatrix.prototype.set = function (J, et, eo, el) {
      let ec = J * this.size + et;
      this.data[ec] = eo,
        el && (this.reservedBit[ec] = !0)
    }
      ,
      BitMatrix.prototype.get = function (J, et) {
        return this.data[J * this.size + et]
      }
      ,
      BitMatrix.prototype.xor = function (J, et, eo) {
        this.data[J * this.size + et] ^= eo
      }
      ,
      BitMatrix.prototype.isReserved = function (J, et) {
        return this.reservedBit[J * this.size + et]
      }
      ,
      J.exports = BitMatrix
  },
  43424: function (J, et, eo) {
    let el = eo(62378)
      , ec = eo(76910);
    function ByteData(J) {
      this.mode = ec.BYTE,
        "string" == typeof J && (J = el(J)),
        this.data = new Uint8Array(J)
    }
    ByteData.getBitsLength = function (J) {
      return 8 * J
    }
      ,
      ByteData.prototype.getLength = function () {
        return this.data.length
      }
      ,
      ByteData.prototype.getBitsLength = function () {
        return ByteData.getBitsLength(this.data.length)
      }
      ,
      ByteData.prototype.write = function (J) {
        for (let et = 0, eo = this.data.length; et < eo; et++)
          J.put(this.data[et], 8)
      }
      ,
      J.exports = ByteData
  },
  35393: function (J, et, eo) {
    let el = eo(64908)
      , ec = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4, 4, 2, 4, 6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4, 8, 10, 11, 4, 9, 12, 16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16, 6, 11, 16, 19, 6, 13, 18, 21, 7, 14, 21, 25, 8, 16, 20, 25, 8, 17, 23, 25, 9, 17, 23, 34, 9, 18, 25, 30, 10, 20, 27, 32, 12, 21, 29, 35, 12, 23, 34, 37, 12, 25, 34, 40, 13, 26, 35, 42, 14, 28, 38, 45, 15, 29, 40, 48, 16, 31, 43, 51, 17, 33, 45, 54, 18, 35, 48, 57, 19, 37, 51, 60, 19, 38, 53, 63, 20, 40, 56, 66, 21, 43, 59, 70, 22, 45, 62, 74, 24, 47, 65, 77, 25, 49, 68, 81]
      , ed = [7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26, 48, 72, 88, 36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60, 110, 160, 192, 72, 130, 192, 224, 80, 150, 224, 264, 96, 176, 260, 308, 104, 198, 288, 352, 120, 216, 320, 384, 132, 240, 360, 432, 144, 280, 408, 480, 168, 308, 448, 532, 180, 338, 504, 588, 196, 364, 546, 650, 224, 416, 600, 700, 224, 442, 644, 750, 252, 476, 690, 816, 270, 504, 750, 900, 300, 560, 810, 960, 312, 588, 870, 1050, 336, 644, 952, 1110, 360, 700, 1020, 1200, 390, 728, 1050, 1260, 420, 784, 1140, 1350, 450, 812, 1200, 1440, 480, 868, 1290, 1530, 510, 924, 1350, 1620, 540, 980, 1440, 1710, 570, 1036, 1530, 1800, 570, 1064, 1590, 1890, 600, 1120, 1680, 1980, 630, 1204, 1770, 2100, 660, 1260, 1860, 2220, 720, 1316, 1950, 2310, 750, 1372, 2040, 2430];
    et.getBlocksCount = function (J, et) {
      switch (et) {
        case el.L:
          return ec[(J - 1) * 4 + 0];
        case el.M:
          return ec[(J - 1) * 4 + 1];
        case el.Q:
          return ec[(J - 1) * 4 + 2];
        case el.H:
          return ec[(J - 1) * 4 + 3];
        default:
          return
      }
    }
      ,
      et.getTotalCodewordsCount = function (J, et) {
        switch (et) {
          case el.L:
            return ed[(J - 1) * 4 + 0];
          case el.M:
            return ed[(J - 1) * 4 + 1];
          case el.Q:
            return ed[(J - 1) * 4 + 2];
          case el.H:
            return ed[(J - 1) * 4 + 3];
          default:
            return
        }
      }
  },
  64908: function (J, et) {
    et.L = {
      bit: 1
    },
      et.M = {
        bit: 0
      },
      et.Q = {
        bit: 3
      },
      et.H = {
        bit: 2
      },
      et.isValid = function (J) {
        return J && void 0 !== J.bit && J.bit >= 0 && J.bit < 4
      }
      ,
      et.from = function (J, eo) {
        if (et.isValid(J))
          return J;
        try {
          return function (J) {
            if ("string" != typeof J)
              throw Error("Param is not a string");
            let eo = J.toLowerCase();
            switch (eo) {
              case "l":
              case "low":
                return et.L;
              case "m":
              case "medium":
                return et.M;
              case "q":
              case "quartile":
                return et.Q;
              case "h":
              case "high":
                return et.H;
              default:
                throw Error("Unknown EC Level: " + J)
            }
          }(J)
        } catch (J) {
          return eo
        }
      }
  },
  76526: function (J, et, eo) {
    let el = eo(10242).getSymbolSize;
    et.getPositions = function (J) {
      let et = el(J);
      return [[0, 0], [et - 7, 0], [0, et - 7]]
    }
  },
  61642: function (J, et, eo) {
    let el = eo(10242)
      , ec = el.getBCHDigit(1335);
    et.getEncodedBits = function (J, et) {
      let eo = J.bit << 3 | et
        , ed = eo << 10;
      for (; el.getBCHDigit(ed) - ec >= 0;)
        ed ^= 1335 << el.getBCHDigit(ed) - ec;
      return (eo << 10 | ed) ^ 21522
    }
  },
  69729: function (J, et) {
    let eo = new Uint8Array(512)
      , el = new Uint8Array(256);
    !function () {
      let J = 1;
      for (let et = 0; et < 255; et++)
        eo[et] = J,
          el[J] = et,
          256 & (J <<= 1) && (J ^= 285);
      for (let J = 255; J < 512; J++)
        eo[J] = eo[J - 255]
    }(),
      et.log = function (J) {
        if (J < 1)
          throw Error("log(" + J + ")");
        return el[J]
      }
      ,
      et.exp = function (J) {
        return eo[J]
      }
      ,
      et.mul = function (J, et) {
        return 0 === J || 0 === et ? 0 : eo[el[J] + el[et]]
      }
  },
  35442: function (J, et, eo) {
    let el = eo(76910)
      , ec = eo(10242);
    function KanjiData(J) {
      this.mode = el.KANJI,
        this.data = J
    }
    KanjiData.getBitsLength = function (J) {
      return 13 * J
    }
      ,
      KanjiData.prototype.getLength = function () {
        return this.data.length
      }
      ,
      KanjiData.prototype.getBitsLength = function () {
        return KanjiData.getBitsLength(this.data.length)
      }
      ,
      KanjiData.prototype.write = function (J) {
        let et;
        for (et = 0; et < this.data.length; et++) {
          let eo = ec.toSJIS(this.data[et]);
          if (eo >= 33088 && eo <= 40956)
            eo -= 33088;
          else if (eo >= 57408 && eo <= 60351)
            eo -= 49472;
          else
            throw Error("Invalid SJIS character: " + this.data[et] + "\nMake sure your charset is UTF-8");
          eo = (eo >>> 8 & 255) * 192 + (255 & eo),
            J.put(eo, 13)
        }
      }
      ,
      J.exports = KanjiData
  },
  27126: function (J, et) {
    et.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    };
    let eo = {
      N1: 3,
      N2: 3,
      N3: 40,
      N4: 10
    };
    et.isValid = function (J) {
      return null != J && "" !== J && !isNaN(J) && J >= 0 && J <= 7
    }
      ,
      et.from = function (J) {
        return et.isValid(J) ? parseInt(J, 10) : void 0
      }
      ,
      et.getPenaltyN1 = function (J) {
        let et = J.size
          , el = 0
          , ec = 0
          , ed = 0
          , eh = null
          , ep = null;
        for (let ef = 0; ef < et; ef++) {
          ec = ed = 0,
            eh = ep = null;
          for (let em = 0; em < et; em++) {
            let et = J.get(ef, em);
            et === eh ? ec++ : (ec >= 5 && (el += eo.N1 + (ec - 5)),
              eh = et,
              ec = 1),
              (et = J.get(em, ef)) === ep ? ed++ : (ed >= 5 && (el += eo.N1 + (ed - 5)),
                ep = et,
                ed = 1)
          }
          ec >= 5 && (el += eo.N1 + (ec - 5)),
            ed >= 5 && (el += eo.N1 + (ed - 5))
        }
        return el
      }
      ,
      et.getPenaltyN2 = function (J) {
        let et = J.size
          , el = 0;
        for (let eo = 0; eo < et - 1; eo++)
          for (let ec = 0; ec < et - 1; ec++) {
            let et = J.get(eo, ec) + J.get(eo, ec + 1) + J.get(eo + 1, ec) + J.get(eo + 1, ec + 1);
            (4 === et || 0 === et) && el++
          }
        return el * eo.N2
      }
      ,
      et.getPenaltyN3 = function (J) {
        let et = J.size
          , el = 0
          , ec = 0
          , ed = 0;
        for (let eo = 0; eo < et; eo++) {
          ec = ed = 0;
          for (let eh = 0; eh < et; eh++)
            ec = ec << 1 & 2047 | J.get(eo, eh),
              eh >= 10 && (1488 === ec || 93 === ec) && el++,
              ed = ed << 1 & 2047 | J.get(eh, eo),
              eh >= 10 && (1488 === ed || 93 === ed) && el++
        }
        return el * eo.N3
      }
      ,
      et.getPenaltyN4 = function (J) {
        let et = 0
          , el = J.data.length;
        for (let eo = 0; eo < el; eo++)
          et += J.data[eo];
        let ec = Math.abs(Math.ceil(100 * et / el / 5) - 10);
        return ec * eo.N4
      }
      ,
      et.applyMask = function (J, eo) {
        let el = eo.size;
        for (let ec = 0; ec < el; ec++)
          for (let ed = 0; ed < el; ed++)
            eo.isReserved(ed, ec) || eo.xor(ed, ec, function (J, eo, el) {
              switch (J) {
                case et.Patterns.PATTERN000:
                  return (eo + el) % 2 == 0;
                case et.Patterns.PATTERN001:
                  return eo % 2 == 0;
                case et.Patterns.PATTERN010:
                  return el % 3 == 0;
                case et.Patterns.PATTERN011:
                  return (eo + el) % 3 == 0;
                case et.Patterns.PATTERN100:
                  return (Math.floor(eo / 2) + Math.floor(el / 3)) % 2 == 0;
                case et.Patterns.PATTERN101:
                  return eo * el % 2 + eo * el % 3 == 0;
                case et.Patterns.PATTERN110:
                  return (eo * el % 2 + eo * el % 3) % 2 == 0;
                case et.Patterns.PATTERN111:
                  return (eo * el % 3 + (eo + el) % 2) % 2 == 0;
                default:
                  throw Error("bad maskPattern:" + J)
              }
            }(J, ed, ec))
      }
      ,
      et.getBestMask = function (J, eo) {
        let el = Object.keys(et.Patterns).length
          , ec = 0
          , ed = 1 / 0;
        for (let eh = 0; eh < el; eh++) {
          eo(eh),
            et.applyMask(eh, J);
          let el = et.getPenaltyN1(J) + et.getPenaltyN2(J) + et.getPenaltyN3(J) + et.getPenaltyN4(J);
          et.applyMask(eh, J),
            el < ed && (ed = el,
              ec = eh)
        }
        return ec
      }
  },
  76910: function (J, et, eo) {
    let el = eo(43114)
      , ec = eo(7007);
    et.NUMERIC = {
      id: "Numeric",
      bit: 1,
      ccBits: [10, 12, 14]
    },
      et.ALPHANUMERIC = {
        id: "Alphanumeric",
        bit: 2,
        ccBits: [9, 11, 13]
      },
      et.BYTE = {
        id: "Byte",
        bit: 4,
        ccBits: [8, 16, 16]
      },
      et.KANJI = {
        id: "Kanji",
        bit: 8,
        ccBits: [8, 10, 12]
      },
      et.MIXED = {
        bit: -1
      },
      et.getCharCountIndicator = function (J, et) {
        if (!J.ccBits)
          throw Error("Invalid mode: " + J);
        if (!el.isValid(et))
          throw Error("Invalid version: " + et);
        return et >= 1 && et < 10 ? J.ccBits[0] : et < 27 ? J.ccBits[1] : J.ccBits[2]
      }
      ,
      et.getBestModeForData = function (J) {
        return ec.testNumeric(J) ? et.NUMERIC : ec.testAlphanumeric(J) ? et.ALPHANUMERIC : ec.testKanji(J) ? et.KANJI : et.BYTE
      }
      ,
      et.toString = function (J) {
        if (J && J.id)
          return J.id;
        throw Error("Invalid mode")
      }
      ,
      et.isValid = function (J) {
        return J && J.bit && J.ccBits
      }
      ,
      et.from = function (J, eo) {
        if (et.isValid(J))
          return J;
        try {
          return function (J) {
            if ("string" != typeof J)
              throw Error("Param is not a string");
            let eo = J.toLowerCase();
            switch (eo) {
              case "numeric":
                return et.NUMERIC;
              case "alphanumeric":
                return et.ALPHANUMERIC;
              case "kanji":
                return et.KANJI;
              case "byte":
                return et.BYTE;
              default:
                throw Error("Unknown mode: " + J)
            }
          }(J)
        } catch (J) {
          return eo
        }
      }
  },
  41085: function (J, et, eo) {
    let el = eo(76910);
    function NumericData(J) {
      this.mode = el.NUMERIC,
        this.data = J.toString()
    }
    NumericData.getBitsLength = function (J) {
      return 10 * Math.floor(J / 3) + (J % 3 ? J % 3 * 3 + 1 : 0)
    }
      ,
      NumericData.prototype.getLength = function () {
        return this.data.length
      }
      ,
      NumericData.prototype.getBitsLength = function () {
        return NumericData.getBitsLength(this.data.length)
      }
      ,
      NumericData.prototype.write = function (J) {
        let et, eo;
        for (et = 0; et + 3 <= this.data.length; et += 3)
          eo = parseInt(this.data.substr(et, 3), 10),
            J.put(eo, 10);
        let el = this.data.length - et;
        el > 0 && (eo = parseInt(this.data.substr(et), 10),
          J.put(eo, 3 * el + 1))
      }
      ,
      J.exports = NumericData
  },
  26143: function (J, et, eo) {
    let el = eo(69729);
    et.mul = function (J, et) {
      let eo = new Uint8Array(J.length + et.length - 1);
      for (let ec = 0; ec < J.length; ec++)
        for (let ed = 0; ed < et.length; ed++)
          eo[ec + ed] ^= el.mul(J[ec], et[ed]);
      return eo
    }
      ,
      et.mod = function (J, et) {
        let eo = new Uint8Array(J);
        for (; eo.length - et.length >= 0;) {
          let J = eo[0];
          for (let ec = 0; ec < et.length; ec++)
            eo[ec] ^= el.mul(et[ec], J);
          let ec = 0;
          for (; ec < eo.length && 0 === eo[ec];)
            ec++;
          eo = eo.slice(ec)
        }
        return eo
      }
      ,
      et.generateECPolynomial = function (J) {
        let eo = new Uint8Array([1]);
        for (let ec = 0; ec < J; ec++)
          eo = et.mul(eo, new Uint8Array([1, el.exp(ec)]));
        return eo
      }
  },
  95115: function (J, et, eo) {
    let el = eo(10242)
      , ec = eo(64908)
      , ed = eo(97245)
      , eh = eo(73280)
      , ep = eo(21845)
      , ef = eo(76526)
      , em = eo(27126)
      , eg = eo(35393)
      , ey = eo(52882)
      , eb = eo(23103)
      , ew = eo(61642)
      , e_ = eo(76910)
      , ex = eo(16130);
    function setupFormatInfo(J, et, eo) {
      let el, ec;
      let ed = J.size
        , eh = ew.getEncodedBits(et, eo);
      for (el = 0; el < 15; el++)
        ec = (eh >> el & 1) == 1,
          el < 6 ? J.set(el, 8, ec, !0) : el < 8 ? J.set(el + 1, 8, ec, !0) : J.set(ed - 15 + el, 8, ec, !0),
          el < 8 ? J.set(8, ed - el - 1, ec, !0) : el < 9 ? J.set(8, 15 - el - 1 + 1, ec, !0) : J.set(8, 15 - el - 1, ec, !0);
      J.set(ed - 8, 8, 1, !0)
    }
    et.create = function (J, et) {
      let eo, ew;
      if (void 0 === J || "" === J)
        throw Error("No input text");
      let eE = ec.M;
      return void 0 !== et && (eE = ec.from(et.errorCorrectionLevel, ec.M),
        eo = eb.from(et.version),
        ew = em.from(et.maskPattern),
        et.toSJISFunc && el.setToSJISFunction(et.toSJISFunc)),
        function (J, et, eo, ec) {
          let ew;
          if (Array.isArray(J))
            ew = ex.fromArray(J);
          else if ("string" == typeof J) {
            let el = et;
            if (!el) {
              let et = ex.rawSplit(J);
              el = eb.getBestVersionForData(et, eo)
            }
            ew = ex.fromString(J, el || 40)
          } else
            throw Error("Invalid data");
          let eE = eb.getBestVersionForData(ew, eo);
          if (!eE)
            throw Error("The amount of data is too big to be stored in a QR Code");
          if (et) {
            if (et < eE)
              throw Error("\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + eE + ".\n")
          } else
            et = eE;
          let eC = function (J, et, eo) {
            let ec = new ed;
            eo.forEach(function (et) {
              ec.put(et.mode.bit, 4),
                ec.put(et.getLength(), e_.getCharCountIndicator(et.mode, J)),
                et.write(ec)
            });
            let eh = el.getSymbolTotalCodewords(J)
              , ep = eg.getTotalCodewordsCount(J, et)
              , ef = (eh - ep) * 8;
            for (ec.getLengthInBits() + 4 <= ef && ec.put(0, 4); ec.getLengthInBits() % 8 != 0;)
              ec.putBit(0);
            let em = (ef - ec.getLengthInBits()) / 8;
            for (let J = 0; J < em; J++)
              ec.put(J % 2 ? 17 : 236, 8);
            return function (J, et, eo) {
              let ec, ed;
              let eh = el.getSymbolTotalCodewords(et)
                , ep = eg.getTotalCodewordsCount(et, eo)
                , ef = eh - ep
                , em = eg.getBlocksCount(et, eo)
                , eb = eh % em
                , ew = em - eb
                , e_ = Math.floor(eh / em)
                , ex = Math.floor(ef / em)
                , eE = ex + 1
                , eC = e_ - ex
                , eS = new ey(eC)
                , ek = 0
                , eT = Array(em)
                , eA = Array(em)
                , eP = 0
                , eR = new Uint8Array(J.buffer);
              for (let J = 0; J < em; J++) {
                let et = J < ew ? ex : eE;
                eT[J] = eR.slice(ek, ek + et),
                  eA[J] = eS.encode(eT[J]),
                  ek += et,
                  eP = Math.max(eP, et)
              }
              let eI = new Uint8Array(eh)
                , eO = 0;
              for (ec = 0; ec < eP; ec++)
                for (ed = 0; ed < em; ed++)
                  ec < eT[ed].length && (eI[eO++] = eT[ed][ec]);
              for (ec = 0; ec < eC; ec++)
                for (ed = 0; ed < em; ed++)
                  eI[eO++] = eA[ed][ec];
              return eI
            }(ec, J, et)
          }(et, eo, ew)
            , eS = el.getSymbolSize(et)
            , ek = new eh(eS);
          return function (J, et) {
            let eo = J.size
              , el = ef.getPositions(et);
            for (let et = 0; et < el.length; et++) {
              let ec = el[et][0]
                , ed = el[et][1];
              for (let et = -1; et <= 7; et++)
                if (!(ec + et <= -1) && !(eo <= ec + et))
                  for (let el = -1; el <= 7; el++)
                    ed + el <= -1 || eo <= ed + el || (et >= 0 && et <= 6 && (0 === el || 6 === el) || el >= 0 && el <= 6 && (0 === et || 6 === et) || et >= 2 && et <= 4 && el >= 2 && el <= 4 ? J.set(ec + et, ed + el, !0, !0) : J.set(ec + et, ed + el, !1, !0))
            }
          }(ek, et),
            function (J) {
              let et = J.size;
              for (let eo = 8; eo < et - 8; eo++) {
                let et = eo % 2 == 0;
                J.set(eo, 6, et, !0),
                  J.set(6, eo, et, !0)
              }
            }(ek),
            function (J, et) {
              let eo = ep.getPositions(et);
              for (let et = 0; et < eo.length; et++) {
                let el = eo[et][0]
                  , ec = eo[et][1];
                for (let et = -2; et <= 2; et++)
                  for (let eo = -2; eo <= 2; eo++)
                    -2 === et || 2 === et || -2 === eo || 2 === eo || 0 === et && 0 === eo ? J.set(el + et, ec + eo, !0, !0) : J.set(el + et, ec + eo, !1, !0)
              }
            }(ek, et),
            setupFormatInfo(ek, eo, 0),
            et >= 7 && function (J, et) {
              let eo, el, ec;
              let ed = J.size
                , eh = eb.getEncodedBits(et);
              for (let et = 0; et < 18; et++)
                eo = Math.floor(et / 3),
                  el = et % 3 + ed - 8 - 3,
                  ec = (eh >> et & 1) == 1,
                  J.set(eo, el, ec, !0),
                  J.set(el, eo, ec, !0)
            }(ek, et),
            function (J, et) {
              let eo = J.size
                , el = -1
                , ec = eo - 1
                , ed = 7
                , eh = 0;
              for (let ep = eo - 1; ep > 0; ep -= 2)
                for (6 === ep && ep--; ;) {
                  for (let eo = 0; eo < 2; eo++)
                    if (!J.isReserved(ec, ep - eo)) {
                      let el = !1;
                      eh < et.length && (el = (et[eh] >>> ed & 1) == 1),
                        J.set(ec, ep - eo, el),
                        -1 == --ed && (eh++,
                          ed = 7)
                    }
                  if ((ec += el) < 0 || eo <= ec) {
                    ec -= el,
                      el = -el;
                    break
                  }
                }
            }(ek, eC),
            isNaN(ec) && (ec = em.getBestMask(ek, setupFormatInfo.bind(null, ek, eo))),
            em.applyMask(ec, ek),
            setupFormatInfo(ek, eo, ec),
          {
            modules: ek,
            version: et,
            errorCorrectionLevel: eo,
            maskPattern: ec,
            segments: ew
          }
        }(J, eo, eE, ew)
    }
  },
  52882: function (J, et, eo) {
    let el = eo(26143);
    function ReedSolomonEncoder(J) {
      this.genPoly = void 0,
        this.degree = J,
        this.degree && this.initialize(this.degree)
    }
    ReedSolomonEncoder.prototype.initialize = function (J) {
      this.degree = J,
        this.genPoly = el.generateECPolynomial(this.degree)
    }
      ,
      ReedSolomonEncoder.prototype.encode = function (J) {
        if (!this.genPoly)
          throw Error("Encoder not initialized");
        let et = new Uint8Array(J.length + this.degree);
        et.set(J);
        let eo = el.mod(et, this.genPoly)
          , ec = this.degree - eo.length;
        if (ec > 0) {
          let J = new Uint8Array(this.degree);
          return J.set(eo, ec),
            J
        }
        return eo
      }
      ,
      J.exports = ReedSolomonEncoder
  },
  7007: function (J, et) {
    let eo = "[0-9]+"
      , el = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
    el = el.replace(/u/g, "\\u");
    let ec = "(?:(?![A-Z0-9 $%*+\\-./:]|" + el + ")(?:.|[\r\n]))+";
    et.KANJI = RegExp(el, "g"),
      et.BYTE_KANJI = RegExp("[^A-Z0-9 $%*+\\-./:]+", "g"),
      et.BYTE = RegExp(ec, "g"),
      et.NUMERIC = RegExp(eo, "g"),
      et.ALPHANUMERIC = RegExp("[A-Z $%*+\\-./:]+", "g");
    let ed = RegExp("^" + el + "$")
      , eh = RegExp("^" + eo + "$")
      , ep = RegExp("^[A-Z0-9 $%*+\\-./:]+$");
    et.testKanji = function (J) {
      return ed.test(J)
    }
      ,
      et.testNumeric = function (J) {
        return eh.test(J)
      }
      ,
      et.testAlphanumeric = function (J) {
        return ep.test(J)
      }
  },
  16130: function (J, et, eo) {
    let el = eo(76910)
      , ec = eo(41085)
      , ed = eo(8260)
      , eh = eo(43424)
      , ep = eo(35442)
      , ef = eo(7007)
      , em = eo(10242)
      , eg = eo(65987);
    function getStringByteLength(J) {
      return unescape(encodeURIComponent(J)).length
    }
    function getSegments(J, et, eo) {
      let el;
      let ec = [];
      for (; null !== (el = J.exec(eo));)
        ec.push({
          data: el[0],
          index: el.index,
          mode: et,
          length: el[0].length
        });
      return ec
    }
    function getSegmentsFromString(J) {
      let et, eo;
      let ec = getSegments(ef.NUMERIC, el.NUMERIC, J)
        , ed = getSegments(ef.ALPHANUMERIC, el.ALPHANUMERIC, J);
      em.isKanjiModeEnabled() ? (et = getSegments(ef.BYTE, el.BYTE, J),
        eo = getSegments(ef.KANJI, el.KANJI, J)) : (et = getSegments(ef.BYTE_KANJI, el.BYTE, J),
          eo = []);
      let eh = ec.concat(ed, et, eo);
      return eh.sort(function (J, et) {
        return J.index - et.index
      }).map(function (J) {
        return {
          data: J.data,
          mode: J.mode,
          length: J.length
        }
      })
    }
    function getSegmentBitsLength(J, et) {
      switch (et) {
        case el.NUMERIC:
          return ec.getBitsLength(J);
        case el.ALPHANUMERIC:
          return ed.getBitsLength(J);
        case el.KANJI:
          return ep.getBitsLength(J);
        case el.BYTE:
          return eh.getBitsLength(J)
      }
    }
    function buildSingleSegment(J, et) {
      let eo;
      let ef = el.getBestModeForData(J);
      if ((eo = el.from(et, ef)) !== el.BYTE && eo.bit < ef.bit)
        throw Error('"' + J + '" cannot be encoded with mode ' + el.toString(eo) + ".\n Suggested mode is: " + el.toString(ef));
      switch (eo !== el.KANJI || em.isKanjiModeEnabled() || (eo = el.BYTE),
      eo) {
        case el.NUMERIC:
          return new ec(J);
        case el.ALPHANUMERIC:
          return new ed(J);
        case el.KANJI:
          return new ep(J);
        case el.BYTE:
          return new eh(J)
      }
    }
    et.fromArray = function (J) {
      return J.reduce(function (J, et) {
        return "string" == typeof et ? J.push(buildSingleSegment(et, null)) : et.data && J.push(buildSingleSegment(et.data, et.mode)),
          J
      }, [])
    }
      ,
      et.fromString = function (J, eo) {
        let ec = getSegmentsFromString(J, em.isKanjiModeEnabled())
          , ed = function (J) {
            let et = [];
            for (let eo = 0; eo < J.length; eo++) {
              let ec = J[eo];
              switch (ec.mode) {
                case el.NUMERIC:
                  et.push([ec, {
                    data: ec.data,
                    mode: el.ALPHANUMERIC,
                    length: ec.length
                  }, {
                      data: ec.data,
                      mode: el.BYTE,
                      length: ec.length
                    }]);
                  break;
                case el.ALPHANUMERIC:
                  et.push([ec, {
                    data: ec.data,
                    mode: el.BYTE,
                    length: ec.length
                  }]);
                  break;
                case el.KANJI:
                  et.push([ec, {
                    data: ec.data,
                    mode: el.BYTE,
                    length: getStringByteLength(ec.data)
                  }]);
                  break;
                case el.BYTE:
                  et.push([{
                    data: ec.data,
                    mode: el.BYTE,
                    length: getStringByteLength(ec.data)
                  }])
              }
            }
            return et
          }(ec)
          , eh = function (J, et) {
            let eo = {}
              , ec = {
                start: {}
              }
              , ed = ["start"];
            for (let eh = 0; eh < J.length; eh++) {
              let ep = J[eh]
                , ef = [];
              for (let J = 0; J < ep.length; J++) {
                let em = ep[J]
                  , eg = "" + eh + J;
                ef.push(eg),
                  eo[eg] = {
                    node: em,
                    lastCount: 0
                  },
                  ec[eg] = {};
                for (let J = 0; J < ed.length; J++) {
                  let eh = ed[J];
                  eo[eh] && eo[eh].node.mode === em.mode ? (ec[eh][eg] = getSegmentBitsLength(eo[eh].lastCount + em.length, em.mode) - getSegmentBitsLength(eo[eh].lastCount, em.mode),
                    eo[eh].lastCount += em.length) : (eo[eh] && (eo[eh].lastCount = em.length),
                      ec[eh][eg] = getSegmentBitsLength(em.length, em.mode) + 4 + el.getCharCountIndicator(em.mode, et))
                }
              }
              ed = ef
            }
            for (let J = 0; J < ed.length; J++)
              ec[ed[J]].end = 0;
            return {
              map: ec,
              table: eo
            }
          }(ed, eo)
          , ep = eg.find_path(eh.map, "start", "end")
          , ef = [];
        for (let J = 1; J < ep.length - 1; J++)
          ef.push(eh.table[ep[J]].node);
        return et.fromArray(ef.reduce(function (J, et) {
          let eo = J.length - 1 >= 0 ? J[J.length - 1] : null;
          return eo && eo.mode === et.mode ? J[J.length - 1].data += et.data : J.push(et),
            J
        }, []))
      }
      ,
      et.rawSplit = function (J) {
        return et.fromArray(getSegmentsFromString(J, em.isKanjiModeEnabled()))
      }
  },
  10242: function (J, et) {
    let eo;
    let el = [0, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706];
    et.getSymbolSize = function (J) {
      if (!J)
        throw Error('"version" cannot be null or undefined');
      if (J < 1 || J > 40)
        throw Error('"version" should be in range from 1 to 40');
      return 4 * J + 17
    }
      ,
      et.getSymbolTotalCodewords = function (J) {
        return el[J]
      }
      ,
      et.getBCHDigit = function (J) {
        let et = 0;
        for (; 0 !== J;)
          et++,
            J >>>= 1;
        return et
      }
      ,
      et.setToSJISFunction = function (J) {
        if ("function" != typeof J)
          throw Error('"toSJISFunc" is not a valid function.');
        eo = J
      }
      ,
      et.isKanjiModeEnabled = function () {
        return void 0 !== eo
      }
      ,
      et.toSJIS = function (J) {
        return eo(J)
      }
  },
  43114: function (J, et) {
    et.isValid = function (J) {
      return !isNaN(J) && J >= 1 && J <= 40
    }
  },
  23103: function (J, et, eo) {
    let el = eo(10242)
      , ec = eo(35393)
      , ed = eo(64908)
      , eh = eo(76910)
      , ep = eo(43114)
      , ef = el.getBCHDigit(7973);
    function getReservedBitsCount(J, et) {
      return eh.getCharCountIndicator(J, et) + 4
    }
    et.from = function (J, et) {
      return ep.isValid(J) ? parseInt(J, 10) : et
    }
      ,
      et.getCapacity = function (J, et, eo) {
        if (!ep.isValid(J))
          throw Error("Invalid QR Code version");
        void 0 === eo && (eo = eh.BYTE);
        let ed = el.getSymbolTotalCodewords(J)
          , ef = ec.getTotalCodewordsCount(J, et)
          , em = (ed - ef) * 8;
        if (eo === eh.MIXED)
          return em;
        let eg = em - getReservedBitsCount(eo, J);
        switch (eo) {
          case eh.NUMERIC:
            return Math.floor(eg / 10 * 3);
          case eh.ALPHANUMERIC:
            return Math.floor(eg / 11 * 2);
          case eh.KANJI:
            return Math.floor(eg / 13);
          case eh.BYTE:
          default:
            return Math.floor(eg / 8)
        }
      }
      ,
      et.getBestVersionForData = function (J, eo) {
        let el;
        let ec = ed.from(eo, ed.M);
        if (Array.isArray(J)) {
          if (J.length > 1)
            return function (J, eo) {
              for (let el = 1; el <= 40; el++) {
                let ec = function (J, et) {
                  let eo = 0;
                  return J.forEach(function (J) {
                    let el = getReservedBitsCount(J.mode, et);
                    eo += el + J.getBitsLength()
                  }),
                    eo
                }(J, el);
                if (ec <= et.getCapacity(el, eo, eh.MIXED))
                  return el
              }
            }(J, ec);
          if (0 === J.length)
            return 1;
          el = J[0]
        } else
          el = J;
        return function (J, eo, el) {
          for (let ec = 1; ec <= 40; ec++)
            if (eo <= et.getCapacity(ec, el, J))
              return ec
        }(el.mode, el.getLength(), ec)
      }
      ,
      et.getEncodedBits = function (J) {
        if (!ep.isValid(J) || J < 7)
          throw Error("Invalid QR Code version");
        let et = J << 12;
        for (; el.getBCHDigit(et) - ef >= 0;)
          et ^= 7973 << el.getBCHDigit(et) - ef;
        return J << 12 | et
      }
  },
  6907: function (J, et, eo) {
    let el = eo(89653);
    et.render = function (J, et, eo) {
      var ec;
      let ed = eo
        , eh = et;
      void 0 !== ed || et && et.getContext || (ed = et,
        et = void 0),
        et || (eh = function () {
          try {
            return document.createElement("canvas")
          } catch (J) {
            throw Error("You need to specify a canvas element")
          }
        }()),
        ed = el.getOptions(ed);
      let ep = el.getImageWidth(J.modules.size, ed)
        , ef = eh.getContext("2d")
        , em = ef.createImageData(ep, ep);
      return el.qrToImageData(em.data, J, ed),
        ec = eh,
        ef.clearRect(0, 0, ec.width, ec.height),
        ec.style || (ec.style = {}),
        ec.height = ep,
        ec.width = ep,
        ec.style.height = ep + "px",
        ec.style.width = ep + "px",
        ef.putImageData(em, 0, 0),
        eh
    }
      ,
      et.renderToDataURL = function (J, eo, el) {
        let ec = el;
        void 0 !== ec || eo && eo.getContext || (ec = eo,
          eo = void 0),
          ec || (ec = {});
        let ed = et.render(J, eo, ec)
          , eh = ec.type || "image/png"
          , ep = ec.rendererOpts || {};
        return ed.toDataURL(eh, ep.quality)
      }
  },
  93776: function (J, et, eo) {
    let el = eo(89653);
    function getColorAttrib(J, et) {
      let eo = J.a / 255
        , el = et + '="' + J.hex + '"';
      return eo < 1 ? el + " " + et + '-opacity="' + eo.toFixed(2).slice(1) + '"' : el
    }
    function svgCmd(J, et, eo) {
      let el = J + et;
      return void 0 !== eo && (el += " " + eo),
        el
    }
    et.render = function (J, et, eo) {
      let ec = el.getOptions(et)
        , ed = J.modules.size
        , eh = J.modules.data
        , ep = ed + 2 * ec.margin
        , ef = ec.color.light.a ? "<path " + getColorAttrib(ec.color.light, "fill") + ' d="M0 0h' + ep + "v" + ep + 'H0z"/>' : ""
        , em = "<path " + getColorAttrib(ec.color.dark, "stroke") + ' d="' + function (J, et, eo) {
          let el = ""
            , ec = 0
            , ed = !1
            , eh = 0;
          for (let ep = 0; ep < J.length; ep++) {
            let ef = Math.floor(ep % et)
              , em = Math.floor(ep / et);
            ef || ed || (ed = !0),
              J[ep] ? (eh++,
                ep > 0 && ef > 0 && J[ep - 1] || (el += ed ? svgCmd("M", ef + eo, .5 + em + eo) : svgCmd("m", ec, 0),
                  ec = 0,
                  ed = !1),
                ef + 1 < et && J[ep + 1] || (el += svgCmd("h", eh),
                  eh = 0)) : ec++
          }
          return el
        }(eh, ed, ec.margin) + '"/>'
        , eg = ec.width ? 'width="' + ec.width + '" height="' + ec.width + '" ' : ""
        , ey = '<svg xmlns="http://www.w3.org/2000/svg" ' + eg + ('viewBox="0 0 ' + ep) + " " + ep + '" shape-rendering="crispEdges">' + ef + em + "</svg>\n";
      return "function" == typeof eo && eo(null, ey),
        ey
    }
  },
  89653: function (J, et) {
    function hex2rgba(J) {
      if ("number" == typeof J && (J = J.toString()),
        "string" != typeof J)
        throw Error("Color should be defined as hex string");
      let et = J.slice().replace("#", "").split("");
      if (et.length < 3 || 5 === et.length || et.length > 8)
        throw Error("Invalid hex color: " + J);
      (3 === et.length || 4 === et.length) && (et = Array.prototype.concat.apply([], et.map(function (J) {
        return [J, J]
      }))),
        6 === et.length && et.push("F", "F");
      let eo = parseInt(et.join(""), 16);
      return {
        r: eo >> 24 & 255,
        g: eo >> 16 & 255,
        b: eo >> 8 & 255,
        a: 255 & eo,
        hex: "#" + et.slice(0, 6).join("")
      }
    }
    et.getOptions = function (J) {
      J || (J = {}),
        J.color || (J.color = {});
      let et = void 0 === J.margin || null === J.margin || J.margin < 0 ? 4 : J.margin
        , eo = J.width && J.width >= 21 ? J.width : void 0
        , el = J.scale || 4;
      return {
        width: eo,
        scale: eo ? 4 : el,
        margin: et,
        color: {
          dark: hex2rgba(J.color.dark || "#000000ff"),
          light: hex2rgba(J.color.light || "#ffffffff")
        },
        type: J.type,
        rendererOpts: J.rendererOpts || {}
      }
    }
      ,
      et.getScale = function (J, et) {
        return et.width && et.width >= J + 2 * et.margin ? et.width / (J + 2 * et.margin) : et.scale
      }
      ,
      et.getImageWidth = function (J, eo) {
        let el = et.getScale(J, eo);
        return Math.floor((J + 2 * eo.margin) * el)
      }
      ,
      et.qrToImageData = function (J, eo, el) {
        let ec = eo.modules.size
          , ed = eo.modules.data
          , eh = et.getScale(ec, el)
          , ep = Math.floor((ec + 2 * el.margin) * eh)
          , ef = el.margin * eh
          , em = [el.color.light, el.color.dark];
        for (let et = 0; et < ep; et++)
          for (let eo = 0; eo < ep; eo++) {
            let eg = (et * ep + eo) * 4
              , ey = el.color.light;
            if (et >= ef && eo >= ef && et < ep - ef && eo < ep - ef) {
              let J = Math.floor((et - ef) / eh)
                , el = Math.floor((eo - ef) / eh);
              ey = em[ed[J * ec + el] ? 1 : 0]
            }
            J[eg++] = ey.r,
              J[eg++] = ey.g,
              J[eg++] = ey.b,
              J[eg] = ey.a
          }
      }
  },
  17563: function (J, et, eo) {
    "use strict";
    let el = eo(70610)
      , ec = eo(44020)
      , ed = eo(80500)
      , eh = eo(92806)
      , isNullOrUndefined = J => null == J
      , ep = Symbol("encodeFragmentIdentifier");
    function validateArrayFormatSeparator(J) {
      if ("string" != typeof J || 1 !== J.length)
        throw TypeError("arrayFormatSeparator must be single character string")
    }
    function encode(J, et) {
      return et.encode ? et.strict ? el(J) : encodeURIComponent(J) : J
    }
    function decode(J, et) {
      return et.decode ? ec(J) : J
    }
    function removeHash(J) {
      let et = J.indexOf("#");
      return -1 !== et && (J = J.slice(0, et)),
        J
    }
    function extract(J) {
      J = removeHash(J);
      let et = J.indexOf("?");
      return -1 === et ? "" : J.slice(et + 1)
    }
    function parseValue(J, et) {
      return et.parseNumbers && !Number.isNaN(Number(J)) && "string" == typeof J && "" !== J.trim() ? J = Number(J) : et.parseBooleans && null !== J && ("true" === J.toLowerCase() || "false" === J.toLowerCase()) && (J = "true" === J.toLowerCase()),
        J
    }
    function parse(J, et) {
      validateArrayFormatSeparator((et = Object.assign({
        decode: !0,
        sort: !0,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: !1,
        parseBooleans: !1
      }, et)).arrayFormatSeparator);
      let eo = function (J) {
        let et;
        switch (J.arrayFormat) {
          case "index":
            return (J, eo, el) => {
              if (et = /\[(\d*)\]$/.exec(J),
                J = J.replace(/\[\d*\]$/, ""),
                !et) {
                el[J] = eo;
                return
              }
              void 0 === el[J] && (el[J] = {}),
                el[J][et[1]] = eo
            }
              ;
          case "bracket":
            return (J, eo, el) => {
              if (et = /(\[\])$/.exec(J),
                J = J.replace(/\[\]$/, ""),
                !et) {
                el[J] = eo;
                return
              }
              if (void 0 === el[J]) {
                el[J] = [eo];
                return
              }
              el[J] = [].concat(el[J], eo)
            }
              ;
          case "colon-list-separator":
            return (J, eo, el) => {
              if (et = /(:list)$/.exec(J),
                J = J.replace(/:list$/, ""),
                !et) {
                el[J] = eo;
                return
              }
              if (void 0 === el[J]) {
                el[J] = [eo];
                return
              }
              el[J] = [].concat(el[J], eo)
            }
              ;
          case "comma":
          case "separator":
            return (et, eo, el) => {
              let ec = "string" == typeof eo && eo.includes(J.arrayFormatSeparator)
                , ed = "string" == typeof eo && !ec && decode(eo, J).includes(J.arrayFormatSeparator);
              eo = ed ? decode(eo, J) : eo;
              let eh = ec || ed ? eo.split(J.arrayFormatSeparator).map(et => decode(et, J)) : null === eo ? eo : decode(eo, J);
              el[et] = eh
            }
              ;
          case "bracket-separator":
            return (et, eo, el) => {
              let ec = /(\[\])$/.test(et);
              if (et = et.replace(/\[\]$/, ""),
                !ec) {
                el[et] = eo ? decode(eo, J) : eo;
                return
              }
              let ed = null === eo ? [] : eo.split(J.arrayFormatSeparator).map(et => decode(et, J));
              if (void 0 === el[et]) {
                el[et] = ed;
                return
              }
              el[et] = [].concat(el[et], ed)
            }
              ;
          default:
            return (J, et, eo) => {
              if (void 0 === eo[J]) {
                eo[J] = et;
                return
              }
              eo[J] = [].concat(eo[J], et)
            }
        }
      }(et)
        , el = Object.create(null);
      if ("string" != typeof J || !(J = J.trim().replace(/^[?#&]/, "")))
        return el;
      for (let ec of J.split("&")) {
        if ("" === ec)
          continue;
        let [J, eh] = ed(et.decode ? ec.replace(/\+/g, " ") : ec, "=");
        eh = void 0 === eh ? null : ["comma", "separator", "bracket-separator"].includes(et.arrayFormat) ? eh : decode(eh, et),
          eo(decode(J, et), eh, el)
      }
      for (let J of Object.keys(el)) {
        let eo = el[J];
        if ("object" == typeof eo && null !== eo)
          for (let J of Object.keys(eo))
            eo[J] = parseValue(eo[J], et);
        else
          el[J] = parseValue(eo, et)
      }
      return !1 === et.sort ? el : (!0 === et.sort ? Object.keys(el).sort() : Object.keys(el).sort(et.sort)).reduce((J, et) => {
        let eo = el[et];
        return eo && "object" == typeof eo && !Array.isArray(eo) ? J[et] = function keysSorter(J) {
          return Array.isArray(J) ? J.sort() : "object" == typeof J ? keysSorter(Object.keys(J)).sort((J, et) => Number(J) - Number(et)).map(et => J[et]) : J
        }(eo) : J[et] = eo,
          J
      }
        , Object.create(null))
    }
    et.extract = extract,
      et.parse = parse,
      et.stringify = (J, et) => {
        if (!J)
          return "";
        validateArrayFormatSeparator((et = Object.assign({
          encode: !0,
          strict: !0,
          arrayFormat: "none",
          arrayFormatSeparator: ","
        }, et)).arrayFormatSeparator);
        let shouldFilter = eo => et.skipNull && isNullOrUndefined(J[eo]) || et.skipEmptyString && "" === J[eo]
          , eo = function (J) {
            switch (J.arrayFormat) {
              case "index":
                return et => (eo, el) => {
                  let ec = eo.length;
                  return void 0 === el || J.skipNull && null === el || J.skipEmptyString && "" === el ? eo : null === el ? [...eo, [encode(et, J), "[", ec, "]"].join("")] : [...eo, [encode(et, J), "[", encode(ec, J), "]=", encode(el, J)].join("")]
                }
                  ;
              case "bracket":
                return et => (eo, el) => void 0 === el || J.skipNull && null === el || J.skipEmptyString && "" === el ? eo : null === el ? [...eo, [encode(et, J), "[]"].join("")] : [...eo, [encode(et, J), "[]=", encode(el, J)].join("")];
              case "colon-list-separator":
                return et => (eo, el) => void 0 === el || J.skipNull && null === el || J.skipEmptyString && "" === el ? eo : null === el ? [...eo, [encode(et, J), ":list="].join("")] : [...eo, [encode(et, J), ":list=", encode(el, J)].join("")];
              case "comma":
              case "separator":
              case "bracket-separator":
                {
                  let et = "bracket-separator" === J.arrayFormat ? "[]=" : "=";
                  return eo => (el, ec) => void 0 === ec || J.skipNull && null === ec || J.skipEmptyString && "" === ec ? el : (ec = null === ec ? "" : ec,
                    0 === el.length) ? [[encode(eo, J), et, encode(ec, J)].join("")] : [[el, encode(ec, J)].join(J.arrayFormatSeparator)]
                }
              default:
                return et => (eo, el) => void 0 === el || J.skipNull && null === el || J.skipEmptyString && "" === el ? eo : null === el ? [...eo, encode(et, J)] : [...eo, [encode(et, J), "=", encode(el, J)].join("")]
            }
          }(et)
          , el = {};
        for (let et of Object.keys(J))
          shouldFilter(et) || (el[et] = J[et]);
        let ec = Object.keys(el);
        return !1 !== et.sort && ec.sort(et.sort),
          ec.map(el => {
            let ec = J[el];
            return void 0 === ec ? "" : null === ec ? encode(el, et) : Array.isArray(ec) ? 0 === ec.length && "bracket-separator" === et.arrayFormat ? encode(el, et) + "[]" : ec.reduce(eo(el), []).join("&") : encode(el, et) + "=" + encode(ec, et)
          }
          ).filter(J => J.length > 0).join("&")
      }
      ,
      et.parseUrl = (J, et) => {
        et = Object.assign({
          decode: !0
        }, et);
        let [eo, el] = ed(J, "#");
        return Object.assign({
          url: eo.split("?")[0] || "",
          query: parse(extract(J), et)
        }, et && et.parseFragmentIdentifier && el ? {
          fragmentIdentifier: decode(el, et)
        } : {})
      }
      ,
      et.stringifyUrl = (J, eo) => {
        eo = Object.assign({
          encode: !0,
          strict: !0,
          [ep]: !0
        }, eo);
        let el = removeHash(J.url).split("?")[0] || ""
          , ec = et.extract(J.url)
          , ed = et.parse(ec, {
            sort: !1
          })
          , eh = Object.assign(ed, J.query)
          , ef = et.stringify(eh, eo);
        ef && (ef = `?${ef}`);
        let em = function (J) {
          let et = ""
            , eo = J.indexOf("#");
          return -1 !== eo && (et = J.slice(eo)),
            et
        }(J.url);
        return J.fragmentIdentifier && (em = `#${eo[ep] ? encode(J.fragmentIdentifier, eo) : J.fragmentIdentifier}`),
          `${el}${ef}${em}`
      }
      ,
      et.pick = (J, eo, el) => {
        el = Object.assign({
          parseFragmentIdentifier: !0,
          [ep]: !1
        }, el);
        let { url: ec, query: ed, fragmentIdentifier: ef } = et.parseUrl(J, el);
        return et.stringifyUrl({
          url: ec,
          query: eh(ed, eo),
          fragmentIdentifier: ef
        }, el)
      }
      ,
      et.exclude = (J, eo, el) => {
        let ec = Array.isArray(eo) ? J => !eo.includes(J) : (J, et) => !eo(J, et);
        return et.pick(J, ec, el)
      }
  },
  85346: function (J) {
    "use strict";
    function tryStringify(J) {
      try {
        return JSON.stringify(J)
      } catch (J) {
        return '"[Circular]"'
      }
    }
    J.exports = function (J, et, eo) {
      var el = eo && eo.stringify || tryStringify;
      if ("object" == typeof J && null !== J) {
        var ec = et.length + 1;
        if (1 === ec)
          return J;
        var ed = Array(ec);
        ed[0] = el(J);
        for (var eh = 1; eh < ec; eh++)
          ed[eh] = el(et[eh]);
        return ed.join(" ")
      }
      if ("string" != typeof J)
        return J;
      var ep = et.length;
      if (0 === ep)
        return J;
      for (var ef = "", em = 0, eg = -1, ey = J && J.length || 0, eb = 0; eb < ey;) {
        if (37 === J.charCodeAt(eb) && eb + 1 < ey) {
          switch (eg = eg > -1 ? eg : 0,
          J.charCodeAt(eb + 1)) {
            case 100:
            case 102:
              if (em >= ep || null == et[em])
                break;
              eg < eb && (ef += J.slice(eg, eb)),
                ef += Number(et[em]),
                eg = eb + 2,
                eb++;
              break;
            case 105:
              if (em >= ep || null == et[em])
                break;
              eg < eb && (ef += J.slice(eg, eb)),
                ef += Math.floor(Number(et[em])),
                eg = eb + 2,
                eb++;
              break;
            case 79:
            case 111:
            case 106:
              if (em >= ep || void 0 === et[em])
                break;
              eg < eb && (ef += J.slice(eg, eb));
              var ew = typeof et[em];
              if ("string" === ew) {
                ef += "'" + et[em] + "'",
                  eg = eb + 2,
                  eb++;
                break
              }
              if ("function" === ew) {
                ef += et[em].name || "<anonymous>",
                  eg = eb + 2,
                  eb++;
                break
              }
              ef += el(et[em]),
                eg = eb + 2,
                eb++;
              break;
            case 115:
              if (em >= ep)
                break;
              eg < eb && (ef += J.slice(eg, eb)),
                ef += String(et[em]),
                eg = eb + 2,
                eb++;
              break;
            case 37:
              eg < eb && (ef += J.slice(eg, eb)),
                ef += "%",
                eg = eb + 2,
                eb++,
                em--
          }
          ++em
        }
        ++eb
      }
      return -1 === eg ? J : (eg < ey && (ef += J.slice(eg)),
        ef)
    }
  },
  69921: function (J, et) {
    "use strict";
    /**
* @license React
* react-is.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
    var eo, el = Symbol.for("react.element"), ec = Symbol.for("react.portal"), ed = Symbol.for("react.fragment"), eh = Symbol.for("react.strict_mode"), ep = Symbol.for("react.profiler"), ef = Symbol.for("react.provider"), em = Symbol.for("react.context"), eg = Symbol.for("react.server_context"), ey = Symbol.for("react.forward_ref"), eb = Symbol.for("react.suspense"), ew = Symbol.for("react.suspense_list"), e_ = Symbol.for("react.memo"), ex = Symbol.for("react.lazy"), eE = Symbol.for("react.offscreen");
    eo = Symbol.for("react.module.reference"),
      et.isValidElementType = function (J) {
        return "string" == typeof J || "function" == typeof J || J === ed || J === ep || J === eh || J === eb || J === ew || J === eE || "object" == typeof J && null !== J && (J.$$typeof === ex || J.$$typeof === e_ || J.$$typeof === ef || J.$$typeof === em || J.$$typeof === ey || J.$$typeof === eo || void 0 !== J.getModuleId)
      }
      ,
      et.typeOf = function (J) {
        if ("object" == typeof J && null !== J) {
          var et = J.$$typeof;
          switch (et) {
            case el:
              switch (J = J.type) {
                case ed:
                case ep:
                case eh:
                case eb:
                case ew:
                  return J;
                default:
                  switch (J = J && J.$$typeof) {
                    case eg:
                    case em:
                    case ey:
                    case ex:
                    case e_:
                    case ef:
                      return J;
                    default:
                      return et
                  }
              }
            case ec:
              return et
          }
        }
      }
  },
  59864: function (J, et, eo) {
    "use strict";
    J.exports = eo(69921)
  },
  25226: function (J) {
    "use strict";
    J.exports = {
      name: "original",
      anchor: "#1034a6",
      anchorVisited: "#440381",
      borderDark: "#848584",
      borderDarkest: "#0a0a0a",
      borderLight: "#dfdfdf",
      borderLightest: "#fefefe",
      canvas: "#ffffff",
      canvasText: "#0a0a0a",
      canvasTextDisabled: "#848584",
      canvasTextDisabledShadow: "#fefefe",
      canvasTextInvert: "#fefefe",
      checkmark: "#0a0a0a",
      checkmarkDisabled: "#848584",
      desktopBackground: "#008080",
      flatDark: "#9e9e9e",
      flatLight: "#d8d8d8",
      focusSecondary: "#fefe03",
      headerBackground: "#060084",
      headerNotActiveBackground: "#7f787f",
      headerNotActiveText: "#c6c6c6",
      headerText: "#fefefe",
      hoverBackground: "#060084",
      material: "#c6c6c6",
      materialDark: "#9a9e9c",
      materialText: "#0a0a0a",
      materialTextDisabled: "#848584",
      materialTextDisabledShadow: "#fefefe",
      materialTextInvert: "#fefefe",
      progress: "#060084",
      tooltip: "#fefbcc"
    }
  },
  24189: function (J, et, eo) {
    var el = eo(99187).Buffer;
    function Hash(J, et) {
      this._block = el.alloc(J),
        this._finalSize = et,
        this._blockSize = J,
        this._len = 0
    }
    Hash.prototype.update = function (J, et) {
      "string" == typeof J && (et = et || "utf8",
        J = el.from(J, et));
      for (var eo = this._block, ec = this._blockSize, ed = J.length, eh = this._len, ep = 0; ep < ed;) {
        for (var ef = eh % ec, em = Math.min(ed - ep, ec - ef), eg = 0; eg < em; eg++)
          eo[ef + eg] = J[ep + eg];
        eh += em,
          ep += em,
          eh % ec == 0 && this._update(eo)
      }
      return this._len += ed,
        this
    }
      ,
      Hash.prototype.digest = function (J) {
        var et = this._len % this._blockSize;
        this._block[et] = 128,
          this._block.fill(0, et + 1),
          et >= this._finalSize && (this._update(this._block),
            this._block.fill(0));
        var eo = 8 * this._len;
        if (eo <= 4294967295)
          this._block.writeUInt32BE(eo, this._blockSize - 4);
        else {
          var el = (4294967295 & eo) >>> 0
            , ec = (eo - el) / 4294967296;
          this._block.writeUInt32BE(ec, this._blockSize - 8),
            this._block.writeUInt32BE(el, this._blockSize - 4)
        }
        this._update(this._block);
        var ed = this._hash();
        return J ? ed.toString(J) : ed
      }
      ,
      Hash.prototype._update = function () {
        throw Error("_update must be implemented by subclass")
      }
      ,
      J.exports = Hash
  },
  89072: function (J, et, eo) {
    var el = J.exports = function (J) {
      var et = el[J = J.toLowerCase()];
      if (!et)
        throw Error(J + " is not supported (we accept pull requests)");
      return new et
    }
      ;
    el.sha = eo(74448),
      el.sha1 = eo(18336),
      el.sha224 = eo(48432),
      el.sha256 = eo(67499),
      el.sha384 = eo(51686),
      el.sha512 = eo(87816)
  },
  99187: function (J, et, eo) {
    /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
    var el = eo(48764)
      , ec = el.Buffer;
    function copyProps(J, et) {
      for (var eo in J)
        et[eo] = J[eo]
    }
    function SafeBuffer(J, et, eo) {
      return ec(J, et, eo)
    }
    ec.from && ec.alloc && ec.allocUnsafe && ec.allocUnsafeSlow ? J.exports = el : (copyProps(el, et),
      et.Buffer = SafeBuffer),
      SafeBuffer.prototype = Object.create(ec.prototype),
      copyProps(ec, SafeBuffer),
      SafeBuffer.from = function (J, et, eo) {
        if ("number" == typeof J)
          throw TypeError("Argument must not be a number");
        return ec(J, et, eo)
      }
      ,
      SafeBuffer.alloc = function (J, et, eo) {
        if ("number" != typeof J)
          throw TypeError("Argument must be a number");
        var el = ec(J);
        return void 0 !== et ? "string" == typeof eo ? el.fill(et, eo) : el.fill(et) : el.fill(0),
          el
      }
      ,
      SafeBuffer.allocUnsafe = function (J) {
        if ("number" != typeof J)
          throw TypeError("Argument must be a number");
        return ec(J)
      }
      ,
      SafeBuffer.allocUnsafeSlow = function (J) {
        if ("number" != typeof J)
          throw TypeError("Argument must be a number");
        return el.SlowBuffer(J)
      }
  },
  74448: function (J, et, eo) {
    var el = eo(35717)
      , ec = eo(24189)
      , ed = eo(99187).Buffer
      , eh = [1518500249, 1859775393, -1894007588, -899497514]
      , ep = Array(80);
    function Sha() {
      this.init(),
        this._w = ep,
        ec.call(this, 64, 56)
    }
    el(Sha, ec),
      Sha.prototype.init = function () {
        return this._a = 1732584193,
          this._b = 4023233417,
          this._c = 2562383102,
          this._d = 271733878,
          this._e = 3285377520,
          this
      }
      ,
      Sha.prototype._update = function (J) {
        for (var et = this._w, eo = 0 | this._a, el = 0 | this._b, ec = 0 | this._c, ed = 0 | this._d, ep = 0 | this._e, ef = 0; ef < 16; ++ef)
          et[ef] = J.readInt32BE(4 * ef);
        for (; ef < 80; ++ef)
          et[ef] = et[ef - 3] ^ et[ef - 8] ^ et[ef - 14] ^ et[ef - 16];
        for (var em = 0; em < 80; ++em) {
          var eg, ey, eb, ew, e_, ex = ~~(em / 20), eE = ((eg = eo) << 5 | eg >>> 27) + (ey = el,
            eb = ec,
            ew = ed,
            0 === ex ? ey & eb | ~ey & ew : 2 === ex ? ey & eb | ey & ew | eb & ew : ey ^ eb ^ ew) + ep + et[em] + eh[ex] | 0;
          ep = ed,
            ed = ec,
            ec = (e_ = el) << 30 | e_ >>> 2,
            el = eo,
            eo = eE
        }
        this._a = eo + this._a | 0,
          this._b = el + this._b | 0,
          this._c = ec + this._c | 0,
          this._d = ed + this._d | 0,
          this._e = ep + this._e | 0
      }
      ,
      Sha.prototype._hash = function () {
        var J = ed.allocUnsafe(20);
        return J.writeInt32BE(0 | this._a, 0),
          J.writeInt32BE(0 | this._b, 4),
          J.writeInt32BE(0 | this._c, 8),
          J.writeInt32BE(0 | this._d, 12),
          J.writeInt32BE(0 | this._e, 16),
          J
      }
      ,
      J.exports = Sha
  },
  18336: function (J, et, eo) {
    var el = eo(35717)
      , ec = eo(24189)
      , ed = eo(99187).Buffer
      , eh = [1518500249, 1859775393, -1894007588, -899497514]
      , ep = Array(80);
    function Sha1() {
      this.init(),
        this._w = ep,
        ec.call(this, 64, 56)
    }
    el(Sha1, ec),
      Sha1.prototype.init = function () {
        return this._a = 1732584193,
          this._b = 4023233417,
          this._c = 2562383102,
          this._d = 271733878,
          this._e = 3285377520,
          this
      }
      ,
      Sha1.prototype._update = function (J) {
        for (var et = this._w, eo = 0 | this._a, el = 0 | this._b, ec = 0 | this._c, ed = 0 | this._d, ep = 0 | this._e, ef = 0; ef < 16; ++ef)
          et[ef] = J.readInt32BE(4 * ef);
        for (; ef < 80; ++ef)
          et[ef] = (eg = et[ef - 3] ^ et[ef - 8] ^ et[ef - 14] ^ et[ef - 16]) << 1 | eg >>> 31;
        for (var em = 0; em < 80; ++em) {
          var eg, ey, eb, ew, e_, ex, eE = ~~(em / 20), eC = ((ey = eo) << 5 | ey >>> 27) + (eb = el,
            ew = ec,
            e_ = ed,
            0 === eE ? eb & ew | ~eb & e_ : 2 === eE ? eb & ew | eb & e_ | ew & e_ : eb ^ ew ^ e_) + ep + et[em] + eh[eE] | 0;
          ep = ed,
            ed = ec,
            ec = (ex = el) << 30 | ex >>> 2,
            el = eo,
            eo = eC
        }
        this._a = eo + this._a | 0,
          this._b = el + this._b | 0,
          this._c = ec + this._c | 0,
          this._d = ed + this._d | 0,
          this._e = ep + this._e | 0
      }
      ,
      Sha1.prototype._hash = function () {
        var J = ed.allocUnsafe(20);
        return J.writeInt32BE(0 | this._a, 0),
          J.writeInt32BE(0 | this._b, 4),
          J.writeInt32BE(0 | this._c, 8),
          J.writeInt32BE(0 | this._d, 12),
          J.writeInt32BE(0 | this._e, 16),
          J
      }
      ,
      J.exports = Sha1
  },
  48432: function (J, et, eo) {
    var el = eo(35717)
      , ec = eo(67499)
      , ed = eo(24189)
      , eh = eo(99187).Buffer
      , ep = Array(64);
    function Sha224() {
      this.init(),
        this._w = ep,
        ed.call(this, 64, 56)
    }
    el(Sha224, ec),
      Sha224.prototype.init = function () {
        return this._a = 3238371032,
          this._b = 914150663,
          this._c = 812702999,
          this._d = 4144912697,
          this._e = 4290775857,
          this._f = 1750603025,
          this._g = 1694076839,
          this._h = 3204075428,
          this
      }
      ,
      Sha224.prototype._hash = function () {
        var J = eh.allocUnsafe(28);
        return J.writeInt32BE(this._a, 0),
          J.writeInt32BE(this._b, 4),
          J.writeInt32BE(this._c, 8),
          J.writeInt32BE(this._d, 12),
          J.writeInt32BE(this._e, 16),
          J.writeInt32BE(this._f, 20),
          J.writeInt32BE(this._g, 24),
          J
      }
      ,
      J.exports = Sha224
  },
  67499: function (J, et, eo) {
    var el = eo(35717)
      , ec = eo(24189)
      , ed = eo(99187).Buffer
      , eh = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]
      , ep = Array(64);
    function Sha256() {
      this.init(),
        this._w = ep,
        ec.call(this, 64, 56)
    }
    el(Sha256, ec),
      Sha256.prototype.init = function () {
        return this._a = 1779033703,
          this._b = 3144134277,
          this._c = 1013904242,
          this._d = 2773480762,
          this._e = 1359893119,
          this._f = 2600822924,
          this._g = 528734635,
          this._h = 1541459225,
          this
      }
      ,
      Sha256.prototype._update = function (J) {
        for (var et = this._w, eo = 0 | this._a, el = 0 | this._b, ec = 0 | this._c, ed = 0 | this._d, ep = 0 | this._e, ef = 0 | this._f, em = 0 | this._g, eg = 0 | this._h, ey = 0; ey < 16; ++ey)
          et[ey] = J.readInt32BE(4 * ey);
        for (; ey < 64; ++ey)
          et[ey] = (((ew = et[ey - 2]) >>> 17 | ew << 15) ^ (ew >>> 19 | ew << 13) ^ ew >>> 10) + et[ey - 7] + (((e_ = et[ey - 15]) >>> 7 | e_ << 25) ^ (e_ >>> 18 | e_ << 14) ^ e_ >>> 3) + et[ey - 16] | 0;
        for (var eb = 0; eb < 64; ++eb) {
          var ew, e_, ex, eE, eC, eS, ek, eT, eA, eP = eg + (((ex = ep) >>> 6 | ex << 26) ^ (ex >>> 11 | ex << 21) ^ (ex >>> 25 | ex << 7)) + (eE = ep,
            eC = ef,
            (eS = em) ^ eE & (eC ^ eS)) + eh[eb] + et[eb] | 0, eR = (((ek = eo) >>> 2 | ek << 30) ^ (ek >>> 13 | ek << 19) ^ (ek >>> 22 | ek << 10)) + ((eT = eo) & (eA = el) | ec & (eT | eA)) | 0;
          eg = em,
            em = ef,
            ef = ep,
            ep = ed + eP | 0,
            ed = ec,
            ec = el,
            el = eo,
            eo = eP + eR | 0
        }
        this._a = eo + this._a | 0,
          this._b = el + this._b | 0,
          this._c = ec + this._c | 0,
          this._d = ed + this._d | 0,
          this._e = ep + this._e | 0,
          this._f = ef + this._f | 0,
          this._g = em + this._g | 0,
          this._h = eg + this._h | 0
      }
      ,
      Sha256.prototype._hash = function () {
        var J = ed.allocUnsafe(32);
        return J.writeInt32BE(this._a, 0),
          J.writeInt32BE(this._b, 4),
          J.writeInt32BE(this._c, 8),
          J.writeInt32BE(this._d, 12),
          J.writeInt32BE(this._e, 16),
          J.writeInt32BE(this._f, 20),
          J.writeInt32BE(this._g, 24),
          J.writeInt32BE(this._h, 28),
          J
      }
      ,
      J.exports = Sha256
  },
  51686: function (J, et, eo) {
    var el = eo(35717)
      , ec = eo(87816)
      , ed = eo(24189)
      , eh = eo(99187).Buffer
      , ep = Array(160);
    function Sha384() {
      this.init(),
        this._w = ep,
        ed.call(this, 128, 112)
    }
    el(Sha384, ec),
      Sha384.prototype.init = function () {
        return this._ah = 3418070365,
          this._bh = 1654270250,
          this._ch = 2438529370,
          this._dh = 355462360,
          this._eh = 1731405415,
          this._fh = 2394180231,
          this._gh = 3675008525,
          this._hh = 1203062813,
          this._al = 3238371032,
          this._bl = 914150663,
          this._cl = 812702999,
          this._dl = 4144912697,
          this._el = 4290775857,
          this._fl = 1750603025,
          this._gl = 1694076839,
          this._hl = 3204075428,
          this
      }
      ,
      Sha384.prototype._hash = function () {
        var J = eh.allocUnsafe(48);
        function writeInt64BE(et, eo, el) {
          J.writeInt32BE(et, el),
            J.writeInt32BE(eo, el + 4)
        }
        return writeInt64BE(this._ah, this._al, 0),
          writeInt64BE(this._bh, this._bl, 8),
          writeInt64BE(this._ch, this._cl, 16),
          writeInt64BE(this._dh, this._dl, 24),
          writeInt64BE(this._eh, this._el, 32),
          writeInt64BE(this._fh, this._fl, 40),
          J
      }
      ,
      J.exports = Sha384
  },
  87816: function (J, et, eo) {
    var el = eo(35717)
      , ec = eo(24189)
      , ed = eo(99187).Buffer
      , eh = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591]
      , ep = Array(160);
    function Sha512() {
      this.init(),
        this._w = ep,
        ec.call(this, 128, 112)
    }
    function sigma0(J, et) {
      return (J >>> 28 | et << 4) ^ (et >>> 2 | J << 30) ^ (et >>> 7 | J << 25)
    }
    function sigma1(J, et) {
      return (J >>> 14 | et << 18) ^ (J >>> 18 | et << 14) ^ (et >>> 9 | J << 23)
    }
    function getCarry(J, et) {
      return J >>> 0 < et >>> 0 ? 1 : 0
    }
    el(Sha512, ec),
      Sha512.prototype.init = function () {
        return this._ah = 1779033703,
          this._bh = 3144134277,
          this._ch = 1013904242,
          this._dh = 2773480762,
          this._eh = 1359893119,
          this._fh = 2600822924,
          this._gh = 528734635,
          this._hh = 1541459225,
          this._al = 4089235720,
          this._bl = 2227873595,
          this._cl = 4271175723,
          this._dl = 1595750129,
          this._el = 2917565137,
          this._fl = 725511199,
          this._gl = 4215389547,
          this._hl = 327033209,
          this
      }
      ,
      Sha512.prototype._update = function (J) {
        for (var et = this._w, eo = 0 | this._ah, el = 0 | this._bh, ec = 0 | this._ch, ed = 0 | this._dh, ep = 0 | this._eh, ef = 0 | this._fh, em = 0 | this._gh, eg = 0 | this._hh, ey = 0 | this._al, eb = 0 | this._bl, ew = 0 | this._cl, e_ = 0 | this._dl, ex = 0 | this._el, eE = 0 | this._fl, eC = 0 | this._gl, eS = 0 | this._hl, ek = 0; ek < 32; ek += 2)
          et[ek] = J.readInt32BE(4 * ek),
            et[ek + 1] = J.readInt32BE(4 * ek + 4);
        for (; ek < 160; ek += 2) {
          var eT, eA, eP, eR, eI, eO, eN, eM, eD = et[ek - 30], ej = et[ek - 30 + 1], eL = ((eT = eD) >>> 1 | (eA = ej) << 31) ^ (eT >>> 8 | eA << 24) ^ eT >>> 7, e$ = ((eP = ej) >>> 1 | (eR = eD) << 31) ^ (eP >>> 8 | eR << 24) ^ (eP >>> 7 | eR << 25);
          eD = et[ek - 4],
            ej = et[ek - 4 + 1];
          var eB = ((eI = eD) >>> 19 | (eO = ej) << 13) ^ (eO >>> 29 | eI << 3) ^ eI >>> 6
            , eF = ((eN = ej) >>> 19 | (eM = eD) << 13) ^ (eM >>> 29 | eN << 3) ^ (eN >>> 6 | eM << 26)
            , eU = et[ek - 14]
            , ez = et[ek - 14 + 1]
            , eH = et[ek - 32]
            , eV = et[ek - 32 + 1]
            , eW = e$ + ez | 0
            , eZ = eL + eU + getCarry(eW, e$) | 0;
          eZ = (eZ = eZ + eB + getCarry(eW = eW + eF | 0, eF) | 0) + eH + getCarry(eW = eW + eV | 0, eV) | 0,
            et[ek] = eZ,
            et[ek + 1] = eW
        }
        for (var eG = 0; eG < 160; eG += 2) {
          eZ = et[eG],
            eW = et[eG + 1];
          var eY, eK, eJ, eQ, eX, e0, e1, e2, e3, e5, e6 = (eY = eo) & (eK = el) | ec & (eY | eK), e4 = (eJ = ey) & (eQ = eb) | ew & (eJ | eQ), e8 = sigma0(eo, ey), e7 = sigma0(ey, eo), e9 = sigma1(ep, ex), tn = sigma1(ex, ep), to = eh[eG], ta = eh[eG + 1], tl = (eX = ep,
            e0 = ef,
            (e1 = em) ^ eX & (e0 ^ e1)), tc = (e2 = ex,
              e3 = eE,
              (e5 = eC) ^ e2 & (e3 ^ e5)), td = eS + tn | 0, th = eg + e9 + getCarry(td, eS) | 0;
          th = (th = (th = th + tl + getCarry(td = td + tc | 0, tc) | 0) + to + getCarry(td = td + ta | 0, ta) | 0) + eZ + getCarry(td = td + eW | 0, eW) | 0;
          var tp = e7 + e4 | 0
            , tf = e8 + e6 + getCarry(tp, e7) | 0;
          eg = em,
            eS = eC,
            em = ef,
            eC = eE,
            ef = ep,
            eE = ex,
            ep = ed + th + getCarry(ex = e_ + td | 0, e_) | 0,
            ed = ec,
            e_ = ew,
            ec = el,
            ew = eb,
            el = eo,
            eb = ey,
            eo = th + tf + getCarry(ey = td + tp | 0, td) | 0
        }
        this._al = this._al + ey | 0,
          this._bl = this._bl + eb | 0,
          this._cl = this._cl + ew | 0,
          this._dl = this._dl + e_ | 0,
          this._el = this._el + ex | 0,
          this._fl = this._fl + eE | 0,
          this._gl = this._gl + eC | 0,
          this._hl = this._hl + eS | 0,
          this._ah = this._ah + eo + getCarry(this._al, ey) | 0,
          this._bh = this._bh + el + getCarry(this._bl, eb) | 0,
          this._ch = this._ch + ec + getCarry(this._cl, ew) | 0,
          this._dh = this._dh + ed + getCarry(this._dl, e_) | 0,
          this._eh = this._eh + ep + getCarry(this._el, ex) | 0,
          this._fh = this._fh + ef + getCarry(this._fl, eE) | 0,
          this._gh = this._gh + em + getCarry(this._gl, eC) | 0,
          this._hh = this._hh + eg + getCarry(this._hl, eS) | 0
      }
      ,
      Sha512.prototype._hash = function () {
        var J = ed.allocUnsafe(64);
        function writeInt64BE(et, eo, el) {
          J.writeInt32BE(et, el),
            J.writeInt32BE(eo, el + 4)
        }
        return writeInt64BE(this._ah, this._al, 0),
          writeInt64BE(this._bh, this._bl, 8),
          writeInt64BE(this._ch, this._cl, 16),
          writeInt64BE(this._dh, this._dl, 24),
          writeInt64BE(this._eh, this._el, 32),
          writeInt64BE(this._fh, this._fl, 40),
          writeInt64BE(this._gh, this._gl, 48),
          writeInt64BE(this._hh, this._hl, 56),
          J
      }
      ,
      J.exports = Sha512
  },
  96774: function (J) {
    J.exports = function (J, et, eo, el) {
      var ec = eo ? eo.call(el, J, et) : void 0;
      if (void 0 !== ec)
        return !!ec;
      if (J === et)
        return !0;
      if ("object" != typeof J || !J || "object" != typeof et || !et)
        return !1;
      var ed = Object.keys(J)
        , eh = Object.keys(et);
      if (ed.length !== eh.length)
        return !1;
      for (var ep = Object.prototype.hasOwnProperty.bind(et), ef = 0; ef < ed.length; ef++) {
        var em = ed[ef];
        if (!ep(em))
          return !1;
        var eg = J[em]
          , ey = et[em];
        if (!1 === (ec = eo ? eo.call(el, eg, ey, em) : void 0) || void 0 === ec && eg !== ey)
          return !1
      }
      return !0
    }
  },
  80500: function (J) {
    "use strict";
    J.exports = (J, et) => {
      if (!("string" == typeof J && "string" == typeof et))
        throw TypeError("Expected the arguments to be of type `string`");
      if ("" === et)
        return [J];
      let eo = J.indexOf(et);
      return -1 === eo ? [J] : [J.slice(0, eo), J.slice(eo + et.length)]
    }
  },
  70610: function (J) {
    "use strict";
    J.exports = J => encodeURIComponent(J).replace(/[!'()*]/g, J => `%${J.charCodeAt(0).toString(16).toUpperCase()}`)
  },
  186: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      f6: function () {
        return Fe
      },
      iv: function () {
        return Ce
      },
      ZP: function () {
        return e2
      }
    });
    var el, ec, ed = eo(59864), eh = eo(67294), ep = eo(96774), ef = eo.n(ep), stylis_browser_esm = function (J) {
      function X(J, et, eo) {
        var el = et.trim().split(eh);
        et = el;
        var ec = el.length
          , ed = J.length;
        switch (ed) {
          case 0:
          case 1:
            var ep = 0;
            for (J = 0 === ed ? "" : J[0] + " "; ep < ec; ++ep)
              et[ep] = Z(J, et[ep], eo).trim();
            break;
          default:
            var ef = ep = 0;
            for (et = []; ep < ec; ++ep)
              for (var em = 0; em < ed; ++em)
                et[ef++] = Z(J[em] + " ", el[ep], eo).trim()
        }
        return et
      }
      function Z(J, et, eo) {
        var el = et.charCodeAt(0);
        switch (33 > el && (el = (et = et.trim()).charCodeAt(0)),
        el) {
          case 38:
            return et.replace(ep, "$1" + J.trim());
          case 58:
            return J.trim() + et.replace(ep, "$1" + J.trim());
          default:
            if (0 < 1 * eo && 0 < et.indexOf("\f"))
              return et.replace(ep, (58 === J.charCodeAt(0) ? "" : "$1") + J.trim())
        }
        return J + et
      }
      function P(J, et, eo, eh) {
        var ep = J + ";"
          , ef = 2 * et + 3 * eo + 4 * eh;
        if (944 === ef) {
          J = ep.indexOf(":", 9) + 1;
          var em = ep.substring(J, ep.length - 1).trim();
          return em = ep.substring(0, J).trim() + em + ";",
            1 === eA || 2 === eA && L(em, 1) ? "-webkit-" + em + em : em
        }
        if (0 === eA || 2 === eA && !L(ep, 1))
          return ep;
        switch (ef) {
          case 1015:
            return 97 === ep.charCodeAt(10) ? "-webkit-" + ep + ep : ep;
          case 951:
            return 116 === ep.charCodeAt(3) ? "-webkit-" + ep + ep : ep;
          case 963:
            return 110 === ep.charCodeAt(5) ? "-webkit-" + ep + ep : ep;
          case 1009:
            if (100 !== ep.charCodeAt(4))
              break;
          case 969:
          case 942:
            return "-webkit-" + ep + ep;
          case 978:
            return "-webkit-" + ep + "-moz-" + ep + ep;
          case 1019:
          case 983:
            return "-webkit-" + ep + "-moz-" + ep + "-ms-" + ep + ep;
          case 883:
            if (45 === ep.charCodeAt(8))
              return "-webkit-" + ep + ep;
            if (0 < ep.indexOf("image-set(", 11))
              return ep.replace(eC, "$1-webkit-$2") + ep;
            break;
          case 932:
            if (45 === ep.charCodeAt(4))
              switch (ep.charCodeAt(5)) {
                case 103:
                  return "-webkit-box-" + ep.replace("-grow", "") + "-webkit-" + ep + "-ms-" + ep.replace("grow", "positive") + ep;
                case 115:
                  return "-webkit-" + ep + "-ms-" + ep.replace("shrink", "negative") + ep;
                case 98:
                  return "-webkit-" + ep + "-ms-" + ep.replace("basis", "preferred-size") + ep
              }
            return "-webkit-" + ep + "-ms-" + ep + ep;
          case 964:
            return "-webkit-" + ep + "-ms-flex-" + ep + ep;
          case 1023:
            if (99 !== ep.charCodeAt(8))
              break;
            return "-webkit-box-pack" + (em = ep.substring(ep.indexOf(":", 15)).replace("flex-", "").replace("space-between", "justify")) + "-webkit-" + ep + "-ms-flex-pack" + em + ep;
          case 1005:
            return ec.test(ep) ? ep.replace(el, ":-webkit-") + ep.replace(el, ":-moz-") + ep : ep;
          case 1e3:
            switch (et = (em = ep.substring(13).trim()).indexOf("-") + 1,
            em.charCodeAt(0) + em.charCodeAt(et)) {
              case 226:
                em = ep.replace(ey, "tb");
                break;
              case 232:
                em = ep.replace(ey, "tb-rl");
                break;
              case 220:
                em = ep.replace(ey, "lr");
                break;
              default:
                return ep
            }
            return "-webkit-" + ep + "-ms-" + em + ep;
          case 1017:
            if (-1 === ep.indexOf("sticky", 9))
              break;
          case 975:
            switch (et = (ep = J).length - 10,
            ef = (em = (33 === ep.charCodeAt(et) ? ep.substring(0, et) : ep).substring(J.indexOf(":", 7) + 1).trim()).charCodeAt(0) + (0 | em.charCodeAt(7))) {
              case 203:
                if (111 > em.charCodeAt(8))
                  break;
              case 115:
                ep = ep.replace(em, "-webkit-" + em) + ";" + ep;
                break;
              case 207:
              case 102:
                ep = ep.replace(em, "-webkit-" + (102 < ef ? "inline-" : "") + "box") + ";" + ep.replace(em, "-webkit-" + em) + ";" + ep.replace(em, "-ms-" + em + "box") + ";" + ep
            }
            return ep + ";";
          case 938:
            if (45 === ep.charCodeAt(5))
              switch (ep.charCodeAt(6)) {
                case 105:
                  return em = ep.replace("-items", ""),
                    "-webkit-" + ep + "-webkit-box-" + em + "-ms-flex-" + em + ep;
                case 115:
                  return "-webkit-" + ep + "-ms-flex-item-" + ep.replace(e_, "") + ep;
                default:
                  return "-webkit-" + ep + "-ms-flex-line-pack" + ep.replace("align-content", "").replace(e_, "") + ep
              }
            break;
          case 973:
          case 989:
            if (45 !== ep.charCodeAt(3) || 122 === ep.charCodeAt(4))
              break;
          case 931:
          case 953:
            if (!0 === eE.test(J))
              return 115 === (em = J.substring(J.indexOf(":") + 1)).charCodeAt(0) ? P(J.replace("stretch", "fill-available"), et, eo, eh).replace(":fill-available", ":stretch") : ep.replace(em, "-webkit-" + em) + ep.replace(em, "-moz-" + em.replace("fill-", "")) + ep;
            break;
          case 962:
            if (ep = "-webkit-" + ep + (102 === ep.charCodeAt(5) ? "-ms-" + ep : "") + ep,
              211 === eo + eh && 105 === ep.charCodeAt(13) && 0 < ep.indexOf("transform", 10))
              return ep.substring(0, ep.indexOf(";", 27) + 1).replace(ed, "$1-webkit-$2") + ep
        }
        return ep
      }
      function L(J, et) {
        var eo = J.indexOf(1 === et ? ":" : "{")
          , el = J.substring(0, 3 !== et ? eo : 10);
        return eo = J.substring(eo + 1, J.length - 1),
          eO(2 !== et ? el : el.replace(ex, "$1"), eo, et)
      }
      function ea(J, et) {
        var eo = P(et, et.charCodeAt(0), et.charCodeAt(1), et.charCodeAt(2));
        return eo !== et + ";" ? eo.replace(ew, " or ($1)").substring(4) : "(" + et + ")"
      }
      function H(J, et, eo, el, ec, ed, eh, ep, ef, em) {
        for (var eg, ey = 0, eb = et; ey < eI; ++ey)
          switch (eg = eR[ey].call(B, J, eb, eo, el, ec, ed, eh, ep, ef, em)) {
            case void 0:
            case !1:
            case !0:
            case null:
              break;
            default:
              eb = eg
          }
        if (eb !== et)
          return eb
      }
      function U(J) {
        return void 0 !== (J = J.prefix) && (eO = null,
          J ? "function" != typeof J ? eA = 1 : (eA = 2,
            eO = J) : eA = 0),
          U
      }
      function B(J, el) {
        var ec = J;
        if (33 > ec.charCodeAt(0) && (ec = ec.trim()),
          ec = [ec],
          0 < eI) {
          var ed = H(-1, el, ec, ec, ek, eS, 0, 0, 0, 0);
          void 0 !== ed && "string" == typeof ed && (el = ed)
        }
        var eh = function M(J, el, ec, ed, eh) {
          for (var ep, ey, ew, e_, ex, eE = 0, eC = 0, eR = 0, eO = 0, eM = 0, eD = 0, ej = ew = ep = 0, eL = 0, e$ = 0, eB = 0, eF = 0, eU = ec.length, ez = eU - 1, eH = "", eV = "", eW = "", eZ = ""; eL < eU;) {
            if (ey = ec.charCodeAt(eL),
              eL === ez && 0 !== eC + eO + eR + eE && (0 !== eC && (ey = 47 === eC ? 10 : 47),
                eO = eR = eE = 0,
                eU++,
                ez++),
              0 === eC + eO + eR + eE) {
              if (eL === ez && (0 < e$ && (eH = eH.replace(eo, "")),
                0 < eH.trim().length)) {
                switch (ey) {
                  case 32:
                  case 9:
                  case 59:
                  case 13:
                  case 10:
                    break;
                  default:
                    eH += ec.charAt(eL)
                }
                ey = 59
              }
              switch (ey) {
                case 123:
                  for (ep = (eH = eH.trim()).charCodeAt(0),
                    ew = 1,
                    eF = ++eL; eL < eU;) {
                    switch (ey = ec.charCodeAt(eL)) {
                      case 123:
                        ew++;
                        break;
                      case 125:
                        ew--;
                        break;
                      case 47:
                        switch (ey = ec.charCodeAt(eL + 1)) {
                          case 42:
                          case 47:
                            r: {
                              for (ej = eL + 1; ej < ez; ++ej)
                                switch (ec.charCodeAt(ej)) {
                                  case 47:
                                    if (42 === ey && 42 === ec.charCodeAt(ej - 1) && eL + 2 !== ej) {
                                      eL = ej + 1;
                                      break r
                                    }
                                    break;
                                  case 10:
                                    if (47 === ey) {
                                      eL = ej + 1;
                                      break r
                                    }
                                }
                              eL = ej
                            }
                        }
                        break;
                      case 91:
                        ey++;
                      case 40:
                        ey++;
                      case 34:
                      case 39:
                        for (; eL++ < ez && ec.charCodeAt(eL) !== ey;)
                          ;
                    }
                    if (0 === ew)
                      break;
                    eL++
                  }
                  if (ew = ec.substring(eF, eL),
                    0 === ep && (ep = (eH = eH.replace(et, "").trim()).charCodeAt(0)),
                    64 === ep) {
                    switch (0 < e$ && (eH = eH.replace(eo, "")),
                    ey = eH.charCodeAt(1)) {
                      case 100:
                      case 109:
                      case 115:
                      case 45:
                        e$ = el;
                        break;
                      default:
                        e$ = eP
                    }
                    if (eF = (ew = M(el, e$, ew, ey, eh + 1)).length,
                      0 < eI && (ex = H(3, ew, e$ = X(eP, eH, eB), el, ek, eS, eF, ey, eh, ed),
                        eH = e$.join(""),
                        void 0 !== ex && 0 === (eF = (ew = ex.trim()).length) && (ey = 0,
                          ew = "")),
                      0 < eF)
                      switch (ey) {
                        case 115:
                          eH = eH.replace(eb, ea);
                        case 100:
                        case 109:
                        case 45:
                          ew = eH + "{" + ew + "}";
                          break;
                        case 107:
                          ew = (eH = eH.replace(ef, "$1 $2")) + "{" + ew + "}",
                            ew = 1 === eA || 2 === eA && L("@" + ew, 3) ? "@-webkit-" + ew + "@" + ew : "@" + ew;
                          break;
                        default:
                          ew = eH + ew,
                            112 === ed && (eV += ew,
                              ew = "")
                      }
                    else
                      ew = ""
                  } else
                    ew = M(el, X(el, eH, eB), ew, ed, eh + 1);
                  eW += ew,
                    ew = eB = e$ = ej = ep = 0,
                    eH = "",
                    ey = ec.charCodeAt(++eL);
                  break;
                case 125:
                case 59:
                  if (1 < (eF = (eH = (0 < e$ ? eH.replace(eo, "") : eH).trim()).length))
                    switch (0 === ej && (45 === (ep = eH.charCodeAt(0)) || 96 < ep && 123 > ep) && (eF = (eH = eH.replace(" ", ":")).length),
                    0 < eI && void 0 !== (ex = H(1, eH, el, J, ek, eS, eV.length, ed, eh, ed)) && 0 === (eF = (eH = ex.trim()).length) && (eH = "\x00\x00"),
                    ep = eH.charCodeAt(0),
                    ey = eH.charCodeAt(1),
                    ep) {
                      case 0:
                        break;
                      case 64:
                        if (105 === ey || 99 === ey) {
                          eZ += eH + ec.charAt(eL);
                          break
                        }
                      default:
                        58 !== eH.charCodeAt(eF - 1) && (eV += P(eH, ep, ey, eH.charCodeAt(2)))
                    }
                  eB = e$ = ej = ep = 0,
                    eH = "",
                    ey = ec.charCodeAt(++eL)
              }
            }
            switch (ey) {
              case 13:
              case 10:
                47 === eC ? eC = 0 : 0 === 1 + ep && 107 !== ed && 0 < eH.length && (e$ = 1,
                  eH += "\x00"),
                  0 < eI * eN && H(0, eH, el, J, ek, eS, eV.length, ed, eh, ed),
                  eS = 1,
                  ek++;
                break;
              case 59:
              case 125:
                if (0 === eC + eO + eR + eE) {
                  eS++;
                  break
                }
              default:
                switch (eS++,
                e_ = ec.charAt(eL),
                ey) {
                  case 9:
                  case 32:
                    if (0 === eO + eE + eC)
                      switch (eM) {
                        case 44:
                        case 58:
                        case 9:
                        case 32:
                          e_ = "";
                          break;
                        default:
                          32 !== ey && (e_ = " ")
                      }
                    break;
                  case 0:
                    e_ = "\\0";
                    break;
                  case 12:
                    e_ = "\\f";
                    break;
                  case 11:
                    e_ = "\\v";
                    break;
                  case 38:
                    0 === eO + eC + eE && (e$ = eB = 1,
                      e_ = "\f" + e_);
                    break;
                  case 108:
                    if (0 === eO + eC + eE + eT && 0 < ej)
                      switch (eL - ej) {
                        case 2:
                          112 === eM && 58 === ec.charCodeAt(eL - 3) && (eT = eM);
                        case 8:
                          111 === eD && (eT = eD)
                      }
                    break;
                  case 58:
                    0 === eO + eC + eE && (ej = eL);
                    break;
                  case 44:
                    0 === eC + eR + eO + eE && (e$ = 1,
                      e_ += "\r");
                    break;
                  case 34:
                  case 39:
                    0 === eC && (eO = eO === ey ? 0 : 0 === eO ? ey : eO);
                    break;
                  case 91:
                    0 === eO + eC + eR && eE++;
                    break;
                  case 93:
                    0 === eO + eC + eR && eE--;
                    break;
                  case 41:
                    0 === eO + eC + eE && eR--;
                    break;
                  case 40:
                    0 === eO + eC + eE && (0 === ep && (2 * eM + 3 * eD == 533 || (ep = 1)),
                      eR++);
                    break;
                  case 64:
                    0 === eC + eR + eO + eE + ej + ew && (ew = 1);
                    break;
                  case 42:
                  case 47:
                    if (!(0 < eO + eE + eR))
                      switch (eC) {
                        case 0:
                          switch (2 * ey + 3 * ec.charCodeAt(eL + 1)) {
                            case 235:
                              eC = 47;
                              break;
                            case 220:
                              eF = eL,
                                eC = 42
                          }
                          break;
                        case 42:
                          47 === ey && 42 === eM && eF + 2 !== eL && (33 === ec.charCodeAt(eF + 2) && (eV += ec.substring(eF, eL + 1)),
                            e_ = "",
                            eC = 0)
                      }
                }
                0 === eC && (eH += e_)
            }
            eD = eM,
              eM = ey,
              eL++
          }
          if (0 < (eF = eV.length)) {
            if (e$ = el,
              0 < eI && void 0 !== (ex = H(2, eV, e$, J, ek, eS, eF, ed, eh, ed)) && 0 === (eV = ex).length)
              return eZ + eV + eW;
            if (eV = e$.join(",") + "{" + eV + "}",
              0 != eA * eT) {
              switch (2 !== eA || L(eV, 2) || (eT = 0),
              eT) {
                case 111:
                  eV = eV.replace(eg, ":-moz-$1") + eV;
                  break;
                case 112:
                  eV = eV.replace(em, "::-webkit-input-$1") + eV.replace(em, "::-moz-$1") + eV.replace(em, ":-ms-input-$1") + eV
              }
              eT = 0
            }
          }
          return eZ + eV + eW
        }(eP, ec, el, 0, 0);
        return 0 < eI && void 0 !== (ed = H(-2, eh, ec, ec, ek, eS, eh.length, 0, 0, 0)) && (eh = ed),
          eT = 0,
          eS = ek = 1,
          eh
      }
      var et = /^\0+/g
        , eo = /[\0\r\f]/g
        , el = /: */g
        , ec = /zoo|gra/
        , ed = /([,: ])(transform)/g
        , eh = /,\r+?/g
        , ep = /([\t\r\n ])*\f?&/g
        , ef = /@(k\w+)\s*(\S*)\s*/
        , em = /::(place)/g
        , eg = /:(read-only)/g
        , ey = /[svh]\w+-[tblr]{2}/
        , eb = /\(\s*(.*)\s*\)/g
        , ew = /([\s\S]*?);/g
        , e_ = /-self|flex-/g
        , ex = /[^]*?(:[rp][el]a[\w-]+)[^]*/
        , eE = /stretch|:\s*\w+\-(?:conte|avail)/
        , eC = /([^-])(image-set\()/
        , eS = 1
        , ek = 1
        , eT = 0
        , eA = 1
        , eP = []
        , eR = []
        , eI = 0
        , eO = null
        , eN = 0;
      return B.use = function T(J) {
        switch (J) {
          case void 0:
          case null:
            eI = eR.length = 0;
            break;
          default:
            if ("function" == typeof J)
              eR[eI++] = J;
            else if ("object" == typeof J)
              for (var et = 0, eo = J.length; et < eo; ++et)
                T(J[et]);
            else
              eN = 0 | !!J
        }
        return T
      }
        ,
        B.set = U,
        void 0 !== J && U(J),
        B
    }, em = {
      animationIterationCount: 1,
      borderImageOutset: 1,
      borderImageSlice: 1,
      borderImageWidth: 1,
      boxFlex: 1,
      boxFlexGroup: 1,
      boxOrdinalGroup: 1,
      columnCount: 1,
      columns: 1,
      flex: 1,
      flexGrow: 1,
      flexPositive: 1,
      flexShrink: 1,
      flexNegative: 1,
      flexOrder: 1,
      gridRow: 1,
      gridRowEnd: 1,
      gridRowSpan: 1,
      gridRowStart: 1,
      gridColumn: 1,
      gridColumnEnd: 1,
      gridColumnSpan: 1,
      gridColumnStart: 1,
      msGridRow: 1,
      msGridRowSpan: 1,
      msGridColumn: 1,
      msGridColumnSpan: 1,
      fontWeight: 1,
      lineHeight: 1,
      opacity: 1,
      order: 1,
      orphans: 1,
      tabSize: 1,
      widows: 1,
      zIndex: 1,
      zoom: 1,
      WebkitLineClamp: 1,
      fillOpacity: 1,
      floodOpacity: 1,
      stopOpacity: 1,
      strokeDasharray: 1,
      strokeDashoffset: 1,
      strokeMiterlimit: 1,
      strokeOpacity: 1,
      strokeWidth: 1
    }, eg = eo(71068), ey = eo(8679), eb = eo.n(ey), ew = eo(83454);
    function v() {
      return (v = Object.assign || function (J) {
        for (var et = 1; et < arguments.length; et++) {
          var eo = arguments[et];
          for (var el in eo)
            Object.prototype.hasOwnProperty.call(eo, el) && (J[el] = eo[el])
        }
        return J
      }
      ).apply(this, arguments)
    }
    var g = function (J, et) {
      for (var eo = [J[0]], el = 0, ec = et.length; el < ec; el += 1)
        eo.push(et[el], J[el + 1]);
      return eo
    }
      , S = function (J) {
        return null !== J && "object" == typeof J && "[object Object]" === (J.toString ? J.toString() : Object.prototype.toString.call(J)) && !(0,
          ed.typeOf)(J)
      }
      , e_ = Object.freeze([])
      , ex = Object.freeze({});
    function b(J) {
      return "function" == typeof J
    }
    function _(J) {
      return J.displayName || J.name || "Component"
    }
    function N(J) {
      return J && "string" == typeof J.styledComponentId
    }
    var eE = void 0 !== ew && (ew.env.REACT_APP_SC_ATTR || ew.env.SC_ATTR) || "data-styled"
      , eC = "undefined" != typeof window && "HTMLElement" in window
      , eS = !!("boolean" == typeof SC_DISABLE_SPEEDY ? SC_DISABLE_SPEEDY : void 0 !== ew && void 0 !== ew.env.REACT_APP_SC_DISABLE_SPEEDY && "" !== ew.env.REACT_APP_SC_DISABLE_SPEEDY ? "false" !== ew.env.REACT_APP_SC_DISABLE_SPEEDY && ew.env.REACT_APP_SC_DISABLE_SPEEDY : void 0 !== ew && void 0 !== ew.env.SC_DISABLE_SPEEDY && "" !== ew.env.SC_DISABLE_SPEEDY && "false" !== ew.env.SC_DISABLE_SPEEDY && ew.env.SC_DISABLE_SPEEDY);
    function j(J) {
      for (var et = arguments.length, eo = Array(et > 1 ? et - 1 : 0), el = 1; el < et; el++)
        eo[el - 1] = arguments[el];
      throw Error("An error occurred. See https://git.io/JUIaE#" + J + " for more information." + (eo.length > 0 ? " Args: " + eo.join(", ") : ""))
    }
    var ek = function () {
      function e(J) {
        this.groupSizes = new Uint32Array(512),
          this.length = 512,
          this.tag = J
      }
      var J = e.prototype;
      return J.indexOfGroup = function (J) {
        for (var et = 0, eo = 0; eo < J; eo++)
          et += this.groupSizes[eo];
        return et
      }
        ,
        J.insertRules = function (J, et) {
          if (J >= this.groupSizes.length) {
            for (var eo = this.groupSizes, el = eo.length, ec = el; J >= ec;)
              (ec <<= 1) < 0 && j(16, "" + J);
            this.groupSizes = new Uint32Array(ec),
              this.groupSizes.set(eo),
              this.length = ec;
            for (var ed = el; ed < ec; ed++)
              this.groupSizes[ed] = 0
          }
          for (var eh = this.indexOfGroup(J + 1), ep = 0, ef = et.length; ep < ef; ep++)
            this.tag.insertRule(eh, et[ep]) && (this.groupSizes[J]++,
              eh++)
        }
        ,
        J.clearGroup = function (J) {
          if (J < this.length) {
            var et = this.groupSizes[J]
              , eo = this.indexOfGroup(J)
              , el = eo + et;
            this.groupSizes[J] = 0;
            for (var ec = eo; ec < el; ec++)
              this.tag.deleteRule(eo)
          }
        }
        ,
        J.getGroup = function (J) {
          var et = "";
          if (J >= this.length || 0 === this.groupSizes[J])
            return et;
          for (var eo = this.groupSizes[J], el = this.indexOfGroup(J), ec = el + eo, ed = el; ed < ec; ed++)
            et += this.tag.getRule(ed) + "/*!sc*/\n";
          return et
        }
        ,
        e
    }()
      , eT = new Map
      , eA = new Map
      , eP = 1
      , B = function (J) {
        if (eT.has(J))
          return eT.get(J);
        for (; eA.has(eP);)
          eP++;
        var et = eP++;
        return eT.set(J, et),
          eA.set(et, J),
          et
      }
      , M = function (J, et) {
        et >= eP && (eP = et + 1),
          eT.set(J, et),
          eA.set(et, J)
      }
      , eR = "style[" + eE + '][data-styled-version="5.3.5"]'
      , eI = RegExp("^" + eE + '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)')
      , F = function (J, et, eo) {
        for (var el, ec = eo.split(","), ed = 0, eh = ec.length; ed < eh; ed++)
          (el = ec[ed]) && J.registerName(et, el)
      }
      , Y = function (J, et) {
        for (var eo = (et.textContent || "").split("/*!sc*/\n"), el = [], ec = 0, ed = eo.length; ec < ed; ec++) {
          var eh = eo[ec].trim();
          if (eh) {
            var ep = eh.match(eI);
            if (ep) {
              var ef = 0 | parseInt(ep[1], 10)
                , em = ep[2];
              0 !== ef && (M(em, ef),
                F(J, em, ep[3]),
                J.getTag().insertRules(ef, el)),
                el.length = 0
            } else
              el.push(eh)
          }
        }
      }
      , q = function () {
        return "undefined" != typeof window && void 0 !== window.__webpack_nonce__ ? window.__webpack_nonce__ : null
      }
      , H = function (J) {
        var et = document.head
          , eo = J || et
          , el = document.createElement("style")
          , ec = function (J) {
            for (var et = J.childNodes, eo = et.length; eo >= 0; eo--) {
              var el = et[eo];
              if (el && 1 === el.nodeType && el.hasAttribute(eE))
                return el
            }
          }(eo)
          , ed = void 0 !== ec ? ec.nextSibling : null;
        el.setAttribute(eE, "active"),
          el.setAttribute("data-styled-version", "5.3.5");
        var eh = q();
        return eh && el.setAttribute("nonce", eh),
          eo.insertBefore(el, ed),
          el
      }
      , eO = function () {
        function e(J) {
          var et = this.element = H(J);
          et.appendChild(document.createTextNode("")),
            this.sheet = function (J) {
              if (J.sheet)
                return J.sheet;
              for (var et = document.styleSheets, eo = 0, el = et.length; eo < el; eo++) {
                var ec = et[eo];
                if (ec.ownerNode === J)
                  return ec
              }
              j(17)
            }(et),
            this.length = 0
        }
        var J = e.prototype;
        return J.insertRule = function (J, et) {
          try {
            return this.sheet.insertRule(et, J),
              this.length++,
              !0
          } catch (J) {
            return !1
          }
        }
          ,
          J.deleteRule = function (J) {
            this.sheet.deleteRule(J),
              this.length--
          }
          ,
          J.getRule = function (J) {
            var et = this.sheet.cssRules[J];
            return void 0 !== et && "string" == typeof et.cssText ? et.cssText : ""
          }
          ,
          e
      }()
      , eN = function () {
        function e(J) {
          var et = this.element = H(J);
          this.nodes = et.childNodes,
            this.length = 0
        }
        var J = e.prototype;
        return J.insertRule = function (J, et) {
          if (J <= this.length && J >= 0) {
            var eo = document.createTextNode(et)
              , el = this.nodes[J];
            return this.element.insertBefore(eo, el || null),
              this.length++,
              !0
          }
          return !1
        }
          ,
          J.deleteRule = function (J) {
            this.element.removeChild(this.nodes[J]),
              this.length--
          }
          ,
          J.getRule = function (J) {
            return J < this.length ? this.nodes[J].textContent : ""
          }
          ,
          e
      }()
      , eM = function () {
        function e(J) {
          this.rules = [],
            this.length = 0
        }
        var J = e.prototype;
        return J.insertRule = function (J, et) {
          return J <= this.length && (this.rules.splice(J, 0, et),
            this.length++,
            !0)
        }
          ,
          J.deleteRule = function (J) {
            this.rules.splice(J, 1),
              this.length--
          }
          ,
          J.getRule = function (J) {
            return J < this.length ? this.rules[J] : ""
          }
          ,
          e
      }()
      , eD = eC
      , ej = {
        isServer: !eC,
        useCSSOMInjection: !eS
      }
      , eL = function () {
        function e(J, et, eo) {
          void 0 === J && (J = ex),
            void 0 === et && (et = {}),
            this.options = v({}, ej, {}, J),
            this.gs = et,
            this.names = new Map(eo),
            this.server = !!J.isServer,
            !this.server && eC && eD && (eD = !1,
              function (J) {
                for (var et = document.querySelectorAll(eR), eo = 0, el = et.length; eo < el; eo++) {
                  var ec = et[eo];
                  ec && "active" !== ec.getAttribute(eE) && (Y(J, ec),
                    ec.parentNode && ec.parentNode.removeChild(ec))
                }
              }(this))
        }
        e.registerId = function (J) {
          return B(J)
        }
          ;
        var J = e.prototype;
        return J.reconstructWithOptions = function (J, et) {
          return void 0 === et && (et = !0),
            new e(v({}, this.options, {}, J), this.gs, et && this.names || void 0)
        }
          ,
          J.allocateGSInstance = function (J) {
            return this.gs[J] = (this.gs[J] || 0) + 1
          }
          ,
          J.getTag = function () {
            var J, et, eo, el, ec;
            return this.tag || (this.tag = (eo = (et = this.options).isServer,
              el = et.useCSSOMInjection,
              ec = et.target,
              J = eo ? new eM(ec) : el ? new eO(ec) : new eN(ec),
              new ek(J)))
          }
          ,
          J.hasNameForId = function (J, et) {
            return this.names.has(J) && this.names.get(J).has(et)
          }
          ,
          J.registerName = function (J, et) {
            if (B(J),
              this.names.has(J))
              this.names.get(J).add(et);
            else {
              var eo = new Set;
              eo.add(et),
                this.names.set(J, eo)
            }
          }
          ,
          J.insertRules = function (J, et, eo) {
            this.registerName(J, et),
              this.getTag().insertRules(B(J), eo)
          }
          ,
          J.clearNames = function (J) {
            this.names.has(J) && this.names.get(J).clear()
          }
          ,
          J.clearRules = function (J) {
            this.getTag().clearGroup(B(J)),
              this.clearNames(J)
          }
          ,
          J.clearTag = function () {
            this.tag = void 0
          }
          ,
          J.toString = function () {
            return function (J) {
              for (var et = J.getTag(), eo = et.length, el = "", ec = 0; ec < eo; ec++) {
                var ed, eh = (ed = ec,
                  eA.get(ed));
                if (void 0 !== eh) {
                  var ep = J.names.get(eh)
                    , ef = et.getGroup(ec);
                  if (ep && ef && ep.size) {
                    var em = eE + ".g" + ec + '[id="' + eh + '"]'
                      , eg = "";
                    void 0 !== ep && ep.forEach(function (J) {
                      J.length > 0 && (eg += J + ",")
                    }),
                      el += "" + ef + em + '{content:"' + eg + '"}/*!sc*/\n'
                  }
                }
              }
              return el
            }(this)
          }
          ,
          e
      }()
      , e$ = /(a)(d)/gi
      , Q = function (J) {
        return String.fromCharCode(J + (J > 25 ? 39 : 97))
      };
    function ee(J) {
      var et, eo = "";
      for (et = Math.abs(J); et > 52; et = et / 52 | 0)
        eo = Q(et % 52) + eo;
      return (Q(et % 52) + eo).replace(e$, "$1-$2")
    }
    var te = function (J, et) {
      for (var eo = et.length; eo;)
        J = 33 * J ^ et.charCodeAt(--eo);
      return J
    }
      , ne = function (J) {
        return te(5381, J)
      };
    function re(J) {
      for (var et = 0; et < J.length; et += 1) {
        var eo = J[et];
        if (b(eo) && !N(eo))
          return !1
      }
      return !0
    }
    var eB = ne("5.3.5")
      , eF = function () {
        function e(J, et, eo) {
          this.rules = J,
            this.staticRulesId = "",
            this.isStatic = (void 0 === eo || eo.isStatic) && re(J),
            this.componentId = et,
            this.baseHash = te(eB, et),
            this.baseStyle = eo,
            eL.registerId(et)
        }
        return e.prototype.generateAndInjectStyles = function (J, et, eo) {
          var el = this.componentId
            , ec = [];
          if (this.baseStyle && ec.push(this.baseStyle.generateAndInjectStyles(J, et, eo)),
            this.isStatic && !eo.hash) {
            if (this.staticRulesId && et.hasNameForId(el, this.staticRulesId))
              ec.push(this.staticRulesId);
            else {
              var ed = Ne(this.rules, J, et, eo).join("")
                , eh = ee(te(this.baseHash, ed) >>> 0);
              if (!et.hasNameForId(el, eh)) {
                var ep = eo(ed, "." + eh, void 0, el);
                et.insertRules(el, eh, ep)
              }
              ec.push(eh),
                this.staticRulesId = eh
            }
          } else {
            for (var ef = this.rules.length, em = te(this.baseHash, eo.hash), eg = "", ey = 0; ey < ef; ey++) {
              var eb = this.rules[ey];
              if ("string" == typeof eb)
                eg += eb;
              else if (eb) {
                var ew = Ne(eb, J, et, eo)
                  , e_ = Array.isArray(ew) ? ew.join("") : ew;
                em = te(em, e_ + ey),
                  eg += e_
              }
            }
            if (eg) {
              var ex = ee(em >>> 0);
              if (!et.hasNameForId(el, ex)) {
                var eE = eo(eg, "." + ex, void 0, el);
                et.insertRules(el, ex, eE)
              }
              ec.push(ex)
            }
          }
          return ec.join(" ")
        }
          ,
          e
      }()
      , eU = /^\s*\/\/.*$/gm
      , ez = [":", "[", ".", "#"];
    function ce(J) {
      var et, eo, el, ec, ed = void 0 === J ? ex : J, eh = ed.options, ep = void 0 === eh ? ex : eh, ef = ed.plugins, em = void 0 === ef ? e_ : ef, eg = new stylis_browser_esm(ep), ey = [], eb = function (J) {
        function t(et) {
          if (et)
            try {
              J(et + "}")
            } catch (J) { }
        }
        return function (et, eo, el, ec, ed, eh, ep, ef, em, eg) {
          switch (et) {
            case 1:
              if (0 === em && 64 === eo.charCodeAt(0))
                return J(eo + ";"),
                  "";
              break;
            case 2:
              if (0 === ef)
                return eo + "/*|*/";
              break;
            case 3:
              switch (ef) {
                case 102:
                case 112:
                  return J(el[0] + eo),
                    "";
                default:
                  return eo + (0 === eg ? "/*|*/" : "")
              }
            case -2:
              eo.split("/*|*/}").forEach(t)
          }
        }
      }(function (J) {
        ey.push(J)
      }), f = function (J, el, ed) {
        return 0 === el && -1 !== ez.indexOf(ed[eo.length]) || ed.match(ec) ? J : "." + et
      };
      function m(J, ed, eh, ep) {
        void 0 === ep && (ep = "&");
        var ef = J.replace(eU, "")
          , em = ed && eh ? eh + " " + ed + " { " + ef + " }" : ef;
        return et = ep,
          el = RegExp("\\" + (eo = ed) + "\\b", "g"),
          ec = RegExp("(\\" + eo + "\\b){2,}"),
          eg(eh || !ed ? "" : ed, em)
      }
      return eg.use([].concat(em, [function (J, et, ec) {
        2 === J && ec.length && ec[0].lastIndexOf(eo) > 0 && (ec[0] = ec[0].replace(el, f))
      }
        , eb, function (J) {
          if (-2 === J) {
            var et = ey;
            return ey = [],
              et
          }
        }
      ])),
        m.hash = em.length ? em.reduce(function (J, et) {
          return et.name || j(15),
            te(J, et.name)
        }, 5381).toString() : "",
        m
    }
    var eH = eh.createContext()
      , eV = (eH.Consumer,
        eh.createContext())
      , eW = (eV.Consumer,
        new eL)
      , eZ = ce();
    function fe() {
      return (0,
        eh.useContext)(eH) || eW
    }
    function ye(J) {
      var et = (0,
        eh.useState)(J.stylisPlugins)
        , eo = et[0]
        , el = et[1]
        , ec = fe()
        , ed = (0,
          eh.useMemo)(function () {
            var et = ec;
            return J.sheet ? et = J.sheet : J.target && (et = et.reconstructWithOptions({
              target: J.target
            }, !1)),
              J.disableCSSOMInjection && (et = et.reconstructWithOptions({
                useCSSOMInjection: !1
              })),
              et
          }, [J.disableCSSOMInjection, J.sheet, J.target])
        , ep = (0,
          eh.useMemo)(function () {
            return ce({
              options: {
                prefix: !J.disableVendorPrefixes
              },
              plugins: eo
            })
          }, [J.disableVendorPrefixes, eo]);
      return (0,
        eh.useEffect)(function () {
          ef()(eo, J.stylisPlugins) || el(J.stylisPlugins)
        }, [J.stylisPlugins]),
        eh.createElement(eH.Provider, {
          value: ed
        }, eh.createElement(eV.Provider, {
          value: ep
        }, J.children))
    }
    var eG = function () {
      function e(J, et) {
        var eo = this;
        this.inject = function (J, et) {
          void 0 === et && (et = eZ);
          var el = eo.name + et.hash;
          J.hasNameForId(eo.id, el) || J.insertRules(eo.id, el, et(eo.rules, el, "@keyframes"))
        }
          ,
          this.toString = function () {
            return j(12, String(eo.name))
          }
          ,
          this.name = J,
          this.id = "sc-keyframes-" + J,
          this.rules = et
      }
      return e.prototype.getName = function (J) {
        return void 0 === J && (J = eZ),
          this.name + J.hash
      }
        ,
        e
    }()
      , eY = /([A-Z])/
      , eK = /([A-Z])/g
      , eJ = /^ms-/
      , Ee = function (J) {
        return "-" + J.toLowerCase()
      };
    function be(J) {
      return eY.test(J) ? J.replace(eK, Ee).replace(eJ, "-ms-") : J
    }
    var _e = function (J) {
      return null == J || !1 === J || "" === J
    };
    function Ne(J, et, eo, el) {
      if (Array.isArray(J)) {
        for (var ec, ed = [], eh = 0, ep = J.length; eh < ep; eh += 1)
          "" !== (ec = Ne(J[eh], et, eo, el)) && (Array.isArray(ec) ? ed.push.apply(ed, ec) : ed.push(ec));
        return ed
      }
      return _e(J) ? "" : N(J) ? "." + J.styledComponentId : b(J) ? "function" != typeof J || J.prototype && J.prototype.isReactComponent || !et ? J : Ne(J(et), et, eo, el) : J instanceof eG ? eo ? (J.inject(eo, el),
        J.getName(el)) : J : S(J) ? function e(J, et) {
          var eo, el = [];
          for (var ec in J)
            J.hasOwnProperty(ec) && !_e(J[ec]) && (Array.isArray(J[ec]) && J[ec].isCss || b(J[ec]) ? el.push(be(ec) + ":", J[ec], ";") : S(J[ec]) ? el.push.apply(el, e(J[ec], ec)) : el.push(be(ec) + ": " + (null == (eo = J[ec]) || "boolean" == typeof eo || "" === eo ? "" : "number" != typeof eo || 0 === eo || ec in em ? String(eo).trim() : eo + "px") + ";"));
          return et ? [et + " {"].concat(el, ["}"]) : el
        }(J) : J.toString()
    }
    var Ae = function (J) {
      return Array.isArray(J) && (J.isCss = !0),
        J
    };
    function Ce(J) {
      for (var et = arguments.length, eo = Array(et > 1 ? et - 1 : 0), el = 1; el < et; el++)
        eo[el - 1] = arguments[el];
      return b(J) || S(J) ? Ae(Ne(g(e_, [J].concat(eo)))) : 0 === eo.length && 1 === J.length && "string" == typeof J[0] ? J : Ae(Ne(g(J, eo)))
    }
    var eQ = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g
      , eX = /(^-|-$)/g;
    function Te(J) {
      return J.replace(eQ, "-").replace(eX, "")
    }
    function ke(J) {
      return "string" == typeof J
    }
    var Ve = function (J) {
      return "function" == typeof J || "object" == typeof J && null !== J && !Array.isArray(J)
    }
      , e0 = eh.createContext();
    function Fe(J) {
      var et = (0,
        eh.useContext)(e0)
        , eo = (0,
          eh.useMemo)(function () {
            var eo;
            return (eo = J.theme) ? b(eo) ? eo(et) : Array.isArray(eo) || "object" != typeof eo ? j(8) : et ? v({}, et, {}, eo) : eo : j(14)
          }, [J.theme, et]);
      return J.children ? eh.createElement(e0.Provider, {
        value: eo
      }, J.children) : null
    }
    e0.Consumer;
    var e1 = {}
      , He = function (J) {
        return function e(J, et, eo) {
          if (void 0 === eo && (eo = ex),
            !(0,
              ed.isValidElementType)(et))
            return j(1, String(et));
          var s = function () {
            return J(et, eo, Ce.apply(void 0, arguments))
          };
          return s.withConfig = function (el) {
            return e(J, et, v({}, eo, {}, el))
          }
            ,
            s.attrs = function (el) {
              return e(J, et, v({}, eo, {
                attrs: Array.prototype.concat(eo.attrs, el).filter(Boolean)
              }))
            }
            ,
            s
        }(function qe(J, et, eo) {
          var el = N(J)
            , ec = !ke(J)
            , ed = et.attrs
            , ep = void 0 === ed ? e_ : ed
            , ef = et.componentId
            , em = void 0 === ef ? (ek = et.displayName,
              eT = et.parentComponentId,
              e1[eA = "string" != typeof ek ? "sc" : Te(ek)] = (e1[eA] || 0) + 1,
              eP = eA + "-" + ee(ne("5.3.5" + eA + e1[eA]) >>> 0),
              eT ? eT + "-" + eP : eP) : ef
            , ey = et.displayName
            , ew = void 0 === ey ? ke(J) ? "styled." + J : "Styled(" + _(J) + ")" : ey
            , eE = et.displayName && et.componentId ? Te(et.displayName) + "-" + et.componentId : et.componentId || em
            , eC = el && J.attrs ? Array.prototype.concat(J.attrs, ep).filter(Boolean) : ep
            , eS = et.shouldForwardProp;
          el && J.shouldForwardProp && (eS = et.shouldForwardProp ? function (eo, el, ec) {
            return J.shouldForwardProp(eo, el, ec) && et.shouldForwardProp(eo, el, ec)
          }
            : J.shouldForwardProp);
          var ek, eT, eA, eP, eR, eI = new eF(eo, eE, el ? J.componentStyle : void 0), eO = eI.isStatic && 0 === ep.length, O = function (J, et) {
            return function (J, et, eo, el) {
              var ec, ed, ep, ef, em, ey, eb, ew = J.attrs, e_ = J.componentStyle, eE = J.defaultProps, eC = J.foldedComponentIds, eS = J.shouldForwardProp, ek = J.styledComponentId, eT = J.target, eA = (ec = (0,
                eh.useContext)(e0),
                void 0 === (ed = eE) && (ed = ex),
                void 0 === (ep = et.theme !== ed.theme && et.theme || ec || ed.theme || ex) && (ep = ex),
                ef = v({}, et, {
                  theme: ep
                }),
                em = {},
                ew.forEach(function (J) {
                  var et, eo, el, ec = J;
                  for (et in b(ec) && (ec = ec(ef)),
                    ec)
                    ef[et] = em[et] = "className" === et ? (eo = em[et],
                      el = ec[et],
                      eo && el ? eo + " " + el : eo || el) : ec[et]
                }),
                [ef, em]), eP = eA[0], eR = eA[1], eI = (ey = fe(),
                  eb = (0,
                    eh.useContext)(eV) || eZ,
                  el ? e_.generateAndInjectStyles(ex, ey, eb) : e_.generateAndInjectStyles(eP, ey, eb)), eO = eR.$as || et.$as || eR.as || et.as || eT, eN = ke(eO), eM = eR !== et ? v({}, et, {}, eR) : et, eD = {};
              for (var ej in eM)
                "$" !== ej[0] && "as" !== ej && ("forwardedAs" === ej ? eD.as = eM[ej] : (eS ? eS(ej, eg.Z, eO) : !eN || (0,
                  eg.Z)(ej)) && (eD[ej] = eM[ej]));
              return et.style && eR.style !== et.style && (eD.style = v({}, et.style, {}, eR.style)),
                eD.className = Array.prototype.concat(eC, ek, eI !== ek ? eI : null, et.className, eR.className).filter(Boolean).join(" "),
                eD.ref = eo,
                (0,
                  eh.createElement)(eO, eD)
            }(eR, J, et, eO)
          };
          return O.displayName = ew,
            (eR = eh.forwardRef(O)).attrs = eC,
            eR.componentStyle = eI,
            eR.displayName = ew,
            eR.shouldForwardProp = eS,
            eR.foldedComponentIds = el ? Array.prototype.concat(J.foldedComponentIds, J.styledComponentId) : e_,
            eR.styledComponentId = eE,
            eR.target = el ? J.target : J,
            eR.withComponent = function (J) {
              var el = et.componentId
                , ec = function (J, et) {
                  if (null == J)
                    return {};
                  var eo, el, ec = {}, ed = Object.keys(J);
                  for (el = 0; el < ed.length; el++)
                    et.indexOf(eo = ed[el]) >= 0 || (ec[eo] = J[eo]);
                  return ec
                }(et, ["componentId"])
                , ed = el && el + "-" + (ke(J) ? J : Te(_(J)));
              return qe(J, v({}, ec, {
                attrs: eC,
                componentId: ed
              }), eo)
            }
            ,
            Object.defineProperty(eR, "defaultProps", {
              get: function () {
                return this._foldedDefaultProps
              },
              set: function (et) {
                this._foldedDefaultProps = el ? function Me(J) {
                  for (var et = arguments.length, eo = Array(et > 1 ? et - 1 : 0), el = 1; el < et; el++)
                    eo[el - 1] = arguments[el];
                  for (var ec = 0; ec < eo.length; ec++) {
                    var ed = eo[ec];
                    if (Ve(ed))
                      for (var eh in ed)
                        "__proto__" !== eh && "constructor" !== eh && "prototype" !== eh && function (J, et, eo) {
                          var el = J[eo];
                          Ve(et) && Ve(el) ? Me(el, et) : J[eo] = et
                        }(J, ed[eh], eh)
                  }
                  return J
                }({}, J.defaultProps, et) : et
              }
            }),
            eR.toString = function () {
              return "." + eR.styledComponentId
            }
            ,
            ec && eb()(eR, J, {
              attrs: !0,
              componentStyle: !0,
              displayName: !0,
              foldedComponentIds: !0,
              shouldForwardProp: !0,
              styledComponentId: !0,
              target: !0,
              withComponent: !0
            }),
            eR
        }, J)
      };
    ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "textPath", "tspan"].forEach(function (J) {
      He[J] = He(J)
    }),
      (el = (function (J, et) {
        this.rules = J,
          this.componentId = et,
          this.isStatic = re(J),
          eL.registerId(this.componentId + 1)
      }
      ).prototype).createStyles = function (J, et, eo, el) {
        var ec = el(Ne(this.rules, et, eo, el).join(""), "")
          , ed = this.componentId + J;
        eo.insertRules(ed, ed, ec)
      }
      ,
      el.removeStyles = function (J, et) {
        et.clearRules(this.componentId + J)
      }
      ,
      el.renderStyles = function (J, et, eo, el) {
        J > 2 && eL.registerId(this.componentId + J),
          this.removeStyles(J, eo),
          this.createStyles(J, et, eo, el)
      }
      ,
      (ec = (function () {
        var J = this;
        this._emitSheetCSS = function () {
          var et = J.instance.toString();
          if (!et)
            return "";
          var eo = q();
          return "<style " + [eo && 'nonce="' + eo + '"', eE + '="true"', 'data-styled-version="5.3.5"'].filter(Boolean).join(" ") + ">" + et + "</style>"
        }
          ,
          this.getStyleTags = function () {
            return J.sealed ? j(2) : J._emitSheetCSS()
          }
          ,
          this.getStyleElement = function () {
            if (J.sealed)
              return j(2);
            var et, eo = ((et = {})[eE] = "",
              et["data-styled-version"] = "5.3.5",
              et.dangerouslySetInnerHTML = {
                __html: J.instance.toString()
              },
              et), el = q();
            return el && (eo.nonce = el),
              [eh.createElement("style", v({}, eo, {
                key: "sc-0-0"
              }))]
          }
          ,
          this.seal = function () {
            J.sealed = !0
          }
          ,
          this.instance = new eL({
            isServer: !0
          }),
          this.sealed = !1
      }
      ).prototype).collectStyles = function (J) {
        return this.sealed ? j(2) : eh.createElement(ye, {
          sheet: this.instance
        }, J)
      }
      ,
      ec.interleaveWithNodeStream = function (J) {
        return j(3)
      }
      ;
    var e2 = He
  },
  70655: function (J, et, eo) {
    "use strict";
    eo.r(et),
      eo.d(et, {
        __assign: function () {
          return __assign
        },
        __asyncDelegator: function () {
          return __asyncDelegator
        },
        __asyncGenerator: function () {
          return __asyncGenerator
        },
        __asyncValues: function () {
          return __asyncValues
        },
        __await: function () {
          return __await
        },
        __awaiter: function () {
          return __awaiter
        },
        __classPrivateFieldGet: function () {
          return __classPrivateFieldGet
        },
        __classPrivateFieldSet: function () {
          return __classPrivateFieldSet
        },
        __createBinding: function () {
          return __createBinding
        },
        __decorate: function () {
          return __decorate
        },
        __exportStar: function () {
          return __exportStar
        },
        __extends: function () {
          return __extends
        },
        __generator: function () {
          return __generator
        },
        __importDefault: function () {
          return __importDefault
        },
        __importStar: function () {
          return __importStar
        },
        __makeTemplateObject: function () {
          return __makeTemplateObject
        },
        __metadata: function () {
          return __metadata
        },
        __param: function () {
          return __param
        },
        __read: function () {
          return __read
        },
        __rest: function () {
          return __rest
        },
        __spread: function () {
          return __spread
        },
        __spreadArrays: function () {
          return __spreadArrays
        },
        __values: function () {
          return __values
        }
      });
    /*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
    var extendStatics = function (J, et) {
      return (extendStatics = Object.setPrototypeOf || ({
        __proto__: []
      }) instanceof Array && function (J, et) {
        J.__proto__ = et
      }
        || function (J, et) {
          for (var eo in et)
            et.hasOwnProperty(eo) && (J[eo] = et[eo])
        }
      )(J, et)
    };
    function __extends(J, et) {
      function __() {
        this.constructor = J
      }
      extendStatics(J, et),
        J.prototype = null === et ? Object.create(et) : (__.prototype = et.prototype,
          new __)
    }
    var __assign = function () {
      return (__assign = Object.assign || function (J) {
        for (var et, eo = 1, el = arguments.length; eo < el; eo++)
          for (var ec in et = arguments[eo])
            Object.prototype.hasOwnProperty.call(et, ec) && (J[ec] = et[ec]);
        return J
      }
      ).apply(this, arguments)
    };
    function __rest(J, et) {
      var eo = {};
      for (var el in J)
        Object.prototype.hasOwnProperty.call(J, el) && 0 > et.indexOf(el) && (eo[el] = J[el]);
      if (null != J && "function" == typeof Object.getOwnPropertySymbols)
        for (var ec = 0, el = Object.getOwnPropertySymbols(J); ec < el.length; ec++)
          0 > et.indexOf(el[ec]) && Object.prototype.propertyIsEnumerable.call(J, el[ec]) && (eo[el[ec]] = J[el[ec]]);
      return eo
    }
    function __decorate(J, et, eo, el) {
      var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        eh = Reflect.decorate(J, et, eo, el);
      else
        for (var ep = J.length - 1; ep >= 0; ep--)
          (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
      return ed > 3 && eh && Object.defineProperty(et, eo, eh),
        eh
    }
    function __param(J, et) {
      return function (eo, el) {
        et(eo, el, J)
      }
    }
    function __metadata(J, et) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(J, et)
    }
    function __awaiter(J, et, eo, el) {
      return new (eo || (eo = Promise))(function (ec, ed) {
        function fulfilled(J) {
          try {
            step(el.next(J))
          } catch (J) {
            ed(J)
          }
        }
        function rejected(J) {
          try {
            step(el.throw(J))
          } catch (J) {
            ed(J)
          }
        }
        function step(J) {
          var et;
          J.done ? ec(J.value) : ((et = J.value) instanceof eo ? et : new eo(function (J) {
            J(et)
          }
          )).then(fulfilled, rejected)
        }
        step((el = el.apply(J, et || [])).next())
      }
      )
    }
    function __generator(J, et) {
      var eo, el, ec, ed, eh = {
        label: 0,
        sent: function () {
          if (1 & ec[0])
            throw ec[1];
          return ec[1]
        },
        trys: [],
        ops: []
      };
      return ed = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      },
        "function" == typeof Symbol && (ed[Symbol.iterator] = function () {
          return this
        }
        ),
        ed;
      function verb(ed) {
        return function (ep) {
          return function (ed) {
            if (eo)
              throw TypeError("Generator is already executing.");
            for (; eh;)
              try {
                if (eo = 1,
                  el && (ec = 2 & ed[0] ? el.return : ed[0] ? el.throw || ((ec = el.return) && ec.call(el),
                    0) : el.next) && !(ec = ec.call(el, ed[1])).done)
                  return ec;
                switch (el = 0,
                ec && (ed = [2 & ed[0], ec.value]),
                ed[0]) {
                  case 0:
                  case 1:
                    ec = ed;
                    break;
                  case 4:
                    return eh.label++,
                    {
                      value: ed[1],
                      done: !1
                    };
                  case 5:
                    eh.label++,
                      el = ed[1],
                      ed = [0];
                    continue;
                  case 7:
                    ed = eh.ops.pop(),
                      eh.trys.pop();
                    continue;
                  default:
                    if (!(ec = (ec = eh.trys).length > 0 && ec[ec.length - 1]) && (6 === ed[0] || 2 === ed[0])) {
                      eh = 0;
                      continue
                    }
                    if (3 === ed[0] && (!ec || ed[1] > ec[0] && ed[1] < ec[3])) {
                      eh.label = ed[1];
                      break
                    }
                    if (6 === ed[0] && eh.label < ec[1]) {
                      eh.label = ec[1],
                        ec = ed;
                      break
                    }
                    if (ec && eh.label < ec[2]) {
                      eh.label = ec[2],
                        eh.ops.push(ed);
                      break
                    }
                    ec[2] && eh.ops.pop(),
                      eh.trys.pop();
                    continue
                }
                ed = et.call(J, eh)
              } catch (J) {
                ed = [6, J],
                  el = 0
              } finally {
                eo = ec = 0
              }
            if (5 & ed[0])
              throw ed[1];
            return {
              value: ed[0] ? ed[1] : void 0,
              done: !0
            }
          }([ed, ep])
        }
      }
    }
    function __createBinding(J, et, eo, el) {
      void 0 === el && (el = eo),
        J[el] = et[eo]
    }
    function __exportStar(J, et) {
      for (var eo in J)
        "default" === eo || et.hasOwnProperty(eo) || (et[eo] = J[eo])
    }
    function __values(J) {
      var et = "function" == typeof Symbol && Symbol.iterator
        , eo = et && J[et]
        , el = 0;
      if (eo)
        return eo.call(J);
      if (J && "number" == typeof J.length)
        return {
          next: function () {
            return J && el >= J.length && (J = void 0),
            {
              value: J && J[el++],
              done: !J
            }
          }
        };
      throw TypeError(et ? "Object is not iterable." : "Symbol.iterator is not defined.")
    }
    function __read(J, et) {
      var eo = "function" == typeof Symbol && J[Symbol.iterator];
      if (!eo)
        return J;
      var el, ec, ed = eo.call(J), eh = [];
      try {
        for (; (void 0 === et || et-- > 0) && !(el = ed.next()).done;)
          eh.push(el.value)
      } catch (J) {
        ec = {
          error: J
        }
      } finally {
        try {
          el && !el.done && (eo = ed.return) && eo.call(ed)
        } finally {
          if (ec)
            throw ec.error
        }
      }
      return eh
    }
    function __spread() {
      for (var J = [], et = 0; et < arguments.length; et++)
        J = J.concat(__read(arguments[et]));
      return J
    }
    function __spreadArrays() {
      for (var J = 0, et = 0, eo = arguments.length; et < eo; et++)
        J += arguments[et].length;
      for (var el = Array(J), ec = 0, et = 0; et < eo; et++)
        for (var ed = arguments[et], eh = 0, ep = ed.length; eh < ep; eh++,
          ec++)
          el[ec] = ed[eh];
      return el
    }
    function __await(J) {
      return this instanceof __await ? (this.v = J,
        this) : new __await(J)
    }
    function __asyncGenerator(J, et, eo) {
      if (!Symbol.asyncIterator)
        throw TypeError("Symbol.asyncIterator is not defined.");
      var el, ec = eo.apply(J, et || []), ed = [];
      return el = {},
        verb("next"),
        verb("throw"),
        verb("return"),
        el[Symbol.asyncIterator] = function () {
          return this
        }
        ,
        el;
      function verb(J) {
        ec[J] && (el[J] = function (et) {
          return new Promise(function (eo, el) {
            ed.push([J, et, eo, el]) > 1 || resume(J, et)
          }
          )
        }
        )
      }
      function resume(J, et) {
        try {
          var eo;
          (eo = ec[J](et)).value instanceof __await ? Promise.resolve(eo.value.v).then(fulfill, reject) : settle(ed[0][2], eo)
        } catch (J) {
          settle(ed[0][3], J)
        }
      }
      function fulfill(J) {
        resume("next", J)
      }
      function reject(J) {
        resume("throw", J)
      }
      function settle(J, et) {
        J(et),
          ed.shift(),
          ed.length && resume(ed[0][0], ed[0][1])
      }
    }
    function __asyncDelegator(J) {
      var et, eo;
      return et = {},
        verb("next"),
        verb("throw", function (J) {
          throw J
        }),
        verb("return"),
        et[Symbol.iterator] = function () {
          return this
        }
        ,
        et;
      function verb(el, ec) {
        et[el] = J[el] ? function (et) {
          return (eo = !eo) ? {
            value: __await(J[el](et)),
            done: "return" === el
          } : ec ? ec(et) : et
        }
          : ec
      }
    }
    function __asyncValues(J) {
      if (!Symbol.asyncIterator)
        throw TypeError("Symbol.asyncIterator is not defined.");
      var et, eo = J[Symbol.asyncIterator];
      return eo ? eo.call(J) : (J = __values(J),
        et = {},
        verb("next"),
        verb("throw"),
        verb("return"),
        et[Symbol.asyncIterator] = function () {
          return this
        }
        ,
        et);
      function verb(eo) {
        et[eo] = J[eo] && function (et) {
          return new Promise(function (el, ec) {
            !function (J, et, eo, el) {
              Promise.resolve(el).then(function (et) {
                J({
                  value: et,
                  done: eo
                })
              }, et)
            }(el, ec, (et = J[eo](et)).done, et.value)
          }
          )
        }
      }
    }
    function __makeTemplateObject(J, et) {
      return Object.defineProperty ? Object.defineProperty(J, "raw", {
        value: et
      }) : J.raw = et,
        J
    }
    function __importStar(J) {
      if (J && J.__esModule)
        return J;
      var et = {};
      if (null != J)
        for (var eo in J)
          Object.hasOwnProperty.call(J, eo) && (et[eo] = J[eo]);
      return et.default = J,
        et
    }
    function __importDefault(J) {
      return J && J.__esModule ? J : {
        default: J
      }
    }
    function __classPrivateFieldGet(J, et) {
      if (!et.has(J))
        throw TypeError("attempted to get private field on non-instance");
      return et.get(J)
    }
    function __classPrivateFieldSet(J, et, eo) {
      if (!et.has(J))
        throw TypeError("attempted to set private field on non-instance");
      return et.set(J, eo),
        eo
    }
  },
  53250: function (J, et, eo) {
    "use strict";
    /**
* @license React
* use-sync-external-store-shim.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
    var el = eo(67294)
      , ec = "function" == typeof Object.is ? Object.is : function (J, et) {
        return J === et && (0 !== J || 1 / J == 1 / et) || J != J && et != et
      }
      , ed = el.useState
      , eh = el.useEffect
      , ep = el.useLayoutEffect
      , ef = el.useDebugValue;
    function r(J) {
      var et = J.getSnapshot;
      J = J.value;
      try {
        var eo = et();
        return !ec(J, eo)
      } catch (J) {
        return !0
      }
    }
    var em = "undefined" == typeof window || void 0 === window.document || void 0 === window.document.createElement ? function (J, et) {
      return et()
    }
      : function (J, et) {
        var eo = et()
          , el = ed({
            inst: {
              value: eo,
              getSnapshot: et
            }
          })
          , ec = el[0].inst
          , em = el[1];
        return ep(function () {
          ec.value = eo,
            ec.getSnapshot = et,
            r(ec) && em({
              inst: ec
            })
        }, [J, eo, et]),
          eh(function () {
            return r(ec) && em({
              inst: ec
            }),
              J(function () {
                r(ec) && em({
                  inst: ec
                })
              })
          }, [J]),
          ef(eo),
          eo
      }
      ;
    et.useSyncExternalStore = void 0 !== el.useSyncExternalStore ? el.useSyncExternalStore : em
  },
  50139: function (J, et, eo) {
    "use strict";
    /**
* @license React
* use-sync-external-store-shim/with-selector.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
    var el = eo(67294)
      , ec = eo(61688)
      , ed = "function" == typeof Object.is ? Object.is : function (J, et) {
        return J === et && (0 !== J || 1 / J == 1 / et) || J != J && et != et
      }
      , eh = ec.useSyncExternalStore
      , ep = el.useRef
      , ef = el.useEffect
      , em = el.useMemo
      , eg = el.useDebugValue;
    et.useSyncExternalStoreWithSelector = function (J, et, eo, el, ec) {
      var ey = ep(null);
      if (null === ey.current) {
        var eb = {
          hasValue: !1,
          value: null
        };
        ey.current = eb
      } else
        eb = ey.current;
      var ew = eh(J, (ey = em(function () {
        function a(et) {
          if (!ep) {
            if (ep = !0,
              J = et,
              et = el(et),
              void 0 !== ec && eb.hasValue) {
              var eo = eb.value;
              if (ec(eo, et))
                return eh = eo
            }
            return eh = et
          }
          if (eo = eh,
            ed(J, et))
            return eo;
          var ef = el(et);
          return void 0 !== ec && ec(eo, ef) ? eo : (J = et,
            eh = ef)
        }
        var J, eh, ep = !1, ef = void 0 === eo ? null : eo;
        return [function () {
          return a(et())
        }
          , null === ef ? void 0 : function () {
            return a(ef())
          }
        ]
      }, [et, eo, el, ec]))[0], ey[1]);
      return ef(function () {
        eb.hasValue = !0,
          eb.value = ew
      }, [ew]),
        eg(ew),
        ew
    }
  },
  61688: function (J, et, eo) {
    "use strict";
    J.exports = eo(53250)
  },
  52798: function (J, et, eo) {
    "use strict";
    J.exports = eo(50139)
  },
  94927: function (J, et, eo) {
    J.exports = function (J, et) {
      if (config("noDeprecation"))
        return J;
      var eo = !1;
      return function () {
        if (!eo) {
          if (config("throwDeprecation"))
            throw Error(et);
          config("traceDeprecation") ? console.trace(et) : console.warn(et),
            eo = !0
        }
        return J.apply(this, arguments)
      }
    }
      ;
    function config(J) {
      try {
        if (!eo.g.localStorage)
          return !1
      } catch (J) {
        return !1
      }
      var et = eo.g.localStorage[J];
      return null != et && "true" === String(et).toLowerCase()
    }
  },
  47529: function (J) {
    J.exports = function () {
      for (var J = {}, eo = 0; eo < arguments.length; eo++) {
        var el = arguments[eo];
        for (var ec in el)
          et.call(el, ec) && (J[ec] = el[ec])
      }
      return J
    }
      ;
    var et = Object.prototype.hasOwnProperty
  },
  35883: function () { },
  46601: function () { },
  29120: function () { },
  46586: function () { },
  36559: function (J, et, eo) {
    "use strict";
    let el = eo(85346);
    J.exports = pino;
    let ec = function () {
      function defd(J) {
        return void 0 !== J && J
      }
      try {
        if ("undefined" != typeof globalThis)
          return globalThis;
        return Object.defineProperty(Object.prototype, "globalThis", {
          get: function () {
            return delete Object.prototype.globalThis,
              this.globalThis = this
          },
          configurable: !0
        }),
          globalThis
      } catch (J) {
        return defd(self) || defd(window) || defd(this) || {}
      }
    }().console || {};
    function pino(J) {
      var et;
      (J = J || {}).browser = J.browser || {};
      let eo = J.browser.transmit;
      if (eo && "function" != typeof eo.send)
        throw Error("pino: transmit option must have a send function");
      let el = J.browser.write || ec;
      J.browser.write && (J.browser.asObject = !0);
      let ed = J.serializers || {}
        , eh = function (J, et) {
          if (Array.isArray(J)) {
            let et = J.filter(function (J) {
              return "!stdSerializers.err" !== J
            });
            return et
          }
          return !0 === J && Object.keys(et)
        }(J.browser.serialize, ed)
        , ep = J.browser.serialize;
      Array.isArray(J.browser.serialize) && J.browser.serialize.indexOf("!stdSerializers.err") > -1 && (ep = !1),
        "function" == typeof el && (el.error = el.fatal = el.warn = el.info = el.debug = el.trace = el),
        !1 === J.enabled && (J.level = "silent");
      let ef = J.level || "info"
        , em = Object.create(el);
      em.log || (em.log = noop),
        Object.defineProperty(em, "levelVal", {
          get: function () {
            return "silent" === this.level ? 1 / 0 : this.levels.values[this.level]
          }
        }),
        Object.defineProperty(em, "level", {
          get: function () {
            return this._level
          },
          set: function (J) {
            if ("silent" !== J && !this.levels.values[J])
              throw Error("unknown level " + J);
            this._level = J,
              set(eg, em, "error", "log"),
              set(eg, em, "fatal", "error"),
              set(eg, em, "warn", "error"),
              set(eg, em, "info", "log"),
              set(eg, em, "debug", "log"),
              set(eg, em, "trace", "log")
          }
        });
      let eg = {
        transmit: eo,
        serialize: eh,
        asObject: J.browser.asObject,
        levels: ["error", "fatal", "warn", "info", "debug", "trace"],
        timestamp: "function" == typeof (et = J).timestamp ? et.timestamp : !1 === et.timestamp ? nullTime : epochTime
      };
      return em.levels = pino.levels,
        em.level = ef,
        em.setMaxListeners = em.getMaxListeners = em.emit = em.addListener = em.on = em.prependListener = em.once = em.prependOnceListener = em.removeListener = em.removeAllListeners = em.listeners = em.listenerCount = em.eventNames = em.write = em.flush = noop,
        em.serializers = ed,
        em._serialize = eh,
        em._stdErrSerialize = ep,
        em.child = function (et, el) {
          if (!et)
            throw Error("missing bindings for child Pino");
          el = el || {},
            eh && et.serializers && (el.serializers = et.serializers);
          let ec = el.serializers;
          if (eh && ec) {
            var ep = Object.assign({}, ed, ec)
              , ef = !0 === J.browser.serialize ? Object.keys(ep) : eh;
            delete et.serializers,
              applySerializers([et], ef, ep, this._stdErrSerialize)
          }
          function Child(J) {
            this._childLevel = (0 | J._childLevel) + 1,
              this.error = bind(J, et, "error"),
              this.fatal = bind(J, et, "fatal"),
              this.warn = bind(J, et, "warn"),
              this.info = bind(J, et, "info"),
              this.debug = bind(J, et, "debug"),
              this.trace = bind(J, et, "trace"),
              ep && (this.serializers = ep,
                this._serialize = ef),
              eo && (this._logEvent = createLogEventShape([].concat(J._logEvent.bindings, et)))
          }
          return Child.prototype = this,
            new Child(this)
        }
        ,
        eo && (em._logEvent = createLogEventShape()),
        em
    }
    function set(J, et, eo, ed) {
      let eh = Object.getPrototypeOf(et);
      et[eo] = et.levelVal > et.levels.values[eo] ? noop : eh[eo] ? eh[eo] : ec[eo] || ec[ed] || noop,
        function (J, et, eo) {
          if (J.transmit || et[eo] !== noop) {
            var ed;
            et[eo] = (ed = et[eo],
              function () {
                let eh = J.timestamp()
                  , ep = Array(arguments.length)
                  , ef = Object.getPrototypeOf && Object.getPrototypeOf(this) === ec ? ec : this;
                for (var em = 0; em < ep.length; em++)
                  ep[em] = arguments[em];
                if (J.serialize && !J.asObject && applySerializers(ep, this._serialize, this.serializers, this._stdErrSerialize),
                  J.asObject ? ed.call(ef, function (J, et, eo, ec) {
                    J._serialize && applySerializers(eo, J._serialize, J.serializers, J._stdErrSerialize);
                    let ed = eo.slice()
                      , eh = ed[0]
                      , ep = {};
                    ec && (ep.time = ec),
                      ep.level = pino.levels.values[et];
                    let ef = (0 | J._childLevel) + 1;
                    if (ef < 1 && (ef = 1),
                      null !== eh && "object" == typeof eh) {
                      for (; ef-- && "object" == typeof ed[0];)
                        Object.assign(ep, ed.shift());
                      eh = ed.length ? el(ed.shift(), ed) : void 0
                    } else
                      "string" == typeof eh && (eh = el(ed.shift(), ed));
                    return void 0 !== eh && (ep.msg = eh),
                      ep
                  }(this, eo, ep, eh)) : ed.apply(ef, ep),
                  J.transmit) {
                  let el = J.transmit.level || et.level
                    , ec = pino.levels.values[el]
                    , ed = pino.levels.values[eo];
                  if (ed < ec)
                    return;
                  (function (J, et, eo) {
                    let el = et.send
                      , ec = et.ts
                      , ed = et.methodLevel
                      , eh = et.methodValue
                      , ep = et.val
                      , ef = J._logEvent.bindings;
                    applySerializers(eo, J._serialize || Object.keys(J.serializers), J.serializers, void 0 === J._stdErrSerialize || J._stdErrSerialize),
                      J._logEvent.ts = ec,
                      J._logEvent.messages = eo.filter(function (J) {
                        return -1 === ef.indexOf(J)
                      }),
                      J._logEvent.level.label = ed,
                      J._logEvent.level.value = eh,
                      el(ed, J._logEvent, ep),
                      J._logEvent = createLogEventShape(ef)
                  }
                  )(this, {
                    ts: eh,
                    methodLevel: eo,
                    methodValue: ed,
                    transmitLevel: el,
                    transmitValue: pino.levels.values[J.transmit.level || et.level],
                    send: J.transmit.send,
                    val: et.levelVal
                  }, ep)
                }
              }
            )
          }
        }(J, et, eo)
    }
    function applySerializers(J, et, eo, el) {
      for (let ec in J)
        if (el && J[ec] instanceof Error)
          J[ec] = pino.stdSerializers.err(J[ec]);
        else if ("object" == typeof J[ec] && !Array.isArray(J[ec]))
          for (let el in J[ec])
            et && et.indexOf(el) > -1 && el in eo && (J[ec][el] = eo[el](J[ec][el]))
    }
    function bind(J, et, eo) {
      return function () {
        let el = Array(1 + arguments.length);
        el[0] = et;
        for (var ec = 1; ec < el.length; ec++)
          el[ec] = arguments[ec - 1];
        return J[eo].apply(this, el)
      }
    }
    function createLogEventShape(J) {
      return {
        ts: 0,
        messages: [],
        bindings: J || [],
        level: {
          label: "",
          value: 0
        }
      }
    }
    function mock() {
      return {}
    }
    function passthrough(J) {
      return J
    }
    function noop() { }
    function nullTime() {
      return !1
    }
    function epochTime() {
      return Date.now()
    }
    pino.levels = {
      values: {
        fatal: 60,
        error: 50,
        warn: 40,
        info: 30,
        debug: 20,
        trace: 10
      },
      labels: {
        10: "trace",
        20: "debug",
        30: "info",
        40: "warn",
        50: "error",
        60: "fatal"
      }
    },
      pino.stdSerializers = {
        mapHttpRequest: mock,
        mapHttpResponse: mock,
        wrapRequestSerializer: passthrough,
        wrapResponseSerializer: passthrough,
        wrapErrorSerializer: passthrough,
        req: mock,
        res: mock,
        err: function (J) {
          let et = {
            type: J.constructor.name,
            msg: J.message,
            stack: J.stack
          };
          for (let eo in J)
            void 0 === et[eo] && (et[eo] = J[eo]);
          return et
        }
      },
      pino.stdTimeFunctions = Object.assign({}, {
        nullTime,
        epochTime,
        unixTime: function () {
          return Math.round(Date.now() / 1e3)
        },
        isoTime: function () {
          return new Date(Date.now()).toISOString()
        }
      })
  },
  87462: function (J, et, eo) {
    "use strict";
    function _extends() {
      return (_extends = Object.assign ? Object.assign.bind() : function (J) {
        for (var et = 1; et < arguments.length; et++) {
          var eo = arguments[et];
          for (var el in eo)
            Object.prototype.hasOwnProperty.call(eo, el) && (J[el] = eo[el])
        }
        return J
      }
      ).apply(this, arguments)
    }
    eo.d(et, {
      Z: function () {
        return _extends
      }
    })
  },
  66474: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      j: function () {
        return ed
      }
    });
    var el = eo(7506)
      , ec = eo(24139)
      , ed = new class extends el.l {
        #_;
        #x;
        #E;
        constructor() {
          super(),
            this.#E = J => {
              if (!ec.sk && window.addEventListener) {
                let listener = () => J();
                return window.addEventListener("visibilitychange", listener, !1),
                  () => {
                    window.removeEventListener("visibilitychange", listener)
                  }
              }
            }
        }
        onSubscribe() {
          this.#x || this.setEventListener(this.#E)
        }
        onUnsubscribe() {
          this.hasListeners() || (this.#x?.(),
            this.#x = void 0)
        }
        setEventListener(J) {
          this.#E = J,
            this.#x?.(),
            this.#x = J(J => {
              "boolean" == typeof J ? this.setFocused(J) : this.onFocus()
            }
            )
        }
        setFocused(J) {
          let et = this.#_ !== J;
          et && (this.#_ = J,
            this.onFocus())
        }
        onFocus() {
          this.listeners.forEach(J => {
            J()
          }
          )
        }
        isFocused() {
          return "boolean" == typeof this.#_ ? this.#_ : globalThis.document?.visibilityState !== "hidden"
        }
      }
  },
  59289: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      R: function () {
        return getDefaultState
      },
      m: function () {
        return eh
      }
    });
    var el = eo(27037)
      , ec = eo(48907)
      , ed = eo(72008)
      , eh = class extends ec.F {
        constructor(J) {
          super(),
            this.mutationId = J.mutationId,
            this.#t = J.defaultOptions,
            this.#m = J.mutationCache,
            this.#n = [],
            this.state = J.state || getDefaultState(),
            this.setOptions(J.options),
            this.scheduleGc()
        }
        #n;
        #t;
        #m;
        #l;
        setOptions(J) {
          this.options = {
            ...this.#t,
            ...J
          },
            this.updateGcTime(this.options.gcTime)
        }
        get meta() {
          return this.options.meta
        }
        addObserver(J) {
          this.#n.includes(J) || (this.#n.push(J),
            this.clearGcTimeout(),
            this.#m.notify({
              type: "observerAdded",
              mutation: this,
              observer: J
            }))
        }
        removeObserver(J) {
          this.#n = this.#n.filter(et => et !== J),
            this.scheduleGc(),
            this.#m.notify({
              type: "observerRemoved",
              mutation: this,
              observer: J
            })
        }
        optionalRemove() {
          this.#n.length || ("pending" === this.state.status ? this.scheduleGc() : this.#m.remove(this))
        }
        continue() {
          return this.#l?.continue() ?? this.execute(this.state.variables)
        }
        async execute(J) {
          let et = "pending" === this.state.status;
          try {
            if (!et) {
              this.#c({
                type: "pending",
                variables: J
              }),
                await this.#m.config.onMutate?.(J, this);
              let et = await this.options.onMutate?.(J);
              et !== this.state.context && this.#c({
                type: "pending",
                context: et,
                variables: J
              })
            }
            let eo = await (this.#l = (0,
              ed.Mz)({
                fn: () => this.options.mutationFn ? this.options.mutationFn(J) : Promise.reject(Error("No mutationFn found")),
                onFail: (J, et) => {
                  this.#c({
                    type: "failed",
                    failureCount: J,
                    error: et
                  })
                }
                ,
                onPause: () => {
                  this.#c({
                    type: "pause"
                  })
                }
                ,
                onContinue: () => {
                  this.#c({
                    type: "continue"
                  })
                }
                ,
                retry: this.options.retry ?? 0,
                retryDelay: this.options.retryDelay,
                networkMode: this.options.networkMode
              }),
              this.#l.promise);
            return await this.#m.config.onSuccess?.(eo, J, this.state.context, this),
              await this.options.onSuccess?.(eo, J, this.state.context),
              await this.#m.config.onSettled?.(eo, null, this.state.variables, this.state.context, this),
              await this.options.onSettled?.(eo, null, J, this.state.context),
              this.#c({
                type: "success",
                data: eo
              }),
              eo
          } catch (et) {
            try {
              throw await this.#m.config.onError?.(et, J, this.state.context, this),
              await this.options.onError?.(et, J, this.state.context),
              await this.#m.config.onSettled?.(void 0, et, this.state.variables, this.state.context, this),
              await this.options.onSettled?.(void 0, et, J, this.state.context),
              et
            } finally {
              this.#c({
                type: "error",
                error: et
              })
            }
          }
        }
        #c(J) {
          this.state = (et => {
            switch (J.type) {
              case "failed":
                return {
                  ...et,
                  failureCount: J.failureCount,
                  failureReason: J.error
                };
              case "pause":
                return {
                  ...et,
                  isPaused: !0
                };
              case "continue":
                return {
                  ...et,
                  isPaused: !1
                };
              case "pending":
                return {
                  ...et,
                  context: J.context,
                  data: void 0,
                  failureCount: 0,
                  failureReason: null,
                  error: null,
                  isPaused: !(0,
                    ed.Kw)(this.options.networkMode),
                  status: "pending",
                  variables: J.variables,
                  submittedAt: Date.now()
                };
              case "success":
                return {
                  ...et,
                  data: J.data,
                  failureCount: 0,
                  failureReason: null,
                  error: null,
                  status: "success",
                  isPaused: !1
                };
              case "error":
                return {
                  ...et,
                  data: void 0,
                  error: J.error,
                  failureCount: et.failureCount + 1,
                  failureReason: J.error,
                  isPaused: !1,
                  status: "error"
                }
            }
          }
          )(this.state),
            el.V.batch(() => {
              this.#n.forEach(et => {
                et.onMutationUpdate(J)
              }
              ),
                this.#m.notify({
                  mutation: this,
                  type: "updated",
                  action: J
                })
            }
            )
        }
      }
      ;
    function getDefaultState() {
      return {
        context: void 0,
        data: void 0,
        error: null,
        failureCount: 0,
        failureReason: null,
        isPaused: !1,
        status: "idle",
        variables: void 0,
        submittedAt: 0
      }
    }
  },
  27037: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      V: function () {
        return el
      }
    });
    var el = function () {
      let J = []
        , et = 0
        , notifyFn = J => {
          J()
        }
        , batchNotifyFn = J => {
          J()
        }
        , scheduleFn = J => setTimeout(J, 0)
        , schedule = eo => {
          et ? J.push(eo) : scheduleFn(() => {
            notifyFn(eo)
          }
          )
        }
        , flush = () => {
          let et = J;
          J = [],
            et.length && scheduleFn(() => {
              batchNotifyFn(() => {
                et.forEach(J => {
                  notifyFn(J)
                }
                )
              }
              )
            }
            )
        }
        ;
      return {
        batch: J => {
          let eo;
          et++;
          try {
            eo = J()
          } finally {
            --et || flush()
          }
          return eo
        }
        ,
        batchCalls: J => (...et) => {
          schedule(() => {
            J(...et)
          }
          )
        }
        ,
        schedule,
        setNotifyFunction: J => {
          notifyFn = J
        }
        ,
        setBatchNotifyFunction: J => {
          batchNotifyFn = J
        }
        ,
        setScheduler: J => {
          scheduleFn = J
        }
      }
    }()
  },
  14304: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      N: function () {
        return ed
      }
    });
    var el = eo(7506)
      , ec = eo(24139)
      , ed = new class extends el.l {
        #C = !0;
        #x;
        #E;
        constructor() {
          super(),
            this.#E = J => {
              if (!ec.sk && window.addEventListener) {
                let onlineListener = () => J(!0)
                  , offlineListener = () => J(!1);
                return window.addEventListener("online", onlineListener, !1),
                  window.addEventListener("offline", offlineListener, !1),
                  () => {
                    window.removeEventListener("online", onlineListener),
                      window.removeEventListener("offline", offlineListener)
                  }
              }
            }
        }
        onSubscribe() {
          this.#x || this.setEventListener(this.#E)
        }
        onUnsubscribe() {
          this.hasListeners() || (this.#x?.(),
            this.#x = void 0)
        }
        setEventListener(J) {
          this.#E = J,
            this.#x?.(),
            this.#x = J(this.setOnline.bind(this))
        }
        setOnline(J) {
          let et = this.#C !== J;
          et && (this.#C = J,
            this.listeners.forEach(et => {
              et(J)
            }
            ))
        }
        isOnline() {
          return this.#C
        }
      }
  },
  48907: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      F: function () {
        return ec
      }
    });
    var el = eo(24139)
      , ec = class {
        #S;
        destroy() {
          this.clearGcTimeout()
        }
        scheduleGc() {
          this.clearGcTimeout(),
            (0,
              el.PN)(this.gcTime) && (this.#S = setTimeout(() => {
                this.optionalRemove()
              }
                , this.gcTime))
        }
        updateGcTime(J) {
          this.gcTime = Math.max(this.gcTime || 0, J ?? (el.sk ? 1 / 0 : 3e5))
        }
        clearGcTimeout() {
          this.#S && (clearTimeout(this.#S),
            this.#S = void 0)
        }
      }
  },
  72008: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      DV: function () {
        return isCancelledError
      },
      Kw: function () {
        return canFetch
      },
      Mz: function () {
        return createRetryer
      }
    });
    var el = eo(66474)
      , ec = eo(14304)
      , ed = eo(24139);
    function defaultRetryDelay(J) {
      return Math.min(1e3 * 2 ** J, 3e4)
    }
    function canFetch(J) {
      return (J ?? "online") !== "online" || ec.N.isOnline()
    }
    var eh = class {
      constructor(J) {
        this.revert = J?.revert,
          this.silent = J?.silent
      }
    }
      ;
    function isCancelledError(J) {
      return J instanceof eh
    }
    function createRetryer(J) {
      let et, eo, ep, ef = !1, em = 0, eg = !1, ey = new Promise((J, et) => {
        eo = J,
          ep = et
      }
      ), shouldPause = () => !el.j.isFocused() || "always" !== J.networkMode && !ec.N.isOnline(), resolve = el => {
        eg || (eg = !0,
          J.onSuccess?.(el),
          et?.(),
          eo(el))
      }
        , reject = eo => {
          eg || (eg = !0,
            J.onError?.(eo),
            et?.(),
            ep(eo))
        }
        , pause = () => new Promise(eo => {
          et = J => {
            let et = eg || !shouldPause();
            return et && eo(J),
              et
          }
            ,
            J.onPause?.()
        }
        ).then(() => {
          et = void 0,
            eg || J.onContinue?.()
        }
        ), run = () => {
          let et;
          if (!eg) {
            try {
              et = J.fn()
            } catch (J) {
              et = Promise.reject(J)
            }
            Promise.resolve(et).then(resolve).catch(et => {
              if (eg)
                return;
              let eo = J.retry ?? (ed.sk ? 0 : 3)
                , el = J.retryDelay ?? defaultRetryDelay
                , ec = "function" == typeof el ? el(em, et) : el
                , eh = !0 === eo || "number" == typeof eo && em < eo || "function" == typeof eo && eo(em, et);
              if (ef || !eh) {
                reject(et);
                return
              }
              em++,
                J.onFail?.(em, et),
                (0,
                  ed._v)(ec).then(() => {
                    if (shouldPause())
                      return pause()
                  }
                  ).then(() => {
                    ef ? reject(et) : run()
                  }
                  )
            }
            )
          }
        }
        ;
      return canFetch(J.networkMode) ? run() : pause().then(run),
      {
        promise: ey,
        cancel: et => {
          eg || (reject(new eh(et)),
            J.abort?.())
        }
        ,
        continue: () => {
          let J = et?.();
          return J ? ey : Promise.resolve()
        }
        ,
        cancelRetry: () => {
          ef = !0
        }
        ,
        continueRetry: () => {
          ef = !1
        }
      }
    }
  },
  7506: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      l: function () {
        return el
      }
    });
    var el = class {
      constructor() {
        this.listeners = new Set,
          this.subscribe = this.subscribe.bind(this)
      }
      subscribe(J) {
        return this.listeners.add(J),
          this.onSubscribe(),
          () => {
            this.listeners.delete(J),
              this.onUnsubscribe()
          }
      }
      hasListeners() {
        return this.listeners.size > 0
      }
      onSubscribe() { }
      onUnsubscribe() { }
    }
  },
  24139: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      Ht: function () {
        return addToStart
      },
      Kp: function () {
        return timeUntilStale
      },
      PN: function () {
        return isValidTimeout
      },
      Q$: function () {
        return replaceEqualDeep
      },
      Rm: function () {
        return hashQueryKeyByOptions
      },
      SE: function () {
        return functionalUpdate
      },
      VS: function () {
        return shallowEqualObjects
      },
      VX: function () {
        return addToEnd
      },
      X7: function () {
        return matchMutation
      },
      Ym: function () {
        return hashKey
      },
      ZT: function () {
        return noop
      },
      _v: function () {
        return sleep
      },
      _x: function () {
        return matchQuery
      },
      oE: function () {
        return replaceData
      },
      sk: function () {
        return el
      },
      to: function () {
        return partialMatchKey
      }
    });
    var el = "undefined" == typeof window || "Deno" in window;
    function noop() { }
    function functionalUpdate(J, et) {
      return "function" == typeof J ? J(et) : J
    }
    function isValidTimeout(J) {
      return "number" == typeof J && J >= 0 && J !== 1 / 0
    }
    function timeUntilStale(J, et) {
      return Math.max(J + (et || 0) - Date.now(), 0)
    }
    function matchQuery(J, et) {
      let { type: eo = "all", exact: el, fetchStatus: ec, predicate: ed, queryKey: eh, stale: ep } = J;
      if (eh) {
        if (el) {
          if (et.queryHash !== hashQueryKeyByOptions(eh, et.options))
            return !1
        } else if (!partialMatchKey(et.queryKey, eh))
          return !1
      }
      if ("all" !== eo) {
        let J = et.isActive();
        if ("active" === eo && !J || "inactive" === eo && J)
          return !1
      }
      return ("boolean" != typeof ep || et.isStale() === ep) && (void 0 === ec || ec === et.state.fetchStatus) && (!ed || !!ed(et))
    }
    function matchMutation(J, et) {
      let { exact: eo, status: el, predicate: ec, mutationKey: ed } = J;
      if (ed) {
        if (!et.options.mutationKey)
          return !1;
        if (eo) {
          if (hashKey(et.options.mutationKey) !== hashKey(ed))
            return !1
        } else if (!partialMatchKey(et.options.mutationKey, ed))
          return !1
      }
      return (!el || et.state.status === el) && (!ec || !!ec(et))
    }
    function hashQueryKeyByOptions(J, et) {
      let eo = et?.queryKeyHashFn || hashKey;
      return eo(J)
    }
    function hashKey(J) {
      return JSON.stringify(J, (J, et) => isPlainObject(et) ? Object.keys(et).sort().reduce((J, eo) => (J[eo] = et[eo],
        J), {}) : et)
    }
    function partialMatchKey(J, et) {
      return J === et || typeof J == typeof et && !!J && !!et && "object" == typeof J && "object" == typeof et && !Object.keys(et).some(eo => !partialMatchKey(J[eo], et[eo]))
    }
    function replaceEqualDeep(J, et) {
      if (J === et)
        return J;
      let eo = isPlainArray(J) && isPlainArray(et);
      if (eo || isPlainObject(J) && isPlainObject(et)) {
        let el = eo ? J : Object.keys(J)
          , ec = el.length
          , ed = eo ? et : Object.keys(et)
          , eh = ed.length
          , ep = eo ? [] : {}
          , ef = 0;
        for (let ec = 0; ec < eh; ec++) {
          let eh = eo ? ec : ed[ec];
          !eo && void 0 === J[eh] && void 0 === et[eh] && el.includes(eh) ? (ep[eh] = void 0,
            ef++) : (ep[eh] = replaceEqualDeep(J[eh], et[eh]),
              ep[eh] === J[eh] && void 0 !== J[eh] && ef++)
        }
        return ec === eh && ef === ec ? J : ep
      }
      return et
    }
    function shallowEqualObjects(J, et) {
      if (J && !et || et && !J)
        return !1;
      for (let eo in J)
        if (J[eo] !== et[eo])
          return !1;
      return !0
    }
    function isPlainArray(J) {
      return Array.isArray(J) && J.length === Object.keys(J).length
    }
    function isPlainObject(J) {
      if (!hasObjectPrototype(J))
        return !1;
      let et = J.constructor;
      if (void 0 === et)
        return !0;
      let eo = et.prototype;
      return !!(hasObjectPrototype(eo) && eo.hasOwnProperty("isPrototypeOf"))
    }
    function hasObjectPrototype(J) {
      return "[object Object]" === Object.prototype.toString.call(J)
    }
    function sleep(J) {
      return new Promise(et => {
        setTimeout(et, J)
      }
      )
    }
    function replaceData(J, et, eo) {
      return "function" == typeof eo.structuralSharing ? eo.structuralSharing(J, et) : !1 !== eo.structuralSharing ? replaceEqualDeep(J, et) : et
    }
    function addToEnd(J, et, eo = 0) {
      let el = [...J, et];
      return eo && el.length > eo ? el.slice(1) : el
    }
    function addToStart(J, et, eo = 0) {
      let el = [et, ...J];
      return eo && el.length > eo ? el.slice(0, -1) : el
    }
  },
  30202: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      NL: function () {
        return useQueryClient
      },
      aH: function () {
        return QueryClientProvider
      }
    });
    var el = eo(67294)
      , ec = el.createContext(void 0)
      , useQueryClient = J => {
        let et = el.useContext(ec);
        if (J)
          return J;
        if (!et)
          throw Error("No QueryClient set, use QueryClientProvider to set one");
        return et
      }
      , QueryClientProvider = ({ client: J, children: et }) => (el.useEffect(() => (J.mount(),
        () => {
          J.unmount()
        }
      ), [J]),
        el.createElement(ec.Provider, {
          value: J
        }, et))
  },
  98029: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      D: function () {
        return useMutation
      }
    });
    var el = eo(67294)
      , ec = eo(59289)
      , ed = eo(27037)
      , eh = eo(7506)
      , ep = eo(24139)
      , ef = class extends eh.l {
        constructor(J, et) {
          super(),
            this.#k = void 0,
            this.#T = J,
            this.setOptions(et),
            this.bindMethods(),
            this.#A()
        }
        #T;
        #k;
        #P;
        #R;
        bindMethods() {
          this.mutate = this.mutate.bind(this),
            this.reset = this.reset.bind(this)
        }
        setOptions(J) {
          let et = this.options;
          this.options = this.#T.defaultMutationOptions(J),
            (0,
              ep.VS)(et, this.options) || this.#T.getMutationCache().notify({
                type: "observerOptionsUpdated",
                mutation: this.#P,
                observer: this
              }),
            this.#P?.setOptions(this.options),
            et?.mutationKey && this.options.mutationKey && (0,
              ep.Ym)(et.mutationKey) !== (0,
                ep.Ym)(this.options.mutationKey) && this.reset()
        }
        onUnsubscribe() {
          this.hasListeners() || this.#P?.removeObserver(this)
        }
        onMutationUpdate(J) {
          this.#A(),
            this.#I(J)
        }
        getCurrentResult() {
          return this.#k
        }
        reset() {
          this.#P?.removeObserver(this),
            this.#P = void 0,
            this.#A(),
            this.#I()
        }
        mutate(J, et) {
          return this.#R = et,
            this.#P?.removeObserver(this),
            this.#P = this.#T.getMutationCache().build(this.#T, this.options),
            this.#P.addObserver(this),
            this.#P.execute(J)
        }
        #A() {
          let J = this.#P?.state ?? (0,
            ec.R)();
          this.#k = {
            ...J,
            isPending: "pending" === J.status,
            isSuccess: "success" === J.status,
            isError: "error" === J.status,
            isIdle: "idle" === J.status,
            mutate: this.mutate,
            reset: this.reset
          }
        }
        #I(J) {
          ed.V.batch(() => {
            if (this.#R && this.hasListeners()) {
              let et = this.#k.variables
                , eo = this.#k.context;
              J?.type === "success" ? (this.#R.onSuccess?.(J.data, et, eo),
                this.#R.onSettled?.(J.data, null, et, eo)) : J?.type === "error" && (this.#R.onError?.(J.error, et, eo),
                  this.#R.onSettled?.(void 0, J.error, et, eo))
            }
            this.listeners.forEach(J => {
              J(this.#k)
            }
            )
          }
          )
        }
      }
      , em = eo(30202)
      , eg = eo(86290);
    function useMutation(J, et) {
      let eo = (0,
        em.NL)(et)
        , [ec] = el.useState(() => new ef(eo, J));
      el.useEffect(() => {
        ec.setOptions(J)
      }
        , [ec, J]);
      let eh = el.useSyncExternalStore(el.useCallback(J => ec.subscribe(ed.V.batchCalls(J)), [ec]), () => ec.getCurrentResult(), () => ec.getCurrentResult())
        , ep = el.useCallback((J, et) => {
          ec.mutate(J, et).catch(noop)
        }
          , [ec]);
      if (eh.error && (0,
        eg.L)(ec.options.throwOnError, [eh.error]))
        throw eh.error;
      return {
        ...eh,
        mutate: ep,
        mutateAsync: eh.mutate
      }
    }
    function noop() { }
  },
  10777: function (J, et, eo) {
    "use strict";
    let el;
    eo.d(et, {
      a: function () {
        return useQuery
      }
    });
    var ec = eo(24139)
      , ed = eo(27037)
      , eh = eo(66474)
      , ep = eo(7506)
      , ef = eo(72008)
      , em = class extends ep.l {
        constructor(J, et) {
          super(),
            this.options = et,
            this.#T = J,
            this.#O = null,
            this.bindMethods(),
            this.setOptions(et)
        }
        #T;
        #N = void 0;
        #M = void 0;
        #k = void 0;
        #D;
        #j;
        #O;
        #L;
        #$;
        #B;
        #F;
        #U;
        #z;
        #H = new Set;
        bindMethods() {
          this.refetch = this.refetch.bind(this)
        }
        onSubscribe() {
          1 === this.listeners.size && (this.#N.addObserver(this),
            shouldFetchOnMount(this.#N, this.options) ? this.#V() : this.updateResult(),
            this.#W())
        }
        onUnsubscribe() {
          this.hasListeners() || this.destroy()
        }
        shouldFetchOnReconnect() {
          return shouldFetchOn(this.#N, this.options, this.options.refetchOnReconnect)
        }
        shouldFetchOnWindowFocus() {
          return shouldFetchOn(this.#N, this.options, this.options.refetchOnWindowFocus)
        }
        destroy() {
          this.listeners = new Set,
            this.#q(),
            this.#Z(),
            this.#N.removeObserver(this)
        }
        setOptions(J, et) {
          let eo = this.options
            , el = this.#N;
          if (this.options = this.#T.defaultQueryOptions(J),
            (0,
              ec.VS)(eo, this.options) || this.#T.getQueryCache().notify({
                type: "observerOptionsUpdated",
                query: this.#N,
                observer: this
              }),
            void 0 !== this.options.enabled && "boolean" != typeof this.options.enabled)
            throw Error("Expected enabled to be a boolean");
          this.options.queryKey || (this.options.queryKey = eo.queryKey),
            this.#G();
          let ed = this.hasListeners();
          ed && shouldFetchOptionally(this.#N, el, this.options, eo) && this.#V(),
            this.updateResult(et),
            ed && (this.#N !== el || this.options.enabled !== eo.enabled || this.options.staleTime !== eo.staleTime) && this.#Y();
          let eh = this.#K();
          ed && (this.#N !== el || this.options.enabled !== eo.enabled || eh !== this.#z) && this.#J(eh)
        }
        getOptimisticResult(J) {
          let et = this.#T.getQueryCache().build(this.#T, J)
            , eo = this.createResult(et, J);
          return (0,
            ec.VS)(this.getCurrentResult(), eo) || (this.#k = eo,
              this.#j = this.options,
              this.#D = this.#N.state),
            eo
        }
        getCurrentResult() {
          return this.#k
        }
        trackResult(J) {
          let et = {};
          return Object.keys(J).forEach(eo => {
            Object.defineProperty(et, eo, {
              configurable: !1,
              enumerable: !0,
              get: () => (this.#H.add(eo),
                J[eo])
            })
          }
          ),
            et
        }
        getCurrentQuery() {
          return this.#N
        }
        refetch({ ...J } = {}) {
          return this.fetch({
            ...J
          })
        }
        fetchOptimistic(J) {
          let et = this.#T.defaultQueryOptions(J)
            , eo = this.#T.getQueryCache().build(this.#T, et);
          return eo.isFetchingOptimistic = !0,
            eo.fetch().then(() => this.createResult(eo, et))
        }
        fetch(J) {
          return this.#V({
            ...J,
            cancelRefetch: J.cancelRefetch ?? !0
          }).then(() => (this.updateResult(),
            this.#k))
        }
        #V(J) {
          this.#G();
          let et = this.#N.fetch(this.options, J);
          return J?.throwOnError || (et = et.catch(ec.ZT)),
            et
        }
        #Y() {
          if (this.#q(),
            ec.sk || this.#k.isStale || !(0,
              ec.PN)(this.options.staleTime))
            return;
          let J = (0,
            ec.Kp)(this.#k.dataUpdatedAt, this.options.staleTime);
          this.#F = setTimeout(() => {
            this.#k.isStale || this.updateResult()
          }
            , J + 1)
        }
        #K() {
          return ("function" == typeof this.options.refetchInterval ? this.options.refetchInterval(this.#N) : this.options.refetchInterval) ?? !1
        }
        #J(J) {
          this.#Z(),
            this.#z = J,
            !ec.sk && !1 !== this.options.enabled && (0,
              ec.PN)(this.#z) && 0 !== this.#z && (this.#U = setInterval(() => {
                (this.options.refetchIntervalInBackground || eh.j.isFocused()) && this.#V()
              }
                , this.#z))
        }
        #W() {
          this.#Y(),
            this.#J(this.#K())
        }
        #q() {
          this.#F && (clearTimeout(this.#F),
            this.#F = void 0)
        }
        #Z() {
          this.#U && (clearInterval(this.#U),
            this.#U = void 0)
        }
        createResult(J, et) {
          let eo;
          let el = this.#N
            , ed = this.options
            , eh = this.#k
            , ep = this.#D
            , em = this.#j
            , eg = J !== el
            , ey = eg ? J.state : this.#M
            , { state: eb } = J
            , { error: ew, errorUpdatedAt: e_, fetchStatus: ex, status: eE } = eb
            , eC = !1;
          if (et._optimisticResults) {
            let eo = this.hasListeners()
              , ec = !eo && shouldFetchOnMount(J, et)
              , eh = eo && shouldFetchOptionally(J, el, et, ed);
            (ec || eh) && (ex = (0,
              ef.Kw)(J.options.networkMode) ? "fetching" : "paused",
              eb.dataUpdatedAt || (eE = "pending")),
              "isRestoring" === et._optimisticResults && (ex = "idle")
          }
          if (et.select && void 0 !== eb.data) {
            if (eh && eb.data === ep?.data && et.select === this.#L)
              eo = this.#$;
            else
              try {
                this.#L = et.select,
                  eo = et.select(eb.data),
                  eo = (0,
                    ec.oE)(eh?.data, eo, et),
                  this.#$ = eo,
                  this.#O = null
              } catch (J) {
                this.#O = J
              }
          } else
            eo = eb.data;
          if (void 0 !== et.placeholderData && void 0 === eo && "pending" === eE) {
            let J;
            if (eh?.isPlaceholderData && et.placeholderData === em?.placeholderData)
              J = eh.data;
            else if (J = "function" == typeof et.placeholderData ? et.placeholderData(this.#B?.state.data, this.#B) : et.placeholderData,
              et.select && void 0 !== J)
              try {
                J = et.select(J),
                  this.#O = null
              } catch (J) {
                this.#O = J
              }
            void 0 !== J && (eE = "success",
              eo = (0,
                ec.oE)(eh?.data, J, et),
              eC = !0)
          }
          this.#O && (ew = this.#O,
            eo = this.#$,
            e_ = Date.now(),
            eE = "error");
          let eS = "fetching" === ex
            , ek = "pending" === eE
            , eT = "error" === eE
            , eA = ek && eS
            , eP = {
              status: eE,
              fetchStatus: ex,
              isPending: ek,
              isSuccess: "success" === eE,
              isError: eT,
              isInitialLoading: eA,
              isLoading: eA,
              data: eo,
              dataUpdatedAt: eb.dataUpdatedAt,
              error: ew,
              errorUpdatedAt: e_,
              failureCount: eb.fetchFailureCount,
              failureReason: eb.fetchFailureReason,
              errorUpdateCount: eb.errorUpdateCount,
              isFetched: eb.dataUpdateCount > 0 || eb.errorUpdateCount > 0,
              isFetchedAfterMount: eb.dataUpdateCount > ey.dataUpdateCount || eb.errorUpdateCount > ey.errorUpdateCount,
              isFetching: eS,
              isRefetching: eS && !ek,
              isLoadingError: eT && 0 === eb.dataUpdatedAt,
              isPaused: "paused" === ex,
              isPlaceholderData: eC,
              isRefetchError: eT && 0 !== eb.dataUpdatedAt,
              isStale: isStale(J, et),
              refetch: this.refetch
            };
          return eP
        }
        updateResult(J) {
          let et = this.#k
            , eo = this.createResult(this.#N, this.options);
          if (this.#D = this.#N.state,
            this.#j = this.options,
            void 0 !== this.#D.data && (this.#B = this.#N),
            (0,
              ec.VS)(eo, et))
            return;
          this.#k = eo;
          let el = {};
          J?.listeners !== !1 && (() => {
            if (!et)
              return !0;
            let { notifyOnChangeProps: J } = this.options
              , eo = "function" == typeof J ? J() : J;
            if ("all" === eo || !eo && !this.#H.size)
              return !0;
            let el = new Set(eo ?? this.#H);
            return this.options.throwOnError && el.add("error"),
              Object.keys(this.#k).some(J => {
                let eo = this.#k[J] !== et[J];
                return eo && el.has(J)
              }
              )
          }
          )() && (el.listeners = !0),
            this.#I({
              ...el,
              ...J
            })
        }
        #G() {
          let J = this.#T.getQueryCache().build(this.#T, this.options);
          if (J === this.#N)
            return;
          let et = this.#N;
          this.#N = J,
            this.#M = J.state,
            this.hasListeners() && (et?.removeObserver(this),
              J.addObserver(this))
        }
        onQueryUpdate() {
          this.updateResult(),
            this.hasListeners() && this.#W()
        }
        #I(J) {
          ed.V.batch(() => {
            J.listeners && this.listeners.forEach(J => {
              J(this.#k)
            }
            ),
              this.#T.getQueryCache().notify({
                query: this.#N,
                type: "observerResultsUpdated"
              })
          }
          )
        }
      }
      ;
    function shouldFetchOnMount(J, et) {
      return !1 !== et.enabled && !J.state.dataUpdatedAt && !("error" === J.state.status && !1 === et.retryOnMount) || J.state.dataUpdatedAt > 0 && shouldFetchOn(J, et, et.refetchOnMount)
    }
    function shouldFetchOn(J, et, eo) {
      if (!1 !== et.enabled) {
        let el = "function" == typeof eo ? eo(J) : eo;
        return "always" === el || !1 !== el && isStale(J, et)
      }
      return !1
    }
    function shouldFetchOptionally(J, et, eo, el) {
      return !1 !== eo.enabled && (J !== et || !1 === el.enabled) && (!eo.suspense || "error" !== J.state.status) && isStale(J, eo)
    }
    function isStale(J, et) {
      return J.isStaleByTime(et.staleTime)
    }
    var eg = eo(67294)
      , ey = eg.createContext((el = !1,
      {
        clearReset: () => {
          el = !1
        }
        ,
        reset: () => {
          el = !0
        }
        ,
        isReset: () => el
      }))
      , useQueryErrorResetBoundary = () => eg.useContext(ey)
      , eb = eo(30202)
      , ew = eg.createContext(!1)
      , useIsRestoring = () => eg.useContext(ew);
    ew.Provider;
    var e_ = eo(86290)
      , ensurePreventErrorBoundaryRetry = (J, et) => {
        (J.suspense || J.throwOnError) && !et.isReset() && (J.retryOnMount = !1)
      }
      , useClearResetErrorBoundary = J => {
        eg.useEffect(() => {
          J.clearReset()
        }
          , [J])
      }
      , getHasError = ({ result: J, errorResetBoundary: et, throwOnError: eo, query: el }) => J.isError && !et.isReset() && !J.isFetching && el && (0,
        e_.L)(eo, [J.error, el])
      , ensureStaleTime = J => {
        J.suspense && "number" != typeof J.staleTime && (J.staleTime = 1e3)
      }
      , shouldSuspend = (J, et) => J?.suspense && et.isPending
      , fetchOptimistic = (J, et, eo) => et.fetchOptimistic(J).catch(() => {
        eo.clearReset()
      }
      );
    function useQuery(J, et) {
      return function (J, et, eo) {
        let el = (0,
          eb.NL)(eo)
          , ec = useIsRestoring()
          , eh = useQueryErrorResetBoundary()
          , ep = el.defaultQueryOptions(J);
        ep._optimisticResults = ec ? "isRestoring" : "optimistic",
          ensureStaleTime(ep),
          ensurePreventErrorBoundaryRetry(ep, eh),
          useClearResetErrorBoundary(eh);
        let [ef] = eg.useState(() => new et(el, ep))
          , em = ef.getOptimisticResult(ep);
        if (eg.useSyncExternalStore(eg.useCallback(J => {
          let et = ec ? () => void 0 : ef.subscribe(ed.V.batchCalls(J));
          return ef.updateResult(),
            et
        }
          , [ef, ec]), () => ef.getCurrentResult(), () => ef.getCurrentResult()),
          eg.useEffect(() => {
            ef.setOptions(ep, {
              listeners: !1
            })
          }
            , [ep, ef]),
          shouldSuspend(ep, em))
          throw fetchOptimistic(ep, ef, eh);
        if (getHasError({
          result: em,
          errorResetBoundary: eh,
          throwOnError: ep.throwOnError,
          query: el.getQueryCache().get(ep.queryHash)
        }))
          throw em.error;
        return ep.notifyOnChangeProps ? em : ef.trackResult(em)
      }(J, em, et)
    }
  },
  86290: function (J, et, eo) {
    "use strict";
    function shouldThrowError(J, et) {
      return "function" == typeof J ? J(...et) : !!J
    }
    eo.d(et, {
      L: function () {
        return shouldThrowError
      }
    })
  },
  37003: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      L: function () {
        return readContract
      }
    });
    var el = eo(88819)
      , ec = eo(81946);
    function readContract(J, et) {
      let { chainId: eo, ...ed } = et
        , eh = J.getClient({
          chainId: eo
        })
        , ep = (0,
          ec.s)(eh, el.L, "readContract");
      return ep(ed)
    }
  },
  81946: function (J, et, eo) {
    "use strict";
    function getAction(J, et, eo) {
      let el = J[et.name ?? eo];
      return "function" == typeof el ? el : eo => et(J, eo)
    }
    eo.d(et, {
      s: function () {
        return getAction
      }
    })
  },
  88598: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      E: function () {
        return eh
      }
    });
    var el = eo(27484)
      , ec = eo(70660)
      , ed = eo(84110);
    el.extend(ed),
      el.extend(ec),
      el.updateLocale("en", {
        relativeTime: {
          future: "in %s",
          past: "%s ago",
          s: "%s sec",
          m: "1 min",
          mm: "%d min",
          h: "1 hr",
          hh: "%d hrs",
          d: "1 d",
          dd: "%d d",
          M: "1 mo",
          MM: "%d mo",
          y: "1 yr",
          yy: "%d yr"
        }
      });
    let eh = {
      getYear: (J = new Date().toISOString()) => el(J).year(),
      getRelativeDateFromNow: J => el(J).fromNow(!0)
    }
  },
  76472: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      AccountController: function () {
        return ef
      },
      ApiController: function () {
        return eM
      },
      fz: function () {
        return e5
      },
      Lr: function () {
        return eZ
      },
      ConnectionController: function () {
        return eX
      },
      ConnectorController: function () {
        return ek
      },
      bq: function () {
        return ed
      },
      j1: function () {
        return eh
      },
      Xs: function () {
        return eB
      },
      IN: function () {
        return eH
      },
      NetworkController: function () {
        return eR
      },
      OptionsController: function () {
        return eC
      },
      Ie: function () {
        return eA
      },
      RouterController: function () {
        return eU
      },
      _4: function () {
        return e6
      },
      yD: function () {
        return e1
      },
      SnackController: function () {
        return eY
      },
      MO: function () {
        return ew
      },
      ThemeController: function () {
        return e3
      },
      sl: function () {
        return eJ
      }
    });
    var el = eo(17832);
    function subscribeKey(J, et, eo, ec) {
      let ed = J[et];
      return (0,
        el.Ld)(J, () => {
          let el = J[et];
          Object.is(ed, el) || eo(ed = el)
        }
          , ec)
    }
    Symbol();
    let ec = "https://secure.web3modal.com"
      , ed = {
        FOUR_MINUTES_MS: 24e4,
        TEN_SEC_MS: 1e4,
        ONE_SEC_MS: 1e3,
        SECURE_SITE: ec,
        SECURE_SITE_DASHBOARD: `${ec}/dashboard`,
        SECURE_SITE_FAVICON: `${ec}/images/favicon.png`,
        RESTRICTED_TIMEZONES: ["ASIA/SHANGHAI", "ASIA/URUMQI", "ASIA/CHONGQING", "ASIA/HARBIN", "ASIA/KASHGAR", "ASIA/MACAU", "ASIA/HONG_KONG", "ASIA/MACAO", "ASIA/BEIJING", "ASIA/HARBIN"],
        CONNECTOR_RDNS_MAP: {
          coinbaseWallet: "com.coinbase.wallet"
        }
      }
      , eh = {
        isMobile: () => "undefined" != typeof window && !!(window.matchMedia("(pointer:coarse)").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent)),
        isAndroid() {
          let J = window.navigator.userAgent.toLowerCase();
          return eh.isMobile() && J.includes("android")
        },
        isIos() {
          let J = window.navigator.userAgent.toLowerCase();
          return eh.isMobile() && (J.includes("iphone") || J.includes("ipad"))
        },
        isClient: () => "undefined" != typeof window,
        isPairingExpired: J => !J || J - Date.now() <= ed.TEN_SEC_MS,
        isAllowedRetry: J => Date.now() - J >= ed.ONE_SEC_MS,
        copyToClopboard(J) {
          navigator.clipboard.writeText(J)
        },
        getPairingExpiry: () => Date.now() + ed.FOUR_MINUTES_MS,
        getPlainAddress: J => J.split(":")[2],
        wait: async J => new Promise(et => {
          setTimeout(et, J)
        }
        ),
        debounce(J, et = 500) {
          let eo;
          return (...el) => {
            eo && clearTimeout(eo),
              eo = setTimeout(function () {
                J(...el)
              }, et)
          }
        },
        isHttpUrl: J => J.startsWith("http://") || J.startsWith("https://"),
        formatNativeUrl(J, et) {
          if (eh.isHttpUrl(J))
            return this.formatUniversalUrl(J, et);
          let eo = J;
          eo.includes("://") || (eo = J.replaceAll("/", "").replaceAll(":", ""),
            eo = `${eo}://`),
            eo.endsWith("/") || (eo = `${eo}/`);
          let el = encodeURIComponent(et);
          return {
            redirect: `${eo}wc?uri=${el}`,
            href: eo
          }
        },
        formatUniversalUrl(J, et) {
          if (!eh.isHttpUrl(J))
            return this.formatNativeUrl(J, et);
          let eo = J;
          eo.endsWith("/") || (eo = `${eo}/`);
          let el = encodeURIComponent(et);
          return {
            redirect: `${eo}wc?uri=${el}`,
            href: eo
          }
        },
        openHref(J, et) {
          window.open(J, et, "noreferrer noopener")
        },
        async preloadImage(J) {
          let et = new Promise((et, eo) => {
            let el = new Image;
            el.onload = et,
              el.onerror = eo,
              el.crossOrigin = "anonymous",
              el.src = J
          }
          );
          return Promise.race([et, eh.wait(2e3)])
        },
        formatBalance(J, et) {
          let eo;
          if ("0" === J)
            eo = "0.000";
          else if ("string" == typeof J) {
            let et = Number(J);
            et && (eo = et.toString().match(/^-?\d+(?:\.\d{0,3})?/u)?.[0])
          }
          return eo ? `${eo} ${et ?? ""}` : "0.000"
        },
        isRestrictedRegion() {
          try {
            let { timeZone: J } = new Intl.DateTimeFormat().resolvedOptions()
              , et = J.toUpperCase();
            return ed.RESTRICTED_TIMEZONES.includes(et)
          } catch {
            return !1
          }
        },
        getApiUrl: () => eh.isRestrictedRegion() ? "https://api.web3modal.org" : "https://api.web3modal.com",
        getBlockchainApiUrl: () => eh.isRestrictedRegion() ? "https://rpc.walletconnect.org" : "https://rpc.walletconnect.com",
        getAnalyticsUrl: () => eh.isRestrictedRegion() ? "https://pulse.walletconnect.org" : "https://pulse.walletconnect.com",
        getUUID: () => crypto?.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, J => {
          let et = 16 * Math.random() | 0;
          return ("x" === J ? et : 3 & et | 8).toString(16)
        }
        ),
        parseError: J => "string" == typeof J ? J : "string" == typeof J?.issues?.[0]?.message ? J.issues[0].message : J instanceof Error ? J.message : "Unknown error"
      }
      , ep = (0,
        el.sj)({
          isConnected: !1
        })
      , ef = {
        state: ep,
        subscribe: J => (0,
          el.Ld)(ep, () => J(ep)),
        subscribeKey: (J, et) => subscribeKey(ep, J, et),
        setIsConnected(J) {
          ep.isConnected = J
        },
        setCaipAddress(J) {
          ep.caipAddress = J,
            ep.address = J ? eh.getPlainAddress(J) : void 0
        },
        setBalance(J, et) {
          ep.balance = J,
            ep.balanceSymbol = et
        },
        setProfileName(J) {
          ep.profileName = J
        },
        setProfileImage(J) {
          ep.profileImage = J
        },
        setAddressExplorerUrl(J) {
          ep.addressExplorerUrl = J
        },
        resetAccount() {
          ep.isConnected = !1,
            ep.caipAddress = void 0,
            ep.address = void 0,
            ep.balance = void 0,
            ep.balanceSymbol = void 0,
            ep.profileName = void 0,
            ep.profileImage = void 0,
            ep.addressExplorerUrl = void 0
        }
      };
    let FetchUtil = class FetchUtil {
      constructor({ baseUrl: J }) {
        this.baseUrl = J
      }
      async get({ headers: J, ...et }) {
        let eo = this.createUrl(et)
          , el = await fetch(eo, {
            method: "GET",
            headers: J
          });
        return el.json()
      }
      async getBlob({ headers: J, ...et }) {
        let eo = this.createUrl(et)
          , el = await fetch(eo, {
            method: "GET",
            headers: J
          });
        return el.blob()
      }
      async post({ body: J, headers: et, ...eo }) {
        let el = this.createUrl(eo)
          , ec = await fetch(el, {
            method: "POST",
            headers: et,
            body: J ? JSON.stringify(J) : void 0
          });
        return ec.json()
      }
      async put({ body: J, headers: et, ...eo }) {
        let el = this.createUrl(eo)
          , ec = await fetch(el, {
            method: "PUT",
            headers: et,
            body: J ? JSON.stringify(J) : void 0
          });
        return ec.json()
      }
      async delete({ body: J, headers: et, ...eo }) {
        let el = this.createUrl(eo)
          , ec = await fetch(el, {
            method: "DELETE",
            headers: et,
            body: J ? JSON.stringify(J) : void 0
          });
        return ec.json()
      }
      createUrl({ path: J, params: et }) {
        let eo = new URL(J, this.baseUrl);
        return et && Object.entries(et).forEach(([J, et]) => {
          et && eo.searchParams.append(J, et)
        }
        ),
          eo
      }
    }
      ;
    let em = "WALLETCONNECT_DEEPLINK_CHOICE"
      , eg = "@w3m/recent"
      , ey = "@w3m/connected_wallet_image_url"
      , eb = "@w3m/connected_connector"
      , ew = {
        setWalletConnectDeepLink({ href: J, name: et }) {
          try {
            localStorage.setItem(em, JSON.stringify({
              href: J,
              name: et
            }))
          } catch {
            console.info("Unable to set WalletConnect deep link")
          }
        },
        getWalletConnectDeepLink() {
          try {
            let J = localStorage.getItem(em);
            if (J)
              return JSON.parse(J)
          } catch {
            console.info("Unable to get WalletConnect deep link")
          }
        },
        deleteWalletConnectDeepLink() {
          try {
            localStorage.removeItem(em)
          } catch {
            console.info("Unable to delete WalletConnect deep link")
          }
        },
        setWeb3ModalRecent(J) {
          try {
            let et = ew.getRecentWallets()
              , eo = et.find(et => et.id === J.id);
            eo || (et.unshift(J),
              et.length > 2 && et.pop(),
              localStorage.setItem(eg, JSON.stringify(et)))
          } catch {
            console.info("Unable to set Web3Modal recent")
          }
        },
        getRecentWallets() {
          try {
            let J = localStorage.getItem(eg);
            return J ? JSON.parse(J) : []
          } catch {
            console.info("Unable to get Web3Modal recent")
          }
          return []
        },
        setConnectedWalletImageUrl(J) {
          try {
            localStorage.setItem(ey, J)
          } catch {
            console.info("Unable to set Connected Wallet Image Url")
          }
        },
        getConnectedWalletImageUrl() {
          try {
            return localStorage.getItem(ey)
          } catch {
            console.info("Unable to set Connected Wallet Image Url")
          }
        },
        setConnectedConnector(J) {
          try {
            localStorage.setItem(eb, J)
          } catch {
            console.info("Unable to set Connected Connector")
          }
        },
        getConnectedConnector() {
          try {
            return localStorage.getItem(eb)
          } catch {
            console.info("Unable to get Connected Connector")
          }
        }
      }
      , e_ = (0,
        el.sj)({
          walletImages: {},
          networkImages: {},
          connectorImages: {},
          tokenImages: {}
        })
      , ex = {
        state: e_,
        subscribeNetworkImages: J => (0,
          el.Ld)(e_.networkImages, () => J(e_.networkImages)),
        subscribeKey: (J, et) => subscribeKey(e_, J, et),
        setWalletImage(J, et) {
          e_.walletImages[J] = et
        },
        setNetworkImage(J, et) {
          e_.networkImages[J] = et
        },
        setConnectorImage(J, et) {
          e_.connectorImages[J] = et
        },
        setTokenImage(J, et) {
          e_.tokenImages[J] = et
        }
      }
      , eE = (0,
        el.sj)({
          projectId: "",
          sdkType: "w3m",
          sdkVersion: "html-wagmi-undefined"
        })
      , eC = {
        state: eE,
        subscribeKey: (J, et) => subscribeKey(eE, J, et),
        setProjectId(J) {
          eE.projectId = J
        },
        setAllWallets(J) {
          eE.allWallets = J
        },
        setIncludeWalletIds(J) {
          eE.includeWalletIds = J
        },
        setExcludeWalletIds(J) {
          eE.excludeWalletIds = J
        },
        setFeaturedWalletIds(J) {
          eE.featuredWalletIds = J
        },
        setTokens(J) {
          eE.tokens = J
        },
        setTermsConditionsUrl(J) {
          eE.termsConditionsUrl = J
        },
        setPrivacyPolicyUrl(J) {
          eE.privacyPolicyUrl = J
        },
        setCustomWallets(J) {
          eE.customWallets = J
        },
        setEnableAnalytics(J) {
          eE.enableAnalytics = J
        },
        setSdkVersion(J) {
          eE.sdkVersion = J
        },
        setMetadata(J) {
          eE.metadata = J
        }
      }
      , eS = (0,
        el.sj)({
          connectors: []
        })
      , ek = {
        state: eS,
        subscribeKey: (J, et) => subscribeKey(eS, J, et),
        setConnectors(J) {
          eS.connectors = J.map(J => (0,
            el.iH)(J))
        },
        addConnector(J) {
          if (eS.connectors.push((0,
            el.iH)(J)),
            "w3mEmail" === J.id) {
            let et = (0,
              el.CO)(eC.state);
            J?.provider?.syncDappData?.({
              metadata: et.metadata,
              sdkVersion: et.sdkVersion,
              projectId: et.projectId
            })
          }
        },
        getEmailConnector: () => eS.connectors.find(J => "EMAIL" === J.type),
        getAnnouncedConnectorRdns: () => eS.connectors.filter(J => "ANNOUNCED" === J.type).map(J => J.info?.rdns),
        getConnectors: () => eS.connectors
      }
      , eT = (0,
        el.sj)({
          open: !1,
          selectedNetworkId: void 0
        })
      , eA = {
        state: eT,
        subscribe: J => (0,
          el.Ld)(eT, () => J(eT)),
        set(J) {
          Object.assign(eT, {
            ...eT,
            ...J
          })
        }
      }
      , eP = (0,
        el.sj)({
          supportsAllNetworks: !0,
          isDefaultCaipNetwork: !1
        })
      , eR = {
        state: eP,
        subscribeKey: (J, et) => subscribeKey(eP, J, et),
        _getClient() {
          if (!eP._client)
            throw Error("NetworkController client not set");
          return eP._client
        },
        setClient(J) {
          eP._client = (0,
            el.iH)(J)
        },
        setCaipNetwork(J) {
          eP.caipNetwork = J,
            eA.set({
              selectedNetworkId: J?.id
            })
        },
        setDefaultCaipNetwork(J) {
          eP.caipNetwork = J,
            eA.set({
              selectedNetworkId: J?.id
            }),
            eP.isDefaultCaipNetwork = !0
        },
        setRequestedCaipNetworks(J) {
          eP.requestedCaipNetworks = J
        },
        async getApprovedCaipNetworksData() {
          let J = await this._getClient().getApprovedCaipNetworksData();
          eP.supportsAllNetworks = J.supportsAllNetworks,
            eP.approvedCaipNetworkIds = J.approvedCaipNetworkIds
        },
        async switchActiveNetwork(J) {
          await this._getClient().switchCaipNetwork(J),
            eP.caipNetwork = J
        },
        resetNetwork() {
          eP.isDefaultCaipNetwork || (eP.caipNetwork = void 0),
            eP.approvedCaipNetworkIds = void 0,
            eP.supportsAllNetworks = !0
        }
      }
      , eI = eh.getApiUrl()
      , eO = new FetchUtil({
        baseUrl: eI
      })
      , eN = (0,
        el.sj)({
          page: 1,
          count: 0,
          featured: [],
          recommended: [],
          wallets: [],
          search: [],
          isAnalyticsEnabled: !1
        })
      , eM = {
        state: eN,
        subscribeKey: (J, et) => subscribeKey(eN, J, et),
        _getApiHeaders() {
          let { projectId: J, sdkType: et, sdkVersion: eo } = eC.state;
          return {
            "x-project-id": J,
            "x-sdk-type": et,
            "x-sdk-version": eo
          }
        },
        async _fetchWalletImage(J) {
          let et = `${eO.baseUrl}/getWalletImage/${J}`
            , eo = await eO.getBlob({
              path: et,
              headers: eM._getApiHeaders()
            });
          ex.setWalletImage(J, URL.createObjectURL(eo))
        },
        async _fetchNetworkImage(J) {
          let et = `${eO.baseUrl}/public/getAssetImage/${J}`
            , eo = await eO.getBlob({
              path: et,
              headers: eM._getApiHeaders()
            });
          ex.setNetworkImage(J, URL.createObjectURL(eo))
        },
        async _fetchConnectorImage(J) {
          let et = `${eO.baseUrl}/public/getAssetImage/${J}`
            , eo = await eO.getBlob({
              path: et,
              headers: eM._getApiHeaders()
            });
          ex.setConnectorImage(J, URL.createObjectURL(eo))
        },
        async fetchNetworkImages() {
          let { requestedCaipNetworks: J } = eR.state
            , et = J?.map(({ imageId: J }) => J).filter(Boolean);
          et && await Promise.allSettled(et.map(J => eM._fetchNetworkImage(J)))
        },
        async fetchConnectorImages() {
          let { connectors: J } = ek.state
            , et = J.map(({ imageId: J }) => J).filter(Boolean);
          await Promise.allSettled(et.map(J => eM._fetchConnectorImage(J)))
        },
        async fetchFeaturedWallets() {
          let { featuredWalletIds: J } = eC.state;
          if (J?.length) {
            let { data: et } = await eO.get({
              path: "/getWallets",
              headers: eM._getApiHeaders(),
              params: {
                page: "1",
                entries: J?.length ? String(J.length) : "4",
                include: J?.join(",")
              }
            });
            et.sort((et, eo) => J.indexOf(et.id) - J.indexOf(eo.id));
            let eo = et.map(J => J.image_id).filter(Boolean);
            await Promise.allSettled(eo.map(J => eM._fetchWalletImage(J))),
              eN.featured = et
          }
        },
        async fetchRecommendedWallets() {
          let { includeWalletIds: J, excludeWalletIds: et, featuredWalletIds: eo } = eC.state
            , el = [...et ?? [], ...eo ?? []].filter(Boolean)
            , { data: ec, count: ed } = await eO.get({
              path: "/getWallets",
              headers: eM._getApiHeaders(),
              params: {
                page: "1",
                entries: "4",
                include: J?.join(","),
                exclude: el?.join(",")
              }
            })
            , eh = ew.getRecentWallets()
            , ep = ec.map(J => J.image_id).filter(Boolean)
            , ef = eh.map(J => J.image_id).filter(Boolean);
          await Promise.allSettled([...ep, ...ef].map(J => eM._fetchWalletImage(J))),
            eN.recommended = ec,
            eN.count = ed ?? 0
        },
        async fetchWallets({ page: J }) {
          let { includeWalletIds: et, excludeWalletIds: eo, featuredWalletIds: el } = eC.state
            , ec = [...eN.recommended.map(({ id: J }) => J), ...eo ?? [], ...el ?? []].filter(Boolean)
            , { data: ed, count: ep } = await eO.get({
              path: "/getWallets",
              headers: eM._getApiHeaders(),
              params: {
                page: String(J),
                entries: "40",
                include: et?.join(","),
                exclude: ec.join(",")
              }
            })
            , ef = ed.map(J => J.image_id).filter(Boolean);
          await Promise.allSettled([...ef.map(J => eM._fetchWalletImage(J)), eh.wait(300)]),
            eN.wallets = [...eN.wallets, ...ed],
            eN.count = ep > eN.count ? ep : eN.count,
            eN.page = J
        },
        async searchWallet({ search: J }) {
          let { includeWalletIds: et, excludeWalletIds: eo } = eC.state;
          eN.search = [];
          let { data: el } = await eO.get({
            path: "/getWallets",
            headers: eM._getApiHeaders(),
            params: {
              page: "1",
              entries: "100",
              search: J,
              include: et?.join(","),
              exclude: eo?.join(",")
            }
          })
            , ec = el.map(J => J.image_id).filter(Boolean);
          await Promise.allSettled([...ec.map(J => eM._fetchWalletImage(J)), eh.wait(300)]),
            eN.search = el
        },
        prefetch() {
          let J = [eM.fetchFeaturedWallets(), eM.fetchRecommendedWallets(), eM.fetchNetworkImages(), eM.fetchConnectorImages()];
          void 0 === eC.state.enableAnalytics && J.push(eM.fetchAnalyticsConfig()),
            eN.prefetchPromise = Promise.race([Promise.allSettled(J), eh.wait(3e3)])
        },
        async fetchAnalyticsConfig() {
          let { isAnalyticsEnabled: J } = await eO.get({
            path: "/getAnalyticsConfig",
            headers: eM._getApiHeaders()
          });
          eC.setEnableAnalytics(J)
        }
      }
      , eD = eh.getAnalyticsUrl()
      , ej = new FetchUtil({
        baseUrl: eD
      })
      , eL = ["MODAL_CREATED"]
      , e$ = (0,
        el.sj)({
          timestamp: Date.now(),
          data: {
            type: "track",
            event: "MODAL_CREATED"
          }
        })
      , eB = {
        state: e$,
        subscribe: J => (0,
          el.Ld)(e$, () => J(e$)),
        _getApiHeaders() {
          let { projectId: J, sdkType: et, sdkVersion: eo } = eC.state;
          return {
            "x-project-id": J,
            "x-sdk-type": et,
            "x-sdk-version": eo
          }
        },
        async _sendAnalyticsEvent(J) {
          try {
            if (eL.includes(J.data.event) || "undefined" == typeof window)
              return;
            await ej.post({
              path: "/e",
              headers: eB._getApiHeaders(),
              body: {
                eventId: eh.getUUID(),
                url: window.location.href,
                domain: window.location.hostname,
                timestamp: J.timestamp,
                props: J.data
              }
            })
          } catch { }
        },
        sendEvent(J) {
          e$.timestamp = Date.now(),
            e$.data = J,
            eC.state.enableAnalytics && eB._sendAnalyticsEvent(e$)
        }
      }
      , eF = (0,
        el.sj)({
          view: "Connect",
          history: ["Connect"]
        })
      , eU = {
        state: eF,
        subscribeKey: (J, et) => subscribeKey(eF, J, et),
        push(J, et) {
          J !== eF.view && (eF.view = J,
            eF.history.push(J),
            eF.data = et)
        },
        reset(J) {
          eF.view = J,
            eF.history = [J]
        },
        replace(J, et) {
          eF.history.length > 1 && eF.history.at(-1) !== J && (eF.view = J,
            eF.history[eF.history.length - 1] = J,
            eF.data = et)
        },
        goBack() {
          if (eF.history.length > 1) {
            eF.history.pop();
            let [J] = eF.history.slice(-1);
            J && (eF.view = J)
          }
        },
        goBackToIndex(J) {
          if (eF.history.length > 1) {
            eF.history = eF.history.slice(0, J + 1);
            let [et] = eF.history.slice(-1);
            et && (eF.view = et)
          }
        }
      }
      , ez = (0,
        el.sj)({
          loading: !1,
          open: !1
        })
      , eH = {
        state: ez,
        subscribe: J => (0,
          el.Ld)(ez, () => J(ez)),
        subscribeKey: (J, et) => subscribeKey(ez, J, et),
        async open(J) {
          await eM.state.prefetchPromise,
            J?.view ? eU.reset(J.view) : ef.state.isConnected ? eU.reset("Account") : eU.reset("Connect"),
            ez.open = !0,
            eA.set({
              open: !0
            }),
            eB.sendEvent({
              type: "track",
              event: "MODAL_OPEN"
            })
        },
        close() {
          ez.open = !1,
            eA.set({
              open: !1
            }),
            eB.sendEvent({
              type: "track",
              event: "MODAL_CLOSE"
            })
        },
        setLoading(J) {
          ez.loading = J
        }
      }
      , eV = eh.getBlockchainApiUrl()
      , eW = new FetchUtil({
        baseUrl: eV
      })
      , eZ = {
        fetchIdentity: ({ caipChainId: J, address: et }) => eW.get({
          path: `/v1/identity/${et}`,
          params: {
            chainId: J,
            projectId: eC.state.projectId
          }
        }),
        fetchTransactions: ({ account: J, projectId: et, cursor: eo }) => eW.get({
          path: `/v1/account/${J}/history?projectId=${et}`,
          params: eo ? {
            cursor: eo
          } : {}
        })
      }
      , eG = (0,
        el.sj)({
          message: "",
          variant: "success",
          open: !1
        })
      , eY = {
        state: eG,
        subscribeKey: (J, et) => subscribeKey(eG, J, et),
        showSuccess(J) {
          eG.message = J,
            eG.variant = "success",
            eG.open = !0
        },
        showError(J) {
          let et = eh.parseError(J);
          eG.message = et,
            eG.variant = "error",
            eG.open = !0
        },
        hide() {
          eG.open = !1
        }
      }
      , eK = (0,
        el.sj)({
          transactions: [],
          transactionsByYear: {},
          loading: !1,
          empty: !1,
          next: void 0
        })
      , eJ = {
        state: eK,
        subscribe: J => (0,
          el.Ld)(eK, () => J(eK)),
        async fetchTransactions(J) {
          let { projectId: et } = eC.state;
          if (!et || !J)
            throw Error("Transactions can't be fetched without a projectId and an accountAddress");
          eK.loading = !0;
          try {
            let eo = await eZ.fetchTransactions({
              account: J,
              projectId: et,
              cursor: eK.next
            })
              , el = this.filterSpamTransactions(eo.data)
              , ec = [...eK.transactions, ...el];
            eK.loading = !1,
              eK.transactions = ec,
              eK.transactionsByYear = this.groupTransactionsByYear(eK.transactionsByYear, el),
              eK.empty = 0 === ec.length,
              eK.next = eo.next ? eo.next : void 0
          } catch (eo) {
            eB.sendEvent({
              type: "track",
              event: "ERROR_FETCH_TRANSACTIONS",
              properties: {
                address: J,
                projectId: et,
                cursor: eK.next
              }
            }),
              eY.showError("Failed to fetch transactions"),
              eK.loading = !1,
              eK.empty = !0
          }
        },
        groupTransactionsByYear: (J = {}, et = []) => (et.forEach(et => {
          let eo = new Date(et.metadata.minedAt).getFullYear();
          J[eo] || (J[eo] = []),
            J[eo]?.push(et)
        }
        ),
          J),
        filterSpamTransactions: J => J.filter(J => {
          let et = J.transfers.every(J => J.nft_info?.flags.is_spam === !0);
          return !et
        }
        ),
        resetTransactions() {
          eK.transactions = [],
            eK.transactionsByYear = {},
            eK.loading = !1,
            eK.empty = !1,
            eK.next = void 0
        }
      }
      , eQ = (0,
        el.sj)({
          wcError: !1,
          buffering: !1
        })
      , eX = {
        state: eQ,
        subscribeKey: (J, et) => subscribeKey(eQ, J, et),
        _getClient() {
          if (!eQ._client)
            throw Error("ConnectionController client not set");
          return eQ._client
        },
        setClient(J) {
          eQ._client = (0,
            el.iH)(J)
        },
        connectWalletConnect() {
          eQ.wcPromise = this._getClient().connectWalletConnect(J => {
            eQ.wcUri = J,
              eQ.wcPairingExpiry = eh.getPairingExpiry()
          }
          )
        },
        async connectExternal(J) {
          await this._getClient().connectExternal?.(J),
            ew.setConnectedConnector(J.type)
        },
        async signMessage(J) {
          return this._getClient().signMessage(J)
        },
        checkInstalled(J) {
          return this._getClient().checkInstalled?.(J)
        },
        resetWcConnection() {
          eQ.wcUri = void 0,
            eQ.wcPairingExpiry = void 0,
            eQ.wcPromise = void 0,
            eQ.wcLinking = void 0,
            eQ.recentWallet = void 0,
            eJ.resetTransactions(),
            ew.deleteWalletConnectDeepLink()
        },
        setWcLinking(J) {
          eQ.wcLinking = J
        },
        setWcError(J) {
          eQ.wcError = J,
            eQ.buffering = !1
        },
        setRecentWallet(J) {
          eQ.recentWallet = J
        },
        setBuffering(J) {
          eQ.buffering = J
        },
        async disconnect() {
          await this._getClient().disconnect(),
            this.resetWcConnection()
        }
      }
      , e0 = (0,
        el.sj)({
          status: "uninitialized",
          isSiweEnabled: !1
        })
      , e1 = {
        state: e0,
        subscribeKey: (J, et) => subscribeKey(e0, J, et),
        subscribe: J => (0,
          el.Ld)(e0, () => J(e0)),
        _getClient() {
          if (!e0._client)
            throw Error("SIWEController client not set");
          return e0._client
        },
        async getNonce() {
          let J = this._getClient()
            , et = await J.getNonce();
          return this.setNonce(et),
            et
        },
        async getSession() {
          let J = this._getClient()
            , et = await J.getSession();
          return et && (this.setSession(et),
            this.setStatus("success")),
            et
        },
        createMessage(J) {
          let et = this._getClient()
            , eo = et.createMessage(J);
          return this.setMessage(eo),
            eo
        },
        async verifyMessage(J) {
          let et = this._getClient()
            , eo = await et.verifyMessage(J);
          return eo
        },
        async signIn() {
          let J = this._getClient()
            , et = await J.signIn();
          return et
        },
        async signOut() {
          let J = this._getClient();
          await J.signOut(),
            this.setStatus("ready"),
            J.onSignOut?.()
        },
        onSignIn(J) {
          let et = this._getClient();
          et.onSignIn?.(J)
        },
        onSignOut() {
          let J = this._getClient();
          J.onSignOut?.()
        },
        setSIWEClient(J) {
          e0._client = (0,
            el.iH)(J),
            e0.status = "ready",
            e0.isSiweEnabled = J.options.enabled
        },
        setNonce(J) {
          e0.nonce = J
        },
        setStatus(J) {
          e0.status = J
        },
        setMessage(J) {
          e0.message = J
        },
        setSession(J) {
          e0.session = J
        }
      }
      , e2 = (0,
        el.sj)({
          themeMode: "dark",
          themeVariables: {}
        })
      , e3 = {
        state: e2,
        subscribe: J => (0,
          el.Ld)(e2, () => J(e2)),
        setThemeMode(J) {
          e2.themeMode = J
        },
        setThemeVariables(J) {
          e2.themeVariables = {
            ...e2.themeVariables,
            ...J
          }
        },
        getSnapshot: () => (0,
          el.CO)(e2)
      }
      , e5 = {
        getWalletImage: J => J?.image_url ? J?.image_url : J?.image_id ? ex.state.walletImages[J.image_id] : void 0,
        getNetworkImage: J => J?.imageUrl ? J?.imageUrl : J?.imageId ? ex.state.networkImages[J.imageId] : void 0,
        getConnectorImage: J => J?.imageUrl ? J.imageUrl : J?.imageId ? ex.state.connectorImages[J.imageId] : void 0
      }
      , e6 = {
        goBackOrCloseModal() {
          eU.state.history.length > 1 ? eU.goBack() : eH.close()
        },
        navigateAfterNetworkSwitch() {
          let { history: J } = eU.state
            , et = J.findIndex(J => "Networks" === J);
          et >= 1 ? eU.goBackToIndex(et - 1) : eH.close()
        }
      }
  },
  52408: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      bq: function () {
        return el
      },
      gk: function () {
        return ed
      },
      CK: function () {
        return ec
      }
    });
    let el = {
      WALLET_CONNECT_CONNECTOR_ID: "walletConnect",
      INJECTED_CONNECTOR_ID: "injected",
      COINBASE_CONNECTOR_ID: "coinbaseWallet",
      COINBASE_SDK_CONNECTOR_ID: "coinbaseWalletSDK",
      SAFE_CONNECTOR_ID: "safe",
      LEDGER_CONNECTOR_ID: "ledger",
      EIP6963_CONNECTOR_ID: "eip6963",
      EMAIL_CONNECTOR_ID: "w3mEmail",
      EIP155: "eip155",
      ADD_CHAIN_METHOD: "wallet_addEthereumChain",
      EIP6963_ANNOUNCE_EVENT: "eip6963:announceProvider",
      EIP6963_REQUEST_EVENT: "eip6963:requestProvider",
      VERSION: "4.0.0-alpha.3"
    }
      , ec = {
        ConnectorExplorerIds: {
          [el.COINBASE_CONNECTOR_ID]: "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
          [el.SAFE_CONNECTOR_ID]: "225affb176778569276e484e1b92637ad061b01e13a048b35a9d280c3b58970f",
          [el.LEDGER_CONNECTOR_ID]: "19177a98252e07ddfc9af2083ba8e07ef627cb6103467ffebb3f8f4205fd7927"
        },
        EIP155NetworkImageIds: {
          1: "692ed6ba-e569-459a-556a-776476829e00",
          42161: "600a9a04-c1b9-42ca-6785-9b4b6ff85200",
          43114: "30c46e53-e989-45fb-4549-be3bd4eb3b00",
          56: "93564157-2e8e-4ce7-81df-b264dbee9b00",
          250: "06b26297-fe0c-4733-5d6b-ffa5498aac00",
          10: "ab9c186a-c52f-464b-2906-ca59d760a400",
          137: "41d04d42-da3b-4453-8506-668cc0727900",
          100: "02b53f6a-e3d4-479e-1cb4-21178987d100",
          9001: "f926ff41-260d-4028-635e-91913fc28e00",
          324: "b310f07f-4ef7-49f3-7073-2a0a39685800",
          314: "5a73b3dd-af74-424e-cae0-0de859ee9400",
          4689: "34e68754-e536-40da-c153-6ef2e7188a00",
          1088: "3897a66d-40b9-4833-162f-a2c90531c900",
          1284: "161038da-44ae-4ec7-1208-0ea569454b00",
          1285: "f1d73bb6-5450-4e18-38f7-fb6484264a00",
          7777777: "845c60df-d429-4991-e687-91ae45791600",
          42220: "ab781bbc-ccc6-418d-d32d-789b15da1f00",
          8453: "7289c336-3981-4081-c5f4-efc26ac64a00",
          1313161554: "3ff73439-a619-4894-9262-4470c773a100"
        },
        ConnectorImageIds: {
          [el.COINBASE_CONNECTOR_ID]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
          [el.COINBASE_SDK_CONNECTOR_ID]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
          [el.SAFE_CONNECTOR_ID]: "461db637-8616-43ce-035a-d89b8a1d5800",
          [el.LEDGER_CONNECTOR_ID]: "54a1aa77-d202-4f8d-0fb2-5d2bb6db0300",
          [el.WALLET_CONNECT_CONNECTOR_ID]: "ef1a1fcf-7fe8-4d69-bd6d-fda1345b4400",
          [el.INJECTED_CONNECTOR_ID]: "07ba87ed-43aa-4adf-4540-9e6a2b9cae00"
        },
        ConnectorNamesMap: {
          [el.INJECTED_CONNECTOR_ID]: "Browser Wallet",
          [el.WALLET_CONNECT_CONNECTOR_ID]: "WalletConnect",
          [el.COINBASE_CONNECTOR_ID]: "Coinbase",
          [el.COINBASE_SDK_CONNECTOR_ID]: "Coinbase",
          [el.LEDGER_CONNECTOR_ID]: "Ledger",
          [el.SAFE_CONNECTOR_ID]: "Safe"
        },
        ConnectorTypesMap: {
          [el.INJECTED_CONNECTOR_ID]: "INJECTED",
          [el.WALLET_CONNECT_CONNECTOR_ID]: "WALLET_CONNECT",
          [el.EIP6963_CONNECTOR_ID]: "ANNOUNCED",
          [el.EMAIL_CONNECTOR_ID]: "EMAIL"
        },
        WalletConnectRpcChainIds: [1, 5, 11155111, 10, 420, 42161, 421613, 137, 80001, 42220, 1313161554, 1313161555, 56, 97, 43114, 43113, 100, 8453, 84531, 7777777, 999, 324, 280]
      }
      , ed = {
        caipNetworkIdToNumber: J => J ? Number(J.split(":")[1]) : void 0,
        getCaipTokens(J) {
          if (!J)
            return;
          let et = {};
          return Object.entries(J).forEach(([J, eo]) => {
            et[`${el.EIP155}:${J}`] = eo
          }
          ),
            et
        }
      }
  },
  90078: function (J, et, eo) {
    "use strict";
    eo.r(et),
      eo.d(et, {
        W3mModal: function () {
          return em
        }
      });
    var el = eo(76472)
      , ec = eo(87214)
      , ed = eo(77996)
      , eh = eo(37380)
      , ep = ed.iv`
:host {
  z-index: var(--w3m-z-index);
  display: block;
  backface-visibility: hidden;
  will-change: opacity;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  pointer-events: none;
  opacity: 0;
  background-color: var(--wui-cover);
}

@keyframes zoom-in {
  0% {
    transform: scale(0.95) translateY(0);
  }
  100% {
    transform: scale(1) translateY(0);
  }
}

@keyframes slide-in {
  0% {
    transform: scale(1) translateY(50px);
  }
  100% {
    transform: scale(1) translateY(0);
  }
}

wui-card {
  max-width: 360px;
  width: 100%;
  position: relative;
  animation-delay: 0.3s;
  animation-duration: 0.2s;
  animation-name: zoom-in;
  animation-fill-mode: backwards;
  animation-timing-function: var(--wui-ease-out-power-2);
  outline: none;
}

wui-flex {
  overflow-x: hidden;
  overflow-y: auto;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  height: 100%;
}

@media (max-height: 700px) and (min-width: 431px) {
  wui-flex {
    align-items: flex-start;
  }

  wui-card {
    margin: var(--wui-spacing-xxl) 0px;
  }
}

@media (max-width: 430px) {
  wui-flex {
    align-items: flex-end;
  }

  wui-card {
    max-width: 100%;
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0;
    border-bottom: none;
    animation-name: slide-in;
  }
}
`
      , __decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let ef = "scroll-lock"
      , em = class extends ed.oi {
        constructor() {
          super(),
            this.unsubscribe = [],
            this.abortController = void 0,
            this.open = el.IN.state.open,
            this.caipAddress = el.AccountController.state.address,
            this.isSiweEnabled = el.yD.state.isSiweEnabled,
            this.initializeTheming(),
            el.ApiController.prefetch(),
            this.unsubscribe.push(el.IN.subscribeKey("open", J => J ? this.onOpen() : this.onClose()), el.yD.subscribeKey("isSiweEnabled", J => {
              this.isSiweEnabled = J
            }
            ), el.AccountController.subscribe(J => this.onNewAccountState(J))),
            el.Xs.sendEvent({
              type: "track",
              event: "MODAL_LOADED"
            })
        }
        disconnectedCallback() {
          this.unsubscribe.forEach(J => J()),
            this.onRemoveKeyboardListener()
        }
        render() {
          return this.open ? ed.dy`
        <wui-flex @click=${this.onOverlayClick.bind(this)}>
          <wui-card role="alertdialog" aria-modal="true" tabindex="0">
            <w3m-header></w3m-header>
            <w3m-router></w3m-router>
            <w3m-snackbar></w3m-snackbar>
          </wui-card>
        </wui-flex>
      ` : null
        }
        async onOverlayClick(J) {
          J.target === J.currentTarget && await this.handleClose()
        }
        async handleClose() {
          this.isSiweEnabled && "success" !== el.yD.state.status && await el.ConnectionController.disconnect(),
            el.IN.close()
        }
        initializeTheming() {
          let { themeVariables: J, themeMode: et } = el.ThemeController.state
            , eo = ec.UiHelperUtil.getColorTheme(et);
          (0,
            ec.initializeTheming)(J, eo)
        }
        async onClose() {
          this.onScrollUnlock(),
            await this.animate([{
              opacity: 1
            }, {
              opacity: 0
            }], {
              duration: 200,
              easing: "ease",
              fill: "forwards"
            }).finished,
            el.SnackController.hide(),
            this.open = !1,
            this.onRemoveKeyboardListener()
        }
        async onOpen() {
          this.onScrollLock(),
            this.open = !0,
            await this.animate([{
              opacity: 0
            }, {
              opacity: 1
            }], {
              duration: 200,
              easing: "ease",
              fill: "forwards",
              delay: 300
            }).finished,
            this.onAddKeyboardListener()
        }
        onScrollLock() {
          let J = document.createElement("style");
          J.dataset.w3m = ef,
            J.textContent = `
    html, body {
      touch-action: none;
      overflow: hidden;
      overscroll-behavior: contain;
    }
    w3m-modal {
      pointer-events: auto;
    }
  `,
            document.head.appendChild(J)
        }
        onScrollUnlock() {
          let J = document.head.querySelector(`style[data-w3m="${ef}"]`);
          J && J.remove()
        }
        onAddKeyboardListener() {
          this.abortController = new AbortController;
          let J = this.shadowRoot?.querySelector("wui-card");
          J?.focus(),
            window.addEventListener("keydown", et => {
              if ("Escape" === et.key)
                this.handleClose();
              else if ("Tab" === et.key) {
                let { tagName: eo } = et.target;
                !eo || eo.includes("W3M-") || eo.includes("WUI-") || J?.focus()
              }
            }
              , this.abortController)
        }
        onRemoveKeyboardListener() {
          this.abortController?.abort(),
            this.abortController = void 0
        }
        async onNewAccountState(J) {
          let { isConnected: et, caipAddress: eo } = J;
          if (this.isSiweEnabled) {
            et && !this.caipAddress && (this.caipAddress = eo),
              et && eo && this.caipAddress !== eo && (await el.yD.signOut(),
                this.onSiweNavigation(),
                this.caipAddress = eo);
            try {
              let J = await el.yD.getSession();
              J && !et ? await el.yD.signOut() : et && !J && this.onSiweNavigation()
            } catch (J) {
              et && this.onSiweNavigation()
            }
          }
        }
        onSiweNavigation() {
          this.open ? el.RouterController.push("ConnectingSiwe") : el.IN.open({
            view: "ConnectingSiwe"
          })
        }
      }
      ;
    em.styles = ep,
      __decorate([(0,
        eh.SB)()], em.prototype, "open", void 0),
      __decorate([(0,
        eh.SB)()], em.prototype, "caipAddress", void 0),
      __decorate([(0,
        eh.SB)()], em.prototype, "isSiweEnabled", void 0),
      em = __decorate([(0,
        ec.customElement)("w3m-modal")], em)
  },
  87214: function (J, et, eo) {
    "use strict";
    let el, ec, ed;
    eo.r(et),
      eo.d(et, {
        TransactionUtil: function () {
          return nD
        },
        UiHelperUtil: function () {
          return t2
        },
        WuiAccountButton: function () {
          return ro
        },
        WuiAllWalletsImage: function () {
          return rd
        },
        WuiAvatar: function () {
          return t4
        },
        WuiButton: function () {
          return rp
        },
        WuiCard: function () {
          return ew
        },
        WuiCardSelect: function () {
          return rE
        },
        WuiCardSelectLoader: function () {
          return ry
        },
        WuiChip: function () {
          return rS
        },
        WuiConnectButton: function () {
          return rT
        },
        WuiCtaButton: function () {
          return rP
        },
        WuiEmailInput: function () {
          return rM
        },
        WuiFlex: function () {
          return t5
        },
        WuiGrid: function () {
          return nP
        },
        WuiIcon: function () {
          return tE
        },
        WuiIconBox: function () {
          return t7
        },
        WuiIconLink: function () {
          return rj
        },
        WuiImage: function () {
          return tS
        },
        WuiInputElement: function () {
          return r$
        },
        WuiInputNumeric: function () {
          return rF
        },
        WuiInputText: function () {
          return rO
        },
        WuiLink: function () {
          return rz
        },
        WuiListAccordion: function () {
          return nE
        },
        WuiListContent: function () {
          return nS
        },
        WuiListItem: function () {
          return rV
        },
        WuiListWallet: function () {
          return r0
        },
        WuiListWalletTransaction: function () {
          return nT
        },
        WuiLoadingHexagon: function () {
          return tT
        },
        WuiLoadingSpinner: function () {
          return tP
        },
        WuiLoadingThumbnail: function () {
          return tI
        },
        WuiLogo: function () {
          return r2
        },
        WuiLogoSelect: function () {
          return r5
        },
        WuiNetworkButton: function () {
          return r4
        },
        WuiNetworkImage: function () {
          return r_
        },
        WuiNoticeCard: function () {
          return n_
        },
        WuiOtp: function () {
          return r7
        },
        WuiQrCode: function () {
          return no
        },
        WuiSearchBar: function () {
          return nc
        },
        WuiSeparator: function () {
          return nI
        },
        WuiShimmer: function () {
          return tN
        },
        WuiSnackbar: function () {
          return nh
        },
        WuiTabs: function () {
          return nf
        },
        WuiTag: function () {
          return rQ
        },
        WuiText: function () {
          return t$
        },
        WuiTooltip: function () {
          return ng
        },
        WuiTransactionListItem: function () {
          return rG
        },
        WuiTransactionListItemLoader: function () {
          return rK
        },
        WuiTransactionVisual: function () {
          return rq
        },
        WuiVisual: function () {
          return t0
        },
        WuiVisualThumbnail: function () {
          return nb
        },
        WuiWalletImage: function () {
          return rl
        },
        customElement: function () {
          return customElement
        },
        initializeTheming: function () {
          return initializeTheming
        },
        setColorTheme: function () {
          return setColorTheme
        },
        setThemeVariables: function () {
          return setThemeVariables
        }
      });
    var eh, ep, ef = eo(77996);
    function initializeTheming(J, et) {
      el = document.createElement("style"),
        ec = document.createElement("style"),
        ed = document.createElement("style"),
        el.textContent = createRootStyles(J).core.cssText,
        ec.textContent = createRootStyles(J).dark.cssText,
        ed.textContent = createRootStyles(J).light.cssText,
        document.head.appendChild(el),
        document.head.appendChild(ec),
        document.head.appendChild(ed),
        setColorTheme(et)
    }
    function setColorTheme(J) {
      ec && ed && ("light" === J ? (ec.removeAttribute("media"),
        ed.media = "enabled") : (ed.removeAttribute("media"),
          ec.media = "enabled"))
    }
    function setThemeVariables(J) {
      el && ec && ed && (el.textContent = createRootStyles(J).core.cssText,
        ec.textContent = createRootStyles(J).dark.cssText,
        ed.textContent = createRootStyles(J).light.cssText)
    }
    function createRootStyles(J) {
      return {
        core: ef.iv`
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
    :root {
      --w3m-color-mix-strength: ${(0,
            ef.$m)(J?.["--w3m-color-mix-strength"] ? `${J["--w3m-color-mix-strength"]}%` : "0%")};
      --w3m-font-family: ${(0,
            ef.$m)(J?.["--w3m-font-family"] || "Inter, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;")};
      --w3m-font-size-master: ${(0,
            ef.$m)(J?.["--w3m-font-size-master"] || "10px")};
      --w3m-border-radius-master: ${(0,
            ef.$m)(J?.["--w3m-border-radius-master"] || "4px")};
      --w3m-z-index: ${(0,
            ef.$m)(J?.["--w3m-z-index"] || 100)};

      --wui-font-family: var(--w3m-font-family);

      --wui-font-size-micro: var(--w3m-font-size-master);
      --wui-font-size-tiny: calc(var(--w3m-font-size-master) * 1.2);
      --wui-font-size-small: calc(var(--w3m-font-size-master) * 1.4);
      --wui-font-size-paragraph: calc(var(--w3m-font-size-master) * 1.6);
      --wui-font-size-large: calc(var(--w3m-font-size-master) * 2);

      --wui-border-radius-5xs: var(--w3m-border-radius-master);
      --wui-border-radius-4xs: calc(var(--w3m-border-radius-master) * 1.5);
      --wui-border-radius-3xs: calc(var(--w3m-border-radius-master) * 2);
      --wui-border-radius-xxs: calc(var(--w3m-border-radius-master) * 3);
      --wui-border-radius-xs: calc(var(--w3m-border-radius-master) * 4);
      --wui-border-radius-s: calc(var(--w3m-border-radius-master) * 5);
      --wui-border-radius-m: calc(var(--w3m-border-radius-master) * 7);
      --wui-border-radius-l: calc(var(--w3m-border-radius-master) * 9);
      --wui-border-radius-3xl: calc(var(--w3m-border-radius-master) * 20);

      --wui-font-weight-light: 400;
      --wui-font-weight-regular: 500;
      --wui-font-weight-medium: 600;
      --wui-font-weight-bold: 700;

      --wui-letter-spacing-large: -0.8px;
      --wui-letter-spacing-paragraph: -0.64px;
      --wui-letter-spacing-small: -0.56px;
      --wui-letter-spacing-tiny: -0.48px;
      --wui-letter-spacing-micro: -0.2px;

      --wui-spacing-0: 0px;
      --wui-spacing-4xs: 2px;
      --wui-spacing-3xs: 4px;
      --wui-spacing-xxs: 6px;
      --wui-spacing-2xs: 7px;
      --wui-spacing-xs: 8px;
      --wui-spacing-1xs: 10px;
      --wui-spacing-s: 12px;
      --wui-spacing-m: 14px;
      --wui-spacing-l: 16px;
      --wui-spacing-2l: 18px;
      --wui-spacing-xl: 20px;
      --wui-spacing-xxl: 24px;
      --wui-spacing-2xl: 32px;
      --wui-spacing-3xl: 40px;
      --wui-spacing-4xl: 90px;

      --wui-icon-box-size-xxs: 14px;
      --wui-icon-box-size-xs: 20px;
      --wui-icon-box-size-sm: 24px;
      --wui-icon-box-size-md: 32px;
      --wui-icon-box-size-lg: 40px;
      --wui-icon-box-size-xl: 64px;

      --wui-icon-size-inherit: inherit;
      --wui-icon-size-xxs: 10px;
      --wui-icon-size-xs: 12px;
      --wui-icon-size-sm: 14px;
      --wui-icon-size-md: 16px;
      --wui-icon-size-mdl: 18px;
      --wui-icon-size-lg: 20px;
      --wui-icon-size-xl: 24px;

      --wui-wallet-image-size-inherit: inherit;
      --wui-wallet-image-size-sm: 40px;
      --wui-wallet-image-size-md: 56px;
      --wui-wallet-image-size-lg: 80px;

      --wui-box-size-md: 100px;
      --wui-box-size-lg: 120px;

      --wui-ease-out-power-2: cubic-bezier(0, 0, 0.22, 1);
      --wui-ease-out-power-1: cubic-bezier(0, 0, 0.55, 1);

      --wui-ease-in-power-3: cubic-bezier(0.66, 0, 1, 1);
      --wui-ease-in-power-2: cubic-bezier(0.45, 0, 1, 1);
      --wui-ease-in-power-1: cubic-bezier(0.3, 0, 1, 1);

      --wui-ease-inout-power-1: cubic-bezier(0.45, 0, 0.55, 1);

      --wui-duration-lg: 200ms;
      --wui-duration-md: 125ms;
      --wui-duration-sm: 75ms;

      --wui-path-network: path(
        'M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z'
      );

      --wui-path-network-lg: path(
        'M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z'
      );

      --wui-color-inherit: inherit;

      --wui-color-inverse-100: #fff;
      --wui-color-inverse-000: #000;

      --wui-cover: rgba(20, 20, 20, 0.8);

      --wui-color-modal-bg: var(--wui-color-modal-bg-base);

      --wui-color-blue-100: var(--wui-color-blue-base-100);

      --wui-color-accent-100: var(--wui-color-accent-base-100);
      --wui-color-accent-090: var(--wui-color-accent-base-090);
      --wui-color-accent-080: var(--wui-color-accent-base-080);

      --wui-accent-glass-090: var(--wui-accent-glass-base-090);
      --wui-accent-glass-080: var(--wui-accent-glass-base-080);
      --wui-accent-glass-020: var(--wui-accent-glass-base-020);
      --wui-accent-glass-015: var(--wui-accent-glass-base-015);
      --wui-accent-glass-010: var(--wui-accent-glass-base-010);
      --wui-accent-glass-005: var(--wui-accent-glass-base-005);
      --wui-accent-glass-002: var(--wui-accent-glass-base-002);

      --wui-color-fg-100: var(--wui-color-fg-base-100);
      --wui-color-fg-125: var(--wui-color-fg-base-125);
      --wui-color-fg-150: var(--wui-color-fg-base-150);
      --wui-color-fg-175: var(--wui-color-fg-base-175);
      --wui-color-fg-200: var(--wui-color-fg-base-200);
      --wui-color-fg-225: var(--wui-color-fg-base-225);
      --wui-color-fg-250: var(--wui-color-fg-base-250);
      --wui-color-fg-275: var(--wui-color-fg-base-275);
      --wui-color-fg-300: var(--wui-color-fg-base-300);

      --wui-color-bg-100: var(--wui-color-bg-base-100);
      --wui-color-bg-125: var(--wui-color-bg-base-125);
      --wui-color-bg-150: var(--wui-color-bg-base-150);
      --wui-color-bg-175: var(--wui-color-bg-base-175);
      --wui-color-bg-200: var(--wui-color-bg-base-200);
      --wui-color-bg-225: var(--wui-color-bg-base-225);
      --wui-color-bg-250: var(--wui-color-bg-base-250);
      --wui-color-bg-275: var(--wui-color-bg-base-275);
      --wui-color-bg-300: var(--wui-color-bg-base-300);

      --wui-color-success-100: var(--wui-color-success-base-100);
      --wui-color-error-100: var(--wui-color-error-base-100);

      --wui-icon-box-bg-error-100: var(--wui-icon-box-bg-error-base-100);
      --wui-icon-box-bg-blue-100: var(--wui-icon-box-bg-blue-base-100);
      --wui-icon-box-bg-success-100: var(--wui-icon-box-bg-success-base-100);
      --wui-icon-box-bg-inverse-100: var(--wui-icon-box-bg-inverse-base-100);

      --wui-all-wallets-bg-100: var(--wui-all-wallets-bg-base-100);

      --wui-avatar-border: var(--wui-avatar-border-base);

      --wui-thumbnail-border: var(--wui-thumbnail-border-base);

      --wui-box-shadow-blue: rgba(71, 161, 255, 0.16);
    }

    @supports (background: color-mix(in srgb, white 50%, black)) {
      :root {
        --wui-color-modal-bg: color-mix(
          in srgb,
          var(--w3m-color-mix) var(--w3m-color-mix-strength),
          var(--wui-color-modal-bg-base)
        );

        --wui-box-shadow-blue: color-mix(in srgb, var(--wui-color-accent-100) 16%, transparent);

        --wui-color-accent-090: color-mix(
          in srgb,
          var(--wui-color-accent-base-100) 90%,
          var(--w3m-default)
        );
        --wui-color-accent-080: color-mix(
          in srgb,
          var(--wui-color-accent-base-100) 80%,
          var(--w3m-default)
        );

        --wui-color-accent-090: color-mix(
          in srgb,
          var(--wui-color-accent-base-100) 90%,
          transparent
        );
        --wui-color-accent-080: color-mix(
          in srgb,
          var(--wui-color-accent-base-100) 80%,
          transparent
        );

        --wui-accent-glass-090: color-mix(
          in srgb,
          var(--wui-color-accent-base-100) 90%,
          transparent
        );
        --wui-accent-glass-080: color-mix(
          in srgb,
          var(--wui-color-accent-base-100) 80%,
          transparent
        );
        --wui-accent-glass-020: color-mix(
          in srgb,
          var(--wui-color-accent-base-100) 20%,
          transparent
        );
        --wui-accent-glass-015: color-mix(
          in srgb,
          var(--wui-color-accent-base-100) 15%,
          transparent
        );
        --wui-accent-glass-010: color-mix(
          in srgb,
          var(--wui-color-accent-base-100) 10%,
          transparent
        );
        --wui-accent-glass-005: color-mix(
          in srgb,
          var(--wui-color-accent-base-100) 5%,
          transparent
        );
        --wui-color-accent-002: color-mix(
          in srgb,
          var(--wui-color-accent-base-100) 2%,
          transparent
        );

        --wui-color-fg-100: color-mix(
          in srgb,
          var(--w3m-color-mix) var(--w3m-color-mix-strength),
          var(--wui-color-fg-base-100)
        );
        --wui-color-fg-125: color-mix(
          in srgb,
          var(--w3m-color-mix) var(--w3m-color-mix-strength),
          var(--wui-color-fg-base-125)
        );
        --wui-color-fg-150: color-mix(
          in srgb,
          var(--w3m-color-mix) var(--w3m-color-mix-strength),
          var(--wui-color-fg-base-150)
        );
        --wui-color-fg-175: color-mix(
          in srgb,
          var(--w3m-color-mix) var(--w3m-color-mix-strength),
          var(--wui-color-fg-base-175)
        );
        --wui-color-fg-200: color-mix(
          in srgb,
          var(--w3m-color-mix) var(--w3m-color-mix-strength),
          var(--wui-color-fg-base-200)
        );
        --wui-color-fg-225: color-mix(
          in srgb,
          var(--w3m-color-mix) var(--w3m-color-mix-strength),
          var(--wui-color-fg-base-225)
        );
        --wui-color-fg-250: color-mix(
          in srgb,
          var(--w3m-color-mix) var(--w3m-color-mix-strength),
          var(--wui-color-fg-base-250)
        );
        --wui-color-fg-275: color-mix(
          in srgb,
          var(--w3m-color-mix) var(--w3m-color-mix-strength),
          var(--wui-color-fg-base-275)
        );
        --wui-color-fg-300: color-mix(
          in srgb,
          var(--w3m-color-mix) var(--w3m-color-mix-strength),
          var(--wui-color-fg-base-300)
        );

        --wui-color-bg-100: color-mix(
          in srgb,
          var(--w3m-color-mix) var(--w3m-color-mix-strength),
          var(--wui-color-bg-base-100)
        );
        --wui-color-bg-125: color-mix(
          in srgb,
          var(--w3m-color-mix) var(--w3m-color-mix-strength),
          var(--wui-color-bg-base-125)
        );
        --wui-color-bg-150: color-mix(
          in srgb,
          var(--w3m-color-mix) var(--w3m-color-mix-strength),
          var(--wui-color-bg-base-150)
        );
        --wui-color-bg-175: color-mix(
          in srgb,
          var(--w3m-color-mix) var(--w3m-color-mix-strength),
          var(--wui-color-bg-base-175)
        );
        --wui-color-bg-200: color-mix(
          in srgb,
          var(--w3m-color-mix) var(--w3m-color-mix-strength),
          var(--wui-color-bg-base-200)
        );
        --wui-color-bg-225: color-mix(
          in srgb,
          var(--w3m-color-mix) var(--w3m-color-mix-strength),
          var(--wui-color-bg-base-225)
        );
        --wui-color-bg-250: color-mix(
          in srgb,
          var(--w3m-color-mix) var(--w3m-color-mix-strength),
          var(--wui-color-bg-base-250)
        );
        --wui-color-bg-275: color-mix(
          in srgb,
          var(--w3m-color-mix) var(--w3m-color-mix-strength),
          var(--wui-color-bg-base-275)
        );
        --wui-color-bg-300: color-mix(
          in srgb,
          var(--w3m-color-mix) var(--w3m-color-mix-strength),
          var(--wui-color-bg-base-300)
        );

        --wui-color-success-100: color-mix(
          in srgb,
          var(--w3m-color-mix) var(--w3m-color-mix-strength),
          var(--wui-color-success-base-100)
        );
        --wui-color-error-100: color-mix(
          in srgb,
          var(--w3m-color-mix) var(--w3m-color-mix-strength),
          var(--wui-color-error-base-100)
        );

        --wui-icon-box-bg-error-100: color-mix(
          in srgb,
          var(--w3m-color-mix) var(--w3m-color-mix-strength),
          var(--wui-icon-box-bg-error-base-100)
        );
        --wui-icon-box-bg-accent-100: color-mix(
          in srgb,
          var(--w3m-color-mix) var(--w3m-color-mix-strength),
          var(--wui-icon-box-bg-blue-base-100)
        );
        --wui-icon-box-bg-success-100: color-mix(
          in srgb,
          var(--w3m-color-mix) var(--w3m-color-mix-strength),
          var(--wui-icon-box-bg-success-base-100)
        );
        --wui-icon-box-bg-inverse-100: color-mix(
          in srgb,
          var(--w3m-color-mix) var(--w3m-color-mix-strength),
          var(--wui-icon-box-bg-inverse-base-100)
        );

        --wui-all-wallets-bg-100: color-mix(
          in srgb,
          var(--w3m-color-mix) var(--w3m-color-mix-strength),
          var(--wui-all-wallets-bg-base-100)
        );

        --wui-avatar-border: color-mix(
          in srgb,
          var(--w3m-color-mix) var(--w3m-color-mix-strength),
          var(--wui-avatar-border-base)
        );

        --wui-thumbnail-border: color-mix(
          in srgb,
          var(--w3m-color-mix) var(--w3m-color-mix-strength),
          var(--wui-thumbnail-border-base)
        );
      }
    }
  `,
        light: ef.iv`
    :root {
      --w3m-color-mix: ${(0,
            ef.$m)(J?.["--w3m-color-mix"] || "#fff")};
      --w3m-accent: ${(0,
            ef.$m)(J?.["--w3m-accent"] || "#47a1ff")};
      --w3m-default: #fff;

      --wui-color-modal-bg-base: #191a1a;

      --wui-color-blue-base-100: #47a1ff;

      --wui-color-accent-base-100: var(--w3m-accent);
      --wui-color-accent-base-090: #59aaff;
      --wui-color-accent-base-080: #6cb4ff;

      --wui-accent-glass-base-090: rgba(71, 161, 255, 0.9);
      --wui-accent-glass-base-080: rgba(71, 161, 255, 0.8);
      --wui-accent-glass-base-020: rgba(71, 161, 255, 0.2);
      --wui-accent-glass-base-015: rgba(71, 161, 255, 0.15);
      --wui-accent-glass-base-010: rgba(71, 161, 255, 0.1);
      --wui-accent-glass-base-005: rgba(71, 161, 255, 0.05);
      --wui-accent-glass-base-002: rgba(71, 161, 255, 0.02);

      --wui-color-fg-base-100: #e4e7e7;
      --wui-color-fg-base-125: #d0d5d5;
      --wui-color-fg-base-150: #a8b1b1;
      --wui-color-fg-base-175: #a8b0b0;
      --wui-color-fg-base-200: #949e9e;
      --wui-color-fg-base-225: #868f8f;
      --wui-color-fg-base-250: #788080;
      --wui-color-fg-base-275: #788181;
      --wui-color-fg-base-300: #6e7777;

      --wui-color-bg-base-100: #141414;
      --wui-color-bg-base-125: #191a1a;
      --wui-color-bg-base-150: #1e1f1f;
      --wui-color-bg-base-175: #222525;
      --wui-color-bg-base-200: #272a2a;
      --wui-color-bg-base-225: #2c3030;
      --wui-color-bg-base-250: #313535;
      --wui-color-bg-base-275: #363b3b;
      --wui-color-bg-base-300: #3b4040;

      --wui-color-success-base-100: #26d962;
      --wui-color-error-base-100: #f25a67;

      --wui-success-glass-001: rgba(38, 217, 98, 0.01);
      --wui-success-glass-002: rgba(38, 217, 98, 0.02);
      --wui-success-glass-005: rgba(38, 217, 98, 0.05);
      --wui-success-glass-010: rgba(38, 217, 98, 0.1);
      --wui-success-glass-015: rgba(38, 217, 98, 0.15);
      --wui-success-glass-020: rgba(38, 217, 98, 0.2);
      --wui-success-glass-025: rgba(38, 217, 98, 0.25);
      --wui-success-glass-030: rgba(38, 217, 98, 0.3);
      --wui-success-glass-060: rgba(38, 217, 98, 0.6);
      --wui-success-glass-080: rgba(38, 217, 98, 0.8);

      --wui-icon-box-bg-error-base-100: #3c2426;
      --wui-icon-box-bg-blue-base-100: #20303f;
      --wui-icon-box-bg-success-base-100: var(--wui-success-glass-015);
      --wui-icon-box-bg-inverse-base-100: #243240;

      --wui-all-wallets-bg-base-100: #222b35;

      --wui-avatar-border-base: #252525;

      --wui-thumbnail-border-base: #252525;

      --wui-gray-glass-001: rgba(255, 255, 255, 0.01);
      --wui-gray-glass-002: rgba(255, 255, 255, 0.02);
      --wui-gray-glass-005: rgba(255, 255, 255, 0.05);
      --wui-gray-glass-010: rgba(255, 255, 255, 0.1);
      --wui-gray-glass-015: rgba(255, 255, 255, 0.15);
      --wui-gray-glass-020: rgba(255, 255, 255, 0.2);
      --wui-gray-glass-025: rgba(255, 255, 255, 0.25);
      --wui-gray-glass-030: rgba(255, 255, 255, 0.3);
      --wui-gray-glass-060: rgba(255, 255, 255, 0.6);
      --wui-gray-glass-080: rgba(255, 255, 255, 0.8);
    }
  `,
        dark: ef.iv`
    :root {
      --w3m-color-mix: ${(0,
            ef.$m)(J?.["--w3m-color-mix"] || "#000")};
      --w3m-accent: ${(0,
            ef.$m)(J?.["--w3m-accent"] || "#3396ff")};
      --w3m-default: #000;

      --wui-color-modal-bg-base: #fff;

      --wui-color-blue-base-100: #3396ff;

      --wui-color-accent-base-100: var(--w3m-accent);
      --wui-color-accent-base-090: #2d7dd2;
      --wui-color-accent-base-080: #2978cc;

      --wui-accent-glass-base-090: rgba(51, 150, 255, 0.9);
      --wui-accent-glass-base-080: rgba(51, 150, 255, 0.8);
      --wui-accent-glass-base-020: rgba(51, 150, 255, 0.2);
      --wui-accent-glass-base-015: rgba(51, 150, 255, 0.15);
      --wui-accent-glass-base-010: rgba(51, 150, 255, 0.1);
      --wui-accent-glass-base-005: rgba(51, 150, 255, 0.05);
      --wui-accent-glass-base-002: rgba(51, 150, 255, 0.02);

      --wui-color-fg-base-100: #141414;
      --wui-color-fg-base-125: #2d3131;
      --wui-color-fg-base-150: #474d4d;
      --wui-color-fg-base-175: #636d6d;
      --wui-color-fg-base-200: #798686;
      --wui-color-fg-base-225: #828f8f;
      --wui-color-fg-base-250: #8b9797;
      --wui-color-fg-base-275: #95a0a0;
      --wui-color-fg-base-300: #9ea9a9;

      --wui-color-bg-base-100: #ffffff;
      --wui-color-bg-base-125: #f5fafa;
      --wui-color-bg-base-150: #f3f8f8;
      --wui-color-bg-base-175: #eef4f4;
      --wui-color-bg-base-200: #eaf1f1;
      --wui-color-bg-base-225: #e5eded;
      --wui-color-bg-base-250: #e1e9e9;
      --wui-color-bg-base-275: #dce7e7;
      --wui-color-bg-base-300: #d8e3e3;

      --wui-color-success-base-100: #26b562;
      --wui-color-error-base-100: #f05142;

      --wui-success-glass-001: rgba(38, 181, 98, 0.01);
      --wui-success-glass-002: rgba(38, 181, 98, 0.02);
      --wui-success-glass-005: rgba(38, 181, 98, 0.05);
      --wui-success-glass-010: rgba(38, 181, 98, 0.1);
      --wui-success-glass-015: rgba(38, 181, 98, 0.15);
      --wui-success-glass-020: rgba(38, 181, 98, 0.2);
      --wui-success-glass-025: rgba(38, 181, 98, 0.25);
      --wui-success-glass-030: rgba(38, 181, 98, 0.3);
      --wui-success-glass-060: rgba(38, 181, 98, 0.6);
      --wui-success-glass-080: rgba(38, 181, 98, 0.8);

      --wui-icon-box-bg-error-base-100: #f4dfdd;
      --wui-icon-box-bg-blue-base-100: #d9ecfb;
      --wui-icon-box-bg-success-base-100: #daf0e4;
      --wui-icon-box-bg-inverse-base-100: #dcecfc;

      --wui-all-wallets-bg-base-100: #e8f1fa;

      --wui-avatar-border-base: #f3f4f4;

      --wui-thumbnail-border-base: #eaefef;

      --wui-gray-glass-001: rgba(0, 0, 0, 0.01);
      --wui-gray-glass-002: rgba(0, 0, 0, 0.02);
      --wui-gray-glass-005: rgba(0, 0, 0, 0.05);
      --wui-gray-glass-010: rgba(0, 0, 0, 0.1);
      --wui-gray-glass-015: rgba(0, 0, 0, 0.15);
      --wui-gray-glass-020: rgba(0, 0, 0, 0.2);
      --wui-gray-glass-025: rgba(0, 0, 0, 0.25);
      --wui-gray-glass-030: rgba(0, 0, 0, 0.3);
      --wui-gray-glass-060: rgba(0, 0, 0, 0.6);
      --wui-gray-glass-080: rgba(0, 0, 0, 0.8);
    }
  `
      }
    }
    let em = ef.iv`
*,
*::after,
*::before,
:host {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-style: normal;
  text-rendering: optimizeSpeed;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-tap-highlight-color: transparent;
  font-family: var(--wui-font-family);
  backface-visibility: hidden;
}
`
      , eg = ef.iv`
button,
a {
  cursor: pointer;
  display: flex;
  justify-content: center;
  align-items: center;
  position: relative;
  transition: all var(--wui-ease-out-power-1) var(--wui-duration-lg);
  outline: none;
  border: 1px solid transparent;
  column-gap: var(--wui-spacing-3xs);
  background-color: transparent;
  text-decoration: none;
}

@media (hover: hover) and (pointer: fine) {
  button:hover:enabled {
    background-color: var(--wui-gray-glass-005);
  }

  button:active:enabled {
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-sm);
    background-color: var(--wui-gray-glass-010);
  }

  button[data-variant='fill']:hover:enabled {
    background-color: var(--wui-color-accent-090);
  }

  button[data-variant='accentBg']:hover:enabled {
    background: var(--wui-accent-glass-015);
  }

  button[data-variant='accentBg']:active:enabled {
    background: var(--wui-accent-glass-020);
  }
}

button:disabled {
  cursor: not-allowed;
  background-color: var(--wui-gray-glass-005);
}

button[data-variant='shade']:disabled,
button[data-variant='accent']:disabled,
button[data-variant='accentBg']:disabled {
  background-color: var(--wui-gray-glass-010);
  color: var(--wui-gray-glass-015);
  filter: grayscale(1);
}

button:disabled > wui-wallet-image,
button:disabled > wui-all-wallets-image,
button:disabled > wui-network-image,
button:disabled > wui-image,
button:disabled > wui-icon-box,
button:disabled > wui-transaction-visual,
button:disabled > wui-logo {
  filter: grayscale(1);
}

button:focus-visible,
a:focus-visible {
  border: 1px solid var(--wui-color-accent-100);
  background-color: var(--wui-gray-glass-005);
  -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
}

button[data-variant='fill']:focus-visible {
  background-color: var(--wui-color-accent-090);
}

button[data-variant='fill'] {
  color: var(--wui-color-inverse-100);
  background-color: var(--wui-color-accent-100);
}

button[data-variant='fill']:disabled {
  color: var(--wui-gray-glass-015);
  background-color: var(--wui-gray-glass-015);
}

button[data-variant='fill']:disabled > wui-icon {
  color: var(--wui-gray-glass-015);
}

button[data-variant='shade'] {
  color: var(--wui-color-fg-200);
}

button[data-variant='accent'],
button[data-variant='accentBg'] {
  color: var(--wui-color-accent-100);
}

button[data-variant='accentBg'] {
  background: var(--wui-accent-glass-010);
  border: 1px solid var(--wui-accent-glass-010);
}

button[data-variant='fullWidth'] {
  width: 100%;
  border-radius: var(--wui-border-radius-xs);
  height: 56px;
  border: none;
  background-color: var(--wui-gray-glass-002);
  color: var(--wui-color-fg-200);
  gap: var(--wui-spacing-xs);
}

button:active:enabled {
  background-color: var(--wui-gray-glass-010);
}

button[data-variant='fill']:active:enabled {
  background-color: var(--wui-color-accent-080);
  border: 1px solid var(--wui-gray-glass-010);
}

input {
  border: none;
  outline: none;
  appearance: none;
}
`
      , ey = ef.iv`
.wui-color-inherit {
  color: var(--wui-color-inherit);
}

.wui-color-accent-100 {
  color: var(--wui-color-accent-100);
}

.wui-color-error-100 {
  color: var(--wui-color-error-100);
}

.wui-color-success-100 {
  color: var(--wui-color-success-100);
}

.wui-color-inverse-100 {
  color: var(--wui-color-inverse-100);
}

.wui-color-inverse-000 {
  color: var(--wui-color-inverse-000);
}

.wui-color-fg-100 {
  color: var(--wui-color-fg-100);
}

.wui-color-fg-200 {
  color: var(--wui-color-fg-200);
}

.wui-color-fg-300 {
  color: var(--wui-color-fg-300);
}

.wui-bg-color-inherit {
  background-color: var(--wui-color-inherit);
}

.wui-bg-color-blue-100 {
  background-color: var(--wui-color-accent-100);
}

.wui-bg-color-error-100 {
  background-color: var(--wui-color-error-100);
}

.wui-bg-color-success-100 {
  background-color: var(--wui-color-success-100);
}

.wui-bg-color-inverse-100 {
  background-color: var(--wui-color-inverse-100);
}

.wui-bg-color-inverse-000 {
  background-color: var(--wui-color-inverse-000);
}

.wui-bg-color-fg-100 {
  background-color: var(--wui-color-fg-100);
}

.wui-bg-color-fg-200 {
  background-color: var(--wui-color-fg-200);
}

.wui-bg-color-fg-300 {
  background-color: var(--wui-color-fg-300);
}
`;
    function customElement(J) {
      return function (et) {
        return "function" == typeof et ? (customElements.get(J) || customElements.define(J, et),
          et) : function (J, et) {
            let { kind: eo, elements: el } = et;
            return {
              kind: eo,
              elements: el,
              finisher(et) {
                customElements.get(J) || customElements.define(J, et)
              }
            }
          }(J, et)
      }
    }
    var eb = ef.iv`
:host {
  display: block;
  border-radius: clamp(0px, var(--wui-border-radius-l), 44px);
  border: 1px solid var(--wui-gray-glass-005);
  background-color: var(--wui-color-modal-bg);
  overflow: hidden;
}
`;
    let ew = class extends ef.oi {
      render() {
        return ef.dy`<slot></slot>`
      }
    }
      ;
    ew.styles = [em, eb],
      ew = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      }([customElement("wui-card")], ew);
    var e_ = eo(37380)
      , ex = ef.iv`
:host {
  display: flex;
  aspect-ratio: 1 / 1;
  color: var(--local-color);
  width: var(--local-width);
}

svg {
  width: inherit;
  height: inherit;
  object-fit: contain;
  object-position: center;
}
`;
    let eE = ef.YP`<svg fill="none" viewBox="0 0 24 24">
<path
  style="fill: var(--wui-color-accent-100);"
  d="M10.2 6.6a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM21 6.6a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM10.2 17.4a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM21 17.4a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0Z"
/>
</svg>`
      , eC = ef.YP`
<svg width="36" height="36">
<path
  d="M28.724 0H7.271A7.269 7.269 0 0 0 0 7.272v21.46A7.268 7.268 0 0 0 7.271 36H28.73A7.272 7.272 0 0 0 36 28.728V7.272A7.275 7.275 0 0 0 28.724 0Z"
  fill="url(#a)"
/>
<path
  d="m17.845 8.271.729-1.26a1.64 1.64 0 1 1 2.843 1.638l-7.023 12.159h5.08c1.646 0 2.569 1.935 1.853 3.276H6.434a1.632 1.632 0 0 1-1.638-1.638c0-.909.73-1.638 1.638-1.638h4.176l5.345-9.265-1.67-2.898a1.642 1.642 0 0 1 2.844-1.638l.716 1.264Zm-6.317 17.5-1.575 2.732a1.64 1.64 0 1 1-2.844-1.638l1.17-2.025c1.323-.41 2.398-.095 3.249.931Zm13.56-4.954h4.262c.909 0 1.638.729 1.638 1.638 0 .909-.73 1.638-1.638 1.638h-2.367l1.597 2.772c.45.788.185 1.782-.602 2.241a1.642 1.642 0 0 1-2.241-.603c-2.69-4.666-4.711-8.159-6.052-10.485-1.372-2.367-.391-4.743.576-5.549 1.075 1.846 2.682 4.631 4.828 8.348Z"
  fill="#fff"
/>
<defs>
  <linearGradient id="a" x1="18" y1="0" x2="18" y2="36" gradientUnits="userSpaceOnUse">
    <stop stop-color="#18BFFB" />
    <stop offset="1" stop-color="#2072F3" />
  </linearGradient>
</defs>
</svg>`
      , eS = ef.YP`<svg fill="none" viewBox="0 0 40 40">
<g clip-path="url(#a)">
  <g clip-path="url(#b)">
    <circle cx="20" cy="19.89" r="20" fill="#000" />
    <g clip-path="url(#c)">
      <path
        fill="#fff"
        d="M28.77 23.3c-.69 1.99-2.75 5.52-4.87 5.56-1.4.03-1.86-.84-3.46-.84-1.61 0-2.12.81-3.45.86-2.25.1-5.72-5.1-5.72-9.62 0-4.15 2.9-6.2 5.42-6.25 1.36-.02 2.64.92 3.47.92.83 0 2.38-1.13 4.02-.97.68.03 2.6.28 3.84 2.08-3.27 2.14-2.76 6.61.75 8.25ZM24.2 7.88c-2.47.1-4.49 2.69-4.2 4.84 2.28.17 4.47-2.39 4.2-4.84Z"
      />
    </g>
  </g>
</g>
<defs>
  <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
  <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
  <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
</defs>
</svg>`
      , ek = ef.YP`<svg fill="none" viewBox="0 0 14 15">
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M7 1.99a1 1 0 0 1 1 1v7.58l2.46-2.46a1 1 0 0 1 1.41 1.42L7.7 13.69a1 1 0 0 1-1.41 0L2.12 9.53A1 1 0 0 1 3.54 8.1L6 10.57V3a1 1 0 0 1 1-1Z"
  clip-rule="evenodd"
/>
</svg>`
      , eT = ef.YP`<svg fill="none" viewBox="0 0 14 15">
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M13 7.99a1 1 0 0 1-1 1H4.4l2.46 2.46a1 1 0 1 1-1.41 1.41L1.29 8.7a1 1 0 0 1 0-1.41L5.46 3.1a1 1 0 0 1 1.41 1.42L4.41 6.99H12a1 1 0 0 1 1 1Z"
  clip-rule="evenodd"
/>
</svg>`
      , eA = ef.YP`<svg fill="none" viewBox="0 0 14 15">
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M1 7.99a1 1 0 0 1 1-1h7.58L7.12 4.53A1 1 0 1 1 8.54 3.1l4.16 4.17a1 1 0 0 1 0 1.41l-4.16 4.17a1 1 0 1 1-1.42-1.41l2.46-2.46H2a1 1 0 0 1-1-1Z"
  clip-rule="evenodd"
/>
</svg>`
      , eP = ef.YP`<svg fill="none" viewBox="0 0 14 15">
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M7 13.99a1 1 0 0 1-1-1V5.4L3.54 7.86a1 1 0 0 1-1.42-1.41L6.3 2.28a1 1 0 0 1 1.41 0l4.17 4.17a1 1 0 1 1-1.41 1.41L8 5.4v7.59a1 1 0 0 1-1 1Z"
  clip-rule="evenodd"
/>
</svg>`
      , eR = ef.YP`<svg fill="none" viewBox="0 0 20 20">
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M4 6.4a1 1 0 0 1-.46.89 6.98 6.98 0 0 0 .38 6.18A7 7 0 0 0 16.46 7.3a1 1 0 0 1-.47-.92 7 7 0 0 0-12 .03Zm-2.02-.5a9 9 0 1 1 16.03 8.2A9 9 0 0 1 1.98 5.9Z"
  clip-rule="evenodd"
/>
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M6.03 8.63c-1.46-.3-2.72-.75-3.6-1.35l-.02-.01-.14-.11a1 1 0 0 1 1.2-1.6l.1.08c.6.4 1.52.74 2.69 1 .16-.99.39-1.88.67-2.65.3-.79.68-1.5 1.15-2.02A2.58 2.58 0 0 1 9.99 1c.8 0 1.45.44 1.92.97.47.52.84 1.23 1.14 2.02.29.77.52 1.66.68 2.64a8 8 0 0 0 2.7-1l.26-.18h.48a1 1 0 0 1 .12 2c-.86.51-2.01.91-3.34 1.18a22.24 22.24 0 0 1-.03 3.19c1.45.29 2.7.73 3.58 1.31a1 1 0 0 1-1.1 1.68c-.6-.4-1.56-.76-2.75-1-.15.8-.36 1.55-.6 2.2-.3.79-.67 1.5-1.14 2.02-.47.53-1.12.97-1.92.97-.8 0-1.45-.44-1.91-.97a6.51 6.51 0 0 1-1.15-2.02c-.24-.65-.44-1.4-.6-2.2-1.18.24-2.13.6-2.73.99a1 1 0 1 1-1.1-1.67c.88-.58 2.12-1.03 3.57-1.31a22.03 22.03 0 0 1-.04-3.2Zm2.2-1.7c.15-.86.34-1.61.58-2.24.24-.65.51-1.12.76-1.4.25-.28.4-.29.42-.29.03 0 .17.01.42.3.25.27.52.74.77 1.4.23.62.43 1.37.57 2.22a19.96 19.96 0 0 1-3.52 0Zm-.18 4.6a20.1 20.1 0 0 1-.03-2.62 21.95 21.95 0 0 0 3.94 0 20.4 20.4 0 0 1-.03 2.63 21.97 21.97 0 0 0-3.88 0Zm.27 2c.13.66.3 1.26.49 1.78.24.65.51 1.12.76 1.4.25.28.4.29.42.29.03 0 .17-.01.42-.3.25-.27.52-.74.77-1.4.19-.5.36-1.1.49-1.78a20.03 20.03 0 0 0-3.35 0Z"
  clip-rule="evenodd"
/>
</svg>`
      , eI = ef.YP`<svg fill="none" viewBox="0 0 14 15">
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M12.04 2.65c.47.3.6.91.3 1.38l-5.78 9a1 1 0 0 1-1.61.1L1.73 9.27A1 1 0 1 1 3.27 8L5.6 10.8l5.05-7.85a1 1 0 0 1 1.38-.3Z"
  clip-rule="evenodd"
/>
</svg>`
      , eO = ef.YP`<svg fill="none" viewBox="0 0 16 16">
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M1.46 4.96a1 1 0 0 1 1.41 0L8 10.09l5.13-5.13a1 1 0 1 1 1.41 1.41l-5.83 5.84a1 1 0 0 1-1.42 0L1.46 6.37a1 1 0 0 1 0-1.41Z"
  clip-rule="evenodd"
/>
</svg>`
      , eN = ef.YP`<svg fill="none" viewBox="0 0 16 16">
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M11.04 1.46a1 1 0 0 1 0 1.41L5.91 8l5.13 5.13a1 1 0 1 1-1.41 1.41L3.79 8.71a1 1 0 0 1 0-1.42l5.84-5.83a1 1 0 0 1 1.41 0Z"
  clip-rule="evenodd"
/>
</svg>`
      , eM = ef.YP`<svg fill="none" viewBox="0 0 16 16">
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M4.96 14.54a1 1 0 0 1 0-1.41L10.09 8 4.96 2.87a1 1 0 0 1 1.41-1.41l5.84 5.83a1 1 0 0 1 0 1.42l-5.84 5.83a1 1 0 0 1-1.41 0Z"
  clip-rule="evenodd"
/>
</svg>`
      , eD = ef.YP`<svg fill="none" viewBox="0 0 16 16">
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M14.54 11.04a1 1 0 0 1-1.41 0L8 5.92l-5.13 5.12a1 1 0 1 1-1.41-1.41l5.83-5.84a1 1 0 0 1 1.42 0l5.83 5.84a1 1 0 0 1 0 1.41Z"
  clip-rule="evenodd"
/>
</svg>`
      , ej = ef.YP`<svg width="36" height="36" fill="none">
<path
  fill="#fff"
  fill-opacity=".05"
  d="M0 14.94c0-5.55 0-8.326 1.182-10.4a9 9 0 0 1 3.359-3.358C6.614 0 9.389 0 14.94 0h6.12c5.55 0 8.326 0 10.4 1.182a9 9 0 0 1 3.358 3.359C36 6.614 36 9.389 36 14.94v6.12c0 5.55 0 8.326-1.182 10.4a9 9 0 0 1-3.359 3.358C29.386 36 26.611 36 21.06 36h-6.12c-5.55 0-8.326 0-10.4-1.182a9 9 0 0 1-3.358-3.359C0 29.386 0 26.611 0 21.06v-6.12Z"
/>
<path
  stroke="#fff"
  stroke-opacity=".05"
  d="M14.94.5h6.12c2.785 0 4.84 0 6.46.146 1.612.144 2.743.43 3.691.97a8.5 8.5 0 0 1 3.172 3.173c.541.948.826 2.08.971 3.692.145 1.62.146 3.675.146 6.459v6.12c0 2.785 0 4.84-.146 6.46-.145 1.612-.43 2.743-.97 3.691a8.5 8.5 0 0 1-3.173 3.172c-.948.541-2.08.826-3.692.971-1.62.145-3.674.146-6.459.146h-6.12c-2.784 0-4.84 0-6.46-.146-1.612-.145-2.743-.43-3.691-.97a8.5 8.5 0 0 1-3.172-3.173c-.541-.948-.827-2.08-.971-3.692C.5 25.9.5 23.845.5 21.06v-6.12c0-2.784 0-4.84.146-6.46.144-1.612.43-2.743.97-3.691A8.5 8.5 0 0 1 4.79 1.617C5.737 1.076 6.869.79 8.48.646 10.1.5 12.156.5 14.94.5Z"
/>
<path
  fill="url(#a)"
  d="M17.998 10.8h12.469a14.397 14.397 0 0 0-24.938.001l6.234 10.798.006-.001a7.19 7.19 0 0 1 6.23-10.799Z"
/>
<path
  fill="url(#b)"
  d="m24.237 21.598-6.234 10.798A14.397 14.397 0 0 0 30.47 10.798H18.002l-.002.006a7.191 7.191 0 0 1 6.237 10.794Z"
/>
<path
  fill="url(#c)"
  d="M11.765 21.601 5.531 10.803A14.396 14.396 0 0 0 18.001 32.4l6.235-10.798-.004-.004a7.19 7.19 0 0 1-12.466.004Z"
/>
<path fill="#fff" d="M18 25.2a7.2 7.2 0 1 0 0-14.4 7.2 7.2 0 0 0 0 14.4Z" />
<path fill="#1A73E8" d="M18 23.7a5.7 5.7 0 1 0 0-11.4 5.7 5.7 0 0 0 0 11.4Z" />
<defs>
  <linearGradient
    id="a"
    x1="6.294"
    x2="41.1"
    y1="5.995"
    y2="5.995"
    gradientUnits="userSpaceOnUse"
  >
    <stop stop-color="#D93025" />
    <stop offset="1" stop-color="#EA4335" />
  </linearGradient>
  <linearGradient
    id="b"
    x1="20.953"
    x2="37.194"
    y1="32.143"
    y2="2.701"
    gradientUnits="userSpaceOnUse"
  >
    <stop stop-color="#FCC934" />
    <stop offset="1" stop-color="#FBBC04" />
  </linearGradient>
  <linearGradient
    id="c"
    x1="25.873"
    x2="9.632"
    y1="31.2"
    y2="1.759"
    gradientUnits="userSpaceOnUse"
  >
    <stop stop-color="#1E8E3E" />
    <stop offset="1" stop-color="#34A853" />
  </linearGradient>
</defs>
</svg>`
      , eL = ef.YP`<svg fill="none" viewBox="0 0 16 16">
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M7 2.99a5 5 0 1 0 0 10 5 5 0 0 0 0-10Zm-7 5a7 7 0 1 1 14 0 7 7 0 0 1-14 0Zm7-4a1 1 0 0 1 1 1v2.58l1.85 1.85a1 1 0 0 1-1.41 1.42L6.29 8.69A1 1 0 0 1 6 8v-3a1 1 0 0 1 1-1Z"
  clip-rule="evenodd"
/>
</svg>`
      , e$ = ef.YP`<svg fill="none" viewBox="0 0 16 16">
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M2.54 2.54a1 1 0 0 1 1.42 0L8 6.6l4.04-4.05a1 1 0 1 1 1.42 1.42L9.4 8l4.05 4.04a1 1 0 0 1-1.42 1.42L8 9.4l-4.04 4.05a1 1 0 0 1-1.42-1.42L6.6 8 2.54 3.96a1 1 0 0 1 0-1.42Z"
  clip-rule="evenodd"
/>
</svg>`
      , eB = ef.YP`<svg fill="none" viewBox="0 0 20 20">
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M10 3a7 7 0 0 0-6.85 8.44l8.29-8.3C10.97 3.06 10.49 3 10 3Zm3.49.93-9.56 9.56c.32.55.71 1.06 1.16 1.5L15 5.1a7.03 7.03 0 0 0-1.5-1.16Zm2.7 2.8-9.46 9.46a7 7 0 0 0 9.46-9.46ZM1.99 5.9A9 9 0 1 1 18 14.09 9 9 0 0 1 1.98 5.91Z"
  clip-rule="evenodd"
/>
</svg>`
      , eF = ef.YP`<svg fill="none" viewBox="0 0 16 16">
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M8 2a6 6 0 1 0 0 12A6 6 0 0 0 8 2ZM0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm10.66-2.65a1 1 0 0 1 .23 1.06L9.83 9.24a1 1 0 0 1-.59.58l-2.83 1.06A1 1 0 0 1 5.13 9.6l1.06-2.82a1 1 0 0 1 .58-.59L9.6 5.12a1 1 0 0 1 1.06.23ZM7.9 7.89l-.13.35.35-.13.12-.35-.34.13Z"
  clip-rule="evenodd"
/>
</svg>`
      , eU = ef.YP`<svg fill="none" viewBox="0 0 16 16">
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M9.5 0h1.67c.68 0 1.26 0 1.73.04.5.05.97.14 1.42.4.52.3.95.72 1.24 1.24.26.45.35.92.4 1.42.04.47.04 1.05.04 1.73V6.5c0 .69 0 1.26-.04 1.74-.05.5-.14.97-.4 1.41-.3.52-.72.95-1.24 1.25-.45.25-.92.35-1.42.4-.43.03-.95.03-1.57.03 0 .62 0 1.14-.04 1.57-.04.5-.14.97-.4 1.42-.29.52-.72.95-1.24 1.24-.44.26-.92.35-1.41.4-.48.04-1.05.04-1.74.04H4.83c-.68 0-1.26 0-1.73-.04-.5-.05-.97-.14-1.42-.4-.52-.3-.95-.72-1.24-1.24a3.39 3.39 0 0 1-.4-1.42A20.9 20.9 0 0 1 0 11.17V9.5c0-.69 0-1.26.04-1.74.05-.5.14-.97.4-1.41.3-.52.72-.95 1.24-1.25.45-.25.92-.35 1.42-.4.43-.03.95-.03 1.57-.03 0-.62 0-1.14.04-1.57.04-.5.14-.97.4-1.42.29-.52.72-.95 1.24-1.24.44-.26.92-.35 1.41-.4A20.9 20.9 0 0 1 9.5 0ZM4.67 6.67c-.63 0-1.06 0-1.4.03-.35.03-.5.09-.6.14-.2.12-.38.3-.5.5-.05.1-.1.24-.14.6C2 8.32 2 8.8 2 9.54v1.59c0 .73 0 1.22.03 1.6.04.35.1.5.15.6.11.2.29.38.5.5.09.05.24.1.6.14.37.03.86.03 1.6.03h1.58c.74 0 1.22 0 1.6-.03.36-.04.5-.1.6-.15.2-.11.38-.29.5-.5.05-.09.1-.24.14-.6.03-.33.03-.76.03-1.39-.6 0-1.13 0-1.57-.04-.5-.04-.97-.14-1.41-.4-.52-.29-.95-.72-1.25-1.24a3.39 3.39 0 0 1-.4-1.41c-.03-.44-.03-.96-.03-1.57Zm3.27-4.64c-.36.04-.5.1-.6.15-.2.11-.38.29-.5.5-.05.09-.1.24-.14.6-.03.37-.03.86-.03 1.6v1.58c0 .74 0 1.22.03 1.6.03.36.09.5.14.6.12.2.3.38.5.5.1.05.24.1.6.14.38.03.86.03 1.6.03h1.59c.73 0 1.22 0 1.6-.03.35-.03.5-.09.6-.14.2-.12.38-.3.5-.5.05-.1.1-.24.14-.6.03-.38.03-.86.03-1.6V4.87c0-.73 0-1.22-.03-1.6a1.46 1.46 0 0 0-.15-.6c-.11-.2-.29-.38-.5-.5-.09-.05-.24-.1-.6-.14-.37-.03-.86-.03-1.6-.03H9.55c-.74 0-1.22 0-1.6.03Z"
  clip-rule="evenodd"
/>
</svg>`
      , ez = ef.YP` <svg fill="none" viewBox="0 0 13 4">
<path fill="currentColor" d="M.5 0h12L8.9 3.13a3.76 3.76 0 0 1-4.8 0L.5 0Z" />
</svg>`
      , eH = ef.YP`<svg fill="none" viewBox="0 0 20 20">
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M13.66 2H6.34c-1.07 0-1.96 0-2.68.08-.74.08-1.42.25-2.01.68a4 4 0 0 0-.89.89c-.43.6-.6 1.27-.68 2.01C0 6.38 0 7.26 0 8.34v.89c0 1.07 0 1.96.08 2.68.08.74.25 1.42.68 2.01a4 4 0 0 0 .89.89c.6.43 1.27.6 2.01.68a27 27 0 0 0 2.68.08h7.32a27 27 0 0 0 2.68-.08 4.03 4.03 0 0 0 2.01-.68 4 4 0 0 0 .89-.89c.43-.6.6-1.27.68-2.01.08-.72.08-1.6.08-2.68v-.89c0-1.07 0-1.96-.08-2.68a4.04 4.04 0 0 0-.68-2.01 4 4 0 0 0-.89-.89c-.6-.43-1.27-.6-2.01-.68C15.62 2 14.74 2 13.66 2ZM2.82 4.38c.2-.14.48-.25 1.06-.31C4.48 4 5.25 4 6.4 4h7.2c1.15 0 1.93 0 2.52.07.58.06.86.17 1.06.31a2 2 0 0 1 .44.44c.14.2.25.48.31 1.06.07.6.07 1.37.07 2.52v.77c0 1.15 0 1.93-.07 2.52-.06.58-.17.86-.31 1.06a2 2 0 0 1-.44.44c-.2.14-.48.25-1.06.32-.6.06-1.37.06-2.52.06H6.4c-1.15 0-1.93 0-2.52-.06-.58-.07-.86-.18-1.06-.32a2 2 0 0 1-.44-.44c-.14-.2-.25-.48-.31-1.06C2 11.1 2 10.32 2 9.17V8.4c0-1.15 0-1.93.07-2.52.06-.58.17-.86.31-1.06a2 2 0 0 1 .44-.44Z"
  clip-rule="evenodd"
/>
<path fill="currentColor" d="M6.14 17.57a1 1 0 1 0 0 2h7.72a1 1 0 1 0 0-2H6.14Z" />
</svg>`
      , eV = ef.YP`<svg fill="none" viewBox="0 0 16 16">
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M6.07 1h.57a1 1 0 0 1 0 2h-.52c-.98 0-1.64 0-2.14.06-.48.05-.7.14-.84.24-.13.1-.25.22-.34.35-.1.14-.2.35-.25.83-.05.5-.05 1.16-.05 2.15v2.74c0 .99 0 1.65.05 2.15.05.48.14.7.25.83.1.14.2.25.34.35.14.1.36.2.84.25.5.05 1.16.05 2.14.05h.52a1 1 0 0 1 0 2h-.57c-.92 0-1.69 0-2.3-.07a3.6 3.6 0 0 1-1.8-.61c-.3-.22-.57-.49-.8-.8a3.6 3.6 0 0 1-.6-1.79C.5 11.11.5 10.35.5 9.43V6.58c0-.92 0-1.7.06-2.31a3.6 3.6 0 0 1 .62-1.8c.22-.3.48-.57.79-.79a3.6 3.6 0 0 1 1.8-.61C4.37 1 5.14 1 6.06 1ZM9.5 3a1 1 0 0 1 1.42 0l4.28 4.3a1 1 0 0 1 0 1.4L10.93 13a1 1 0 0 1-1.42-1.42L12.1 9H6.8a1 1 0 1 1 0-2h5.3L9.51 4.42a1 1 0 0 1 0-1.41Z"
  clip-rule="evenodd"
/>
</svg>`
      , eW = ef.YP`<svg fill="none" viewBox="0 0 40 40">
<g clip-path="url(#a)">
  <g clip-path="url(#b)">
    <circle cx="20" cy="19.89" r="20" fill="#5865F2" />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M25.71 28.15C30.25 28 32 25.02 32 25.02c0-6.61-2.96-11.98-2.96-11.98-2.96-2.22-5.77-2.15-5.77-2.15l-.29.32c3.5 1.07 5.12 2.61 5.12 2.61a16.75 16.75 0 0 0-10.34-1.93l-.35.04a15.43 15.43 0 0 0-5.88 1.9s1.71-1.63 5.4-2.7l-.2-.24s-2.81-.07-5.77 2.15c0 0-2.96 5.37-2.96 11.98 0 0 1.73 2.98 6.27 3.13l1.37-1.7c-2.6-.79-3.6-2.43-3.6-2.43l.58.35.09.06.08.04.02.01.08.05a17.25 17.25 0 0 0 4.52 1.58 14.4 14.4 0 0 0 8.3-.86c.72-.27 1.52-.66 2.37-1.21 0 0-1.03 1.68-3.72 2.44.61.78 1.35 1.67 1.35 1.67Zm-9.55-9.6c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28.01-1.25-.93-2.28-2.1-2.28Zm7.5 0c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28 0-1.25-.93-2.28-2.1-2.28Z"
      clip-rule="evenodd"
    />
  </g>
</g>
<defs>
  <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
  <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
</defs>
</svg>`
      , eZ = ef.YP`<svg fill="none" viewBox="0 0 16 16">
<path
  fill="currentColor"
  d="M4.25 7a.63.63 0 0 0-.63.63v3.97c0 .28-.2.51-.47.54l-.75.07a.93.93 0 0 1-.9-.47A7.51 7.51 0 0 1 5.54.92a7.5 7.5 0 0 1 9.54 4.62c.12.35.06.72-.16 1-.74.97-1.68 1.78-2.6 2.44V4.44a.64.64 0 0 0-.63-.64h-1.06c-.35 0-.63.3-.63.64v5.5c0 .23-.12.42-.32.5l-.52.23V6.05c0-.36-.3-.64-.64-.64H7.45c-.35 0-.64.3-.64.64v4.97c0 .25-.17.46-.4.52a5.8 5.8 0 0 0-.45.11v-4c0-.36-.3-.65-.64-.65H4.25ZM14.07 12.4A7.49 7.49 0 0 1 3.6 14.08c4.09-.58 9.14-2.5 11.87-6.6v.03a7.56 7.56 0 0 1-1.41 4.91Z"
/>
</svg>`
      , eG = ef.YP`<svg fill="none" viewBox="0 0 14 15">
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M6.71 2.99a.57.57 0 0 0-.57.57 1 1 0 0 1-1 1c-.58 0-.96 0-1.24.03-.27.03-.37.07-.42.1a.97.97 0 0 0-.36.35c-.04.08-.09.21-.11.67a2.57 2.57 0 0 1 0 5.13c.02.45.07.6.11.66.09.15.21.28.36.36.07.04.21.1.67.12a2.57 2.57 0 0 1 5.12 0c.46-.03.6-.08.67-.12a.97.97 0 0 0 .36-.36c.03-.04.07-.14.1-.41.02-.29.03-.66.03-1.24a1 1 0 0 1 1-1 .57.57 0 0 0 0-1.15 1 1 0 0 1-1-1c0-.58 0-.95-.03-1.24a1.04 1.04 0 0 0-.1-.42.97.97 0 0 0-.36-.36 1.04 1.04 0 0 0-.42-.1c-.28-.02-.65-.02-1.24-.02a1 1 0 0 1-1-1 .57.57 0 0 0-.57-.57ZM5.15 13.98a1 1 0 0 0 .99-1v-.78a.57.57 0 0 1 1.14 0v.78a1 1 0 0 0 .99 1H8.36a66.26 66.26 0 0 0 .73 0 3.78 3.78 0 0 0 1.84-.38c.46-.26.85-.64 1.1-1.1.23-.4.32-.8.36-1.22.02-.2.03-.4.03-.63a2.57 2.57 0 0 0 0-4.75c0-.23-.01-.44-.03-.63a2.96 2.96 0 0 0-.35-1.22 2.97 2.97 0 0 0-1.1-1.1c-.4-.22-.8-.31-1.22-.35a8.7 8.7 0 0 0-.64-.04 2.57 2.57 0 0 0-4.74 0c-.23 0-.44.02-.63.04-.42.04-.83.13-1.22.35-.46.26-.84.64-1.1 1.1-.33.57-.37 1.2-.39 1.84a21.39 21.39 0 0 0 0 .72v.1a1 1 0 0 0 1 .99h.78a.57.57 0 0 1 0 1.15h-.77a1 1 0 0 0-1 .98v.1a63.87 63.87 0 0 0 0 .73c0 .64.05 1.27.38 1.83.26.47.64.85 1.1 1.11.56.32 1.2.37 1.84.38a20.93 20.93 0 0 0 .72 0h.1Z"
  clip-rule="evenodd"
/>
</svg>`
      , eY = ef.YP`<svg fill="none" viewBox="0 0 14 15">
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M3.74 3.99a1 1 0 0 1 1-1H11a1 1 0 0 1 1 1v6.26a1 1 0 0 1-2 0V6.4l-6.3 6.3a1 1 0 0 1-1.4-1.42l6.29-6.3H4.74a1 1 0 0 1-1-1Z"
  clip-rule="evenodd"
/>
</svg>`
      , eK = ef.YP`<svg fill="none" viewBox="0 0 40 40">
<g clip-path="url(#a)">
  <g clip-path="url(#b)">
    <circle cx="20" cy="19.89" r="20" fill="#1877F2" />
    <g clip-path="url(#c)">
      <path
        fill="#fff"
        d="M26 12.38h-2.89c-.92 0-1.61.38-1.61 1.34v1.66H26l-.36 4.5H21.5v12H17v-12h-3v-4.5h3V12.5c0-3.03 1.6-4.62 5.2-4.62H26v4.5Z"
      />
    </g>
  </g>
  <path
    fill="#1877F2"
    d="M40 20a20 20 0 1 0-23.13 19.76V25.78H11.8V20h5.07v-4.4c0-5.02 3-7.79 7.56-7.79 2.19 0 4.48.4 4.48.4v4.91h-2.53c-2.48 0-3.25 1.55-3.25 3.13V20h5.54l-.88 5.78h-4.66v13.98A20 20 0 0 0 40 20Z"
  />
  <path
    fill="#fff"
    d="m27.79 25.78.88-5.78h-5.55v-3.75c0-1.58.78-3.13 3.26-3.13h2.53V8.2s-2.3-.39-4.48-.39c-4.57 0-7.55 2.77-7.55 7.78V20H11.8v5.78h5.07v13.98a20.15 20.15 0 0 0 6.25 0V25.78h4.67Z"
  />
</g>
<defs>
  <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
  <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
  <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
</defs>
</svg>`
      , eJ = ef.YP`<svg fill="none" viewBox="0 0 16 16">
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M0 3a1 1 0 0 1 1-1h14a1 1 0 1 1 0 2H1a1 1 0 0 1-1-1Zm2.63 5.25a1 1 0 0 1 1-1h8.75a1 1 0 1 1 0 2H3.63a1 1 0 0 1-1-1Zm2.62 5.25a1 1 0 0 1 1-1h3.5a1 1 0 0 1 0 2h-3.5a1 1 0 0 1-1-1Z"
  clip-rule="evenodd"
/>
</svg>`
      , eQ = ef.YP`<svg fill="none" viewBox="0 0 40 40">
<g clip-path="url(#a)">
  <g clip-path="url(#b)">
    <circle cx="20" cy="19.89" r="20" fill="#1B1F23" />
    <g clip-path="url(#c)">
      <path
        fill="#fff"
        d="M8 19.89a12 12 0 1 1 15.8 11.38c-.6.12-.8-.26-.8-.57v-3.3c0-1.12-.4-1.85-.82-2.22 2.67-.3 5.48-1.31 5.48-5.92 0-1.31-.47-2.38-1.24-3.22.13-.3.54-1.52-.12-3.18 0 0-1-.32-3.3 1.23a11.54 11.54 0 0 0-6 0c-2.3-1.55-3.3-1.23-3.3-1.23a4.32 4.32 0 0 0-.12 3.18 4.64 4.64 0 0 0-1.24 3.22c0 4.6 2.8 5.63 5.47 5.93-.34.3-.65.83-.76 1.6-.69.31-2.42.84-3.5-1 0 0-.63-1.15-1.83-1.23 0 0-1.18-.02-.09.73 0 0 .8.37 1.34 1.76 0 0 .7 2.14 4.03 1.41v2.24c0 .31-.2.68-.8.57A12 12 0 0 1 8 19.9Z"
      />
    </g>
  </g>
</g>
<defs>
  <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
  <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
  <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
</defs>
</svg>`
      , eX = ef.YP`<svg fill="none" viewBox="0 0 40 40">
<g clip-path="url(#a)">
  <g clip-path="url(#b)">
    <circle cx="20" cy="19.89" r="20" fill="#fff" fill-opacity=".05" />
    <g clip-path="url(#c)">
      <path
        fill="#4285F4"
        d="M20 17.7v4.65h6.46a5.53 5.53 0 0 1-2.41 3.61l3.9 3.02c2.26-2.09 3.57-5.17 3.57-8.82 0-.85-.08-1.67-.22-2.46H20Z"
      />
      <path
        fill="#34A853"
        d="m13.27 22.17-.87.67-3.11 2.42A12 12 0 0 0 20 31.9c3.24 0 5.96-1.07 7.94-2.9l-3.9-3.03A7.15 7.15 0 0 1 20 27.12a7.16 7.16 0 0 1-6.72-4.94v-.01Z"
      />
      <path
        fill="#FBBC05"
        d="M9.29 14.5a11.85 11.85 0 0 0 0 10.76l3.99-3.1a7.19 7.19 0 0 1 0-4.55l-4-3.1Z"
      />
      <path
        fill="#EA4335"
        d="M20 12.66c1.77 0 3.34.61 4.6 1.8l3.43-3.44A11.51 11.51 0 0 0 20 7.89c-4.7 0-8.74 2.69-10.71 6.62l3.99 3.1A7.16 7.16 0 0 1 20 12.66Z"
      />
    </g>
  </g>
</g>
<defs>
  <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
  <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
  <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
</defs>
</svg>`
      , e0 = ef.YP`<svg fill="none" viewBox="0 0 16 16">
<path
  fill="currentColor"
  d="M8.51 5.66a.83.83 0 0 0-.57-.2.83.83 0 0 0-.52.28.8.8 0 0 0-.25.52 1 1 0 0 1-2 0c0-.75.34-1.43.81-1.91a2.75 2.75 0 0 1 4.78 1.92c0 1.24-.8 1.86-1.25 2.2l-.04.03c-.47.36-.5.43-.5.65a1 1 0 1 1-2 0c0-1.25.8-1.86 1.24-2.2l.04-.04c.47-.36.5-.43.5-.65 0-.3-.1-.49-.24-.6ZM9.12 11.87a1.13 1.13 0 1 1-2.25 0 1.13 1.13 0 0 1 2.25 0Z"
/>
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6a6 6 0 1 0 0 12A6 6 0 0 0 8 2Z"
  clip-rule="evenodd"
/>
</svg>`
      , e1 = ef.YP`<svg fill="none" viewBox="0 0 14 15">
<path
  fill="currentColor"
  d="M6 10.49a1 1 0 1 0 2 0v-2a1 1 0 0 0-2 0v2ZM7 4.49a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"
/>
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M7 14.99a7 7 0 1 0 0-14 7 7 0 0 0 0 14Zm5-7a5 5 0 1 1-10 0 5 5 0 0 1 10 0Z"
  clip-rule="evenodd"
/>
</svg>`
      , e2 = ef.YP`<svg fill="none" viewBox="0 0 16 16">
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M4.83 1.34h6.34c.68 0 1.26 0 1.73.04.5.05.97.15 1.42.4.52.3.95.72 1.24 1.24.26.45.35.92.4 1.42.04.47.04 1.05.04 1.73v3.71c0 .69 0 1.26-.04 1.74-.05.5-.14.97-.4 1.41-.3.52-.72.95-1.24 1.25-.45.25-.92.35-1.42.4-.47.03-1.05.03-1.73.03H4.83c-.68 0-1.26 0-1.73-.04-.5-.04-.97-.14-1.42-.4-.52-.29-.95-.72-1.24-1.24a3.39 3.39 0 0 1-.4-1.41A20.9 20.9 0 0 1 0 9.88v-3.7c0-.7 0-1.27.04-1.74.05-.5.14-.97.4-1.42.3-.52.72-.95 1.24-1.24.45-.25.92-.35 1.42-.4.47-.04 1.05-.04 1.73-.04ZM3.28 3.38c-.36.03-.51.08-.6.14-.21.11-.39.29-.5.5a.8.8 0 0 0-.08.19l5.16 3.44c.45.3 1.03.3 1.48 0L13.9 4.2a.79.79 0 0 0-.08-.2c-.11-.2-.29-.38-.5-.5-.09-.05-.24-.1-.6-.13-.37-.04-.86-.04-1.6-.04H4.88c-.73 0-1.22 0-1.6.04ZM14 6.54 9.85 9.31a3.33 3.33 0 0 1-3.7 0L2 6.54v3.3c0 .74 0 1.22.03 1.6.04.36.1.5.15.6.11.2.29.38.5.5.09.05.24.1.6.14.37.03.86.03 1.6.03h6.25c.73 0 1.22 0 1.6-.03.35-.03.5-.09.6-.14.2-.12.38-.3.5-.5.05-.1.1-.24.14-.6.03-.38.03-.86.03-1.6v-3.3Z"
  clip-rule="evenodd"
/>
</svg>`
      , e3 = ef.YP`<svg fill="none" viewBox="0 0 20 20">
<path fill="currentColor" d="M10.81 5.81a2 2 0 1 1-4 0 2 2 0 0 1 4 0Z" />
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M3 4.75A4.75 4.75 0 0 1 7.75 0h4.5A4.75 4.75 0 0 1 17 4.75v10.5A4.75 4.75 0 0 1 12.25 20h-4.5A4.75 4.75 0 0 1 3 15.25V4.75ZM7.75 2A2.75 2.75 0 0 0 5 4.75v10.5A2.75 2.75 0 0 0 7.75 18h4.5A2.75 2.75 0 0 0 15 15.25V4.75A2.75 2.75 0 0 0 12.25 2h-4.5Z"
  clip-rule="evenodd"
/>
</svg>`
      , e5 = ef.YP`<svg fill="none" viewBox="0 0 22 20">
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M16.32 13.62a3.14 3.14 0 1 1-.99 1.72l-1.6-.93a3.83 3.83 0 0 1-3.71 1 3.66 3.66 0 0 1-1.74-1l-1.6.94a3.14 3.14 0 1 1-1-1.73l1.6-.94a3.7 3.7 0 0 1 0-2 3.81 3.81 0 0 1 1.8-2.33c.29-.17.6-.3.92-.38V6.1a3.14 3.14 0 1 1 2 0l-.01.02v1.85H12a3.82 3.82 0 0 1 2.33 1.8 3.7 3.7 0 0 1 .39 2.91l1.6.93ZM2.6 16.54a1.14 1.14 0 0 0 1.98-1.14 1.14 1.14 0 0 0-1.98 1.14ZM11 2.01a1.14 1.14 0 1 0 0 2.28 1.14 1.14 0 0 0 0-2.28Zm1.68 10.45c.08-.19.14-.38.16-.58v-.05l.02-.13v-.13a1.92 1.92 0 0 0-.24-.8l-.11-.15a1.89 1.89 0 0 0-.74-.6 1.86 1.86 0 0 0-.77-.17h-.19a1.97 1.97 0 0 0-.89.34 1.98 1.98 0 0 0-.61.74 1.99 1.99 0 0 0-.16.9v.05a1.87 1.87 0 0 0 .24.74l.1.15c.12.16.26.3.42.42l.16.1.13.07.04.02a1.84 1.84 0 0 0 .76.17h.17a2 2 0 0 0 .91-.35 1.78 1.78 0 0 0 .52-.58l.03-.05a.84.84 0 0 0 .05-.11Zm5.15 4.5a1.14 1.14 0 0 0 1.14-1.97 1.13 1.13 0 0 0-1.55.41c-.32.55-.13 1.25.41 1.56Z"
  clip-rule="evenodd"
/>
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M4.63 9.43a1.5 1.5 0 1 0 1.5-2.6 1.5 1.5 0 0 0-1.5 2.6Zm.32-1.55a.5.5 0 0 1 .68-.19.5.5 0 0 1 .18.68.5.5 0 0 1-.68.19.5.5 0 0 1-.18-.68ZM17.94 8.88a1.5 1.5 0 1 1-2.6-1.5 1.5 1.5 0 1 1 2.6 1.5ZM16.9 7.69a.5.5 0 0 0-.68.19.5.5 0 0 0 .18.68.5.5 0 0 0 .68-.19.5.5 0 0 0-.18-.68ZM9.75 17.75a1.5 1.5 0 1 1 2.6 1.5 1.5 1.5 0 1 1-2.6-1.5Zm1.05 1.18a.5.5 0 0 0 .68-.18.5.5 0 0 0-.18-.68.5.5 0 0 0-.68.18.5.5 0 0 0 .18.68Z"
  clip-rule="evenodd"
/>
</svg>`
      , e6 = ef.YP`<svg fill="none" viewBox="0 0 20 20">
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M9.13 1h1.71c1.46 0 2.63 0 3.56.1.97.1 1.8.33 2.53.85a5 5 0 0 1 1.1 1.11c.53.73.75 1.56.86 2.53.1.93.1 2.1.1 3.55v1.72c0 1.45 0 2.62-.1 3.55-.1.97-.33 1.8-.86 2.53a5 5 0 0 1-1.1 1.1c-.73.53-1.56.75-2.53.86-.93.1-2.1.1-3.55.1H9.13c-1.45 0-2.62 0-3.56-.1-.96-.1-1.8-.33-2.52-.85a5 5 0 0 1-1.1-1.11 5.05 5.05 0 0 1-.86-2.53c-.1-.93-.1-2.1-.1-3.55V9.14c0-1.45 0-2.62.1-3.55.1-.97.33-1.8.85-2.53a5 5 0 0 1 1.1-1.1 5.05 5.05 0 0 1 2.53-.86C6.51 1 7.67 1 9.13 1ZM5.79 3.09a3.1 3.1 0 0 0-1.57.48 3 3 0 0 0-.66.67c-.24.32-.4.77-.48 1.56-.1.82-.1 1.88-.1 3.4v1.6c0 1.15 0 2.04.05 2.76l.41-.42c.5-.5.93-.92 1.32-1.24.41-.33.86-.6 1.43-.7a3 3 0 0 1 .94 0c.35.06.66.2.95.37a17.11 17.11 0 0 0 .8.45c.1-.08.2-.2.41-.4l.04-.03a27 27 0 0 1 1.95-1.84 4.03 4.03 0 0 1 1.91-.94 4 4 0 0 1 1.25 0c.73.11 1.33.46 1.91.94l.64.55V9.2c0-1.52 0-2.58-.1-3.4a3.1 3.1 0 0 0-.48-1.56 3 3 0 0 0-.66-.67 3.1 3.1 0 0 0-1.56-.48C13.37 3 12.3 3 10.79 3h-1.6c-1.52 0-2.59 0-3.4.09Zm11.18 10-.04-.05a26.24 26.24 0 0 0-1.83-1.74c-.45-.36-.73-.48-.97-.52a2 2 0 0 0-.63 0c-.24.04-.51.16-.97.52-.46.38-1.01.93-1.83 1.74l-.02.02c-.17.18-.34.34-.49.47a2.04 2.04 0 0 1-1.08.5 1.97 1.97 0 0 1-1.25-.27l-.79-.46-.02-.02a.65.65 0 0 0-.24-.1 1 1 0 0 0-.31 0c-.08.02-.21.06-.49.28-.3.24-.65.59-1.2 1.14l-.56.56-.65.66a3 3 0 0 0 .62.6c.33.24.77.4 1.57.49.81.09 1.88.09 3.4.09h1.6c1.52 0 2.58 0 3.4-.09a3.1 3.1 0 0 0 1.56-.48 3 3 0 0 0 .66-.67c.24-.32.4-.77.49-1.56l.07-1.12Zm-8.02-1.03ZM4.99 7a2 2 0 1 1 4 0 2 2 0 0 1-4 0Z"
  clip-rule="evenodd"
/>
</svg>`
      , e4 = ef.YP`<svg fill="none" viewBox="0 0 16 16">
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M8 0a1 1 0 0 1 1 1v5.38a1 1 0 0 1-2 0V1a1 1 0 0 1 1-1ZM5.26 2.6a1 1 0 0 1-.28 1.39 5.46 5.46 0 1 0 6.04 0 1 1 0 1 1 1.1-1.67 7.46 7.46 0 1 1-8.25 0 1 1 0 0 1 1.4.28Z"
  clip-rule="evenodd"
/>
</svg>`
      , e8 = ef.YP` <svg
width="36"
height="36"
fill="none"
>
<path
  d="M0 8a8 8 0 0 1 8-8h20a8 8 0 0 1 8 8v20a8 8 0 0 1-8 8H8a8 8 0 0 1-8-8V8Z"
  fill="#fff"
  fill-opacity=".05"
/>
<path
  d="m18.262 17.513-8.944 9.49v.01a2.417 2.417 0 0 0 3.56 1.452l.026-.017 10.061-5.803-4.703-5.132Z"
  fill="#EA4335"
/>
<path
  d="m27.307 15.9-.008-.008-4.342-2.52-4.896 4.36 4.913 4.912 4.325-2.494a2.42 2.42 0 0 0 .008-4.25Z"
  fill="#FBBC04"
/>
<path
  d="M9.318 8.997c-.05.202-.084.403-.084.622V26.39c0 .218.025.42.084.621l9.246-9.247-9.246-8.768Z"
  fill="#4285F4"
/>
<path
  d="m18.33 18 4.627-4.628-10.053-5.828a2.427 2.427 0 0 0-3.586 1.444L18.329 18Z"
  fill="#34A853"
/>
<path
  d="M8 .5h20A7.5 7.5 0 0 1 35.5 8v20a7.5 7.5 0 0 1-7.5 7.5H8A7.5 7.5 0 0 1 .5 28V8A7.5 7.5 0 0 1 8 .5Z"
  stroke="#fff"
  stroke-opacity=".05"
/>
</svg>`
      , e7 = ef.YP`<svg fill="none" viewBox="0 0 20 20">
<path
  fill="currentColor"
  d="M3 6a3 3 0 0 1 3-3h1a1 1 0 1 0 0-2H6a5 5 0 0 0-5 5v1a1 1 0 0 0 2 0V6ZM13 1a1 1 0 1 0 0 2h1a3 3 0 0 1 3 3v1a1 1 0 1 0 2 0V6a5 5 0 0 0-5-5h-1ZM3 13a1 1 0 1 0-2 0v1a5 5 0 0 0 5 5h1a1 1 0 1 0 0-2H6a3 3 0 0 1-3-3v-1ZM19 13a1 1 0 1 0-2 0v1a3 3 0 0 1-3 3h-1a1 1 0 1 0 0 2h1.01a5 5 0 0 0 5-5v-1ZM5.3 6.36c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05A1.5 1.5 0 0 0 9.2 8.14c.06-.2.06-.43.06-.89s0-.7-.06-.89A1.5 1.5 0 0 0 8.14 5.3c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06ZM10.8 6.36c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05a1.5 1.5 0 0 0 1.06-1.06c.06-.2.06-.43.06-.89s0-.7-.06-.89a1.5 1.5 0 0 0-1.06-1.06c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06ZM5.26 12.75c0-.46 0-.7.05-.89a1.5 1.5 0 0 1 1.06-1.06c.19-.05.42-.05.89-.05.46 0 .7 0 .88.05.52.14.93.54 1.06 1.06.06.2.06.43.06.89s0 .7-.06.89a1.5 1.5 0 0 1-1.06 1.06c-.19.05-.42.05-.88.05-.47 0-.7 0-.9-.05a1.5 1.5 0 0 1-1.05-1.06c-.05-.2-.05-.43-.05-.89ZM10.8 11.86c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05a1.5 1.5 0 0 0 1.06-1.06c.06-.2.06-.43.06-.89s0-.7-.06-.89a1.5 1.5 0 0 0-1.06-1.06c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06Z"
/>
</svg>`
      , e9 = ef.YP`<svg fill="none" viewBox="0 0 14 16">
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M3.94 1.04a1 1 0 0 1 .7 1.23l-.48 1.68a5.85 5.85 0 0 1 8.53 4.32 5.86 5.86 0 0 1-11.4 2.56 1 1 0 0 1 1.9-.57 3.86 3.86 0 1 0 1.83-4.5l1.87.53a1 1 0 0 1-.55 1.92l-4.1-1.15a1 1 0 0 1-.69-1.23l1.16-4.1a1 1 0 0 1 1.23-.7Z"
  clip-rule="evenodd"
/>
</svg>`
      , tn = ef.YP`<svg fill="none" viewBox="0 0 20 20">
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M9.36 4.21a5.14 5.14 0 1 0 0 10.29 5.14 5.14 0 0 0 0-10.29ZM1.64 9.36a7.71 7.71 0 1 1 14 4.47l2.52 2.5a1.29 1.29 0 1 1-1.82 1.83l-2.51-2.51A7.71 7.71 0 0 1 1.65 9.36Z"
  clip-rule="evenodd"
/>
</svg>`
      , to = ef.YP`<svg fill="none" viewBox="0 0 20 20">
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M6.76.3a1 1 0 0 1 0 1.4L4.07 4.4h9a1 1 0 1 1 0 2h-9l2.69 2.68a1 1 0 1 1-1.42 1.42L.95 6.09a1 1 0 0 1 0-1.4l4.4-4.4a1 1 0 0 1 1.4 0Zm6.49 9.21a1 1 0 0 1 1.41 0l4.39 4.4a1 1 0 0 1 0 1.4l-4.39 4.4a1 1 0 0 1-1.41-1.42l2.68-2.68h-9a1 1 0 0 1 0-2h9l-2.68-2.68a1 1 0 0 1 0-1.42Z"
  clip-rule="evenodd"
/>
</svg>`
      , ta = ef.YP`<svg width="10" height="10" viewBox="0 0 10 10">
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M3.77986 0.566631C4.0589 0.845577 4.0589 1.29784 3.77986 1.57678L3.08261 2.2738H6.34184C6.73647 2.2738 7.05637 2.5936 7.05637 2.98808C7.05637 3.38257 6.73647 3.70237 6.34184 3.70237H3.08261L3.77986 4.39938C4.0589 4.67833 4.0589 5.13059 3.77986 5.40954C3.50082 5.68848 3.04841 5.68848 2.76937 5.40954L0.852346 3.49316C0.573306 3.21421 0.573306 2.76195 0.852346 2.48301L2.76937 0.566631C3.04841 0.287685 3.50082 0.287685 3.77986 0.566631ZM6.22 4.59102C6.49904 4.31208 6.95145 4.31208 7.23049 4.59102L9.14751 6.5074C9.42655 6.78634 9.42655 7.23861 9.14751 7.51755L7.23049 9.43393C6.95145 9.71287 6.49904 9.71287 6.22 9.43393C5.94096 9.15498 5.94096 8.70272 6.22 8.42377L6.91725 7.72676L3.65802 7.72676C3.26339 7.72676 2.94349 7.40696 2.94349 7.01247C2.94349 6.61798 3.26339 6.29819 3.65802 6.29819L6.91725 6.29819L6.22 5.60117C5.94096 5.32223 5.94096 4.86997 6.22 4.59102Z"
  clip-rule="evenodd"
/>
</svg>`
      , tl = ef.YP`<svg fill="none" viewBox="0 0 14 14">
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M3.48 2.18a1 1 0 0 1 1.41 0l2.68 2.68a1 1 0 1 1-1.41 1.42l-.98-.98v4.56a1 1 0 0 1-2 0V5.3l-.97.98A1 1 0 0 1 .79 4.86l2.69-2.68Zm6.34 2.93a1 1 0 0 1 1 1v4.56l.97-.98a1 1 0 1 1 1.42 1.42l-2.69 2.68a1 1 0 0 1-1.41 0l-2.68-2.68a1 1 0 0 1 1.41-1.42l.98.98V6.1a1 1 0 0 1 1-1Z"
  clip-rule="evenodd"
/>
</svg>`
      , tc = ef.YP`<svg fill="none" viewBox="0 0 40 40">
<g clip-path="url(#a)">
  <g clip-path="url(#b)">
    <circle cx="20" cy="19.89" r="20" fill="#5865F2" />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M25.71 28.15C30.25 28 32 25.02 32 25.02c0-6.61-2.96-11.98-2.96-11.98-2.96-2.22-5.77-2.15-5.77-2.15l-.29.32c3.5 1.07 5.12 2.61 5.12 2.61a16.75 16.75 0 0 0-10.34-1.93l-.35.04a15.43 15.43 0 0 0-5.88 1.9s1.71-1.63 5.4-2.7l-.2-.24s-2.81-.07-5.77 2.15c0 0-2.96 5.37-2.96 11.98 0 0 1.73 2.98 6.27 3.13l1.37-1.7c-2.6-.79-3.6-2.43-3.6-2.43l.58.35.09.06.08.04.02.01.08.05a17.25 17.25 0 0 0 4.52 1.58 14.4 14.4 0 0 0 8.3-.86c.72-.27 1.52-.66 2.37-1.21 0 0-1.03 1.68-3.72 2.44.61.78 1.35 1.67 1.35 1.67Zm-9.55-9.6c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28.01-1.25-.93-2.28-2.1-2.28Zm7.5 0c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28 0-1.25-.93-2.28-2.1-2.28Z"
      clip-rule="evenodd"
    />
  </g>
</g>
<defs>
  <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
  <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
</defs>
</svg> `
      , td = ef.YP`<svg fill="none" viewBox="0 0 40 40">
<g clip-path="url(#a)">
  <g clip-path="url(#b)">
    <circle cx="20" cy="19.89" r="20" fill="#5A3E85" />
    <g clip-path="url(#c)">
      <path
        fill="#fff"
        d="M18.22 25.7 20 23.91h3.34l2.1-2.1v-6.68H15.4v8.78h2.82v1.77Zm3.87-8.16h1.25v3.66H22.1v-3.66Zm-3.34 0H20v3.66h-1.25v-3.66ZM20 7.9a12 12 0 1 0 0 24 12 12 0 0 0 0-24Zm6.69 14.56-3.66 3.66h-2.72l-1.77 1.78h-1.88V26.1H13.3v-9.82l.94-2.4H26.7v8.56Z"
      />
    </g>
  </g>
</g>
<defs>
  <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
  <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
  <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
</defs>
</svg>`
      , th = ef.YP`<svg fill="none" viewBox="0 0 40 40">
<g clip-path="url(#a)">
  <g clip-path="url(#b)">
    <circle cx="20" cy="19.89" r="20" fill="#1D9BF0" />
    <path
      fill="#fff"
      d="M30 13.81c-.74.33-1.53.55-2.36.65.85-.51 1.5-1.32 1.8-2.27-.79.47-1.66.8-2.6 1a4.1 4.1 0 0 0-7 3.73c-3.4-.17-6.42-1.8-8.45-4.28a4.1 4.1 0 0 0 1.27 5.47c-.67-.02-1.3-.2-1.86-.5a4.1 4.1 0 0 0 3.3 4.07c-.58.15-1.21.19-1.86.07a4.1 4.1 0 0 0 3.83 2.85A8.25 8.25 0 0 1 10 26.3a11.62 11.62 0 0 0 6.29 1.84c7.62 0 11.92-6.44 11.66-12.2.8-.59 1.5-1.3 2.05-2.13Z"
    />
  </g>
</g>
<defs>
  <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
  <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
</defs>
</svg>`
      , tp = ef.YP`<svg fill="none" viewBox="0 0 16 16">
<path
  fill="currentColor"
  d="m14.36 4.74.01.42c0 4.34-3.3 9.34-9.34 9.34A9.3 9.3 0 0 1 0 13.03a6.6 6.6 0 0 0 4.86-1.36 3.29 3.29 0 0 1-3.07-2.28c.5.1 1 .07 1.48-.06A3.28 3.28 0 0 1 .64 6.11v-.04c.46.26.97.4 1.49.41A3.29 3.29 0 0 1 1.11 2.1a9.32 9.32 0 0 0 6.77 3.43 3.28 3.28 0 0 1 5.6-3 6.59 6.59 0 0 0 2.08-.8 3.3 3.3 0 0 1-1.45 1.82A6.53 6.53 0 0 0 16 3.04c-.44.66-1 1.23-1.64 1.7Z"
/>
</svg>`
      , tf = ef.YP`<svg fill="none" viewBox="0 0 28 28">
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M18.1 4.76c-.42-.73-1.33-1.01-2.09-.66l-1.42.66c-.37.18-.8.18-1.18 0l-1.4-.65a1.63 1.63 0 0 0-2.1.66l-.84 1.45c-.2.34-.53.59-.92.67l-1.7.35c-.83.17-1.39.94-1.3 1.78l.19 1.56c.04.39-.08.78-.33 1.07l-1.12 1.3c-.52.6-.52 1.5 0 2.11L5 16.38c.25.3.37.68.33 1.06l-.18 1.57c-.1.83.46 1.6 1.28 1.78l1.7.35c.4.08.73.32.93.66l.84 1.43a1.63 1.63 0 0 0 2.09.66l1.41-.66c.37-.17.8-.17 1.18 0l1.43.67c.76.35 1.66.07 2.08-.65l.86-1.45c.2-.34.54-.58.92-.66l1.68-.35A1.63 1.63 0 0 0 22.84 19l-.18-1.57a1.4 1.4 0 0 1 .33-1.06l1.12-1.32c.52-.6.52-1.5 0-2.11l-1.12-1.3a1.4 1.4 0 0 1-.33-1.07l.18-1.57c.1-.83-.46-1.6-1.28-1.77l-1.68-.35a1.4 1.4 0 0 1-.92-.66l-.86-1.47Zm-3.27-3.2a4.43 4.43 0 0 1 5.69 1.78l.54.93 1.07.22a4.43 4.43 0 0 1 3.5 4.84l-.11.96.7.83a4.43 4.43 0 0 1 .02 5.76l-.72.85.1.96a4.43 4.43 0 0 1-3.5 4.84l-1.06.22-.54.92a4.43 4.43 0 0 1-5.68 1.77l-.84-.4-.82.39a4.43 4.43 0 0 1-5.7-1.79l-.51-.89-1.09-.22a4.43 4.43 0 0 1-3.5-4.84l.1-.96-.72-.85a4.43 4.43 0 0 1 .01-5.76l.71-.83-.1-.95a4.43 4.43 0 0 1 3.5-4.84l1.08-.23.53-.9a4.43 4.43 0 0 1 5.7-1.8l.81.38.83-.39ZM18.2 9.4c.65.42.84 1.28.42 1.93l-4.4 6.87a1.4 1.4 0 0 1-2.26.14L9.5 15.39a1.4 1.4 0 0 1 2.15-1.8l1.23 1.48 3.38-5.26a1.4 1.4 0 0 1 1.93-.42Z"
  clip-rule="evenodd"
/>
</svg>`
      , tm = ef.YP`<svg fill="none" viewBox="0 0 14 14">
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="m4.1 12.43-.45-.78-.93-.2a1.65 1.65 0 0 1-1.31-1.8l.1-.86-.61-.71a1.65 1.65 0 0 1 0-2.16l.6-.7-.09-.85c-.1-.86.47-1.64 1.3-1.81l.94-.2.45-.78A1.65 1.65 0 0 1 6.23.9l.77.36.78-.36c.77-.36 1.69-.07 2.12.66l.47.8.91.2c.84.17 1.4.95 1.31 1.8l-.1.86.6.7c.54.62.54 1.54.01 2.16l-.6.71.09.86c.1.85-.47 1.63-1.3 1.8l-.92.2-.47.79a1.65 1.65 0 0 1-2.12.66L7 12.74l-.77.36c-.78.35-1.7.07-2.13-.67Zm5.74-6.9a1 1 0 1 0-1.68-1.07L6.32 7.3l-.55-.66a1 1 0 0 0-1.54 1.28l1.43 1.71a1 1 0 0 0 1.61-.1l2.57-4Z"
  clip-rule="evenodd"
/>
</svg>`
      , tg = ef.YP`
<svg fill="none" viewBox="0 0 48 44">
  <path
    style="fill: var(--wui-color-bg-300);"
    d="M4.56 8.64c-1.23 1.68-1.23 4.08-1.23 8.88v8.96c0 4.8 0 7.2 1.23 8.88.39.55.87 1.02 1.41 1.42C7.65 38 10.05 38 14.85 38h14.3c4.8 0 7.2 0 8.88-1.22a6.4 6.4 0 0 0 1.41-1.42c.83-1.14 1.1-2.6 1.19-4.92a6.4 6.4 0 0 0 5.16-4.65c.21-.81.21-1.8.21-3.79 0-1.98 0-2.98-.22-3.79a6.4 6.4 0 0 0-5.15-4.65c-.1-2.32-.36-3.78-1.19-4.92a6.4 6.4 0 0 0-1.41-1.42C36.35 6 33.95 6 29.15 6h-14.3c-4.8 0-7.2 0-8.88 1.22a6.4 6.4 0 0 0-1.41 1.42Z"
  />
  <path
    style="fill: var(--wui-color-fg-200);"
    fill-rule="evenodd"
    d="M2.27 11.33a6.4 6.4 0 0 1 6.4-6.4h26.66a6.4 6.4 0 0 1 6.4 6.4v1.7a6.4 6.4 0 0 1 5.34 6.3v5.34a6.4 6.4 0 0 1-5.34 6.3v1.7a6.4 6.4 0 0 1-6.4 6.4H8.67a6.4 6.4 0 0 1-6.4-6.4V11.33ZM39.6 31.07h-6.93a9.07 9.07 0 1 1 0-18.14h6.93v-1.6a4.27 4.27 0 0 0-4.27-4.26H8.67a4.27 4.27 0 0 0-4.27 4.26v21.34a4.27 4.27 0 0 0 4.27 4.26h26.66a4.27 4.27 0 0 0 4.27-4.26v-1.6Zm-6.93-16a6.93 6.93 0 0 0 0 13.86h8a4.27 4.27 0 0 0 4.26-4.26v-5.34a4.27 4.27 0 0 0-4.26-4.26h-8Z"
    clip-rule="evenodd"
  />
</svg>
`
      , ty = ef.YP`<svg fill="none" viewBox="0 0 20 20">
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M0 5.5c0-1.8 1.46-3.25 3.25-3.25H14.5c1.8 0 3.25 1.46 3.25 3.25v.28A3.25 3.25 0 0 1 20 8.88v2.24c0 1.45-.94 2.68-2.25 3.1v.28c0 1.8-1.46 3.25-3.25 3.25H3.25A3.25 3.25 0 0 1 0 14.5v-9Zm15.75 8.88h-2.38a4.38 4.38 0 0 1 0-8.76h2.38V5.5c0-.69-.56-1.25-1.25-1.25H3.25C2.56 4.25 2 4.81 2 5.5v9c0 .69.56 1.25 1.25 1.25H14.5c.69 0 1.25-.56 1.25-1.25v-.13Zm-2.38-6.76a2.37 2.37 0 1 0 0 4.75h3.38c.69 0 1.25-.55 1.25-1.24V8.87c0-.69-.56-1.24-1.25-1.24h-3.38Z"
  clip-rule="evenodd"
/>
</svg>`
      , tb = ef.YP`<svg fill="none" viewBox="0 0 96 67">
<path
  fill="currentColor"
  d="M25.32 18.8a32.56 32.56 0 0 1 45.36 0l1.5 1.47c.63.62.63 1.61 0 2.22l-5.15 5.05c-.31.3-.82.3-1.14 0l-2.07-2.03a22.71 22.71 0 0 0-31.64 0l-2.22 2.18c-.31.3-.82.3-1.14 0l-5.15-5.05a1.55 1.55 0 0 1 0-2.22l1.65-1.62Zm56.02 10.44 4.59 4.5c.63.6.63 1.6 0 2.21l-20.7 20.26c-.62.61-1.63.61-2.26 0L48.28 41.83a.4.4 0 0 0-.56 0L33.03 56.21c-.63.61-1.64.61-2.27 0L10.07 35.95a1.55 1.55 0 0 1 0-2.22l4.59-4.5a1.63 1.63 0 0 1 2.27 0L31.6 43.63a.4.4 0 0 0 .57 0l14.69-14.38a1.63 1.63 0 0 1 2.26 0l14.69 14.38a.4.4 0 0 0 .57 0l14.68-14.38a1.63 1.63 0 0 1 2.27 0Z"
/>
<path
  stroke="#000"
  stroke-opacity=".1"
  d="M25.67 19.15a32.06 32.06 0 0 1 44.66 0l1.5 1.48c.43.42.43 1.09 0 1.5l-5.15 5.05a.31.31 0 0 1-.44 0l-2.07-2.03a23.21 23.21 0 0 0-32.34 0l-2.22 2.18a.31.31 0 0 1-.44 0l-5.15-5.05a1.05 1.05 0 0 1 0-1.5l1.65-1.63ZM81 29.6l4.6 4.5c.42.41.42 1.09 0 1.5l-20.7 20.26c-.43.43-1.14.43-1.57 0L48.63 41.47a.9.9 0 0 0-1.26 0L32.68 55.85c-.43.43-1.14.43-1.57 0L10.42 35.6a1.05 1.05 0 0 1 0-1.5l4.59-4.5a1.13 1.13 0 0 1 1.57 0l14.68 14.38a.9.9 0 0 0 1.27 0l-.35-.35.35.35L47.22 29.6a1.13 1.13 0 0 1 1.56 0l14.7 14.38a.9.9 0 0 0 1.26 0L79.42 29.6a1.13 1.13 0 0 1 1.57 0Z"
/>
</svg>`
      , tw = ef.YP`<svg fill="none" viewBox="0 0 20 20">
<path
  fill="currentColor"
  d="M11 6.67a1 1 0 1 0-2 0v2.66a1 1 0 0 0 2 0V6.67ZM10 14.5a1.25 1.25 0 1 0 0-2.5 1.25 1.25 0 0 0 0 2.5Z"
/>
<path
  fill="currentColor"
  fill-rule="evenodd"
  d="M10 1a9 9 0 1 0 0 18 9 9 0 0 0 0-18Zm-7 9a7 7 0 1 1 14 0 7 7 0 0 1-14 0Z"
  clip-rule="evenodd"
/>
</svg>`
      , t_ = ef.YP`<svg xmlns="http://www.w3.org/2000/svg" width="14" height="12" viewBox="0 0 14 12" fill="none">
<path fill-rule="evenodd" clip-rule="evenodd" d="M10.687 0.557043C11.1462 0.671832 11.4254 1.13706 11.3106 1.59615C11.2044 2.02082 11.0975 2.51184 10.9822 3.04102C10.7176 4.25623 10.4091 5.6727 9.96482 6.94907C10.1435 7.58939 10.3065 8.16905 10.4935 8.68429C10.6447 9.10072 10.7858 9.39487 10.9179 9.58289C11.0055 9.70747 11.0597 9.74443 11.0748 9.75277C11.096 9.75724 11.1075 9.75764 11.1531 9.71916C11.2342 9.65067 11.3386 9.50891 11.4426 9.28357C11.5416 9.06892 11.614 8.8366 11.662 8.6497C11.6854 8.55831 11.7019 8.48242 11.7122 8.43111C11.7174 8.40555 11.7209 8.38638 11.723 8.37476L11.725 8.36363C11.8 7.89659 12.2395 7.57864 12.7068 7.65342C13.1742 7.72822 13.4925 8.16766 13.4177 8.63494C13.4153 8.64924 13.42 8.62063 13.4177 8.63494L13.4175 8.63596L13.4173 8.63721L13.4168 8.64037L13.4153 8.64924L13.4105 8.67692C13.4064 8.69961 13.4006 8.73069 13.3929 8.76891C13.3776 8.84516 13.3545 8.95091 13.3224 9.07586C13.2593 9.32166 13.1564 9.66085 12.9992 10.0015C12.8469 10.3315 12.6139 10.7288 12.2595 11.0282C11.8757 11.3523 11.35 11.5553 10.7293 11.4312C10.1645 11.3183 9.77597 10.939 9.51527 10.5681C9.2535 10.1957 9.05129 9.7349 8.88212 9.26898C8.87877 9.25975 8.87542 9.25049 8.87208 9.2412C8.03954 10.4941 6.83375 11.4479 5.03926 11.4479C3.48049 11.4479 2.31021 10.7159 1.56788 9.63945C0.846767 8.5938 0.544023 7.25403 0.573206 5.9702C0.60242 4.68505 0.966023 3.36073 1.69055 2.33272C2.42915 1.28475 3.5614 0.531453 5.03927 0.531453C6.44937 0.531453 7.4408 1.29593 8.1276 2.27567C8.48261 2.7821 8.77248 3.36668 9.0177 3.97383C9.1059 3.59106 9.18901 3.20908 9.27086 2.83294C9.39492 2.26277 9.51606 1.70605 9.64752 1.18046C9.76235 0.721369 10.2277 0.442254 10.687 0.557043ZM8.16354 6.87693C8.08689 6.60534 8.01003 6.33741 7.93241 6.08076C7.59522 4.96581 7.22132 3.969 6.72371 3.25914C6.24674 2.57873 5.72135 2.24516 5.03927 2.24516C4.21565 2.24516 3.56947 2.6422 3.09195 3.31975C2.60035 4.01725 2.31013 4.99361 2.28705 6.00913C2.26393 7.02599 2.51041 7.9869 2.97927 8.66676C3.42691 9.31586 4.08734 9.73417 5.03926 9.73417C6.48097 9.73417 7.4216 8.72164 8.14437 6.9249C8.15079 6.90893 8.15718 6.89294 8.16354 6.87693Z" fill="#47A1FF"/>
</svg>`;
    var wui_icon_decorate = function (J, et, eo, el) {
      var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        eh = Reflect.decorate(J, et, eo, el);
      else
        for (var ep = J.length - 1; ep >= 0; ep--)
          (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
      return ed > 3 && eh && Object.defineProperty(et, eo, eh),
        eh
    };
    let tx = {
      allWallets: eE,
      alpha: t_,
      appStore: eC,
      chromeStore: ej,
      apple: eS,
      arrowBottom: ek,
      arrowLeft: eT,
      arrowRight: eA,
      arrowTop: eP,
      browser: eR,
      checkmark: eI,
      chevronBottom: eO,
      chevronLeft: eN,
      chevronRight: eM,
      chevronTop: eD,
      clock: eL,
      close: e$,
      compass: eF,
      coinPlaceholder: eB,
      copy: eU,
      cursor: ez,
      desktop: eH,
      disconnect: eV,
      discord: eW,
      etherscan: eZ,
      extension: eG,
      externalLink: eY,
      facebook: eK,
      filters: eJ,
      github: eQ,
      google: eX,
      helpCircle: e0,
      infoCircle: e1,
      mail: e2,
      mobile: e3,
      networkPlaceholder: e5,
      nftPlaceholder: e6,
      off: e4,
      playStore: e8,
      qrCode: e7,
      refresh: e9,
      search: tn,
      swapHorizontal: to,
      swapHorizontalBold: ta,
      swapVertical: tl,
      telegram: tc,
      twitch: td,
      twitter: th,
      twitterIcon: tp,
      verify: tf,
      verifyFilled: tm,
      wallet: ty,
      walletConnect: tb,
      walletPlaceholder: tg,
      warningCircle: tw
    }
      , tE = class extends ef.oi {
        constructor() {
          super(...arguments),
            this.size = "md",
            this.name = "copy",
            this.color = "fg-300"
        }
        render() {
          return this.style.cssText = `
    --local-color: var(--wui-color-${this.color});
    --local-width: var(--wui-icon-size-${this.size});
  `,
            ef.dy`${tx[this.name]}`
        }
      }
      ;
    tE.styles = [em, ey, ex],
      wui_icon_decorate([(0,
        e_.Cb)()], tE.prototype, "size", void 0),
      wui_icon_decorate([(0,
        e_.Cb)()], tE.prototype, "name", void 0),
      wui_icon_decorate([(0,
        e_.Cb)()], tE.prototype, "color", void 0),
      tE = wui_icon_decorate([customElement("wui-icon")], tE);
    var tC = ef.iv`
:host {
  display: block;
  width: 100%;
  height: 100%;
}

img {
  display: block;
  width: 100%;
  height: 100%;
  object-fit: cover;
  object-position: center center;
  border-radius: inherit;
}
`
      , wui_image_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let tS = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.src = "./path/to/image.jpg",
          this.alt = "Image"
      }
      render() {
        return ef.dy`<img src=${this.src} alt=${this.alt} />`
      }
    }
      ;
    tS.styles = [em, ey, tC],
      wui_image_decorate([(0,
        e_.Cb)()], tS.prototype, "src", void 0),
      wui_image_decorate([(0,
        e_.Cb)()], tS.prototype, "alt", void 0),
      tS = wui_image_decorate([customElement("wui-image")], tS);
    var tk = ef.iv`
:host {
  display: block;
  width: var(--wui-box-size-lg);
  height: var(--wui-box-size-lg);
}

svg {
  width: var(--wui-box-size-lg);
  height: var(--wui-box-size-lg);
  fill: none;
  stroke: transparent;
  stroke-linecap: round;
  transition: all var(--wui-ease-in-power-3) var(--wui-duration-lg);
}

use {
  stroke: var(--wui-color-accent-100);
  stroke-width: 2px;
  stroke-dasharray: 54, 118;
  stroke-dashoffset: 172;
  animation: dash 1s linear infinite;
}

@keyframes dash {
  to {
    stroke-dashoffset: 0px;
  }
}
`;
    let tT = class extends ef.oi {
      render() {
        return ef.dy`
    <svg viewBox="0 0 54 59">
      <path
        id="wui-loader-path"
        d="M17.22 5.295c3.877-2.277 5.737-3.363 7.72-3.726a11.44 11.44 0 0 1 4.12 0c1.983.363 3.844 1.45 7.72 3.726l6.065 3.562c3.876 2.276 5.731 3.372 7.032 4.938a11.896 11.896 0 0 1 2.06 3.63c.683 1.928.688 4.11.688 8.663v7.124c0 4.553-.005 6.735-.688 8.664a11.896 11.896 0 0 1-2.06 3.63c-1.3 1.565-3.156 2.66-7.032 4.937l-6.065 3.563c-3.877 2.276-5.737 3.362-7.72 3.725a11.46 11.46 0 0 1-4.12 0c-1.983-.363-3.844-1.449-7.72-3.726l-6.065-3.562c-3.876-2.276-5.731-3.372-7.032-4.938a11.885 11.885 0 0 1-2.06-3.63c-.682-1.928-.688-4.11-.688-8.663v-7.124c0-4.553.006-6.735.688-8.664a11.885 11.885 0 0 1 2.06-3.63c1.3-1.565 3.156-2.66 7.032-4.937l6.065-3.562Z"
      />
      <use xlink:href="#wui-loader-path"></use>
    </svg>
  `
      }
    }
      ;
    tT.styles = [em, tk],
      tT = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      }([customElement("wui-loading-hexagon")], tT);
    var tA = ef.iv`
:host {
  display: flex;
}

:host([data-size='sm']) > svg {
  width: 12px;
  height: 12px;
}

:host([data-size='md']) > svg {
  width: 16px;
  height: 16px;
}

:host([data-size='lg']) > svg {
  width: 24px;
  height: 24px;
}

:host([data-size='xl']) > svg {
  width: 32px;
  height: 32px;
}

svg {
  animation: rotate 2s linear infinite;
  transition: all var(--wui-ease-in-power-3) var(--wui-duration-lg);
}

circle {
  fill: none;
  stroke: var(--local-color);
  stroke-width: 4px;
  stroke-dasharray: 1, 124;
  stroke-dashoffset: 0;
  stroke-linecap: round;
  animation: dash 1.5s ease-in-out infinite;
}

:host([data-size='md']) > svg > circle {
  stroke-width: 6px;
}

:host([data-size='sm']) > svg > circle {
  stroke-width: 8px;
}

@keyframes rotate {
  100% {
    transform: rotate(360deg);
  }
}

@keyframes dash {
  0% {
    stroke-dasharray: 1, 124;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 90, 124;
    stroke-dashoffset: -35;
  }

  100% {
    stroke-dashoffset: -125;
  }
}
`
      , wui_loading_spinner_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let tP = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.color = "accent-100",
          this.size = "lg"
      }
      render() {
        return this.style.cssText = `--local-color: var(--wui-color-${this.color});`,
          this.dataset.size = this.size,
          ef.dy`<svg viewBox="25 25 50 50">
    <circle r="20" cy="50" cx="50"></circle>
  </svg>`
      }
    }
      ;
    tP.styles = [em, tA],
      wui_loading_spinner_decorate([(0,
        e_.Cb)()], tP.prototype, "color", void 0),
      wui_loading_spinner_decorate([(0,
        e_.Cb)()], tP.prototype, "size", void 0),
      tP = wui_loading_spinner_decorate([customElement("wui-loading-spinner")], tP);
    var tR = ef.iv`
:host {
  display: block;
  width: var(--wui-box-size-md);
  height: var(--wui-box-size-md);
}

svg {
  width: var(--wui-box-size-md);
  height: var(--wui-box-size-md);
  transition: all var(--wui-ease-in-power-3) var(--wui-duration-lg);
}

rect {
  fill: none;
  stroke: var(--wui-color-accent-100);
  stroke-width: 4px;
  stroke-linecap: round;
  animation: dash 1s linear infinite;
}

@keyframes dash {
  to {
    stroke-dashoffset: 0px;
  }
}
`
      , wui_loading_thumbnail_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let tI = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.radius = 36
      }
      render() {
        return this.svgLoaderTemplate()
      }
      svgLoaderTemplate() {
        let J = this.radius > 50 ? 50 : this.radius
          , et = 36 - J;
        return ef.dy`
    <svg viewBox="0 0 110 110" width="110" height="110">
      <rect
        x="2"
        y="2"
        width="106"
        height="106"
        rx=${J}
        stroke-dasharray="${116 + et} ${245 + et}"
        stroke-dashoffset=${360 + 1.75 * et}
      />
    </svg>
  `
      }
    }
      ;
    tI.styles = [em, tR],
      wui_loading_thumbnail_decorate([(0,
        e_.Cb)({
          type: Number
        })], tI.prototype, "radius", void 0),
      tI = wui_loading_thumbnail_decorate([customElement("wui-loading-thumbnail")], tI);
    var tO = ef.iv`
:host {
  display: block;
  box-shadow: inset 0 0 0 1px var(--wui-gray-glass-005);
  background: linear-gradient(
    120deg,
    var(--wui-color-bg-200) 5%,
    var(--wui-color-bg-200) 48%,
    var(--wui-color-bg-300) 55%,
    var(--wui-color-bg-300) 60%,
    var(--wui-color-bg-300) calc(60% + 10px),
    var(--wui-color-bg-200) calc(60% + 12px),
    var(--wui-color-bg-200) 100%
  );
  background-size: 250%;
  animation: shimmer 3s linear infinite reverse;
}

@keyframes shimmer {
  from {
    background-position: -250% 0;
  }
  to {
    background-position: 250% 0;
  }
}
`
      , wui_shimmer_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let tN = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.width = "",
          this.height = "",
          this.borderRadius = "m"
      }
      render() {
        return this.style.cssText = `
    width: ${this.width};
    height: ${this.height};
    border-radius: clamp(0px,var(--wui-border-radius-${this.borderRadius}), 40px);
  `,
          ef.dy`<slot></slot>`
      }
    }
      ;
    tN.styles = [tO],
      wui_shimmer_decorate([(0,
        e_.Cb)()], tN.prototype, "width", void 0),
      wui_shimmer_decorate([(0,
        e_.Cb)()], tN.prototype, "height", void 0),
      wui_shimmer_decorate([(0,
        e_.Cb)()], tN.prototype, "borderRadius", void 0),
      tN = wui_shimmer_decorate([customElement("wui-shimmer")], tN);
    var tM = eo(69699)
      , tD = eo(48476);
    /**
* @license
* Copyright 2018 Google LLC
* SPDX-License-Identifier: BSD-3-Clause
*/
    let tj = (0,
      tD.XM)(class extends tD.Xe {
        constructor(J) {
          if (super(J),
            J.type !== tD.pX.ATTRIBUTE || "class" !== J.name || J.strings?.length > 2)
            throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.")
        }
        render(J) {
          return " " + Object.keys(J).filter(et => J[et]).join(" ") + " "
        }
        update(J, [et]) {
          if (void 0 === this.it) {
            for (let eo in this.it = new Set,
              void 0 !== J.strings && (this.st = new Set(J.strings.join(" ").split(/\s/).filter(J => "" !== J))),
              et)
              et[eo] && !this.st?.has(eo) && this.it.add(eo);
            return this.render(et)
          }
          let eo = J.element.classList;
          for (let J of this.it)
            J in et || (eo.remove(J),
              this.it.delete(J));
          for (let J in et) {
            let el = !!et[J];
            el === this.it.has(J) || this.st?.has(J) || (el ? (eo.add(J),
              this.it.add(J)) : (eo.remove(J),
                this.it.delete(J)))
          }
          return tM.Jb
        }
      }
      );
    var tL = ef.iv`
:host {
  display: flex !important;
}

slot {
  display: inline-block;
  font-style: normal;
  font-family: var(--wui-font-family);
  font-feature-settings:
    'tnum' on,
    'lnum' on,
    'case' on;
  line-height: 130%;
  font-weight: var(--wui-font-weight-regular);
  overflow: inherit;
  text-overflow: inherit;
  text-align: var(--local-align);
  color: var(--local-color);
}

.wui-font-large-500,
.wui-font-large-600,
.wui-font-large-700 {
  font-size: var(--wui-font-size-large);
  letter-spacing: var(--wui-letter-spacing-large);
}

.wui-font-paragraph-500,
.wui-font-paragraph-600,
.wui-font-paragraph-700 {
  font-size: var(--wui-font-size-paragraph);
  letter-spacing: var(--wui-letter-spacing-paragraph);
}

.wui-font-small-400,
.wui-font-small-500,
.wui-font-small-600 {
  font-size: var(--wui-font-size-small);
  letter-spacing: var(--wui-letter-spacing-small);
}

.wui-font-tiny-500,
.wui-font-tiny-600 {
  font-size: var(--wui-font-size-tiny);
  letter-spacing: var(--wui-letter-spacing-tiny);
}

.wui-font-micro-700,
.wui-font-micro-600 {
  font-size: var(--wui-font-size-micro);
  letter-spacing: var(--wui-letter-spacing-micro);
  text-transform: uppercase;
}

.wui-font-small-400,
.wui-font-paragraph-400 {
  font-weight: var(--wui-font-weight-light);
}

.wui-font-large-700,
.wui-font-paragraph-700,
.wui-font-micro-700 {
  font-weight: var(--wui-font-weight-bold);
}

.wui-font-large-600,
.wui-font-paragraph-600,
.wui-font-small-600,
.wui-font-tiny-600,
.wui-font-micro-600 {
  font-weight: var(--wui-font-weight-medium);
}
`
      , wui_text_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let t$ = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.variant = "paragraph-500",
          this.color = "fg-300",
          this.align = "left"
      }
      render() {
        let J = {
          [`wui-font-${this.variant}`]: !0,
          [`wui-color-${this.color}`]: !0
        };
        return this.style.cssText = `
    --local-align: ${this.align};
    --local-color: var(--wui-color-${this.color});
  `,
          ef.dy`<slot class=${tj(J)}></slot>`
      }
    }
      ;
    t$.styles = [em, tL],
      wui_text_decorate([(0,
        e_.Cb)()], t$.prototype, "variant", void 0),
      wui_text_decorate([(0,
        e_.Cb)()], t$.prototype, "color", void 0),
      wui_text_decorate([(0,
        e_.Cb)()], t$.prototype, "align", void 0),
      t$ = wui_text_decorate([customElement("wui-text")], t$);
    let tB = ef.YP`<svg fill="none" viewBox="0 0 60 60">
<rect width="60" height="60" fill="#1DC956" rx="30" />
<circle cx="30" cy="30" r="3" fill="#fff" />
<path
  fill="#2BEE6C"
  stroke="#fff"
  stroke-width="2"
  d="m45.32 17.9-.88-.42.88.42.02-.05c.1-.2.21-.44.26-.7l-.82-.15.82.16a2 2 0 0 0-.24-1.4c-.13-.23-.32-.42-.47-.57a8.42 8.42 0 0 1-.04-.04l-.04-.04a2.9 2.9 0 0 0-.56-.47l-.51.86.5-.86a2 2 0 0 0-1.4-.24c-.26.05-.5.16-.69.26l-.05.02-15.05 7.25-.1.05c-1.14.55-1.85.89-2.46 1.37a7 7 0 0 0-1.13 1.14c-.5.6-.83 1.32-1.38 2.45l-.05.11-7.25 15.05-.02.05c-.1.2-.21.43-.26.69a2 2 0 0 0 .24 1.4l.85-.5-.85.5c.13.23.32.42.47.57l.04.04.04.04c.15.15.34.34.56.47a2 2 0 0 0 1.41.24l-.2-.98.2.98c.25-.05.5-.17.69-.26l.05-.02-.42-.87.42.87 15.05-7.25.1-.05c1.14-.55 1.85-.89 2.46-1.38a7 7 0 0 0 1.13-1.13 12.87 12.87 0 0 0 1.43-2.56l7.25-15.05Z"
/>
<path
  fill="#1DC956"
  d="M33.38 32.72 30.7 29.3 15.86 44.14l.2.2a1 1 0 0 0 1.14.2l15.1-7.27a3 3 0 0 0 1.08-4.55Z"
/>
<path
  fill="#86F999"
  d="m26.62 27.28 2.67 3.43 14.85-14.85-.2-.2a1 1 0 0 0-1.14-.2l-15.1 7.27a3 3 0 0 0-1.08 4.55Z"
/>
<circle cx="30" cy="30" r="3" fill="#fff" transform="rotate(45 30 30)" />
<rect width="59" height="59" x=".5" y=".5" stroke="#062B2B" stroke-opacity=".1" rx="29.5" />
</svg> `
      , tF = ef.YP`<svg viewBox="0 0 60 60" fill="none">
<g clip-path="url(#clip0_7734_50402)">
  <path
    d="M0 24.9C0 15.6485 0 11.0228 1.97053 7.56812C3.3015 5.23468 5.23468 3.3015 7.56812 1.97053C11.0228 0 15.6485 0 24.9 0H35.1C44.3514 0 48.9772 0 52.4319 1.97053C54.7653 3.3015 56.6985 5.23468 58.0295 7.56812C60 11.0228 60 15.6485 60 24.9V35.1C60 44.3514 60 48.9772 58.0295 52.4319C56.6985 54.7653 54.7653 56.6985 52.4319 58.0295C48.9772 60 44.3514 60 35.1 60H24.9C15.6485 60 11.0228 60 7.56812 58.0295C5.23468 56.6985 3.3015 54.7653 1.97053 52.4319C0 48.9772 0 44.3514 0 35.1V24.9Z"
    fill="#EB8B47"
  />
  <path
    d="M0.5 24.9C0.5 20.2652 0.50047 16.8221 0.744315 14.105C0.987552 11.3946 1.46987 9.45504 2.40484 7.81585C3.69145 5.56019 5.56019 3.69145 7.81585 2.40484C9.45504 1.46987 11.3946 0.987552 14.105 0.744315C16.8221 0.50047 20.2652 0.5 24.9 0.5H35.1C39.7348 0.5 43.1779 0.50047 45.895 0.744315C48.6054 0.987552 50.545 1.46987 52.1841 2.40484C54.4398 3.69145 56.3086 5.56019 57.5952 7.81585C58.5301 9.45504 59.0124 11.3946 59.2557 14.105C59.4995 16.8221 59.5 20.2652 59.5 24.9V35.1C59.5 39.7348 59.4995 43.1779 59.2557 45.895C59.0124 48.6054 58.5301 50.545 57.5952 52.1841C56.3086 54.4398 54.4398 56.3086 52.1841 57.5952C50.545 58.5301 48.6054 59.0124 45.895 59.2557C43.1779 59.4995 39.7348 59.5 35.1 59.5H24.9C20.2652 59.5 16.8221 59.4995 14.105 59.2557C11.3946 59.0124 9.45504 58.5301 7.81585 57.5952C5.56019 56.3086 3.69145 54.4398 2.40484 52.1841C1.46987 50.545 0.987552 48.6054 0.744315 45.895C0.50047 43.1779 0.5 39.7348 0.5 35.1V24.9Z"
    stroke="#062B2B"
    stroke-opacity="0.1"
  />
  <path
    d="M19 52C24.5228 52 29 47.5228 29 42C29 36.4772 24.5228 32 19 32C13.4772 32 9 36.4772 9 42C9 47.5228 13.4772 52 19 52Z"
    fill="#FF974C"
    stroke="white"
    stroke-width="2"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M42.8437 8.3264C42.4507 7.70891 41.5493 7.70891 41.1564 8.32641L28.978 27.4638C28.5544 28.1295 29.0326 29.0007 29.8217 29.0007H54.1783C54.9674 29.0007 55.4456 28.1295 55.022 27.4638L42.8437 8.3264Z"
    fill="white"
  />
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M42.3348 11.6456C42.659 11.7608 42.9061 12.1492 43.4005 12.926L50.7332 24.4488C51.2952 25.332 51.5763 25.7737 51.5254 26.1382C51.4915 26.3808 51.3698 26.6026 51.1833 26.7614C50.9031 27 50.3796 27 49.3327 27H34.6673C33.6204 27 33.0969 27 32.8167 26.7614C32.6302 26.6026 32.5085 26.3808 32.4746 26.1382C32.4237 25.7737 32.7048 25.332 33.2669 24.4488L40.5995 12.926C41.0939 12.1492 41.341 11.7608 41.6652 11.6456C41.8818 11.5687 42.1182 11.5687 42.3348 11.6456ZM35.0001 26.999C38.8661 26.999 42.0001 23.865 42.0001 19.999C42.0001 23.865 45.1341 26.999 49.0001 26.999H35.0001Z"
    fill="#FF974C"
  />
  <path
    d="M10.1061 9.35712C9.9973 9.67775 9.99867 10.0388 9.99978 10.3323C9.99989 10.3611 10 10.3893 10 10.4167V25.5833C10 25.6107 9.99989 25.6389 9.99978 25.6677C9.99867 25.9612 9.9973 26.3222 10.1061 26.6429C10.306 27.2317 10.7683 27.694 11.3571 27.8939C11.6777 28.0027 12.0388 28.0013 12.3323 28.0002C12.3611 28.0001 12.3893 28 12.4167 28H19C24.5228 28 29 23.5228 29 18C29 12.4772 24.5228 8 19 8H12.4167C12.3893 8 12.3611 7.99989 12.3323 7.99978C12.0388 7.99867 11.6778 7.9973 11.3571 8.10614C10.7683 8.306 10.306 8.76834 10.1061 9.35712Z"
    fill="#FF974C"
    stroke="white"
    stroke-width="2"
  />
  <circle cx="19" cy="18" r="4" fill="#EB8B47" stroke="white" stroke-width="2" />
  <circle cx="19" cy="42" r="4" fill="#EB8B47" stroke="white" stroke-width="2" />
</g>
<defs>
  <clipPath id="clip0_7734_50402">
    <rect width="60" height="60" fill="white" />
  </clipPath>
</defs>
</svg> `
      , tU = ef.YP`<svg fill="none" viewBox="0 0 60 60">
<g clip-path="url(#a)">
  <path
    fill="#1DC956"
    d="M0 25.01c0-9.25 0-13.88 1.97-17.33a15 15 0 0 1 5.6-5.6C11.02.11 15.65.11 24.9.11h10.2c9.25 0 13.88 0 17.33 1.97a15 15 0 0 1 5.6 5.6C60 11.13 60 15.76 60 25v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6c-3.45 1.97-8.08 1.97-17.33 1.97H24.9c-9.25 0-13.88 0-17.33-1.97a15 15 0 0 1-5.6-5.6C0 49.1 0 44.46 0 35.21v-10.2Z"
  />
  <path
    fill="#2BEE6C"
    d="M16.1 60c-3.82-.18-6.4-.64-8.53-1.86a15 15 0 0 1-5.6-5.6C.55 50.06.16 46.97.04 41.98L4.2 40.6a4 4 0 0 0 2.48-2.39l4.65-12.4a2 2 0 0 1 2.5-1.2l2.53.84a2 2 0 0 0 2.43-1l2.96-5.94a2 2 0 0 1 3.7.32l3.78 12.58a2 2 0 0 0 3.03 1.09l3.34-2.23a2 2 0 0 0 .65-.7l5.3-9.72a2 2 0 0 1 1.42-1.01l4.14-.69a2 2 0 0 1 1.6.44l3.9 3.24a2 2 0 0 0 2.7-.12l4.62-4.63c.08 2.2.08 4.8.08 7.93v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6c-2.13 1.22-4.7 1.68-8.54 1.86H16.11Z"
  />
  <path
    fill="#fff"
    d="m.07 43.03-.05-2.1 3.85-1.28a3 3 0 0 0 1.86-1.79l4.66-12.4a3 3 0 0 1 3.75-1.8l2.53.84a1 1 0 0 0 1.21-.5l2.97-5.94a3 3 0 0 1 5.56.48l3.77 12.58a1 1 0 0 0 1.51.55l3.34-2.23a1 1 0 0 0 .33-.35l5.3-9.71a3 3 0 0 1 2.14-1.53l4.13-.69a3 3 0 0 1 2.41.66l3.9 3.24a1 1 0 0 0 1.34-.06l5.28-5.28c.05.85.08 1.75.1 2.73L56 22.41a3 3 0 0 1-4.04.19l-3.9-3.25a1 1 0 0 0-.8-.21l-4.13.69a1 1 0 0 0-.72.5l-5.3 9.72a3 3 0 0 1-.97 1.05l-3.34 2.23a3 3 0 0 1-4.53-1.63l-3.78-12.58a1 1 0 0 0-1.85-.16l-2.97 5.94a3 3 0 0 1-3.63 1.5l-2.53-.84a1 1 0 0 0-1.25.6l-4.65 12.4a5 5 0 0 1-3.1 3L.07 43.02Z"
  />
  <path
    fill="#fff"
    fill-rule="evenodd"
    d="M49.5 19a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0Z"
    clip-rule="evenodd"
  />
  <path fill="#fff" d="M45 .28v59.66l-2 .1V.19c.7.02 1.37.05 2 .1Z" />
  <path fill="#2BEE6C" d="M47.5 19a3.5 3.5 0 1 1-7 0 3.5 3.5 0 0 1 7 0Z" />
  <path
    stroke="#fff"
    stroke-opacity=".1"
    d="M.5 25.01c0-4.63 0-8.08.24-10.8.25-2.7.73-4.64 1.66-6.28a14.5 14.5 0 0 1 5.42-5.41C9.46 1.58 11.39 1.1 14.1.85A133 133 0 0 1 24.9.61h10.2c4.63 0 8.08 0 10.8.24 2.7.25 4.65.73 6.28 1.67a14.5 14.5 0 0 1 5.42 5.4c.93 1.65 1.41 3.58 1.66 6.3.24 2.71.24 6.16.24 10.79v10.2c0 4.64 0 8.08-.24 10.8-.25 2.7-.73 4.65-1.66 6.28a14.5 14.5 0 0 1-5.42 5.42c-1.63.93-3.57 1.41-6.28 1.66-2.72.24-6.17.24-10.8.24H24.9c-4.63 0-8.08 0-10.8-.24-2.7-.25-4.64-.73-6.28-1.66a14.5 14.5 0 0 1-5.42-5.42C1.47 50.66 1 48.72.74 46.01A133 133 0 0 1 .5 35.2v-10.2Z"
  />
</g>
<defs>
  <clipPath id="a"><path fill="#fff" d="M0 0h60v60H0z" /></clipPath>
</defs>
</svg>`
      , tz = ef.YP`<svg fill="none" viewBox="0 0 60 60">
<g clip-path="url(#a)">
  <rect width="60" height="60" fill="#C653C6" rx="30" />
  <path
    fill="#E87DE8"
    d="M57.98.01v19.5a4.09 4.09 0 0 0-2.63 2.29L50.7 34.2a2 2 0 0 1-2.5 1.2l-2.53-.84a2 2 0 0 0-2.42 1l-2.97 5.94a2 2 0 0 1-3.7-.32L32.8 28.6a2 2 0 0 0-3.02-1.09l-3.35 2.23a2 2 0 0 0-.64.7l-5.3 9.72a2 2 0 0 1-1.43 1.01l-4.13.69a2 2 0 0 1-1.61-.44l-3.9-3.24a2 2 0 0 0-2.69.12L2.1 42.93.02 43V.01h57.96Z"
  />
  <path
    fill="#fff"
    d="m61.95 16.94.05 2.1-3.85 1.28a3 3 0 0 0-1.86 1.79l-4.65 12.4a3 3 0 0 1-3.76 1.8l-2.53-.84a1 1 0 0 0-1.2.5l-2.98 5.94a3 3 0 0 1-5.55-.48l-3.78-12.58a1 1 0 0 0-1.5-.55l-3.35 2.23a1 1 0 0 0-.32.35l-5.3 9.72a3 3 0 0 1-2.14 1.52l-4.14.69a3 3 0 0 1-2.41-.66l-3.9-3.24a1 1 0 0 0-1.34.06l-5.28 5.28c-.05-.84-.08-1.75-.1-2.73l3.97-3.96a3 3 0 0 1 4.04-.19l3.89 3.25a1 1 0 0 0 .8.21l4.14-.68a1 1 0 0 0 .71-.51l5.3-9.71a3 3 0 0 1 .97-1.06l3.34-2.23a3 3 0 0 1 4.54 1.63l3.77 12.58a1 1 0 0 0 1.86.16l2.96-5.93a3 3 0 0 1 3.64-1.5l2.52.83a1 1 0 0 0 1.25-.6l4.66-12.4a5 5 0 0 1 3.1-2.99l4.43-1.48Z"
  />
  <path
    fill="#fff"
    fill-rule="evenodd"
    d="M35.5 27a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0Z"
    clip-rule="evenodd"
  />
  <path fill="#fff" d="M31 0v60h-2V0h2Z" />
  <path fill="#E87DE8" d="M33.5 27a3.5 3.5 0 1 1-7 0 3.5 3.5 0 0 1 7 0Z" />
</g>
<rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="29.5" />
<defs>
  <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
</defs>
</svg> `
      , tH = ef.YP`<svg fill="none" viewBox="0 0 60 60">
<g clip-path="url(#a)">
  <rect width="60" height="60" fill="#987DE8" rx="30" />
  <path
    fill="#fff"
    fill-rule="evenodd"
    d="m15.48 28.37 11.97-19.3a3 3 0 0 1 5.1 0l11.97 19.3a6 6 0 0 1 .9 3.14v.03a6 6 0 0 1-1.16 3.56L33.23 50.2a4 4 0 0 1-6.46 0L15.73 35.1a6 6 0 0 1-1.15-3.54v-.03a6 6 0 0 1 .9-3.16Z"
    clip-rule="evenodd"
  />
  <path
    fill="#643CDD"
    d="M30.84 10.11a1 1 0 0 0-.84-.46V24.5l12.6 5.53a2 2 0 0 0-.28-1.4L30.84 10.11Z"
  />
  <path
    fill="#BDADEB"
    d="M30 9.65a1 1 0 0 0-.85.46L17.66 28.64a2 2 0 0 0-.26 1.39L30 24.5V9.65Z"
  />
  <path
    fill="#643CDD"
    d="M30 50.54a1 1 0 0 0 .8-.4l11.24-15.38c.3-.44-.2-1-.66-.73l-9.89 5.68a3 3 0 0 1-1.5.4v10.43Z"
  />
  <path
    fill="#BDADEB"
    d="m17.97 34.76 11.22 15.37c.2.28.5.41.8.41V40.11a3 3 0 0 1-1.49-.4l-9.88-5.68c-.47-.27-.97.3-.65.73Z"
  />
  <path
    fill="#401AB3"
    d="M42.6 30.03 30 24.5v13.14a3 3 0 0 0 1.5-.4l10.14-5.83a2 2 0 0 0 .95-1.38Z"
  />
  <path
    fill="#7C5AE2"
    d="M30 37.64V24.46l-12.6 5.57a2 2 0 0 0 .97 1.39l10.13 5.82a3 3 0 0 0 1.5.4Z"
  />
</g>
<rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="29.5" />
<defs>
  <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
</defs>
</svg> `
      , tV = ef.YP`<svg fill="none" viewBox="0 0 60 60">
<rect width="60" height="60" fill="#1DC956" rx="3" />
<path
  fill="#1FAD7E"
  stroke="#fff"
  stroke-width="2"
  d="m30.49 29.13-.49-.27-.49.27-12.77 7.1-.05.02c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45l-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-12.77-7.1Z"
/>
<path
  fill="#2BEE6C"
  stroke="#fff"
  stroke-width="2"
  d="m30.49 19.13-.49-.27-.49.27-12.77 7.1-.05.02c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45l-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-12.77-7.1Z"
/>
<path
  fill="#86F999"
  stroke="#fff"
  stroke-width="2"
  d="m46.69 21.06-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-6.32-3.51-.18-.1c-2.33-1.3-3.72-2.06-5.22-2.33a9 9 0 0 0-3.08 0c-1.5.27-2.9 1.04-5.22 2.33l-.17.1-6.33 3.51-.05.03c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45Z"
/>
<rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`
      , tW = ef.YP`<svg fill="none" viewBox="0 0 60 60">
<rect width="60" height="60" fill="#C653C6" rx="3" />
<path
  fill="#fff"
  d="M20.03 15.22C20 15.6 20 16.07 20 17v2.8c0 1.14 0 1.7-.2 2.12-.15.31-.3.5-.58.71-.37.28-1.06.42-2.43.7-.59.12-1.11.29-1.6.51a9 9 0 0 0-4.35 4.36C10 30 10 32.34 10 37c0 4.66 0 7 .84 8.8a9 9 0 0 0 4.36 4.36C17 51 19.34 51 24 51h12c4.66 0 7 0 8.8-.84a9 9 0 0 0 4.36-4.36C50 44 50 41.66 50 37c0-4.66 0-7-.84-8.8a9 9 0 0 0-4.36-4.36c-.48-.22-1-.39-1.6-.5-1.36-.29-2.05-.43-2.42-.7-.27-.22-.43-.4-.58-.72-.2-.42-.2-.98-.2-2.11V17c0-.93 0-1.4-.03-1.78a9 9 0 0 0-8.19-8.19C31.4 7 30.93 7 30 7s-1.4 0-1.78.03a9 9 0 0 0-8.19 8.19Z"
/>
<path
  fill="#E87DE8"
  d="M22 17c0-.93 0-1.4.04-1.78a7 7 0 0 1 6.18-6.18C28.6 9 29.07 9 30 9s1.4 0 1.78.04a7 7 0 0 1 6.18 6.18c.04.39.04.85.04 1.78v4.5a1.5 1.5 0 0 1-3 0V17c0-.93 0-1.4-.08-1.78a4 4 0 0 0-3.14-3.14C31.39 12 30.93 12 30 12s-1.4 0-1.78.08a4 4 0 0 0-3.14 3.14c-.08.39-.08.85-.08 1.78v4.5a1.5 1.5 0 0 1-3 0V17Z"
/>
<path
  fill="#E87DE8"
  fill-rule="evenodd"
  d="M12 36.62c0-4.32 0-6.48.92-8.09a7 7 0 0 1 2.61-2.61C17.14 25 19.3 25 23.62 25h6.86c.46 0 .7 0 .9.02 2.73.22 4.37 2.43 4.62 4.98.27-2.7 2.11-5 5.02-5A6.98 6.98 0 0 1 48 31.98v5.4c0 4.32 0 6.48-.92 8.09a7 7 0 0 1-2.61 2.61c-1.61.92-3.77.92-8.09.92h-5.86c-.46 0-.7 0-.9-.02-2.73-.22-4.37-2.43-4.62-4.98-.26 2.58-1.94 4.82-4.71 4.99l-.7.01c-.55 0-.82 0-1.05-.02a7 7 0 0 1-6.52-6.52c-.02-.23-.02-.5-.02-1.05v-4.79Zm21.24-.27a4 4 0 1 0-6.48 0 31.28 31.28 0 0 1 1.57 2.23c.17.4.17.81.17 1.24V42.5a1.5 1.5 0 0 0 3 0V39.82c0-.43 0-.85.17-1.24.09-.2.58-.87 1.57-2.23Z"
  clip-rule="evenodd"
/>
<rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`
      , tq = ef.YP`<svg fill="none" viewBox="0 0 60 60">
<g clip-path="url(#a)">
  <path
    fill="#EB8B47"
    d="M0 24.9c0-9.25 0-13.88 1.97-17.33a15 15 0 0 1 5.6-5.6C11.02 0 15.65 0 24.9 0h10.2c9.25 0 13.88 0 17.33 1.97a15 15 0 0 1 5.6 5.6C60 11.02 60 15.65 60 24.9v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6C48.98 60 44.35 60 35.1 60H24.9c-9.25 0-13.88 0-17.33-1.97a15 15 0 0 1-5.6-5.6C0 48.98 0 44.35 0 35.1V24.9Z"
  />
  <path
    stroke="#062B2B"
    stroke-opacity=".1"
    d="M.5 24.9c0-4.64 0-8.08.24-10.8.25-2.7.73-4.65 1.66-6.28A14.5 14.5 0 0 1 7.82 2.4C9.46 1.47 11.39 1 14.1.74A133 133 0 0 1 24.9.5h10.2c4.63 0 8.08 0 10.8.24 2.7.25 4.65.73 6.28 1.66a14.5 14.5 0 0 1 5.42 5.42c.93 1.63 1.41 3.57 1.66 6.28.24 2.72.24 6.16.24 10.8v10.2c0 4.63 0 8.08-.24 10.8-.25 2.7-.73 4.64-1.66 6.28a14.5 14.5 0 0 1-5.42 5.41c-1.63.94-3.57 1.42-6.28 1.67-2.72.24-6.17.24-10.8.24H24.9c-4.63 0-8.08 0-10.8-.24-2.7-.25-4.64-.73-6.28-1.67a14.5 14.5 0 0 1-5.42-5.4C1.47 50.53 1 48.6.74 45.88A133 133 0 0 1 .5 35.1V24.9Z"
  />
  <path
    fill="#FF974C"
    stroke="#fff"
    stroke-width="2"
    d="M39.2 29.2a13 13 0 1 0-18.4 0l1.3 1.28a12.82 12.82 0 0 1 2.1 2.39 6 6 0 0 1 .6 1.47c.2.76.2 1.56.2 3.17v11.24c0 1.08 0 1.61.13 2.12a4 4 0 0 0 .41.98c.26.45.64.83 1.4 1.6l.3.29c.65.65.98.98 1.36 1.09.26.07.54.07.8 0 .38-.11.7-.44 1.36-1.1l3.48-3.47c.65-.65.98-.98 1.09-1.36a1.5 1.5 0 0 0 0-.8c-.1-.38-.44-.7-1.1-1.36l-.47-.48c-.65-.65-.98-.98-1.09-1.36a1.5 1.5 0 0 1 0-.8c.1-.38.44-.7 1.1-1.36l.47-.48c.65-.65.98-.98 1.09-1.36a1.5 1.5 0 0 0 0-.8c-.1-.38-.44-.7-1.1-1.36l-.48-.5c-.65-.64-.98-.97-1.08-1.35a1.5 1.5 0 0 1 0-.79c.1-.38.42-.7 1.06-1.36l5.46-5.55Z"
  />
  <circle cx="30" cy="17" r="4" fill="#EB8B47" stroke="#fff" stroke-width="2" />
</g>
<defs>
  <clipPath id="a"><path fill="#fff" d="M0 0h60v60H0z" /></clipPath>
</defs>
</svg> `
      , tZ = ef.YP`<svg fill="none" viewBox="0 0 60 60">
<g clip-path="url(#a)">
  <rect width="60" height="60" fill="#00ACE6" rx="30" />
  <circle cx="64" cy="39" r="50" fill="#1AC6FF" stroke="#fff" stroke-width="2" />
  <circle cx="78" cy="30" r="50" fill="#4DD2FF" stroke="#fff" stroke-width="2" />
  <circle cx="72" cy="15" r="35" fill="#80DFFF" stroke="#fff" stroke-width="2" />
  <circle cx="34" cy="-17" r="45" stroke="#fff" stroke-width="2" />
  <circle cx="34" cy="-5" r="50" stroke="#fff" stroke-width="2" />
  <circle cx="30" cy="45" r="4" fill="#4DD2FF" stroke="#fff" stroke-width="2" />
  <circle cx="39.5" cy="27.5" r="4" fill="#80DFFF" stroke="#fff" stroke-width="2" />
  <circle cx="16" cy="24" r="4" fill="#19C6FF" stroke="#fff" stroke-width="2" />
</g>
<rect width="59" height="59" x=".5" y=".5" stroke="#062B2B" stroke-opacity=".1" rx="29.5" />
<defs>
  <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
</defs>
</svg>`
      , tG = ef.YP`<svg fill="none" viewBox="0 0 60 60">
<g clip-path="url(#a)">
  <rect width="60" height="60" fill="#C653C6" rx="3" />
  <path
    fill="#E87DE8"
    stroke="#fff"
    stroke-width="2"
    d="M52.1 47.34c0-4.24-1.44-9.55-5.9-12.4a2.86 2.86 0 0 0-1.6-3.89v-.82c0-1.19-.52-2.26-1.35-3a4.74 4.74 0 0 0-2.4-6.26v-5.5a11.31 11.31 0 1 0-22.63 0v2.15a3.34 3.34 0 0 0-1.18 5.05 4.74 4.74 0 0 0-.68 6.44A5.22 5.22 0 0 0 14 35.92c-3.06 4.13-6.1 8.3-6.1 15.64 0 2.67.37 4.86.74 6.39a20.3 20.3 0 0 0 .73 2.39l.02.04v.01l.92-.39-.92.4.26.6h38.26l.3-.49-.87-.51.86.5.02-.01.03-.07a16.32 16.32 0 0 0 .57-1.05c.36-.72.85-1.74 1.33-2.96a25.51 25.51 0 0 0 1.94-9.07Z"
  />
  <path
    fill="#fff"
    fill-rule="evenodd"
    d="M26.5 29.5c-3-.5-5.5-3-5.5-7v-7c0-.47 0-.7.03-.9a3 3 0 0 1 2.58-2.57c.2-.03.42-.03.89-.03 2 0 2.5-2.5 2.5-2.5s0 2.5 2.5 2.5c1.4 0 2.1 0 2.65.23a3 3 0 0 1 1.62 1.62c.23.55.23 1.25.23 2.65v6c0 4-3 7-6.5 7 1.35.23 4 0 6.5-2v9.53C34 38.5 31.5 40 28 40s-6-1.5-6-2.97L24 34l2.5 1.5v-6ZM26 47h4.5c2.5 0 3 4 3 5.5h-3l-1-1.5H26v-4Zm-6.25 5.5H24V57h-8c0-1 1-4.5 3.75-4.5Z"
    clip-rule="evenodd"
  />
</g>
<rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
<defs>
  <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="3" /></clipPath>
</defs>
</svg> `
      , tY = ef.YP`<svg fill="none" viewBox="0 0 60 60">
<rect width="60" height="60" fill="#794CFF" rx="3" />
<path
  fill="#987DE8"
  stroke="#fff"
  stroke-width="2"
  d="M33 22.5v-1H16v5H8.5V36H13v-5h3v7.5h17V31h1v7.5h17v-17H34v5h-1v-4Z"
/>
<path fill="#fff" d="M37.5 25h10v10h-10z" />
<path fill="#4019B2" d="M42.5 25h5v10h-5z" />
<path fill="#fff" d="M19.5 25h10v10h-10z" />
<path fill="#4019B2" d="M24.5 25h5v10h-5z" />
<path fill="#fff" d="M12 30.5h4V37h-4v-6.5Z" />
<rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`
      , tK = ef.YP`<svg
viewBox="0 0 60 60"
fill="none"
>
<g clip-path="url(#1)">
  <rect width="60" height="60" rx="30" fill="#00ACE6" />
  <path
    d="M59 73C59 89.0163 46.0163 102 30 102C13.9837 102 1 89.0163 1 73C1 56.9837 12 44 30 44C48 44 59 56.9837 59 73Z"
    fill="#1AC6FF"
    stroke="white"
    stroke-width="2"
  />
  <path
    d="M18.6904 19.9015C19.6264 15.3286 23.3466 11.8445 27.9708 11.2096C29.3231 11.024 30.6751 11.0238 32.0289 11.2096C36.6532 11.8445 40.3733 15.3286 41.3094 19.9015C41.4868 20.7681 41.6309 21.6509 41.7492 22.5271C41.8811 23.5041 41.8811 24.4944 41.7492 25.4715C41.6309 26.3476 41.4868 27.2304 41.3094 28.097C40.3733 32.6699 36.6532 36.154 32.0289 36.7889C30.6772 36.9744 29.3216 36.9743 27.9708 36.7889C23.3466 36.154 19.6264 32.6699 18.6904 28.097C18.513 27.2304 18.3689 26.3476 18.2506 25.4715C18.1186 24.4944 18.1186 23.5041 18.2506 22.5271C18.3689 21.6509 18.513 20.7681 18.6904 19.9015Z"
    fill="#1AC6FF"
    stroke="white"
    stroke-width="2"
  />
  <circle cx="24.5" cy="23.5" r="1.5" fill="white" />
  <circle cx="35.5" cy="23.5" r="1.5" fill="white" />
  <path
    d="M31 20L28 28H32"
    stroke="white"
    stroke-width="2"
    stroke-linecap="round"
    stroke-linejoin="round"
  />
</g>
<rect x="0.5" y="0.5" width="59" height="59" rx="29.5" stroke="white" stroke-opacity="0.1" />
<defs>
  <clipPath id="1">
    <rect width="60" height="60" rx="30" fill="white" />
  </clipPath>
</defs>
</svg> `
      , tJ = ef.YP`<svg viewBox="0 0 60 60" fill="none">
<g clip-path="url(#1)">
  <path
    d="M0 24.9C0 15.6485 0 11.0228 1.97053 7.56812C3.3015 5.23468 5.23468 3.3015 7.56812 1.97053C11.0228 0 15.6485 0 24.9 0H35.1C44.3514 0 48.9772 0 52.4319 1.97053C54.7653 3.3015 56.6985 5.23468 58.0295 7.56812C60 11.0228 60 15.6485 60 24.9V35.1C60 44.3514 60 48.9772 58.0295 52.4319C56.6985 54.7653 54.7653 56.6985 52.4319 58.0295C48.9772 60 44.3514 60 35.1 60H24.9C15.6485 60 11.0228 60 7.56812 58.0295C5.23468 56.6985 3.3015 54.7653 1.97053 52.4319C0 48.9772 0 44.3514 0 35.1V24.9Z"
    fill="#794CFF"
  />
  <path
    d="M0.5 24.9C0.5 20.2652 0.50047 16.8221 0.744315 14.105C0.987552 11.3946 1.46987 9.45504 2.40484 7.81585C3.69145 5.56019 5.56019 3.69145 7.81585 2.40484C9.45504 1.46987 11.3946 0.987552 14.105 0.744315C16.8221 0.50047 20.2652 0.5 24.9 0.5H35.1C39.7348 0.5 43.1779 0.50047 45.895 0.744315C48.6054 0.987552 50.545 1.46987 52.1841 2.40484C54.4398 3.69145 56.3086 5.56019 57.5952 7.81585C58.5301 9.45504 59.0124 11.3946 59.2557 14.105C59.4995 16.8221 59.5 20.2652 59.5 24.9V35.1C59.5 39.7348 59.4995 43.1779 59.2557 45.895C59.0124 48.6054 58.5301 50.545 57.5952 52.1841C56.3086 54.4398 54.4398 56.3086 52.1841 57.5952C50.545 58.5301 48.6054 59.0124 45.895 59.2557C43.1779 59.4995 39.7348 59.5 35.1 59.5H24.9C20.2652 59.5 16.8221 59.4995 14.105 59.2557C11.3946 59.0124 9.45504 58.5301 7.81585 57.5952C5.56019 56.3086 3.69145 54.4398 2.40484 52.1841C1.46987 50.545 0.987552 48.6054 0.744315 45.895C0.50047 43.1779 0.5 39.7348 0.5 35.1V24.9Z"
    stroke="#062B2B"
    stroke-opacity="0.1"
  />
  <path
    d="M35.1403 31.5016C35.1193 30.9637 35.388 30.4558 35.8446 30.1707C36.1207 29.9982 36.4761 29.8473 36.7921 29.7685C37.3143 29.6382 37.8664 29.7977 38.2386 30.1864C38.8507 30.8257 39.3004 31.6836 39.8033 32.408C40.2796 33.0942 41.4695 33.2512 41.9687 32.5047C42.4839 31.7341 42.9405 30.8229 43.572 30.1399C43.9375 29.7447 44.4866 29.5756 45.0111 29.6967C45.3283 29.7701 45.6863 29.9147 45.9655 30.0823C46.4269 30.3595 46.7045 30.8626 46.6928 31.4008C46.6731 32.3083 46.3764 33.2571 46.2158 34.1473C46.061 35.0048 46.9045 35.8337 47.7592 35.664C48.6464 35.4878 49.5899 35.1747 50.497 35.1391C51.0348 35.1181 51.5427 35.3868 51.8279 35.8433C52.0004 36.1195 52.1513 36.4749 52.2301 36.7908C52.3604 37.3131 52.2009 37.8651 51.8121 38.2374C51.1729 38.8495 50.3151 39.2991 49.5908 39.8019C48.9046 40.2782 48.7473 41.4683 49.4939 41.9675C50.2644 42.4827 51.1757 42.9393 51.8587 43.5708C52.2539 43.9362 52.423 44.4854 52.3018 45.0099C52.2285 45.3271 52.0839 45.6851 51.9162 45.9642C51.6391 46.4257 51.1359 46.7032 50.5978 46.6916C49.6903 46.6719 48.7417 46.3753 47.8516 46.2146C46.9939 46.0598 46.1648 46.9035 46.3346 47.7583C46.5108 48.6454 46.8239 49.5888 46.8594 50.4958C46.8805 51.0336 46.6117 51.5415 46.1552 51.8267C45.879 51.9992 45.5236 52.15 45.2077 52.2289C44.6854 52.3592 44.1334 52.1997 43.7611 51.8109C43.1491 51.1718 42.6996 50.314 42.1968 49.5897C41.7203 48.9034 40.5301 48.7463 40.0309 49.493C39.5157 50.2634 39.0592 51.1746 38.4278 51.8574C38.0623 52.2527 37.5132 52.4218 36.9887 52.3006C36.6715 52.2273 36.3135 52.0826 36.0343 51.915C35.5729 51.6379 35.2953 51.1347 35.307 50.5966C35.3267 49.6891 35.6233 48.7405 35.7839 47.8505C35.9388 46.9928 35.0951 46.1636 34.2402 46.3334C33.3531 46.5096 32.4098 46.8227 31.5028 46.8582C30.9649 46.8793 30.457 46.6105 30.1719 46.154C29.9994 45.8778 29.8485 45.5224 29.7697 45.2065C29.6394 44.6842 29.7989 44.1322 30.1877 43.7599C30.8269 43.1479 31.6847 42.6982 32.4091 42.1954C33.0954 41.7189 33.2522 40.5289 32.5056 40.0297C31.7351 39.5145 30.824 39.058 30.1411 38.4265C29.7459 38.0611 29.5768 37.5119 29.698 36.9875C29.7713 36.6702 29.9159 36.3122 30.0836 36.0331C30.3607 35.5717 30.8638 35.2941 31.402 35.3058C32.3095 35.3255 33.2583 35.6221 34.1485 35.7828C35.006 35.9376 35.8349 35.094 35.6652 34.2393C35.489 33.3521 35.1759 32.4087 35.1403 31.5016Z"
    fill="#906EF7"
    stroke="white"
    stroke-width="2"
  />
  <path
    d="M20.7706 8.22357C20.9036 7.51411 21.5231 7 22.2449 7H23.7551C24.4769 7 25.0964 7.51411 25.2294 8.22357C25.5051 9.69403 25.4829 11.6321 27.1202 12.2606C27.3092 12.3331 27.4958 12.4105 27.6798 12.4926C29.2818 13.2072 30.6374 11.8199 31.8721 10.9752C32.4678 10.5676 33.2694 10.6421 33.7798 11.1525L34.8477 12.2204C35.3581 12.7308 35.4326 13.5323 35.025 14.128C34.1802 15.3627 32.7931 16.7183 33.5077 18.3202C33.5898 18.5043 33.6672 18.6909 33.7398 18.88C34.3683 20.5171 36.3061 20.4949 37.7764 20.7706C38.4859 20.9036 39 21.5231 39 22.2449V23.7551C39 24.4769 38.4859 25.0964 37.7764 25.2294C36.3061 25.5051 34.3685 25.483 33.7401 27.1201C33.6675 27.3093 33.59 27.4961 33.5079 27.6803C32.7934 29.282 34.1803 30.6374 35.025 31.8719C35.4326 32.4677 35.3581 33.2692 34.8477 33.7796L33.7798 34.8475C33.2694 35.3579 32.4678 35.4324 31.8721 35.0248C30.6376 34.1801 29.2823 32.7934 27.6806 33.508C27.4962 33.5903 27.3093 33.6678 27.12 33.7405C25.483 34.3688 25.5051 36.3062 25.2294 37.7764C25.0964 38.4859 24.4769 39 23.7551 39H22.2449C21.5231 39 20.9036 38.4859 20.7706 37.7764C20.4949 36.3062 20.517 34.3688 18.88 33.7405C18.6908 33.6678 18.5039 33.5903 18.3196 33.5081C16.7179 32.7936 15.3625 34.1804 14.1279 35.0251C13.5322 35.4327 12.7307 35.3582 12.2203 34.8478L11.1524 33.7799C10.642 33.2695 10.5675 32.4679 10.9751 31.8722C11.8198 30.6376 13.2067 29.2822 12.4922 27.6804C12.41 27.4962 12.3325 27.3093 12.2599 27.1201C11.6315 25.483 9.69392 25.5051 8.22357 25.2294C7.51411 25.0964 7 24.4769 7 23.7551V22.2449C7 21.5231 7.51411 20.9036 8.22357 20.7706C9.69394 20.4949 11.6317 20.5171 12.2602 18.88C12.3328 18.6909 12.4103 18.5042 12.4924 18.3201C13.207 16.7181 11.8198 15.3625 10.975 14.1278C10.5674 13.5321 10.6419 12.7305 11.1523 12.2201L12.2202 11.1522C12.7306 10.6418 13.5322 10.5673 14.1279 10.9749C15.3626 11.8197 16.7184 13.2071 18.3204 12.4925C18.5044 12.4105 18.6909 12.3331 18.8799 12.2606C20.5171 11.6321 20.4949 9.69403 20.7706 8.22357Z"
    fill="#906EF7"
    stroke="white"
    stroke-width="2"
  />
  <circle cx="23" cy="23" r="6" fill="#794CFF" stroke="white" stroke-width="2" />
  <circle cx="41" cy="41" r="4" fill="#794CFF" stroke="white" stroke-width="2" />
</g>
<defs>
  <clipPath id="1">
    <rect width="60" height="60" fill="white" />
  </clipPath>
</defs>
</svg> `;
    var tQ = ef.iv`
:host {
  display: block;
  width: 55px;
  height: 55px;
}
`
      , wui_visual_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let tX = {
      browser: tB,
      dao: tF,
      defi: tU,
      defiAlt: tz,
      eth: tH,
      layers: tV,
      lock: tW,
      login: tq,
      network: tZ,
      nft: tG,
      noun: tY,
      profile: tK,
      system: tJ
    }
      , t0 = class extends ef.oi {
        constructor() {
          super(...arguments),
            this.name = "browser"
        }
        render() {
          return ef.dy`${tX[this.name]}`
        }
      }
      ;
    t0.styles = [em, tQ],
      wui_visual_decorate([(0,
        e_.Cb)()], t0.prototype, "name", void 0),
      t0 = wui_visual_decorate([customElement("wui-visual")], t0);
    var t1 = eo(35592);
    let t2 = {
      getSpacingStyles: (J, et) => Array.isArray(J) ? J[et] ? `var(--wui-spacing-${J[et]})` : void 0 : "string" == typeof J ? `var(--wui-spacing-${J})` : void 0,
      getFormattedDate: J => new Intl.DateTimeFormat("en-US", {
        month: "short",
        day: "numeric"
      }).format(J),
      getHostName(J) {
        let et = new URL(J);
        return et.hostname
      },
      getTruncateString: ({ string: J, charsStart: et, charsEnd: eo, truncate: el }) => J.length <= et + eo ? J : "end" === el ? `${J.substring(0, et)}...` : "start" === el ? `...${J.substring(J.length - eo)}` : `${J.substring(0, Math.floor(et))}...${J.substring(J.length - Math.floor(eo))}`,
      generateAvatarColors(J) {
        let et = J.toLowerCase().replace(/^0x/iu, "")
          , eo = et.substring(0, 6)
          , el = this.hexToRgb(eo)
          , ec = getComputedStyle(document.documentElement).getPropertyValue("--w3m-border-radius-master")
          , ed = Number(ec?.replace("px", ""))
          , eh = 100 - 3 * ed
          , ep = `${eh}% ${eh}% at 65% 40%`
          , ef = [];
        for (let J = 0; J < 5; J += 1) {
          let et = this.tintColor(el, .15 * J);
          ef.push(`rgb(${et[0]}, ${et[1]}, ${et[2]})`)
        }
        return `
  --local-color-1: ${ef[0]};
  --local-color-2: ${ef[1]};
  --local-color-3: ${ef[2]};
  --local-color-4: ${ef[3]};
  --local-color-5: ${ef[4]};
  --local-radial-circle: ${ep}
 `
      },
      hexToRgb(J) {
        let et = parseInt(J, 16);
        return [et >> 16 & 255, et >> 8 & 255, 255 & et]
      },
      tintColor(J, et) {
        let [eo, el, ec] = J
          , ed = Math.round(eo + (255 - eo) * et)
          , eh = Math.round(el + (255 - el) * et)
          , ep = Math.round(ec + (255 - ec) * et);
        return [ed, eh, ep]
      },
      isNumber: J => /^[0-9]+$/u.test(J),
      getColorTheme: J => J || ("undefined" != typeof window && window.matchMedia ? window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light" : "dark")
    };
    var t3 = ef.iv`
:host {
  display: flex;
  width: inherit;
  height: inherit;
}
`
      , wui_flex_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let t5 = class extends ef.oi {
      render() {
        return this.style.cssText = `
    flex-direction: ${this.flexDirection};
    flex-wrap: ${this.flexWrap};
    flex-basis: ${this.flexBasis};
    flex-grow: ${this.flexGrow};
    flex-shrink: ${this.flexShrink};
    align-items: ${this.alignItems};
    justify-content: ${this.justifyContent};
    column-gap: ${this.columnGap && `var(--wui-spacing-${this.columnGap})`};
    row-gap: ${this.rowGap && `var(--wui-spacing-${this.rowGap})`};
    gap: ${this.gap && `var(--wui-spacing-${this.gap})`};
    padding-top: ${this.padding && t2.getSpacingStyles(this.padding, 0)};
    padding-right: ${this.padding && t2.getSpacingStyles(this.padding, 1)};
    padding-bottom: ${this.padding && t2.getSpacingStyles(this.padding, 2)};
    padding-left: ${this.padding && t2.getSpacingStyles(this.padding, 3)};
    margin-top: ${this.margin && t2.getSpacingStyles(this.margin, 0)};
    margin-right: ${this.margin && t2.getSpacingStyles(this.margin, 1)};
    margin-bottom: ${this.margin && t2.getSpacingStyles(this.margin, 2)};
    margin-left: ${this.margin && t2.getSpacingStyles(this.margin, 3)};
  `,
          ef.dy`<slot></slot>`
      }
    }
      ;
    t5.styles = [em, t3],
      wui_flex_decorate([(0,
        e_.Cb)()], t5.prototype, "flexDirection", void 0),
      wui_flex_decorate([(0,
        e_.Cb)()], t5.prototype, "flexWrap", void 0),
      wui_flex_decorate([(0,
        e_.Cb)()], t5.prototype, "flexBasis", void 0),
      wui_flex_decorate([(0,
        e_.Cb)()], t5.prototype, "flexGrow", void 0),
      wui_flex_decorate([(0,
        e_.Cb)()], t5.prototype, "flexShrink", void 0),
      wui_flex_decorate([(0,
        e_.Cb)()], t5.prototype, "alignItems", void 0),
      wui_flex_decorate([(0,
        e_.Cb)()], t5.prototype, "justifyContent", void 0),
      wui_flex_decorate([(0,
        e_.Cb)()], t5.prototype, "columnGap", void 0),
      wui_flex_decorate([(0,
        e_.Cb)()], t5.prototype, "rowGap", void 0),
      wui_flex_decorate([(0,
        e_.Cb)()], t5.prototype, "gap", void 0),
      wui_flex_decorate([(0,
        e_.Cb)()], t5.prototype, "padding", void 0),
      wui_flex_decorate([(0,
        e_.Cb)()], t5.prototype, "margin", void 0),
      t5 = wui_flex_decorate([customElement("wui-flex")], t5);
    var t6 = ef.iv`
:host {
  display: block;
  width: var(--wui-icon-box-size-xl);
  height: var(--wui-icon-box-size-xl);
  border-radius: var(--wui-border-radius-3xl);
  box-shadow: 0 0 0 8px var(--wui-gray-glass-005);
  overflow: hidden;
  position: relative;
}

:host([data-variant='generated']) {
  --mixed-local-color-1: var(--local-color-1);
  --mixed-local-color-2: var(--local-color-2);
  --mixed-local-color-3: var(--local-color-3);
  --mixed-local-color-4: var(--local-color-4);
  --mixed-local-color-5: var(--local-color-5);
}

@supports (background: color-mix(in srgb, white 50%, black)) {
  :host([data-variant='generated']) {
    --mixed-local-color-1: color-mix(
      in srgb,
      var(--w3m-color-mix) var(--w3m-color-mix-strength),
      var(--local-color-1)
    );
    --mixed-local-color-2: color-mix(
      in srgb,
      var(--w3m-color-mix) var(--w3m-color-mix-strength),
      var(--local-color-2)
    );
    --mixed-local-color-3: color-mix(
      in srgb,
      var(--w3m-color-mix) var(--w3m-color-mix-strength),
      var(--local-color-3)
    );
    --mixed-local-color-4: color-mix(
      in srgb,
      var(--w3m-color-mix) var(--w3m-color-mix-strength),
      var(--local-color-4)
    );
    --mixed-local-color-5: color-mix(
      in srgb,
      var(--w3m-color-mix) var(--w3m-color-mix-strength),
      var(--local-color-5)
    );
  }
}

:host([data-variant='generated']) {
  box-shadow: 0 0 0 8px var(--wui-gray-glass-005);
  background: radial-gradient(
    var(--local-radial-circle),
    #fff 0.52%,
    var(--mixed-local-color-5) 31.25%,
    var(--mixed-local-color-3) 51.56%,
    var(--mixed-local-color-2) 65.63%,
    var(--mixed-local-color-1) 82.29%,
    var(--mixed-local-color-4) 100%
  );
}

:host([data-variant='default']) {
  box-shadow: 0 0 0 8px var(--wui-gray-glass-005);
  background: radial-gradient(
    75.29% 75.29% at 64.96% 24.36%,
    #fff 0.52%,
    #f5ccfc 31.25%,
    #dba4f5 51.56%,
    #9a8ee8 65.63%,
    #6493da 82.29%,
    #6ebdea 100%
  );
}
`
      , wui_avatar_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let t4 = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.imageSrc = void 0,
          this.alt = void 0,
          this.address = void 0
      }
      render() {
        return ef.dy`${this.visualTemplate()}`
      }
      visualTemplate() {
        if (this.imageSrc)
          return this.dataset.variant = "image",
            ef.dy`<wui-image src=${this.imageSrc} alt=${this.alt ?? "avatar"}></wui-image>`;
        if (this.address) {
          this.dataset.variant = "generated";
          let J = t2.generateAvatarColors(this.address);
          return this.style.cssText = J,
            null
        }
        return this.dataset.variant = "default",
          null
      }
    }
      ;
    t4.styles = [em, t6],
      wui_avatar_decorate([(0,
        e_.Cb)()], t4.prototype, "imageSrc", void 0),
      wui_avatar_decorate([(0,
        e_.Cb)()], t4.prototype, "alt", void 0),
      wui_avatar_decorate([(0,
        e_.Cb)()], t4.prototype, "address", void 0),
      t4 = wui_avatar_decorate([customElement("wui-avatar")], t4);
    var t8 = ef.iv`
:host {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  position: relative;
  overflow: hidden;
  background-color: var(--wui-gray-glass-020);
  border-radius: var(--local-border-radius);
  box-shadow: 0 0 0 1px var(--local-border);
  width: var(--local-size);
  height: var(--local-size);
  min-height: var(--local-size);
  min-width: var(--local-size);
}

@supports (background: color-mix(in srgb, white 50%, black)) {
  :host {
    background-color: color-mix(in srgb, var(--local-bg-value) var(--local-bg-mix), transparent);
  }
}
`
      , wui_icon_box_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let t7 = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.size = "md",
          this.backgroundColor = "accent-100",
          this.iconColor = "accent-100",
          this.background = "transparent",
          this.border = !1,
          this.borderColor = "wui-color-bg-125",
          this.icon = "copy"
      }
      render() {
        let J = this.iconSize || this.size
          , et = "lg" === this.size
          , eo = "xl" === this.size
          , el = "gray" === this.background
          , ec = "opaque" === this.background
          , ed = "accent-100" === this.backgroundColor && ec || "success-100" === this.backgroundColor && ec || "error-100" === this.backgroundColor && ec || "inverse-100" === this.backgroundColor && ec
          , eh = `var(--wui-color-${this.backgroundColor})`;
        return ed ? eh = `var(--wui-icon-box-bg-${this.backgroundColor})` : el && (eh = `var(--wui-gray-${this.backgroundColor})`),
          this.style.cssText = `
     --local-bg-value: ${eh};
     --local-bg-mix: ${ed || el ? "100%" : et ? "12%" : "16%"};
     --local-border-radius: var(--wui-border-radius-${et ? "xxs" : eo ? "s" : "3xl"});
     --local-size: var(--wui-icon-box-size-${this.size});
     --local-border: ${"wui-color-bg-125" === this.borderColor ? "2px" : "1px"} solid ${this.border ? `var(--${this.borderColor})` : "transparent"}
 `,
          ef.dy` <wui-icon color=${this.iconColor} size=${J} name=${this.icon}></wui-icon> `
      }
    }
      ;
    t7.styles = [em, eg, t8],
      wui_icon_box_decorate([(0,
        e_.Cb)()], t7.prototype, "size", void 0),
      wui_icon_box_decorate([(0,
        e_.Cb)()], t7.prototype, "backgroundColor", void 0),
      wui_icon_box_decorate([(0,
        e_.Cb)()], t7.prototype, "iconColor", void 0),
      wui_icon_box_decorate([(0,
        e_.Cb)()], t7.prototype, "iconSize", void 0),
      wui_icon_box_decorate([(0,
        e_.Cb)()], t7.prototype, "background", void 0),
      wui_icon_box_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], t7.prototype, "border", void 0),
      wui_icon_box_decorate([(0,
        e_.Cb)()], t7.prototype, "borderColor", void 0),
      wui_icon_box_decorate([(0,
        e_.Cb)()], t7.prototype, "icon", void 0),
      t7 = wui_icon_box_decorate([customElement("wui-icon-box")], t7);
    var t9 = ef.iv`
:host {
  display: block;
}

button {
  border-radius: var(--wui-border-radius-3xl);
  background: var(--wui-gray-glass-002);
  display: flex;
  gap: var(--wui-spacing-xs);
  padding: var(--wui-spacing-3xs) var(--wui-spacing-xs) var(--wui-spacing-3xs)
    var(--wui-spacing-xs);
  border: 1px solid var(--wui-gray-glass-005);
}

button:disabled {
  background: var(--wui-gray-glass-015);
}

button:disabled > wui-text {
  color: var(--wui-gray-glass-015);
}

button:disabled > wui-flex > wui-text {
  color: var(--wui-gray-glass-015);
}

button:disabled > wui-image,
button:disabled > wui-icon-box,
button:disabled > wui-flex > wui-avatar {
  filter: grayscale(1);
}

button:has(wui-image) {
  padding: var(--wui-spacing-3xs) var(--wui-spacing-3xs) var(--wui-spacing-3xs)
    var(--wui-spacing-xs);
}

wui-text {
  color: var(--wui-color-fg-100);
}

wui-flex > wui-text {
  color: var(--wui-color-fg-200);
  transition: all var(--wui-ease-out-power-1) var(--wui-duration-lg);
}

wui-image,
wui-icon-box {
  border-radius: var(--wui-border-radius-3xl);
  width: 24px;
  height: 24px;
  box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
}

wui-flex {
  border-radius: var(--wui-border-radius-3xl);
  border: 1px solid var(--wui-gray-glass-005);
  background: var(--wui-gray-glass-005);
  padding: 4px var(--wui-spacing-m) 4px var(--wui-spacing-xxs);
}

button.local-no-balance {
  border-radius: 0px;
  border: none;
  background: transparent;
}

wui-avatar {
  width: 20px;
  height: 20px;
  box-shadow: 0 0 0 2px var(--wui-accent-glass-010);
}

@media (max-width: 500px) {
  button {
    gap: 0px;
    padding: var(--wui-spacing-3xs) var(--wui-spacing-xs) !important;
    height: 32px;
  }
  wui-image,
  wui-icon-box,
  button > wui-text {
    visibility: hidden;
    width: 0px;
    height: 0px;
  }
  button {
    border-radius: 0px;
    border: none;
    background: transparent;
    padding: 0px;
  }
}

@media (hover: hover) and (pointer: fine) {
  button:hover:enabled > wui-flex > wui-text {
    color: var(--wui-color-fg-175);
  }

  button:active:enabled > wui-flex > wui-text {
    color: var(--wui-color-fg-175);
  }
}
`
      , wui_account_button_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let ro = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.networkSrc = void 0,
          this.avatarSrc = void 0,
          this.balance = void 0,
          this.disabled = !1,
          this.isProfileName = !1,
          this.address = "",
          this.charsStart = 4,
          this.charsEnd = 6
      }
      render() {
        return ef.dy`
    <button
      ?disabled=${this.disabled}
      class=${(0,
            t1.o)(this.balance ? void 0 : "local-no-balance")}
    >
      ${this.balanceTemplate()}
      <wui-flex gap="xxs" alignItems="center">
        <wui-avatar
          .imageSrc=${this.avatarSrc}
          alt=${this.address}
          address=${this.address}
        ></wui-avatar>
        <wui-text variant="paragraph-600" color="inherit">
          ${t2.getTruncateString({
              string: this.address,
              charsStart: this.isProfileName ? 18 : this.charsStart,
              charsEnd: this.isProfileName ? 0 : this.charsEnd,
              truncate: this.isProfileName ? "end" : "middle"
            })}
        </wui-text>
      </wui-flex>
    </button>
  `
      }
      balanceTemplate() {
        if (this.balance) {
          let J = this.networkSrc ? ef.dy`<wui-image src=${this.networkSrc}></wui-image>` : ef.dy`
          <wui-icon-box
            size="sm"
            iconColor="fg-200"
            backgroundColor="fg-300"
            icon="networkPlaceholder"
          ></wui-icon-box>
        `;
          return ef.dy`
      ${J}
      <wui-text variant="paragraph-600" color="inherit"> ${this.balance} </wui-text>
    `
        }
        return null
      }
    }
      ;
    ro.styles = [em, eg, t9],
      wui_account_button_decorate([(0,
        e_.Cb)()], ro.prototype, "networkSrc", void 0),
      wui_account_button_decorate([(0,
        e_.Cb)()], ro.prototype, "avatarSrc", void 0),
      wui_account_button_decorate([(0,
        e_.Cb)()], ro.prototype, "balance", void 0),
      wui_account_button_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], ro.prototype, "disabled", void 0),
      wui_account_button_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], ro.prototype, "isProfileName", void 0),
      wui_account_button_decorate([(0,
        e_.Cb)()], ro.prototype, "address", void 0),
      wui_account_button_decorate([(0,
        e_.Cb)()], ro.prototype, "charsStart", void 0),
      wui_account_button_decorate([(0,
        e_.Cb)()], ro.prototype, "charsEnd", void 0),
      ro = wui_account_button_decorate([customElement("wui-account-button")], ro);
    var ra = ef.iv`
:host {
  position: relative;
  background-color: var(--wui-gray-glass-002);
  display: flex;
  justify-content: center;
  align-items: center;
  width: var(--local-size);
  height: var(--local-size);
  border-radius: inherit;
  border-radius: var(--local-border-radius);
}

:host > wui-flex {
  overflow: hidden;
  border-radius: inherit;
  border-radius: var(--local-border-radius);
}

:host::after {
  content: '';
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  border-radius: inherit;
  border: 1px solid var(--wui-gray-glass-010);
  pointer-events: none;
}

:host([name='Extension'])::after {
  border: 1px solid var(--wui-accent-glass-010);
}

:host([data-wallet-icon='allWallets']) {
  background-color: var(--wui-all-wallets-bg-100);
}

:host([data-wallet-icon='allWallets'])::after {
  border: 1px solid var(--wui-accent-glass-010);
}

wui-icon[data-parent-size='inherit'] {
  width: 75%;
  height: 75%;
  align-items: center;
}

wui-icon[data-parent-size='sm'] {
  width: 18px;
  height: 18px;
}

wui-icon[data-parent-size='md'] {
  width: 24px;
  height: 24px;
}

wui-icon[data-parent-size='lg'] {
  width: 42px;
  height: 42px;
}

wui-icon[data-parent-size='full'] {
  width: 100%;
  height: 100%;
}

:host > wui-icon-box {
  position: absolute;
  overflow: hidden;
  right: -1px;
  bottom: -2px;
  z-index: 1;
  border: 2px solid var(--wui-color-bg-base-150, #1e1f1f);
  padding: 1px;
}
`
      , wui_wallet_image_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let rl = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.size = "md",
          this.name = "",
          this.installed = !1,
          this.badgeSize = "xs"
      }
      render() {
        let J = "xxs";
        return J = "lg" === this.size ? "m" : "md" === this.size ? "xs" : "xxs",
          this.style.cssText = `
     --local-border-radius: var(--wui-border-radius-${J});
     --local-size: var(--wui-wallet-image-size-${this.size});
 `,
          this.walletIcon && (this.dataset.walletIcon = this.walletIcon),
          ef.dy`
    <wui-flex justifyContent="center" alignItems="center"> ${this.templateVisual()} </wui-flex>
  `
      }
      templateVisual() {
        return this.imageSrc ? ef.dy`<wui-image src=${this.imageSrc} alt=${this.name}></wui-image>` : this.walletIcon ? ef.dy`<wui-icon
      data-parent-size="md"
      size="md"
      color="inherit"
      name=${this.walletIcon}
    ></wui-icon>` : ef.dy`<wui-icon
    data-parent-size=${this.size}
    size="inherit"
    color="inherit"
    name="walletPlaceholder"
  ></wui-icon>`
      }
    }
      ;
    rl.styles = [em, ra],
      wui_wallet_image_decorate([(0,
        e_.Cb)()], rl.prototype, "size", void 0),
      wui_wallet_image_decorate([(0,
        e_.Cb)()], rl.prototype, "name", void 0),
      wui_wallet_image_decorate([(0,
        e_.Cb)()], rl.prototype, "imageSrc", void 0),
      wui_wallet_image_decorate([(0,
        e_.Cb)()], rl.prototype, "walletIcon", void 0),
      wui_wallet_image_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], rl.prototype, "installed", void 0),
      wui_wallet_image_decorate([(0,
        e_.Cb)()], rl.prototype, "badgeSize", void 0),
      rl = wui_wallet_image_decorate([customElement("wui-wallet-image")], rl);
    var rc = ef.iv`
:host {
  position: relative;
  border-radius: var(--wui-border-radius-xxs);
  width: 40px;
  height: 40px;
  overflow: hidden;
  background: var(--wui-gray-glass-002);
  display: flex;
  justify-content: center;
  align-items: center;
  flex-wrap: wrap;
  gap: var(--wui-spacing-4xs);
  padding: 3.75px !important;
}

:host::after {
  content: '';
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  border-radius: inherit;
  border: 1px solid var(--wui-gray-glass-010);
  pointer-events: none;
}

:host > wui-wallet-image {
  width: 14px;
  height: 14px;
  border-radius: var(--wui-border-radius-5xs);
}

:host > wui-flex {
  padding: 2px;
  position: fixed;
  overflow: hidden;
  left: 34px;
  bottom: 8px;
  background: var(--dark-background-150, #1e1f1f);
  border-radius: 50%;
  z-index: 2;
  display: flex;
}
`
      , wui_all_wallets_image_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let rd = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.walletImages = []
      }
      render() {
        let J = this.walletImages.length < 4;
        return ef.dy`${this.walletImages.slice(0, 4).map(({ src: J, walletName: et }) => ef.dy`
          <wui-wallet-image
            size="inherit"
            imageSrc=${J}
            name=${(0,
            t1.o)(et)}
          ></wui-wallet-image>
        `)}
    ${J ? [...Array(4 - this.walletImages.length)].map(() => ef.dy` <wui-wallet-image size="inherit" name=""></wui-wallet-image>`) : null}
    <wui-flex>
      <wui-icon-box
        size="xxs"
        iconSize="xxs"
        iconcolor="success-100"
        backgroundcolor="success-100"
        icon="checkmark"
        background="opaque"
      ></wui-icon-box>
    </wui-flex>`
      }
    }
      ;
    rd.styles = [em, rc],
      wui_all_wallets_image_decorate([(0,
        e_.Cb)({
          type: Array
        })], rd.prototype, "walletImages", void 0),
      rd = wui_all_wallets_image_decorate([customElement("wui-all-wallets-image")], rd);
    var rh = ef.iv`
:host {
  width: var(--local-width);
  position: relative;
}

button {
  border: 1px solid var(--wui-gray-glass-010);
  border-radius: var(--wui-border-radius-m);
  width: var(--local-width);
}

button:disabled {
  border: 1px solid var(--wui-gray-glass-010);
}

button[data-size='sm'] {
  padding: var(--wui-spacing-xxs) var(--wui-spacing-s);
}

button[data-size='sm'][data-icon-left='true'] {
  padding: var(--wui-spacing-xxs) var(--wui-spacing-s) var(--wui-spacing-xxs)
    var(--wui-spacing-xs);
}

button[data-size='sm'][data-icon-right='true'] {
  padding: var(--wui-spacing-xxs) var(--wui-spacing-xs) var(--wui-spacing-xxs)
    var(--wui-spacing-s);
}

::slotted(*) {
  transition: opacity 200ms ease-in-out;
  opacity: var(--local-opacity-100);
}

button > wui-text {
  transition: opacity 200ms ease-in-out;
  opacity: var(--local-opacity-100);
}

button[data-size='md'] {
  padding: 8.2px var(--wui-spacing-l) 9px var(--wui-spacing-l);
}

button[data-size='md'][data-icon-left='true'] {
  padding: 8.2px var(--wui-spacing-l) 9px var(--wui-spacing-s);
}

button[data-size='md'][data-icon-right='true'] {
  padding: 8.2px var(--wui-spacing-s) 9px var(--wui-spacing-l);
}

wui-loading-spinner {
  position: absolute;
  left: 50%;
  top: 50%;
  transition: all 200ms ease-in-out;
  transform: translate(-50%, -50%);
  opacity: var(--local-opacity-000);
}
`
      , wui_button_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let rp = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.size = "md",
          this.disabled = !1,
          this.fullWidth = !1,
          this.loading = !1,
          this.variant = "fill",
          this.hasIconLeft = !1,
          this.hasIconRight = !1
      }
      render() {
        this.style.cssText = `
  --local-width: ${this.fullWidth ? "100%" : "auto"};
  --local-opacity-100: ${this.loading ? 0 : 1};
  --local-opacity-000: ${this.loading ? 1 : 0};`;
        let J = "md" === this.size ? "paragraph-600" : "small-600";
        return ef.dy`
    <button
      data-variant=${this.variant}
      data-icon-left=${this.hasIconLeft}
      data-icon-right=${this.hasIconRight}
      data-size=${this.size}
      ?disabled=${this.disabled || this.loading}
      ontouchstart
    >
      ${this.loadingTemplate()}
      <slot name="iconLeft" @slotchange=${() => this.handleSlotLeftChange()}></slot>
      <wui-text variant=${J} color="inherit">
        <slot></slot>
      </wui-text>
      <slot name="iconRight" @slotchange=${() => this.handleSlotRightChange()}></slot>
    </button>
  `
      }
      handleSlotLeftChange() {
        this.hasIconLeft = !0
      }
      handleSlotRightChange() {
        this.hasIconRight = !0
      }
      loadingTemplate() {
        return this.loading ? ef.dy`<wui-loading-spinner color="fg-300"></wui-loading-spinner>` : ef.dy``
      }
    }
      ;
    rp.styles = [em, eg, rh],
      wui_button_decorate([(0,
        e_.Cb)()], rp.prototype, "size", void 0),
      wui_button_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], rp.prototype, "disabled", void 0),
      wui_button_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], rp.prototype, "fullWidth", void 0),
      wui_button_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], rp.prototype, "loading", void 0),
      wui_button_decorate([(0,
        e_.Cb)()], rp.prototype, "variant", void 0),
      wui_button_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], rp.prototype, "hasIconLeft", void 0),
      wui_button_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], rp.prototype, "hasIconRight", void 0),
      rp = wui_button_decorate([customElement("wui-button")], rp);
    let rm = ef.YP`<svg  viewBox="0 0 48 54" fill="none">
<path
  d="M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z"
/>
</svg>`;
    var rg = ef.iv`
:host {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 76px;
  row-gap: var(--wui-spacing-xs);
  padding: var(--wui-spacing-xs) 10px;
  background-color: var(--wui-gray-glass-002);
  border-radius: clamp(0px, var(--wui-border-radius-xs), 20px);
  position: relative;
}

wui-shimmer[data-type='network'] {
  border: none;
  -webkit-clip-path: var(--wui-path-network);
  clip-path: var(--wui-path-network);
}

svg {
  position: absolute;
  width: 48px;
  height: 54px;
  z-index: 1;
}

svg > path {
  stroke: var(--wui-gray-glass-010);
  stroke-width: 1px;
}
`
      , wui_card_select_loader_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let ry = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.type = "wallet"
      }
      render() {
        return ef.dy`
    ${this.shimmerTemplate()}
    <wui-shimmer width="56px" height="20px" borderRadius="xs"></wui-shimmer>
  `
      }
      shimmerTemplate() {
        return "network" === this.type ? ef.dy` <wui-shimmer
        data-type=${this.type}
        width="48px"
        height="54px"
        borderRadius="xs"
      ></wui-shimmer>
      ${rm}` : ef.dy`<wui-shimmer width="56px" height="56px" borderRadius="xs"></wui-shimmer>`
      }
    }
      ;
    ry.styles = [em, eg, rg],
      wui_card_select_loader_decorate([(0,
        e_.Cb)()], ry.prototype, "type", void 0),
      ry = wui_card_select_loader_decorate([customElement("wui-card-select-loader")], ry);
    let rb = ef.YP`<svg width="86" height="96" fill="none">
<path
  d="M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z"
/>
</svg>`;
    var rw = ef.iv`
:host {
  position: relative;
  border-radius: inherit;
  display: flex;
  justify-content: center;
  align-items: center;
  width: var(--local-width);
  height: var(--local-height);
}

svg {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 1;
  fill: var(--wui-gray-glass-002);
}

svg > path {
  stroke: var(--local-stroke);
  transition: stroke var(--wui-ease-out-power-1) var(--wui-duration-lg);
}

wui-image {
  width: 100%;
  height: 100%;
  -webkit-clip-path: var(--local-path);
  clip-path: var(--local-path);
  background: var(--wui-gray-glass-002);
}

wui-icon {
  transform: translateY(-5%);
  width: var(--local-icon-size);
  height: var(--local-icon-size);
}
`
      , wui_network_image_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let r_ = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.size = "md",
          this.name = "uknown",
          this.selected = !1
      }
      render() {
        let J = "lg" === this.size;
        return this.style.cssText = `
    --local-stroke: ${this.selected ? "var(--wui-color-accent-100)" : "var(--wui-gray-glass-010)"};
    --local-path: ${J ? "var(--wui-path-network-lg)" : "var(--wui-path-network)"};
    --local-width: ${J ? "86px" : "48px"};
    --local-height: ${J ? "96px" : "54px"};
    --local-icon-size: ${J ? "42px" : "24px"};
  `,
          ef.dy`${this.templateVisual()} ${J ? rb : rm}`
      }
      templateVisual() {
        return this.imageSrc ? ef.dy`<wui-image src=${this.imageSrc} alt=${this.name}></wui-image>` : ef.dy`<wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></wui-icon>`
      }
    }
      ;
    r_.styles = [em, rw],
      wui_network_image_decorate([(0,
        e_.Cb)()], r_.prototype, "size", void 0),
      wui_network_image_decorate([(0,
        e_.Cb)()], r_.prototype, "name", void 0),
      wui_network_image_decorate([(0,
        e_.Cb)()], r_.prototype, "imageSrc", void 0),
      wui_network_image_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], r_.prototype, "selected", void 0),
      r_ = wui_network_image_decorate([customElement("wui-network-image")], r_);
    var rx = ef.iv`
button {
  flex-direction: column;
  width: 76px;
  row-gap: var(--wui-spacing-xs);
  padding: var(--wui-spacing-xs) var(--wui-spacing-0);
  background-color: var(--wui-gray-glass-002);
  border-radius: clamp(0px, var(--wui-border-radius-xs), 20px);
}

button > wui-text {
  color: var(--wui-color-fg-100);
  max-width: var(--wui-icon-box-size-xl);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  justify-content: center;
}

button:disabled > wui-text {
  color: var(--wui-gray-glass-015);
}

[data-selected='true'] {
  background-color: var(--wui-accent-glass-020);
}

@media (hover: hover) and (pointer: fine) {
  [data-selected='true']:hover:enabled {
    background-color: var(--wui-accent-glass-015);
  }
}

[data-selected='true']:active:enabled {
  background-color: var(--wui-accent-glass-010);
}
`
      , wui_card_select_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let rE = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.name = "Unknown",
          this.type = "wallet",
          this.imageSrc = void 0,
          this.disabled = !1,
          this.selected = !1,
          this.installed = !1
      }
      render() {
        return ef.dy`
    <button data-selected=${(0,
            t1.o)(this.selected)} ?disabled=${this.disabled} ontouchstart>
      ${this.imageTemplate()}
      <wui-text variant="tiny-500" color=${this.selected ? "accent-100" : "inherit"}>
        ${this.name}
      </wui-text>
    </button>
  `
      }
      imageTemplate() {
        return "network" === this.type ? ef.dy`
      <wui-network-image
        .selected=${this.selected}
        imageSrc=${(0,
            t1.o)(this.imageSrc)}
        name=${this.name}
      >
      </wui-network-image>
    ` : ef.dy`
    <wui-wallet-image
      size="md"
      imageSrc=${(0,
            t1.o)(this.imageSrc)}
      name=${this.name}
      .installed=${this.installed}
      badgeSize="sm"
    >
    </wui-wallet-image>
  `
      }
    }
      ;
    rE.styles = [em, eg, rx],
      wui_card_select_decorate([(0,
        e_.Cb)()], rE.prototype, "name", void 0),
      wui_card_select_decorate([(0,
        e_.Cb)()], rE.prototype, "type", void 0),
      wui_card_select_decorate([(0,
        e_.Cb)()], rE.prototype, "imageSrc", void 0),
      wui_card_select_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], rE.prototype, "disabled", void 0),
      wui_card_select_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], rE.prototype, "selected", void 0),
      wui_card_select_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], rE.prototype, "installed", void 0),
      rE = wui_card_select_decorate([customElement("wui-card-select")], rE);
    var rC = ef.iv`
a {
  border: 1px solid var(--wui-gray-glass-010);
  border-radius: var(--wui-border-radius-3xl);
}

wui-image {
  border-radius: var(--wui-border-radius-3xl);
  overflow: hidden;
}

a.disabled > wui-icon,
a.disabled > wui-image {
  filter: grayscale(1);
}

a[data-variant='fill'] {
  color: var(--wui-color-inverse-100);
  background-color: var(--wui-color-accent-100);
}

a[data-variant='shade'],
a[data-variant='shadeSmall'] {
  background-color: transparent;
  background-color: var(--wui-gray-glass-010);
  color: var(--wui-color-fg-200);
}

a[data-variant='success'] {
  column-gap: var(--wui-spacing-xxs);
  border: 1px solid var(--wui-success-glass-010);
  background-color: var(--wui-success-glass-010);
  color: var(--wui-color-success-100);
}

a[data-variant='transparent'] {
  column-gap: var(--wui-spacing-xxs);
  background-color: transparent;
  color: var(--wui-color-fg-150);
}

a[data-variant='transparent'],
a[data-variant='success'],
a[data-variant='shadeSmall'] {
  padding: 7px var(--wui-spacing-s) 7px 10px;
}

a[data-variant='transparent']:has(wui-text:first-child),
a[data-variant='success']:has(wui-text:first-child),
a[data-variant='shadeSmall']:has(wui-text:first-child) {
  padding: 7px var(--wui-spacing-s);
}

a[data-variant='fill'],
a[data-variant='shade'] {
  column-gap: var(--wui-spacing-xs);
  padding: var(--wui-spacing-xxs) var(--wui-spacing-m) var(--wui-spacing-xxs)
    var(--wui-spacing-xs);
}

a[data-variant='fill']:has(wui-text:first-child),
a[data-variant='shade']:has(wui-text:first-child) {
  padding: 9px var(--wui-spacing-m) 9px var(--wui-spacing-m);
}

a[data-variant='fill'] > wui-image,
a[data-variant='shade'] > wui-image {
  width: 24px;
  height: 24px;
}

a[data-variant='fill'] > wui-image {
  box-shadow: inset 0 0 0 1px var(--wui-color-accent-090);
}

a[data-variant='shade'] > wui-image,
a[data-variant='shadeSmall'] > wui-image {
  box-shadow: inset 0 0 0 1px var(--wui-gray-glass-010);
}

a[data-variant='fill'] > wui-icon,
a[data-variant='shade'] > wui-icon {
  width: 14px;
  height: 14px;
}

a[data-variant='transparent'] > wui-image,
a[data-variant='success'] > wui-image,
a[data-variant='shadeSmall'] > wui-image {
  width: 14px;
  height: 14px;
}

a[data-variant='transparent'] > wui-icon,
a[data-variant='success'] > wui-icon,
a[data-variant='shadeSmall'] > wui-icon {
  width: 12px;
  height: 12px;
}

a[data-variant='fill']:focus-visible {
  background-color: var(--wui-color-accent-090);
}

a[data-variant='shade']:focus-visible,
a[data-variant='shadeSmall']:focus-visible {
  background-color: var(--wui-gray-glass-015);
}

a[data-variant='transparent']:focus-visible {
  background-color: var(--wui-gray-glass-005);
}

a[data-variant='success']:focus-visible {
  background-color: var(--wui-success-glass-015);
}

a.disabled {
  color: var(--wui-gray-glass-015);
  background-color: var(--wui-gray-glass-015);
  pointer-events: none;
}

@media (hover: hover) and (pointer: fine) {
  a[data-variant='fill']:hover {
    background-color: var(--wui-color-accent-090);
  }

  a[data-variant='shade']:hover,
  a[data-variant='shadeSmall']:hover {
    background-color: var(--wui-gray-glass-015);
  }

  a[data-variant='transparent']:hover {
    background-color: var(--wui-gray-glass-005);
  }

  a[data-variant='success']:hover {
    background-color: var(--wui-success-glass-015);
  }
}

a[data-variant='fill']:active {
  background-color: var(--wui-color-accent-080);
}

a[data-variant='shade']:active,
a[data-variant='shadeSmall']:active {
  background-color: var(--wui-gray-glass-020);
}

a[data-variant='transparent']:active {
  background-color: var(--wui-gray-glass-010);
}

a[data-variant='success']:active {
  background-color: var(--wui-success-glass-020);
}
`
      , wui_chip_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let rS = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.variant = "fill",
          this.imageSrc = void 0,
          this.disabled = !1,
          this.icon = "externalLink",
          this.href = "",
          this.text = void 0
      }
      render() {
        let J = "success" === this.variant || "transparent" === this.variant || "shadeSmall" === this.variant;
        return ef.dy`
    <a
      rel="noreferrer"
      target="_blank"
      href=${this.href}
      class=${this.disabled ? "disabled" : ""}
      data-variant=${this.variant}
    >
      ${this.imageTemplate()}
      <wui-text variant=${J ? "small-600" : "paragraph-600"} color="inherit">
        ${this.title ? this.title : t2.getHostName(this.href)}
      </wui-text>
      <wui-icon name=${this.icon} color="inherit" size="inherit"></wui-icon>
    </a>
  `
      }
      imageTemplate() {
        return this.imageSrc ? ef.dy`<wui-image src=${this.imageSrc}></wui-image>` : null
      }
    }
      ;
    rS.styles = [em, eg, rC],
      wui_chip_decorate([(0,
        e_.Cb)()], rS.prototype, "variant", void 0),
      wui_chip_decorate([(0,
        e_.Cb)()], rS.prototype, "imageSrc", void 0),
      wui_chip_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], rS.prototype, "disabled", void 0),
      wui_chip_decorate([(0,
        e_.Cb)()], rS.prototype, "icon", void 0),
      wui_chip_decorate([(0,
        e_.Cb)()], rS.prototype, "href", void 0),
      wui_chip_decorate([(0,
        e_.Cb)()], rS.prototype, "text", void 0),
      rS = wui_chip_decorate([customElement("wui-chip")], rS);
    var rk = ef.iv`
:host {
  position: relative;
  display: block;
}

button {
  background: var(--wui-color-accent-100);
  border: 1px solid var(--wui-gray-glass-010);
  border-radius: var(--wui-border-radius-m);
  gap: var(--wui-spacing-xs);
}

button.loading {
  background: var(--wui-gray-glass-010);
  border: 1px solid var(--wui-gray-glass-010);
  pointer-events: none;
}

button:disabled {
  background-color: var(--wui-gray-glass-015);
  border: 1px solid var(--wui-gray-glass-010);
}

button:disabled > wui-text {
  color: var(--wui-gray-glass-015);
}

@media (hover: hover) and (pointer: fine) {
  button:hover:enabled {
    background-color: var(--wui-color-accent-090);
  }

  button:active:enabled {
    background-color: var(--wui-color-accent-080);
  }
}

button:focus-visible {
  border: 1px solid var(--wui-gray-glass-010);
  background-color: var(--wui-color-accent-090);
  -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
}

button[data-size='sm'] {
  padding: 6.75px 10px 7.25px;
}

::slotted(*) {
  transition: opacity 200ms ease-in-out;
  opacity: var(--local-opacity-100);
}

button > wui-text {
  transition: opacity 200ms ease-in-out;
  opacity: var(--local-opacity-100);
  color: var(--wui-color-inverse-100);
}

button[data-size='md'] {
  padding: 9px var(--wui-spacing-l) 9px var(--wui-spacing-l);
}

button[data-size='md'] + wui-text {
  padding-left: var(--wui-spacing-3xs);
}

@media (max-width: 500px) {
  button[data-size='md'] {
    height: 32px;
    padding: 5px 12px;
  }

  button[data-size='md'] > wui-text > slot {
    font-size: 14px !important;
  }
}

wui-loading-spinner {
  width: 14px;
  height: 14px;
}

wui-loading-spinner::slotted(svg) {
  width: 10px !important;
  height: 10px !important;
}

button[data-size='sm'] > wui-loading-spinner {
  width: 12px;
  height: 12px;
}
`
      , wui_connect_button_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let rT = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.size = "md",
          this.loading = !1
      }
      render() {
        let J = "md" === this.size ? "paragraph-600" : "small-600";
        return ef.dy`
    <button data-size=${this.size} ?disabled=${this.loading} ontouchstart>
      ${this.loadingTemplate()}
      <wui-text variant=${J} color=${this.loading ? "accent-100" : "inherit"}>
        <slot></slot>
      </wui-text>
    </button>
  `
      }
      loadingTemplate() {
        return this.loading ? ef.dy`<wui-loading-spinner size=${this.size} color="accent-100"></wui-loading-spinner>` : null
      }
    }
      ;
    rT.styles = [em, eg, rk],
      wui_connect_button_decorate([(0,
        e_.Cb)()], rT.prototype, "size", void 0),
      wui_connect_button_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], rT.prototype, "loading", void 0),
      rT = wui_connect_button_decorate([customElement("wui-connect-button")], rT);
    var rA = ef.iv`
wui-flex {
  width: 100%;
  background-color: var(--wui-gray-glass-002);
  border-radius: var(--wui-border-radius-xs);
}
`
      , wui_cta_button_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let rP = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.disabled = !1,
          this.label = "",
          this.buttonLabel = ""
      }
      render() {
        return ef.dy`
    <wui-flex
      justifyContent="space-between"
      alignItems="center"
      .padding=${["1xs", "2l", "1xs", "2l"]}
    >
      <wui-text variant="paragraph-500" color="fg-200">${this.label}</wui-text>
      <wui-button size="sm" variant="accent">
        ${this.buttonLabel}
        <wui-icon size="xs" color="inherit" slot="iconRight" name="chevronRight"></wui-icon>
      </wui-button>
    </wui-flex>
  `
      }
    }
      ;
    rP.styles = [em, eg, rA],
      wui_cta_button_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], rP.prototype, "disabled", void 0),
      wui_cta_button_decorate([(0,
        e_.Cb)()], rP.prototype, "label", void 0),
      wui_cta_button_decorate([(0,
        e_.Cb)()], rP.prototype, "buttonLabel", void 0),
      rP = wui_cta_button_decorate([customElement("wui-cta-button")], rP);
    var rR = eo(69178)
      , rI = ef.iv`
:host {
  position: relative;
  width: 100%;
  display: inline-block;
  color: var(--wui-color-fg-275);
}

input {
  width: 100%;
  border-radius: var(--wui-border-radius-xs);
  border: 1px solid var(--wui-gray-glass-005);
  background: var(--wui-gray-glass-005);
  font-size: var(--wui-font-size-paragraph);
  font-weight: var(--wui-font-weight-light);
  letter-spacing: var(--wui-letter-spacing-paragraph);
  color: var(--wui-color-fg-100);
  transition: all var(--wui-ease-inout-power-1) var(--wui-duration-lg);
  caret-color: var(--wui-color-accent-100);
}

input:disabled {
  cursor: not-allowed;
  border: 1px solid var(--wui-gray-glass-010);
}

input:disabled::placeholder,
input:disabled + wui-icon {
  color: var(--wui-color-fg-300);
}

input::placeholder {
  color: var(--wui-color-fg-275);
}

input:focus:enabled {
  transition: all var(--wui-ease-out-power-2) var(--wui-duration-sm);
  background-color: var(--wui-gray-glass-010);
  border: 1px solid var(--wui-color-accent-100);
  -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
}

input:hover:enabled {
  background-color: var(--wui-gray-glass-010);
}

wui-icon {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  pointer-events: none;
}

.wui-size-sm {
  padding: 9px var(--wui-spacing-m) 10px var(--wui-spacing-s);
}

wui-icon + .wui-size-sm {
  padding: 9px var(--wui-spacing-m) 10px 36px;
}

wui-icon[data-input='sm'] {
  left: var(--wui-spacing-s);
}

.wui-size-md {
  padding: 15px var(--wui-spacing-m) var(--wui-spacing-l) var(--wui-spacing-m);
}

wui-icon + .wui-size-md,
wui-loading-spinner + .wui-size-md {
  padding: 10.5px var(--wui-spacing-3xl) 10.5px 40px;
}

wui-icon[data-input='md'] {
  left: var(--wui-spacing-l);
}

input:placeholder-shown ~ ::slotted(wui-input-element),
input:placeholder-shown ~ ::slotted(wui-icon) {
  opacity: 0;
  pointer-events: none;
}

::slotted(wui-input-element),
::slotted(wui-icon) {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  transition: all var(--wui-ease-in-power-2) var(--wui-duration-md);
}

::slotted(wui-input-element) {
  right: var(--wui-spacing-m);
}

::slotted(wui-icon) {
  right: 0px;
}
`
      , wui_input_text_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let rO = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.inputElementRef = (0,
            rR.V)(),
          this.size = "md",
          this.disabled = !1,
          this.placeholder = "",
          this.type = "text"
      }
      render() {
        let J = `wui-size-${this.size}`;
        return ef.dy` ${this.templateIcon()}
    <input
      ${(0,
            rR.i)(this.inputElementRef)}
      class=${J}
      type=${this.type}
      enterkeyhint=${(0,
            t1.o)(this.enterKeyHint)}
      ?disabled=${this.disabled}
      placeholder=${this.placeholder}
      @input=${this.dispatchInputChangeEvent.bind(this)}
      value=${(0,
            t1.o)(this.value)}
    />
    <slot></slot>`
      }
      templateIcon() {
        return this.icon ? ef.dy`<wui-icon
      data-input=${this.size}
      size="sm"
      color="inherit"
      name=${this.icon}
    ></wui-icon>` : null
      }
      dispatchInputChangeEvent() {
        this.dispatchEvent(new CustomEvent("inputChange", {
          detail: this.inputElementRef.value?.value,
          bubbles: !0,
          composed: !0
        }))
      }
    }
      ;
    rO.styles = [em, eg, rI],
      wui_input_text_decorate([(0,
        e_.Cb)()], rO.prototype, "size", void 0),
      wui_input_text_decorate([(0,
        e_.Cb)()], rO.prototype, "icon", void 0),
      wui_input_text_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], rO.prototype, "disabled", void 0),
      wui_input_text_decorate([(0,
        e_.Cb)()], rO.prototype, "placeholder", void 0),
      wui_input_text_decorate([(0,
        e_.Cb)()], rO.prototype, "type", void 0),
      wui_input_text_decorate([(0,
        e_.Cb)()], rO.prototype, "keyHint", void 0),
      wui_input_text_decorate([(0,
        e_.Cb)()], rO.prototype, "value", void 0),
      rO = wui_input_text_decorate([customElement("wui-input-text")], rO);
    var rN = ef.iv`
:host {
  position: relative;
  display: inline-block;
}

wui-text {
  margin: var(--wui-spacing-xxs) var(--wui-spacing-m) var(--wui-spacing-0) var(--wui-spacing-m);
}
`
      , wui_email_input_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let rM = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.disabled = !1
      }
      render() {
        return ef.dy`
    <wui-input-text
      placeholder="Email"
      icon="mail"
      size="md"
      .disabled=${this.disabled}
      .value=${this.value}
      data-testid="wui-email-input"
    ></wui-input-text>
    ${this.templateError()}
  `
      }
      templateError() {
        return this.errorMessage ? ef.dy`<wui-text variant="tiny-500" color="error-100">${this.errorMessage}</wui-text>` : null
      }
    }
      ;
    rM.styles = [em, rN],
      wui_email_input_decorate([(0,
        e_.Cb)()], rM.prototype, "errorMessage", void 0),
      wui_email_input_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], rM.prototype, "disabled", void 0),
      wui_email_input_decorate([(0,
        e_.Cb)()], rM.prototype, "value", void 0),
      rM = wui_email_input_decorate([customElement("wui-email-input")], rM);
    var rD = ef.iv`
button {
  border-radius: var(--wui-border-radius-xxs);
  color: var(--wui-color-fg-100);
  padding: var(--wui-spacing-2xs);
}

@media (max-width: 700px) {
  button {
    padding: var(--wui-spacing-s);
  }
}

button > wui-icon {
  pointer-events: none;
}

button:disabled > wui-icon {
  color: var(--wui-color-bg-300) !important;
}

button:disabled {
  background-color: transparent;
}
`
      , wui_icon_link_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let rj = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.size = "md",
          this.disabled = !1,
          this.icon = "copy",
          this.iconColor = "inherit"
      }
      render() {
        return ef.dy`
    <button ?disabled=${this.disabled} ontouchstart>
      <wui-icon color=${this.iconColor} size=${this.size} name=${this.icon}></wui-icon>
    </button>
  `
      }
    }
      ;
    rj.styles = [em, eg, ey, rD],
      wui_icon_link_decorate([(0,
        e_.Cb)()], rj.prototype, "size", void 0),
      wui_icon_link_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], rj.prototype, "disabled", void 0),
      wui_icon_link_decorate([(0,
        e_.Cb)()], rj.prototype, "icon", void 0),
      wui_icon_link_decorate([(0,
        e_.Cb)()], rj.prototype, "iconColor", void 0),
      rj = wui_icon_link_decorate([customElement("wui-icon-link")], rj);
    var rL = ef.iv`
button {
  background-color: var(--wui-color-fg-300);
  border-radius: var(--wui-border-radius-4xs);
  width: 16px;
  height: 16px;
}

button:disabled {
  background-color: var(--wui-color-bg-300);
}

wui-icon {
  color: var(--wui-color-bg-200) !important;
}

button:focus-visible {
  background-color: var(--wui-color-fg-250);
  border: 1px solid var(--wui-color-accent-100);
}

button:active:enabled {
  background-color: var(--wui-color-fg-225);
}

@media (hover: hover) and (pointer: fine) {
  button:hover:enabled {
    background-color: var(--wui-color-fg-250);
  }
}
`
      , wui_input_element_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let r$ = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.icon = "copy"
      }
      render() {
        return ef.dy`
    <button>
      <wui-icon color="inherit" size="xxs" name=${this.icon}></wui-icon>
    </button>
  `
      }
    }
      ;
    r$.styles = [em, eg, rL],
      wui_input_element_decorate([(0,
        e_.Cb)()], r$.prototype, "icon", void 0),
      r$ = wui_input_element_decorate([customElement("wui-input-element")], r$);
    var rB = ef.iv`
:host {
  position: relative;
  display: inline-block;
}

input {
  width: 50px;
  height: 50px;
  background: var(--wui-gray-glass-010);
  border-radius: var(--wui-border-radius-xs);
  border: 1px solid var(--wui-gray-glass-005);
  font-family: var(--wui-font-family);
  font-size: var(--wui-font-size-large);
  font-weight: var(--wui-font-weight-regular);
  letter-spacing: var(--wui-letter-spacing-large);
  text-align: center;
  color: var(--wui-color-fg-100);
  caret-color: var(--wui-color-accent-100);
  transition: all var(--wui-ease-inout-power-1) var(--wui-duration-lg);
  box-sizing: border-box;
  -webkit-appearance: none;
  -moz-appearance: textfield;
  padding: 0px;
}

input::-webkit-outer-spin-button,
input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

input[type='number'] {
  -moz-appearance: textfield;
}

input:disabled {
  cursor: not-allowed;
  border: 1px solid var(--wui-gray-glass-010);
  background: var(--wui-gray-glass-005);
}

input:focus:enabled {
  transition: all var(--wui-ease-out-power-2) var(--wui-duration-sm);
  background-color: var(--wui-gray-glass-015);
  border: 1px solid var(--wui-color-accent-100);
  -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
}
@media (hover: hover) and (pointer: fine) {
  input:hover:enabled {
    background-color: var(--wui-gray-glass-015);
  }
}
`
      , wui_input_numeric_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let rF = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.disabled = !1,
          this.value = ""
      }
      render() {
        return ef.dy`<input
    type="number"
    maxlength="1"
    inputmode="numeric"
    autofocus
    ?disabled=${this.disabled}
    value=${this.value}
  /> `
      }
    }
      ;
    rF.styles = [em, eg, rB],
      wui_input_numeric_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], rF.prototype, "disabled", void 0),
      wui_input_numeric_decorate([(0,
        e_.Cb)({
          type: String
        })], rF.prototype, "value", void 0),
      rF = wui_input_numeric_decorate([customElement("wui-input-numeric")], rF);
    var rU = ef.iv`
button {
  padding: var(--wui-spacing-4xs) var(--wui-spacing-xxs);
  border-radius: var(--wui-border-radius-3xs);
  background-color: transparent;
  color: var(--wui-color-accent-100);
}

button:disabled {
  background-color: transparent;
  color: var(--wui-gray-glass-015);
}
`
      , wui_link_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let rz = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.disabled = !1,
          this.color = "inherit"
      }
      render() {
        return ef.dy`
    <button ?disabled=${this.disabled} ontouchstart>
      <slot name="iconLeft"></slot>
      <wui-text variant="small-600" color=${this.color}>
        <slot></slot>
      </wui-text>
      <slot name="iconRight"></slot>
    </button>
  `
      }
    }
      ;
    rz.styles = [em, eg, rU],
      wui_link_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], rz.prototype, "disabled", void 0),
      wui_link_decorate([(0,
        e_.Cb)()], rz.prototype, "color", void 0),
      rz = wui_link_decorate([customElement("wui-link")], rz);
    var rH = ef.iv`
button {
  column-gap: var(--wui-spacing-s);
  padding: 11px 18px 11px var(--wui-spacing-s);
  width: 100%;
  background-color: var(--wui-gray-glass-002);
  border-radius: var(--wui-border-radius-xs);
  color: var(--wui-color-fg-250);
}

button[data-iconvariant='square'],
button[data-iconvariant='square-blue'] {
  padding: 6px 18px 6px 9px;
}

button > wui-flex {
  flex: 1;
}

button > wui-image {
  width: 32px;
  height: 32px;
  box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
  border-radius: var(--wui-border-radius-3xl);
}

button > wui-icon {
  width: 36px;
  height: 36px;
}

button > wui-icon-box[data-variant='blue'] {
  box-shadow: 0 0 0 2px var(--wui-accent-glass-005);
}

button > wui-icon-box[data-variant='overlay'] {
  box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
}

button > wui-icon-box[data-variant='square-blue'] {
  border-radius: var(--wui-border-radius-3xs);
  position: relative;
  border: none;
  width: 36px;
  height: 36px;
}

button > wui-icon-box[data-variant='square-blue']::after {
  content: '';
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  border-radius: inherit;
  border: 1px solid var(--wui-accent-glass-010);
  pointer-events: none;
}

button > wui-icon:last-child {
  width: 14px;
  height: 14px;
}

button:disabled {
  background-color: var(--wui-gray-glass-015);
  color: var(--wui-gray-glass-015);
}

button[data-loading='true'] > wui-icon {
  transition: opacity 200ms ease-in-out;
  opacity: 0;
}

wui-loading-spinner {
  position: absolute;
  right: 18px;
  top: 50%;
  transform: translateY(-50%);
}
`
      , wui_list_item_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let rV = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.variant = "icon",
          this.disabled = !1,
          this.imageSrc = void 0,
          this.alt = void 0,
          this.chevron = !1,
          this.loading = !1
      }
      render() {
        return ef.dy`
    <button
      ?disabled=${!!this.loading || !!this.disabled}
      data-loading=${this.loading}
      data-iconvariant=${(0,
            t1.o)(this.iconVariant)}
      ontouchstart
    >
      ${this.loadingTemplate()} ${this.visualTemplate()}
      <wui-flex gap="3xs">
        <slot></slot>
      </wui-flex>
      ${this.chevronTemplate()}
    </button>
  `
      }
      visualTemplate() {
        if ("image" === this.variant && this.imageSrc)
          return ef.dy`<wui-image src=${this.imageSrc} alt=${this.alt ?? "list item"}></wui-image>`;
        if ("square" === this.iconVariant && this.icon && "icon" === this.variant)
          return ef.dy`<wui-icon name=${this.icon}></wui-icon>`;
        if ("icon" === this.variant && this.icon && this.iconVariant) {
          let J = ["blue", "square-blue"].includes(this.iconVariant) ? "accent-100" : "fg-200"
            , et = "square-blue" === this.iconVariant ? "mdl" : "md"
            , eo = this.iconSize ? this.iconSize : et;
          return ef.dy`
      <wui-icon-box
        data-variant=${this.iconVariant}
        icon=${this.icon}
        iconSize=${eo}
        background="transparent"
        iconColor=${J}
        backgroundColor=${J}
        size=${et}
      ></wui-icon-box>
    `
        }
        return null
      }
      loadingTemplate() {
        return this.loading ? ef.dy`<wui-loading-spinner color="fg-300"></wui-loading-spinner>` : ef.dy``
      }
      chevronTemplate() {
        return this.chevron ? ef.dy`<wui-icon size="inherit" color="fg-200" name="chevronRight"></wui-icon>` : null
      }
    }
      ;
    rV.styles = [em, eg, rH],
      wui_list_item_decorate([(0,
        e_.Cb)()], rV.prototype, "icon", void 0),
      wui_list_item_decorate([(0,
        e_.Cb)()], rV.prototype, "iconSize", void 0),
      wui_list_item_decorate([(0,
        e_.Cb)()], rV.prototype, "variant", void 0),
      wui_list_item_decorate([(0,
        e_.Cb)()], rV.prototype, "iconVariant", void 0),
      wui_list_item_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], rV.prototype, "disabled", void 0),
      wui_list_item_decorate([(0,
        e_.Cb)()], rV.prototype, "imageSrc", void 0),
      wui_list_item_decorate([(0,
        e_.Cb)()], rV.prototype, "alt", void 0),
      wui_list_item_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], rV.prototype, "chevron", void 0),
      wui_list_item_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], rV.prototype, "loading", void 0),
      rV = wui_list_item_decorate([customElement("wui-list-item")], rV),
      (eh = ep || (ep = {})).approve = "approved",
      eh.bought = "bought",
      eh.borrow = "borrowed",
      eh.burn = "burnt",
      eh.cancel = "canceled",
      eh.claim = "claimed",
      eh.deploy = "deployed",
      eh.deposit = "deposited",
      eh.execute = "executed",
      eh.mint = "minted",
      eh.receive = "received",
      eh.repay = "repaid",
      eh.send = "sent",
      eh.sell = "sold",
      eh.stake = "staked",
      eh.trade = "swapped",
      eh.unstake = "unstaked",
      eh.withdraw = "withdrawn";
    var rW = ef.iv`
:host > wui-flex {
  display: flex;
  justify-content: center;
  align-items: center;
  position: relative;
  width: 40px;
  height: 40px;
  box-shadow: inset 0 0 0 1px var(--wui-gray-glass-005);
  background-color: var(--wui-gray-glass-005);
}

:host > wui-flex wui-image {
  display: block;
}

:host > wui-flex,
:host > wui-flex wui-image,
.swap-images-container,
.swap-images-container.nft,
wui-image.nft {
  border-top-left-radius: var(--local-left-border-radius);
  border-top-right-radius: var(--local-right-border-radius);
  border-bottom-left-radius: var(--local-left-border-radius);
  border-bottom-right-radius: var(--local-right-border-radius);
}

wui-icon {
  width: 20px;
  height: 20px;
}

wui-icon-box {
  position: absolute;
  right: 0;
  bottom: 0;
  transform: translate(20%, 20%);
}

.swap-images-container {
  position: relative;
  width: 40px;
  height: 40px;
  overflow: hidden;
}

.swap-images-container wui-image:first-child {
  position: absolute;
  width: 40px;
  height: 40px;
  top: 0;
  left: 0%;
  clip-path: inset(0px calc(50% + 2px) 0px 0%);
}

.swap-images-container wui-image:last-child {
  clip-path: inset(0px 0px 0px calc(50% + 2px));
}
`
      , wui_transaction_visual_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let rq = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.images = [],
          this.secondImage = {
            type: void 0,
            url: ""
          }
      }
      render() {
        let [J, et] = this.images
          , eo = J?.type === "NFT"
          , el = et?.url ? "NFT" === et.type : eo;
        return this.style.cssText = `
  --local-left-border-radius: ${eo ? "var(--wui-border-radius-xxs)" : "var(--wui-border-radius-s)"};
  --local-right-border-radius: ${el ? "var(--wui-border-radius-xxs)" : "var(--wui-border-radius-s)"};
  `,
          ef.dy`<wui-flex> ${this.templateVisual()} ${this.templateIcon()} </wui-flex>`
      }
      templateVisual() {
        let [J, et] = this.images
          , eo = J?.type
          , el = 2 === this.images.length;
        return el && (J?.url || et?.url) ? ef.dy`<div class="swap-images-container">
      ${J?.url ? ef.dy`<wui-image src=${J.url} alt="Transaction image"></wui-image>` : null}
      ${et?.url ? ef.dy`<wui-image src=${et.url} alt="Transaction image"></wui-image>` : null}
    </div>` : J?.url ? ef.dy`<wui-image src=${J.url} alt="Transaction image"></wui-image>` : "NFT" === eo ? ef.dy`<wui-icon size="inherit" color="fg-200" name="nftPlaceholder"></wui-icon>` : ef.dy`<wui-icon size="inherit" color="fg-200" name="coinPlaceholder"></wui-icon>`
      }
      templateIcon() {
        let J, et = "accent-100";
        return (J = this.getIcon(),
          this.status && (et = this.getStatusColor()),
          J) ? ef.dy`
    <wui-icon-box
      size="xxs"
      iconColor=${et}
      backgroundColor=${et}
      background="opaque"
      icon=${J}
      ?border=${!0}
      borderColor="wui-color-bg-125"
    ></wui-icon-box>
  ` : null
      }
      getDirectionIcon() {
        switch (this.direction) {
          case "in":
            return "arrowBottom";
          case "out":
            return "arrowTop";
          default:
            return
        }
      }
      getIcon() {
        return this.onlyDirectionIcon ? this.getDirectionIcon() : "trade" === this.type ? "swapHorizontalBold" : "approve" === this.type ? "checkmark" : "cancel" === this.type ? "close" : this.getDirectionIcon()
      }
      getStatusColor() {
        switch (this.status) {
          case "confirmed":
            return "success-100";
          case "failed":
            return "error-100";
          case "pending":
            return "inverse-100";
          default:
            return "accent-100"
        }
      }
    }
      ;
    rq.styles = [rW],
      wui_transaction_visual_decorate([(0,
        e_.Cb)()], rq.prototype, "type", void 0),
      wui_transaction_visual_decorate([(0,
        e_.Cb)()], rq.prototype, "status", void 0),
      wui_transaction_visual_decorate([(0,
        e_.Cb)()], rq.prototype, "direction", void 0),
      wui_transaction_visual_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], rq.prototype, "onlyDirectionIcon", void 0),
      wui_transaction_visual_decorate([(0,
        e_.Cb)({
          type: Array
        })], rq.prototype, "images", void 0),
      wui_transaction_visual_decorate([(0,
        e_.Cb)({
          type: Object
        })], rq.prototype, "secondImage", void 0),
      rq = wui_transaction_visual_decorate([customElement("wui-transaction-visual")], rq);
    var rZ = ef.iv`
:host > wui-flex:first-child {
  align-items: center;
  column-gap: var(--wui-spacing-s);
  padding: 6.5px var(--wui-spacing-l) 6.5px var(--wui-spacing-xs);
  width: 100%;
}

:host > wui-flex:first-child wui-text:nth-child(1) {
  text-transform: capitalize;
}

wui-transaction-visual {
  width: 40px;
  height: 40px;
}

wui-flex {
  flex: 1;
}

:host wui-flex wui-flex {
  overflow: hidden;
}

:host .description-container wui-text span {
  word-break: break-all;
}

:host .description-container wui-text {
  overflow: hidden;
}

:host .description-separator-icon {
  margin: 0px 6px;
}

:host wui-text > span {
  overflow: hidden;
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 1;
}
`
      , wui_transaction_list_item_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let rG = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.type = "approve",
          this.onlyDirectionIcon = !1,
          this.images = []
      }
      render() {
        return ef.dy`
    <wui-flex>
      <wui-transaction-visual
        .status=${this.status}
        direction=${(0,
            t1.o)(this.direction)}
        type=${this.type}
        onlyDirectionIcon=${(0,
            t1.o)(this.onlyDirectionIcon)}
        .images=${this.images}
      ></wui-transaction-visual>
      <wui-flex flexDirection="column" gap="3xs">
        <wui-text variant="paragraph-600" color="fg-100">
          ${ep[this.type]}
        </wui-text>
        <wui-flex class="description-container">
          ${this.templateDescription()} ${this.templateSecondDescription()}
        </wui-flex>
      </wui-flex>
      <wui-text variant="micro-700" color="fg-300"><span>${this.date}</span></wui-text>
    </wui-flex>
  `
      }
      templateDescription() {
        let J = this.descriptions?.[0];
        return J ? ef.dy`
        <wui-text variant="small-500" color="fg-200">
          <span>${J}</span>
        </wui-text>
      ` : null
      }
      templateSecondDescription() {
        let J = this.descriptions?.[1];
        return J ? ef.dy`
        <wui-icon class="description-separator-icon" size="xxs" name="arrowRight"></wui-icon>
        <wui-text variant="small-400" color="fg-200">
          <span>${J}</span>
        </wui-text>
      ` : null
      }
    }
      ;
    rG.styles = [em, rZ],
      wui_transaction_list_item_decorate([(0,
        e_.Cb)()], rG.prototype, "type", void 0),
      wui_transaction_list_item_decorate([(0,
        e_.Cb)({
          type: Array
        })], rG.prototype, "descriptions", void 0),
      wui_transaction_list_item_decorate([(0,
        e_.Cb)()], rG.prototype, "date", void 0),
      wui_transaction_list_item_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], rG.prototype, "onlyDirectionIcon", void 0),
      wui_transaction_list_item_decorate([(0,
        e_.Cb)()], rG.prototype, "status", void 0),
      wui_transaction_list_item_decorate([(0,
        e_.Cb)()], rG.prototype, "direction", void 0),
      wui_transaction_list_item_decorate([(0,
        e_.Cb)({
          type: Array
        })], rG.prototype, "images", void 0),
      rG = wui_transaction_list_item_decorate([customElement("wui-transaction-list-item")], rG);
    var rY = ef.iv`
:host > wui-flex:first-child {
  column-gap: var(--wui-spacing-s);
  padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
  width: 100%;
}

wui-flex {
  display: flex;
  flex: 1;
}
`;
    let rK = class extends ef.oi {
      render() {
        return ef.dy`
    <wui-flex alignItems="center">
      <wui-shimmer width="40px" height="40px"></wui-shimmer>
      <wui-flex flexDirection="column" gap="2xs">
        <wui-shimmer width="72px" height="16px" borderRadius="4xs"></wui-shimmer>
        <wui-shimmer width="148px" height="14px" borderRadius="4xs"></wui-shimmer>
      </wui-flex>
      <wui-shimmer width="24px" height="12px" borderRadius="5xs"></wui-shimmer>
    </wui-flex>
  `
      }
    }
      ;
    rK.styles = [em, rY],
      rK = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      }([customElement("wui-transaction-list-item-loader")], rK);
    var rJ = ef.iv`
:host {
  display: block;
  padding: 3.5px 5px !important;
  border-radius: var(--wui-border-radius-5xs);
}

:host([data-variant='main']) {
  background-color: var(--wui-accent-glass-015);
  color: var(--wui-color-accent-100);
}

:host([data-variant='shade']) {
  background-color: var(--wui-gray-glass-010);
  color: var(--wui-color-fg-200);
}

:host([data-variant='success']) {
  background-color: var(--wui-icon-box-bg-success-100);
  color: var(--wui-color-success-100);
}

:host([data-variant='error']) {
  background-color: var(--wui-icon-box-bg-error-100);
  color: var(--wui-color-error-100);
}
`
      , wui_tag_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let rQ = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.variant = "main"
      }
      render() {
        return this.dataset.variant = this.variant,
          ef.dy`
    <wui-text data-variant=${this.variant} variant="micro-700" color="inherit">
      <slot></slot>
    </wui-text>
  `
      }
    }
      ;
    rQ.styles = [em, rJ],
      wui_tag_decorate([(0,
        e_.Cb)()], rQ.prototype, "variant", void 0),
      rQ = wui_tag_decorate([customElement("wui-tag")], rQ);
    var rX = ef.iv`
button {
  column-gap: var(--wui-spacing-s);
  padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
  width: 100%;
  background-color: var(--wui-gray-glass-002);
  border-radius: var(--wui-border-radius-xs);
  color: var(--wui-color-fg-100);
}

button > wui-text:nth-child(2) {
  display: flex;
  flex: 1;
}

wui-icon {
  color: var(--wui-color-fg-200) !important;
}

button:disabled {
  background-color: var(--wui-gray-glass-015);
  color: var(--wui-gray-glass-015);
}

button:disabled > wui-tag {
  background-color: var(--wui-gray-glass-010);
  color: var(--wui-color-fg-300);
}
`
      , wui_list_wallet_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let r0 = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.walletImages = [],
          this.imageSrc = "",
          this.name = "",
          this.installed = !1,
          this.disabled = !1,
          this.showAllWallets = !1
      }
      render() {
        return ef.dy`
    <button ?disabled=${this.disabled} ontouchstart>
      ${this.templateAllWallets()} ${this.templateWalletImage()}
      <wui-text variant="paragraph-500" color="inherit">${this.name}</wui-text>
      ${this.templateStatus()}
    </button>
  `
      }
      templateAllWallets() {
        return this.showAllWallets && this.imageSrc ? ef.dy` <wui-all-wallets-image .imageeSrc=${this.imageSrc}> </wui-all-wallets-image> ` : this.showAllWallets && this.walletIcon ? ef.dy` <wui-wallet-image .walletIcon=${this.walletIcon} size="sm"> </wui-wallet-image> ` : null
      }
      templateWalletImage() {
        return !this.showAllWallets && this.imageSrc ? ef.dy`<wui-wallet-image
      size="sm"
      imageSrc=${this.imageSrc}
      name=${this.name}
      .installed=${this.installed}
    ></wui-wallet-image>` : this.showAllWallets || this.imageSrc ? null : ef.dy`<wui-wallet-image size="sm" name=${this.name}></wui-wallet-image>`
      }
      templateStatus() {
        return this.tagLabel && this.tagVariant ? ef.dy`<wui-tag variant=${this.tagVariant}>${this.tagLabel}</wui-tag>` : this.icon ? ef.dy`<wui-icon color="inherit" size="sm" name=${this.icon}></wui-icon>` : null
      }
    }
      ;
    r0.styles = [em, eg, rX],
      wui_list_wallet_decorate([(0,
        e_.Cb)({
          type: Array
        })], r0.prototype, "walletImages", void 0),
      wui_list_wallet_decorate([(0,
        e_.Cb)()], r0.prototype, "imageSrc", void 0),
      wui_list_wallet_decorate([(0,
        e_.Cb)()], r0.prototype, "name", void 0),
      wui_list_wallet_decorate([(0,
        e_.Cb)()], r0.prototype, "tagLabel", void 0),
      wui_list_wallet_decorate([(0,
        e_.Cb)()], r0.prototype, "tagVariant", void 0),
      wui_list_wallet_decorate([(0,
        e_.Cb)()], r0.prototype, "icon", void 0),
      wui_list_wallet_decorate([(0,
        e_.Cb)()], r0.prototype, "walletIcon", void 0),
      wui_list_wallet_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], r0.prototype, "installed", void 0),
      wui_list_wallet_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], r0.prototype, "disabled", void 0),
      wui_list_wallet_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], r0.prototype, "showAllWallets", void 0),
      r0 = wui_list_wallet_decorate([customElement("wui-list-wallet")], r0);
    var r1 = ef.iv`
:host {
  display: block;
  width: 40px;
  height: 40px;
  border-radius: var(--wui-border-radius-3xl);
  border: 1px solid var(--wui-gray-glass-010);
  overflow: hidden;
}

wui-icon {
  width: 100%;
  height: 100%;
}
`
      , wui_logo_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let r2 = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.logo = "google"
      }
      render() {
        return ef.dy`<wui-icon color="inherit" size="inherit" name=${this.logo}></wui-icon> `
      }
    }
      ;
    r2.styles = [em, r1],
      wui_logo_decorate([(0,
        e_.Cb)()], r2.prototype, "logo", void 0),
      r2 = wui_logo_decorate([customElement("wui-logo")], r2);
    var r3 = ef.iv`
:host {
  display: block;
}

button {
  width: 50px;
  height: 50px;
  background: var(--wui-gray-glass-002);
  border-radius: var(--wui-border-radius-xs);
}
`
      , wui_logo_select_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let r5 = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.logo = "google",
          this.disabled = !1
      }
      render() {
        return ef.dy`
    <button ?disabled=${this.disabled} ontouchstart>
      <wui-logo logo=${this.logo}></wui-logo>
    </button>
  `
      }
    }
      ;
    r5.styles = [em, eg, r3],
      wui_logo_select_decorate([(0,
        e_.Cb)()], r5.prototype, "logo", void 0),
      wui_logo_select_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], r5.prototype, "disabled", void 0),
      r5 = wui_logo_select_decorate([customElement("wui-logo-select")], r5);
    var r6 = ef.iv`
:host {
  display: block;
}

button {
  border-radius: var(--wui-border-radius-3xl);
  display: flex;
  gap: var(--wui-spacing-xs);
  padding: var(--wui-spacing-2xs) var(--wui-spacing-s) var(--wui-spacing-2xs)
    var(--wui-spacing-xs);
  border: 1px solid var(--wui-gray-glass-010);
  background-color: var(--wui-gray-glass-005);
  color: var(--wui-color-fg-100);
}

button:disabled {
  border: 1px solid var(--wui-gray-glass-005);
  background-color: var(--wui-gray-glass-015);
  color: var(--wui-gray-glass-015);
}

@media (hover: hover) and (pointer: fine) {
  button:hover:enabled {
    background-color: var(--wui-gray-glass-010);
  }

  button:active:enabled {
    background-color: var(--wui-gray-glass-015);
  }
}

wui-image,
wui-icon-box {
  border-radius: var(--wui-border-radius-3xl);
  width: 24px;
  height: 24px;
  box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
}
`
      , wui_network_button_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let r4 = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.imageSrc = void 0,
          this.disabled = !1
      }
      render() {
        return ef.dy`
    <button ?disabled=${this.disabled}>
      ${this.visualTemplate()}
      <wui-text variant="paragraph-600" color="inherit">
        <slot></slot>
      </wui-text>
    </button>
  `
      }
      visualTemplate() {
        return this.imageSrc ? ef.dy`<wui-image src=${this.imageSrc}></wui-image>` : ef.dy`
    <wui-icon-box
      size="sm"
      iconColor="inverse-100"
      backgroundColor="fg-100"
      icon="networkPlaceholder"
    ></wui-icon-box>
  `
      }
    }
      ;
    r4.styles = [em, eg, r6],
      wui_network_button_decorate([(0,
        e_.Cb)()], r4.prototype, "imageSrc", void 0),
      wui_network_button_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], r4.prototype, "disabled", void 0),
      r4 = wui_network_button_decorate([customElement("wui-network-button")], r4);
    var r8 = ef.iv`
:host {
  position: relative;
  display: block;
}
`
      , wui_otp_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let r7 = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.length = 6,
          this.otp = "",
          this.values = Array.from({
            length: this.length
          }).map(() => ""),
          this.numerics = [],
          this.shouldInputBeEnabled = J => {
            let et = this.values.slice(0, J);
            return et.every(J => "" !== J)
          }
          ,
          this.handleKeyDown = (J, et) => {
            let eo = J.target
              , el = this.getInputElement(eo);
            if (!el)
              return;
            ["ArrowLeft", "ArrowRight", "Shift", "Delete"].includes(J.key) && J.preventDefault();
            let ec = el.selectionStart;
            switch (J.key) {
              case "ArrowLeft":
                ec && el.setSelectionRange(ec + 1, ec + 1),
                  this.focusInputField("prev", et);
                break;
              case "ArrowRight":
              case "Shift":
                this.focusInputField("next", et);
                break;
              case "Delete":
              case "Backspace":
                "" === el.value ? this.focusInputField("prev", et) : this.updateInput(el, et, "")
            }
          }
          ,
          this.focusInputField = (J, et) => {
            if ("next" === J) {
              let J = et + 1;
              if (!this.shouldInputBeEnabled(J))
                return;
              let eo = this.numerics[J < this.length ? J : et]
                , el = eo ? this.getInputElement(eo) : void 0;
              el && (el.disabled = !1,
                el.focus())
            }
            if ("prev" === J) {
              let J = et - 1
                , eo = this.numerics[J > -1 ? J : et]
                , el = eo ? this.getInputElement(eo) : void 0;
              el && el.focus()
            }
          }
      }
      firstUpdated() {
        this.otp && (this.values = this.otp.split(""));
        let J = this.shadowRoot?.querySelectorAll("wui-input-numeric");
        J && (this.numerics = Array.from(J)),
          this.numerics[0]?.focus()
      }
      render() {
        return ef.dy`
    <wui-flex gap="xxs" data-testid="wui-otp-input">
      ${Array.from({
          length: this.length
        }).map((J, et) => ef.dy`
          <wui-input-numeric
            @input=${J => this.handleInput(J, et)}
            @keydown=${J => this.handleKeyDown(J, et)}
            .disabled=${!this.shouldInputBeEnabled(et)}
            .value=${this.values[et] || ""}
          >
          </wui-input-numeric>
        `)}
    </wui-flex>
  `
      }
      updateInput(J, et, eo) {
        let el = this.numerics[et]
          , ec = J || (el ? this.getInputElement(el) : void 0);
        ec && (ec.value = eo,
          this.values = this.values.map((J, el) => el === et ? eo : J))
      }
      handleInput(J, et) {
        let eo = J.target
          , el = this.getInputElement(eo);
        if (el) {
          let eo = el.value;
          if ("insertFromPaste" === J.inputType)
            this.handlePaste(el, eo, et);
          else {
            let ec = t2.isNumber(eo);
            ec && J.data ? (this.updateInput(el, et, J.data),
              this.focusInputField("next", et)) : this.updateInput(el, et, "")
          }
        }
        this.dispatchInputChangeEvent()
      }
      handlePaste(J, et, eo) {
        let el = et[0]
          , ec = el && t2.isNumber(el);
        if (ec) {
          this.updateInput(J, eo, el);
          let ec = et.substring(1);
          if (eo + 1 < this.length && ec.length) {
            let J = this.numerics[eo + 1]
              , et = J ? this.getInputElement(J) : void 0;
            et && this.handlePaste(et, ec, eo + 1)
          } else
            this.focusInputField("next", eo)
        } else
          this.updateInput(J, eo, "")
      }
      getInputElement(J) {
        return J.shadowRoot?.querySelector("input") ? J.shadowRoot.querySelector("input") : null
      }
      dispatchInputChangeEvent() {
        let J = this.values.join("");
        this.dispatchEvent(new CustomEvent("inputChange", {
          detail: J,
          bubbles: !0,
          composed: !0
        }))
      }
    }
      ;
    r7.styles = [em, r8],
      wui_otp_decorate([(0,
        e_.Cb)({
          type: Number
        })], r7.prototype, "length", void 0),
      wui_otp_decorate([(0,
        e_.Cb)({
          type: String
        })], r7.prototype, "otp", void 0),
      wui_otp_decorate([(0,
        e_.SB)()], r7.prototype, "values", void 0),
      r7 = wui_otp_decorate([customElement("wui-otp")], r7);
    var r9 = eo(92592);
    function isAdjecentDots(J, et, eo) {
      return J !== et && (J - et < 0 ? et - J : J - et) <= eo + .1
    }
    let nn = {
      generate(J, et, eo) {
        let el = "#141414"
          , ec = []
          , ed = function (J, et) {
            let eo = Array.prototype.slice.call(r9.create(J, {
              errorCorrectionLevel: "Q"
            }).modules.data, 0)
              , el = Math.sqrt(eo.length);
            return eo.reduce((J, et, eo) => (eo % el == 0 ? J.push([et]) : J[J.length - 1].push(et)) && J, [])
          }(J, 0)
          , eh = et / ed.length
          , ep = [{
            x: 0,
            y: 0
          }, {
            x: 1,
            y: 0
          }, {
            x: 0,
            y: 1
          }];
        ep.forEach(({ x: J, y: et }) => {
          let eo = (ed.length - 7) * eh * J
            , em = (ed.length - 7) * eh * et;
          for (let J = 0; J < ep.length; J += 1) {
            let et = eh * (7 - 2 * J);
            ec.push(ef.YP`
          <rect
            fill=${2 === J ? el : "transparent"}
            width=${0 === J ? et - 5 : et}
            rx= ${0 === J ? (et - 5) * .45 : .45 * et}
            ry= ${0 === J ? (et - 5) * .45 : .45 * et}
            stroke=${el}
            stroke-width=${0 === J ? 5 : 0}
            height=${0 === J ? et - 5 : et}
            x= ${0 === J ? em + eh * J + 2.5 : em + eh * J}
            y= ${0 === J ? eo + eh * J + 2.5 : eo + eh * J}
          />
        `)
          }
        }
        );
        let em = Math.floor((eo + 25) / eh)
          , eg = ed.length / 2 - em / 2
          , ey = ed.length / 2 + em / 2 - 1
          , eb = [];
        ed.forEach((J, et) => {
          J.forEach((J, eo) => {
            if (ed[et][eo] && !(et < 7 && eo < 7 || et > ed.length - 8 && eo < 7 || et < 7 && eo > ed.length - 8) && !(et > eg && et < ey && eo > eg && eo < ey)) {
              let J = et * eh + eh / 2
                , el = eo * eh + eh / 2;
              eb.push([J, el])
            }
          }
          )
        }
        );
        let ew = {};
        return eb.forEach(([J, et]) => {
          ew[J] ? ew[J]?.push(et) : ew[J] = [et]
        }
        ),
          Object.entries(ew).map(([J, et]) => {
            let eo = et.filter(J => et.every(et => !isAdjecentDots(J, et, eh)));
            return [Number(J), eo]
          }
          ).forEach(([J, et]) => {
            et.forEach(et => {
              ec.push(ef.YP`<circle cx=${J} cy=${et} fill=${el} r=${eh / 2.5} />`)
            }
            )
          }
          ),
          Object.entries(ew).filter(([J, et]) => et.length > 1).map(([J, et]) => {
            let eo = et.filter(J => et.some(et => isAdjecentDots(J, et, eh)));
            return [Number(J), eo]
          }
          ).map(([J, et]) => {
            et.sort((J, et) => J < et ? -1 : 1);
            let eo = [];
            for (let J of et) {
              let et = eo.find(et => et.some(et => isAdjecentDots(J, et, eh)));
              et ? et.push(J) : eo.push([J])
            }
            return [J, eo.map(J => [J[0], J[J.length - 1]])]
          }
          ).forEach(([J, et]) => {
            et.forEach(([et, eo]) => {
              ec.push(ef.YP`
            <line
              x1=${J}
              x2=${J}
              y1=${et}
              y2=${eo}
              stroke=${el}
              stroke-width=${eh / 1.25}
              stroke-linecap="round"
            />
          `)
            }
            )
          }
          ),
          ec
      }
    };
    var ns = ef.iv`
:host {
  position: relative;
  user-select: none;
  display: block;
  overflow: hidden;
  aspect-ratio: 1 / 1;
  width: var(--local-size);
}

:host([data-theme='dark']) {
  border-radius: clamp(0px, var(--wui-border-radius-l), 40px);
  background-color: var(--wui-color-inverse-100);
  padding: var(--wui-spacing-l);
}

:host([data-theme='light']) {
  box-shadow: 0 0 0 1px var(--wui-color-bg-125);
  background-color: var(--wui-color-bg-125);
}

svg:first-child,
wui-image,
wui-icon {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translateY(-50%) translateX(-50%);
}

wui-image {
  width: 25%;
  height: 25%;
  border-radius: var(--wui-border-radius-xs);
}

wui-icon {
  width: 100%;
  height: 100%;
  color: #3396ff !important;
  transform: translateY(-50%) translateX(-50%) scale(0.25);
}
`
      , wui_qr_code_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let no = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.uri = "",
          this.size = 0,
          this.theme = "dark",
          this.imageSrc = void 0,
          this.alt = void 0
      }
      render() {
        return this.dataset.theme = this.theme,
          this.style.cssText = `--local-size: ${this.size}px`,
          ef.dy`${this.templateVisual()} ${this.templateSvg()}`
      }
      templateSvg() {
        let J = "light" === this.theme ? this.size : this.size - 32;
        return ef.YP`
    <svg height=${J} width=${J}>
      ${nn.generate(this.uri, J, J / 4)}
    </svg>
  `
      }
      templateVisual() {
        return this.imageSrc ? ef.dy`<wui-image src=${this.imageSrc} alt=${this.alt ?? "logo"}></wui-image>` : ef.dy`<wui-icon size="inherit" color="inherit" name="walletConnect"></wui-icon>`
      }
    }
      ;
    no.styles = [em, ns],
      wui_qr_code_decorate([(0,
        e_.Cb)()], no.prototype, "uri", void 0),
      wui_qr_code_decorate([(0,
        e_.Cb)({
          type: Number
        })], no.prototype, "size", void 0),
      wui_qr_code_decorate([(0,
        e_.Cb)()], no.prototype, "theme", void 0),
      wui_qr_code_decorate([(0,
        e_.Cb)()], no.prototype, "imageSrc", void 0),
      wui_qr_code_decorate([(0,
        e_.Cb)()], no.prototype, "alt", void 0),
      no = wui_qr_code_decorate([customElement("wui-qr-code")], no);
    var nl = ef.iv`
:host {
  position: relative;
  display: inline-block;
  width: 100%;
}
`;
    let nc = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.inputComponentRef = (0,
            rR.V)()
      }
      render() {
        return ef.dy`
    <wui-input-text
      ${(0,
            rR.i)(this.inputComponentRef)}
      placeholder="Search wallet"
      icon="search"
      type="search"
      enterKeyHint="search"
      size="sm"
    >
      <wui-input-element @click=${this.clearValue} icon="close"></wui-input-element>
    </wui-input-text>
  `
      }
      clearValue() {
        let J = this.inputComponentRef.value
          , et = J?.inputElementRef.value;
        et && (et.value = "",
          et.focus(),
          et.dispatchEvent(new Event("input")))
      }
    }
      ;
    nc.styles = [em, nl],
      nc = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      }([customElement("wui-search-bar")], nc);
    var nd = ef.iv`
:host {
  display: flex;
  column-gap: var(--wui-spacing-xs);
  align-items: center;
  padding: var(--wui-spacing-xs) var(--wui-spacing-m) var(--wui-spacing-xs) var(--wui-spacing-xs);
  border-radius: var(--wui-border-radius-3xl);
  border: 1px solid var(--wui-gray-glass-005);
  background-color: var(--wui-color-bg-175);
  box-shadow:
    0px 14px 64px -4px rgba(0, 0, 0, 0.15),
    0px 8px 22px -6px rgba(0, 0, 0, 0.15);
}
`
      , wui_snackbar_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let nh = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.backgroundColor = "accent-100",
          this.iconColor = "accent-100",
          this.icon = "checkmark",
          this.message = ""
      }
      render() {
        return ef.dy`
    <wui-icon-box
      size="sm"
      iconSize="xs"
      iconColor=${this.iconColor}
      backgroundColor=${this.backgroundColor}
      icon=${this.icon}
      background="opaque"
    ></wui-icon-box>
    <wui-text variant="paragraph-500" color="fg-100">${this.message}</wui-text>
  `
      }
    }
      ;
    nh.styles = [em, nd],
      wui_snackbar_decorate([(0,
        e_.Cb)()], nh.prototype, "backgroundColor", void 0),
      wui_snackbar_decorate([(0,
        e_.Cb)()], nh.prototype, "iconColor", void 0),
      wui_snackbar_decorate([(0,
        e_.Cb)()], nh.prototype, "icon", void 0),
      wui_snackbar_decorate([(0,
        e_.Cb)()], nh.prototype, "message", void 0),
      nh = wui_snackbar_decorate([customElement("wui-snackbar")], nh);
    var np = ef.iv`
:host {
  display: inline-flex;
  background-color: var(--wui-gray-glass-002);
  border-radius: var(--wui-border-radius-3xl);
  padding: var(--wui-spacing-3xs);
  position: relative;
  height: 36px;
  overflow: hidden;
}

:host::before {
  content: '';
  position: absolute;
  pointer-events: none;
  top: 4px;
  left: 4px;
  display: block;
  width: var(--local-tab-width);
  height: 28px;
  border-radius: var(--wui-border-radius-3xl);
  background-color: var(--wui-gray-glass-002);
  box-shadow: inset 0 0 0 1px var(--wui-gray-glass-002);
  transform: translateX(calc(var(--local-tab) * var(--local-tab-width)));
  transition: transform var(--wui-ease-out-power-2) var(--wui-duration-lg);
}

:host([data-type='flex'])::before {
  left: 3px;
  transform: translateX(calc((var(--local-tab) * 34px) + (var(--local-tab) * 4px)));
}

:host([data-type='flex']) {
  display: flex;
  padding: 0px 0px 0px 12px;
  gap: 4px;
}

:host([data-type='flex']) > button > wui-text {
  position: absolute;
  left: 18px;
  opacity: 0;
}

button[data-active='true'] > wui-icon,
button[data-active='true'] > wui-text {
  color: var(--wui-color-fg-100);
}

button[data-active='false'] > wui-icon,
button[data-active='false'] > wui-text {
  color: var(--wui-color-fg-200);
}

button[data-active='true']:disabled,
button[data-active='false']:disabled {
  background-color: transparent;
  opacity: 0.5;
  cursor: not-allowed;
}

button[data-active='true']:disabled > wui-text {
  color: var(--wui-color-fg-200);
}

button[data-active='false']:disabled > wui-text {
  color: var(--wui-color-fg-300);
}

button > wui-icon,
button > wui-text {
  pointer-events: none;
  transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
}

button {
  width: var(--local-tab-width);
}

:host([data-type='flex']) > button {
  width: 34px;
  position: relative;
  display: flex;
  justify-content: flex-start;
}

button:hover:enabled,
button:active:enabled {
  background-color: transparent !important;
}

button:hover:enabled > wui-icon,
button:active:enabled > wui-icon {
  color: var(--wui-color-fg-125);
}

button:hover:enabled > wui-text,
button:active:enabled > wui-text {
  color: var(--wui-color-fg-125);
}

button {
  border-radius: var(--wui-border-radius-3xl);
}
`
      , wui_tabs_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let nf = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.tabs = [],
          this.onTabChange = () => null,
          this.buttons = [],
          this.disabled = !1,
          this.activeTab = 0,
          this.localTabWidth = "100px",
          this.isDense = !1
      }
      render() {
        return this.isDense = this.tabs.length > 3,
          this.style.cssText = `
    --local-tab: ${this.activeTab};
    --local-tab-width: ${this.localTabWidth};
  `,
          this.dataset.type = this.isDense ? "flex" : "block",
          this.tabs.map((J, et) => {
            let eo = et === this.activeTab;
            return ef.dy`
      <button
        ?disabled=${this.disabled}
        @click=${() => this.onTabClick(et)}
        data-active=${eo}
      >
        <wui-icon size="xs" color="inherit" name=${J.icon}></wui-icon>
        <wui-text variant="small-600" color="inherit"> ${J.label} </wui-text>
      </button>
    `
          }
          )
      }
      firstUpdated() {
        this.shadowRoot && this.isDense && (this.buttons = [...this.shadowRoot.querySelectorAll("button")],
          setTimeout(() => {
            this.animateTabs(0, !0)
          }
            , 0))
      }
      onTabClick(J) {
        this.buttons && this.animateTabs(J, !1),
          this.activeTab = J,
          this.onTabChange(J)
      }
      animateTabs(J, et) {
        let eo = this.buttons[this.activeTab]
          , el = this.buttons[J]
          , ec = eo?.querySelector("wui-text")
          , ed = el?.querySelector("wui-text")
          , eh = el?.getBoundingClientRect()
          , ep = ed?.getBoundingClientRect();
        eo && ec && !et && J !== this.activeTab && (ec.animate([{
          opacity: 0
        }], {
          duration: 50,
          easing: "ease",
          fill: "forwards"
        }),
          eo.animate([{
            width: "34px"
          }], {
            duration: 500,
            easing: "ease",
            fill: "forwards"
          })),
          el && eh && ep && ed && (J !== this.activeTab || et) && (this.localTabWidth = `${Math.round(eh.width + ep.width) + 6}px`,
            el.animate([{
              width: `${eh.width + ep.width}px`
            }], {
              duration: et ? 0 : 500,
              fill: "forwards",
              easing: "ease"
            }),
            ed.animate([{
              opacity: 1
            }], {
              duration: et ? 0 : 125,
              delay: et ? 0 : 200,
              fill: "forwards",
              easing: "ease"
            }))
      }
    }
      ;
    nf.styles = [em, eg, np],
      wui_tabs_decorate([(0,
        e_.Cb)({
          type: Array
        })], nf.prototype, "tabs", void 0),
      wui_tabs_decorate([(0,
        e_.Cb)()], nf.prototype, "onTabChange", void 0),
      wui_tabs_decorate([(0,
        e_.Cb)({
          type: Array
        })], nf.prototype, "buttons", void 0),
      wui_tabs_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], nf.prototype, "disabled", void 0),
      wui_tabs_decorate([(0,
        e_.SB)()], nf.prototype, "activeTab", void 0),
      wui_tabs_decorate([(0,
        e_.SB)()], nf.prototype, "localTabWidth", void 0),
      wui_tabs_decorate([(0,
        e_.SB)()], nf.prototype, "isDense", void 0),
      nf = wui_tabs_decorate([customElement("wui-tabs")], nf);
    var nm = ef.iv`
:host {
  display: block;
  padding: 9px var(--wui-spacing-s) 10px var(--wui-spacing-s);
  border-radius: var(--wui-border-radius-xxs);
  background-color: var(--wui-color-fg-100);
  color: var(--wui-color-bg-100);
  position: relative;
}

wui-icon {
  position: absolute;
  width: 12px !important;
  height: 4px !important;
}

wui-icon[data-placement='top'] {
  bottom: 0;
  left: 50%;
  transform: translate(-50%, 95%);
}

wui-icon[data-placement='bottom'] {
  top: 0;
  left: 50%;
  transform: translate(-50%, -95%) rotate(180deg);
}

wui-icon[data-placement='right'] {
  top: 50%;
  left: 0;
  transform: translate(-65%, -50%) rotate(90deg);
}

wui-icon[data-placement='left'] {
  top: 50%;
  right: 0%;
  transform: translate(65%, -50%) rotate(270deg);
}
`
      , wui_tooltip_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let ng = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.placement = "top",
          this.message = ""
      }
      render() {
        return ef.dy`<wui-icon
      data-placement=${this.placement}
      color="fg-100"
      size="inherit"
      name="cursor"
    ></wui-icon>
    <wui-text color="inherit" variant="small-500">${this.message}</wui-text>`
      }
    }
      ;
    ng.styles = [em, eg, nm],
      wui_tooltip_decorate([(0,
        e_.Cb)()], ng.prototype, "placement", void 0),
      wui_tooltip_decorate([(0,
        e_.Cb)()], ng.prototype, "message", void 0),
      ng = wui_tooltip_decorate([customElement("wui-tooltip")], ng);
    var ny = ef.iv`
:host {
  display: flex;
  justify-content: center;
  align-items: center;
  width: var(--wui-icon-box-size-xl);
  height: var(--wui-icon-box-size-xl);
  box-shadow: 0 0 0 8px var(--wui-thumbnail-border);
  border-radius: var(--local-border-radius);
  overflow: hidden;
}

wui-icon {
  width: 32px;
  height: 32px;
}
`
      , wui_visual_thumbnail_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let nb = class extends ef.oi {
      render() {
        return this.style.cssText = `--local-border-radius: ${this.borderRadiusFull ? "1000px" : "20px"};`,
          ef.dy`${this.templateVisual()}`
      }
      templateVisual() {
        return this.imageSrc ? ef.dy`<wui-image src=${this.imageSrc} alt=${this.alt ?? ""}></wui-image>` : ef.dy`<wui-icon
    data-parent-size="md"
    size="inherit"
    color="inherit"
    name="walletPlaceholder"
  ></wui-icon>`
      }
    }
      ;
    nb.styles = [em, ny],
      wui_visual_thumbnail_decorate([(0,
        e_.Cb)()], nb.prototype, "imageSrc", void 0),
      wui_visual_thumbnail_decorate([(0,
        e_.Cb)()], nb.prototype, "alt", void 0),
      wui_visual_thumbnail_decorate([(0,
        e_.Cb)({
          type: Boolean
        })], nb.prototype, "borderRadiusFull", void 0),
      nb = wui_visual_thumbnail_decorate([customElement("wui-visual-thumbnail")], nb);
    var nw = ef.iv`
:host {
  display: block;
}

button {
  width: 100%;
  display: block;
  padding-top: var(--wui-spacing-l);
  padding-bottom: var(--wui-spacing-l);
  padding-left: var(--wui-spacing-s);
  padding-right: var(--wui-spacing-2l);
  border-radius: var(--wui-border-radius-s);
  background-color: var(--wui-accent-glass-015);
}

button:hover {
  background-color: var(--wui-accent-glass-010) !important;
}

button:active {
  background-color: var(--wui-accent-glass-020) !important;
}
`
      , wui_notice_card_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let n_ = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.label = "",
          this.description = "",
          this.icon = "wallet"
      }
      render() {
        return ef.dy`
    <button>
      <wui-flex gap="m" alignItems="center" justifyContent="space-between">
        <wui-icon-box
          size="lg"
          iconcolor="accent-100"
          backgroundcolor="accent-100"
          icon=${this.icon}
          background="transparent"
        ></wui-icon-box>

        <wui-flex flexDirection="column" gap="3xs">
          <wui-text variant="paragraph-500" color="fg-100">${this.label}</wui-text>
          <wui-text variant="small-400" color="fg-200">${this.description}</wui-text>
        </wui-flex>

        <wui-icon size="md" color="fg-200" name="chevronRight"></wui-icon>
      </wui-flex>
    </button>
  `
      }
    }
      ;
    n_.styles = [em, eg, nw],
      wui_notice_card_decorate([(0,
        e_.Cb)()], n_.prototype, "label", void 0),
      wui_notice_card_decorate([(0,
        e_.Cb)()], n_.prototype, "description", void 0),
      wui_notice_card_decorate([(0,
        e_.Cb)()], n_.prototype, "icon", void 0),
      n_ = wui_notice_card_decorate([customElement("wui-notice-card")], n_);
    var nx = ef.iv`
button {
  height: auto;
  position: relative;
  flex-direction: column;
  gap: var(--wui-spacing-s);
  padding: 17px 18px 17px var(--wui-spacing-m);
  width: 100%;
  background-color: var(--wui-gray-glass-002);
  border-radius: var(--wui-border-radius-xs);
  color: var(--wui-color-fg-250);
}

.overflowedContent {
  width: 100%;
  overflow: hidden;
}

.overflowedContent[data-active='false']:after {
  content: '';
  position: absolute;
  top: 50%;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(to top, var(--wui-color-bg-200), transparent);
  border-bottom-left-radius: var(--wui-border-radius-xs);
  border-bottom-right-radius: var(--wui-border-radius-xs);
}

.heightContent {
  max-height: 100px;
}

pre {
  text-align: left;
  white-space: pre-wrap;
  height: auto;
  overflow-x: auto;
  overflow-wrap: anywhere;
}
`
      , wui_list_accordion_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let nE = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.textTitle = "",
          this.overflowedContent = "",
          this.toggled = !1,
          this.enableAccordion = !1,
          this.scrollElement = void 0,
          this.scrollHeightElement = 0
      }
      firstUpdated() {
        setTimeout(() => {
          let J = this.shadowRoot?.querySelector(".heightContent");
          if (J) {
            this.scrollElement = J;
            let et = J?.scrollHeight;
            et && et > 100 && (this.enableAccordion = !0,
              this.scrollHeightElement = et,
              this.requestUpdate())
          }
        }
          , 0)
      }
      render() {
        return ef.dy`
    <button ontouchstart @click=${() => this.onClick()}>
      <wui-flex justifyContent="space-between" alignItems="center">
        <wui-text variant="paragraph-500" color="fg-100">${this.textTitle}</wui-text>
        ${this.chevronTemplate()}
      </wui-flex>
      <div
        data-active=${!this.enableAccordion || !!this.toggled}
        class="overflowedContent"
      >
        <div class="heightContent">
          <wui-text variant="paragraph-400" color="fg-200">
            <pre>${this.overflowedContent}</pre>
          </wui-text>
        </div>
      </div>
    </button>
  `
      }
      onClick() {
        let J = this.shadowRoot?.querySelector("wui-icon");
        this.enableAccordion && (this.toggled = !this.toggled,
          this.requestUpdate(),
          this.scrollElement && this.scrollElement.animate([{
            maxHeight: this.toggled ? "100px" : `${this.scrollHeightElement}px`
          }, {
            maxHeight: this.toggled ? `${this.scrollHeightElement}px` : "100px"
          }], {
            duration: 300,
            fill: "forwards",
            easing: "ease"
          }),
          J && J.animate([{
            transform: this.toggled ? "rotate(0deg)" : "rotate(180deg)"
          }, {
            transform: this.toggled ? "rotate(180deg)" : "rotate(0deg)"
          }], {
            duration: 300,
            fill: "forwards",
            easing: "ease"
          }))
      }
      chevronTemplate() {
        return this.enableAccordion ? ef.dy` <wui-icon color="fg-100" size="sm" name="chevronBottom"></wui-icon>` : null
      }
    }
      ;
    nE.styles = [em, eg, nx],
      wui_list_accordion_decorate([(0,
        e_.Cb)()], nE.prototype, "textTitle", void 0),
      wui_list_accordion_decorate([(0,
        e_.Cb)()], nE.prototype, "overflowedContent", void 0),
      nE = wui_list_accordion_decorate([customElement("wui-list-accordion")], nE);
    var nC = ef.iv`
:host {
  display: flex;
  column-gap: var(--wui-spacing-s);
  padding: 17px 18px 17px var(--wui-spacing-m);
  width: 100%;
  background-color: var(--wui-gray-glass-002);
  border-radius: var(--wui-border-radius-xs);
  color: var(--wui-color-fg-250);
}

wui-image {
  width: var(--wui-icon-size-lg);
  height: var(--wui-icon-size-lg);
  border-radius: var(--wui-border-radius-3xl);
}

wui-icon {
  width: var(--wui-icon-size-lg);
  height: var(--wui-icon-size-lg);
}
`
      , wui_list_content_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let nS = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.imageSrc = void 0,
          this.textTitle = "",
          this.textValue = void 0
      }
      render() {
        return ef.dy`
    <wui-flex justifyContent="space-between" alignItems="center">
      <wui-text variant="paragraph-500" color=${this.textValue ? "fg-200" : "fg-100"}>
        ${this.textTitle}
      </wui-text>
      ${this.templateContent()}
    </wui-flex>
  `
      }
      templateContent() {
        return this.imageSrc ? ef.dy`<wui-image src=${this.imageSrc} alt=${this.textTitle}></wui-image>` : this.textValue ? ef.dy` <wui-text variant="paragraph-400" color="fg-100"> ${this.textValue} </wui-text>` : ef.dy`<wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></wui-icon>`
      }
    }
      ;
    nS.styles = [em, eg, nC],
      wui_list_content_decorate([(0,
        e_.Cb)()], nS.prototype, "imageSrc", void 0),
      wui_list_content_decorate([(0,
        e_.Cb)()], nS.prototype, "textTitle", void 0),
      wui_list_content_decorate([(0,
        e_.Cb)()], nS.prototype, "textValue", void 0),
      nS = wui_list_content_decorate([customElement("wui-list-content")], nS);
    var nk = ef.iv`
:host {
  display: flex;
  flex-direction: column;
  gap: var(--wui-spacing-l);
  padding: 17px 18px 17px var(--wui-spacing-m);
  width: 100%;
  background-color: var(--wui-gray-glass-002);
  border-radius: var(--wui-border-radius-xs);
  color: var(--wui-color-fg-250);
}

wui-image {
  width: var(--wui-icon-size-lg);
  height: var(--wui-icon-size-lg);
  border-radius: var(--wui-border-radius-3xl);
}

wui-icon {
  width: var(--wui-icon-size-lg);
  height: var(--wui-icon-size-lg);
}
`
      , wui_list_wallet_transaction_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let nT = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.amount = "",
          this.networkCurreny = "",
          this.networkImageUrl = "",
          this.receiverAddress = ""
      }
      render() {
        return ef.dy`
    <wui-flex justifyContent="space-between" alignItems="center">
      <wui-text variant="paragraph-500" color="fg-200">Sending</wui-text>
      <wui-flex gap="xs" alignItems="center">
        <wui-text variant="paragraph-400" color="fg-100">
          ${this.amount} ${this.networkCurreny}
        </wui-text>
        ${this.templateNetworkVisual()}
      </wui-flex>
    </wui-flex>
    <wui-flex justifyContent="space-between" alignItems="center">
      <wui-text variant="paragraph-500" color="fg-200">To</wui-text>
      <wui-chip
        icon="externalLink"
        variant="shadeSmall"
        href=${this.receiverAddress}
        title=${this.receiverAddress}
      ></wui-chip>
    </wui-flex>
  `
      }
      templateNetworkVisual() {
        return this.networkImageUrl ? ef.dy`<wui-image src=${this.networkImageUrl} alt="Network Image"></wui-image>` : ef.dy`<wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></wui-icon>`
      }
    }
      ;
    nT.styles = [em, eg, nk],
      wui_list_wallet_transaction_decorate([(0,
        e_.Cb)()], nT.prototype, "amount", void 0),
      wui_list_wallet_transaction_decorate([(0,
        e_.Cb)()], nT.prototype, "networkCurreny", void 0),
      wui_list_wallet_transaction_decorate([(0,
        e_.Cb)()], nT.prototype, "networkImageUrl", void 0),
      wui_list_wallet_transaction_decorate([(0,
        e_.Cb)()], nT.prototype, "receiverAddress", void 0),
      nT = wui_list_wallet_transaction_decorate([customElement("wui-list-wallet-transaction")], nT);
    var nA = ef.iv`
:host {
  display: grid;
  width: inherit;
  height: inherit;
}
`
      , wui_grid_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let nP = class extends ef.oi {
      render() {
        return this.style.cssText = `
    grid-template-rows: ${this.gridTemplateRows};
    grid-template-columns: ${this.gridTemplateColumns};
    justify-items: ${this.justifyItems};
    align-items: ${this.alignItems};
    justify-content: ${this.justifyContent};
    align-content: ${this.alignContent};
    column-gap: ${this.columnGap && `var(--wui-spacing-${this.columnGap})`};
    row-gap: ${this.rowGap && `var(--wui-spacing-${this.rowGap})`};
    gap: ${this.gap && `var(--wui-spacing-${this.gap})`};
    padding-top: ${this.padding && t2.getSpacingStyles(this.padding, 0)};
    padding-right: ${this.padding && t2.getSpacingStyles(this.padding, 1)};
    padding-bottom: ${this.padding && t2.getSpacingStyles(this.padding, 2)};
    padding-left: ${this.padding && t2.getSpacingStyles(this.padding, 3)};
    margin-top: ${this.margin && t2.getSpacingStyles(this.margin, 0)};
    margin-right: ${this.margin && t2.getSpacingStyles(this.margin, 1)};
    margin-bottom: ${this.margin && t2.getSpacingStyles(this.margin, 2)};
    margin-left: ${this.margin && t2.getSpacingStyles(this.margin, 3)};
  `,
          ef.dy`<slot></slot>`
      }
    }
      ;
    nP.styles = [em, nA],
      wui_grid_decorate([(0,
        e_.Cb)()], nP.prototype, "gridTemplateRows", void 0),
      wui_grid_decorate([(0,
        e_.Cb)()], nP.prototype, "gridTemplateColumns", void 0),
      wui_grid_decorate([(0,
        e_.Cb)()], nP.prototype, "justifyItems", void 0),
      wui_grid_decorate([(0,
        e_.Cb)()], nP.prototype, "alignItems", void 0),
      wui_grid_decorate([(0,
        e_.Cb)()], nP.prototype, "justifyContent", void 0),
      wui_grid_decorate([(0,
        e_.Cb)()], nP.prototype, "alignContent", void 0),
      wui_grid_decorate([(0,
        e_.Cb)()], nP.prototype, "columnGap", void 0),
      wui_grid_decorate([(0,
        e_.Cb)()], nP.prototype, "rowGap", void 0),
      wui_grid_decorate([(0,
        e_.Cb)()], nP.prototype, "gap", void 0),
      wui_grid_decorate([(0,
        e_.Cb)()], nP.prototype, "padding", void 0),
      wui_grid_decorate([(0,
        e_.Cb)()], nP.prototype, "margin", void 0),
      nP = wui_grid_decorate([customElement("wui-grid")], nP);
    var nR = ef.iv`
:host {
  position: relative;
  display: flex;
  width: 100%;
  height: 1px;
  background-color: var(--wui-gray-glass-005);
  justify-content: center;
  align-items: center;
}

:host > wui-text {
  position: absolute;
  padding: 0px 10px;
  background-color: var(--wui-color-modal-bg);
}
`
      , wui_separator_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let nI = class extends ef.oi {
      constructor() {
        super(...arguments),
          this.text = ""
      }
      render() {
        return ef.dy`${this.template()}`
      }
      template() {
        return this.text ? ef.dy`<wui-text variant="small-500" color="fg-200">${this.text}</wui-text>` : null
      }
    }
      ;
    nI.styles = [em, nR],
      wui_separator_decorate([(0,
        e_.Cb)()], nI.prototype, "text", void 0),
      nI = wui_separator_decorate([customElement("wui-separator")], nI);
    var nO = eo(88598);
    let nN = ["receive", "deposit", "borrow", "claim"]
      , nM = ["withdraw", "repay", "burn"]
      , nD = {
        getTransactionGroupTitle(J) {
          let et = nO.E.getYear();
          return J === et ? "This Year" : J
        },
        getTransactionImages(J) {
          let [et, eo] = J
            , el = !!et && J?.every(J => !!J.nft_info)
            , ec = J?.length > 1
            , ed = J?.length === 2;
          return ed && !el ? [this.getTransactionImage(et), this.getTransactionImage(eo)] : ec ? J.map(J => this.getTransactionImage(J)) : [this.getTransactionImage(et)]
        },
        getTransactionImage: J => ({
          type: nD.getTransactionTransferTokenType(J),
          url: nD.getTransactionImageURL(J)
        }),
        getTransactionImageURL(J) {
          let et = null
            , eo = !!J?.nft_info
            , el = !!J?.fungible_info;
          return J && eo ? et = J?.nft_info?.content?.preview?.url : J && el && (et = J?.fungible_info?.icon?.url),
            et
        },
        getTransactionTransferTokenType: J => J?.fungible_info ? "FUNGIBLE" : J?.nft_info ? "NFT" : null,
        getTransactionDescriptions(J) {
          let et = J.metadata?.operationType
            , eo = J.transfers
            , el = J.transfers?.length > 0
            , ec = J.transfers?.length > 1
            , ed = el && eo?.every(J => !!J.fungible_info)
            , [eh, ep] = eo
            , ef = this.getTransferDescription(eh);
          if (this.getTransferDescription(ep),
            !el) {
            let eo = "send" === et || "receive" === et;
            return eo && ed ? [ef = t2.getTruncateString({
              string: J.metadata.sentFrom,
              charsStart: 4,
              charsEnd: 6,
              truncate: "middle"
            }), t2.getTruncateString({
              string: J.metadata.sentTo,
              charsStart: 4,
              charsEnd: 6,
              truncate: "middle"
            })] : [J.metadata.status]
          }
          if (ec)
            return eo.map(J => this.getTransferDescription(J));
          let em = "";
          return nN.includes(et) ? em = "+" : nM.includes(et) && (em = "-"),
            [ef = em.concat(ef)]
        },
        getTransferDescription(J) {
          let et = "";
          return J && (J?.nft_info ? et = J?.nft_info?.name || "-" : J?.fungible_info && (et = this.getFungibleTransferDescription(J) || "-")),
            et
        },
        getFungibleTransferDescription(J) {
          if (!J)
            return null;
          let et = this.getQuantityFixedValue(J?.quantity.numeric)
            , eo = [et, J?.fungible_info?.symbol].join(" ").trim();
          return eo
        },
        getQuantityFixedValue(J) {
          if (!J)
            return null;
          let et = parseFloat(J);
          return et.toFixed(3)
        }
      }
  },
  75374: function (J, et, eo) {
    "use strict";
    let el, ec;
    function useWeb3Modal() {
      if (!el)
        throw Error('Please call "createWeb3Modal" before using "useWeb3Modal" hook');
      return {
        open: async function (J) {
          await el?.open(J)
        },
        close: async function () {
          await el?.close()
        }
      }
    }
    eo.d(et, {
      OY: function () {
        return createWeb3Modal
      },
      k_: function () {
        return useWeb3Modal
      }
    }),
      eo(67294);
    let getVersion = () => "@wagmi/core@2.6.1";
    var ed, eh, __classPrivateFieldGet = function (J, et, eo, el) {
      if ("a" === eo && !el)
        throw TypeError("Private accessor was defined without a getter");
      if ("function" == typeof et ? J !== et || !el : !et.has(J))
        throw TypeError("Cannot read private member from an object whose class did not declare it");
      return "m" === eo ? el : "a" === eo ? el.call(J) : el ? el.value : et.get(J)
    };
    let base_BaseError = class base_BaseError extends Error {
      get docsBaseUrl() {
        return "https://wagmi.sh/core"
      }
      get version() {
        return getVersion()
      }
      constructor(J, et = {}) {
        super(),
          ed.add(this),
          Object.defineProperty(this, "details", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          Object.defineProperty(this, "docsPath", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          Object.defineProperty(this, "metaMessages", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          Object.defineProperty(this, "shortMessage", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "WagmiCoreError"
          });
        let eo = et.cause instanceof base_BaseError ? et.cause.details : et.cause?.message ? et.cause.message : et.details
          , el = et.cause instanceof base_BaseError && et.cause.docsPath || et.docsPath;
        this.message = [J || "An error occurred.", "", ...et.metaMessages ? [...et.metaMessages, ""] : [], ...el ? [`Docs: ${this.docsBaseUrl}${el}.html${et.docsSlug ? `#${et.docsSlug}` : ""}`] : [], ...eo ? [`Details: ${eo}`] : [], `Version: ${this.version}`].join("\n"),
          et.cause && (this.cause = et.cause),
          this.details = eo,
          this.docsPath = el,
          this.metaMessages = et.metaMessages,
          this.shortMessage = J
      }
      walk(J) {
        return __classPrivateFieldGet(this, ed, "m", eh).call(this, this, J)
      }
    }
      ;
    ed = new WeakSet,
      eh = function _BaseError_walk(J, et) {
        return et?.(J) ? J : J.cause ? __classPrivateFieldGet(this, ed, "m", _BaseError_walk).call(this, J.cause, et) : J
      }
      ;
    let ChainNotConfiguredError = class ChainNotConfiguredError extends base_BaseError {
      constructor() {
        super("Chain not configured."),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ChainNotConfiguredError"
          })
      }
    }
      ;
    let ConnectorAlreadyConnectedError = class ConnectorAlreadyConnectedError extends base_BaseError {
      constructor() {
        super("Connector already connected."),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ConnectorAlreadyConnectedError"
          })
      }
    }
      ;
    let ConnectorNotConnectedError = class ConnectorNotConnectedError extends base_BaseError {
      constructor() {
        super("Connector not connected."),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ConnectorNotConnectedError"
          })
      }
    }
      ;
    let ConnectorAccountNotFoundError = class ConnectorAccountNotFoundError extends base_BaseError {
      constructor({ address: J, connector: et }) {
        super(`Account "${J}" not found for connector "${et.name}".`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ConnectorAccountNotFoundError"
          })
      }
    }
      ;
    let SwitchChainNotSupportedError = class SwitchChainNotSupportedError extends base_BaseError {
      constructor({ connector: J }) {
        super(`"${J.name}" does not support programmatic chain switching.`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "SwitchChainNotSupportedError"
          })
      }
    }
      ;
    async function switchChain(J, et) {
      let { chainId: eo } = et
        , el = J.state.connections.get(et.connector?.uid ?? J.state.current);
      if (el) {
        let J = el.connector;
        if (!J.switchChain)
          throw new SwitchChainNotSupportedError({
            connector: J
          });
        let et = await J.switchChain({
          chainId: eo
        });
        return et
      }
      let ec = J.chains.find(J => J.id === eo);
      if (!ec)
        throw new ChainNotConfiguredError;
      return J.setState(J => ({
        ...J,
        chainId: eo
      })),
        ec
    }
    async function connect(J, et) {
      let eo;
      if ((eo = "function" == typeof et.connector ? J._internal.connectors.setup(et.connector) : et.connector).uid === J.state.current)
        throw new ConnectorAlreadyConnectedError;
      try {
        J.setState(J => ({
          ...J,
          status: "connecting"
        })),
          eo.emitter.emit("message", {
            type: "connecting"
          });
        let el = await eo.connect({
          chainId: et.chainId
        })
          , ec = el.accounts;
        return eo.emitter.off("connect", J._internal.events.connect),
          eo.emitter.on("change", J._internal.events.change),
          eo.emitter.on("disconnect", J._internal.events.disconnect),
          await J.storage?.setItem("recentConnectorId", eo.id),
          J.setState(J => ({
            ...J,
            connections: new Map(J.connections).set(eo.uid, {
              accounts: ec,
              chainId: el.chainId,
              connector: eo
            }),
            current: eo.uid,
            status: "connected"
          })),
        {
          accounts: ec,
          chainId: el.chainId
        }
      } catch (et) {
        throw J.setState(J => ({
          ...J,
          status: J.current ? "connected" : "disconnected"
        })),
        et
      }
    }
    async function disconnect(J, et = {}) {
      let eo;
      if (et.connector)
        eo = et.connector;
      else {
        let { connections: et, current: el } = J.state
          , ec = et.get(el);
        eo = ec?.connector
      }
      let el = J.state.connections;
      eo && (await eo.disconnect(),
        eo.emitter.off("change", J._internal.events.change),
        eo.emitter.off("disconnect", J._internal.events.disconnect),
        eo.emitter.on("connect", J._internal.events.connect),
        el.delete(eo.uid)),
        J.setState(J => {
          if (0 === el.size)
            return {
              ...J,
              connections: new Map,
              current: void 0,
              status: "disconnected"
            };
          let et = el.values().next().value;
          return {
            ...J,
            connections: new Map(el),
            current: et.connector.uid
          }
        }
        );
      {
        let et = J.state.current;
        if (!et)
          return;
        let eo = J.state.connections.get(et)?.connector;
        if (!eo)
          return;
        await J.storage?.setItem("recentConnectorId", eo.id)
      }
    }
    var ep = eo(14503)
      , ef = eo(8998)
      , em = eo(92106);
    async function signMessage(J, { account: et = J.account, message: eo }) {
      if (!et)
        throw new ef.o({
          docsPath: "/docs/actions/wallet/signMessage"
        });
      let el = (0,
        ep.T)(et);
      if ("local" === el.type)
        return el.signMessage({
          message: eo
        });
      let ec = "string" == typeof eo ? (0,
        em.$G)(eo) : eo.raw instanceof Uint8Array ? (0,
          em.NC)(eo.raw) : eo.raw;
      return J.request({
        method: "personal_sign",
        params: [ec, el.address]
      }, {
        retryCount: 0
      })
    }
    var eg = eo(81946)
      , ey = eo(16189)
      , eb = eo(3980);
    async function getConnectorClient(J, et = {}) {
      let eo;
      if (et.connector) {
        let { connector: J } = et
          , [el, ec] = await Promise.all([J.getAccounts(), J.getChainId()]);
        eo = {
          accounts: el,
          chainId: ec,
          connector: J
        }
      } else
        eo = J.state.connections.get(J.state.current);
      if (!eo)
        throw new ConnectorNotConnectedError;
      let el = et.chainId ?? eo.chainId
        , ec = eo.connector;
      if (ec.getClient)
        return ec.getClient({
          chainId: el
        });
      let ed = (0,
        ep.T)(et.account ?? eo.accounts[0])
        , eh = J.chains.find(J => J.id === el)
        , ef = await eo.connector.getProvider({
          chainId: el
        });
      if (et.account && !eo.accounts.includes(ed.address))
        throw new ConnectorAccountNotFoundError({
          address: ed.address,
          connector: ec
        });
      return (0,
        ey.e)({
          account: ed,
          chain: eh,
          name: "Connector Client",
          transport: J => (0,
            eb.P)(ef)({
              ...J,
              retryCount: 0
            })
        })
    }
    async function signMessage_signMessage(J, et) {
      let { account: eo, connector: el, ...ec } = et
        , ed = await getConnectorClient(J, {
          account: eo,
          connector: el
        })
        , eh = (0,
          eg.s)(ed, signMessage, "signMessage");
      return eh(ec)
    }
    function getAccount(J) {
      let et = J.state.current
        , eo = J.state.connections.get(et)
        , el = eo?.accounts
        , ec = el?.[0]
        , ed = J.chains.find(J => J.id === eo?.chainId)
        , eh = J.state.status;
      switch (eh) {
        case "connected":
          return {
            address: ec,
            addresses: el,
            chain: ed,
            chainId: eo?.chainId,
            connector: eo?.connector,
            isConnected: !0,
            isConnecting: !1,
            isDisconnected: !1,
            isReconnecting: !1,
            status: eh
          };
        case "reconnecting":
          return {
            address: ec,
            addresses: el,
            chain: ed,
            chainId: eo?.chainId,
            connector: eo?.connector,
            isConnected: !!ec,
            isConnecting: !1,
            isDisconnected: !1,
            isReconnecting: !0,
            status: eh
          };
        case "connecting":
          return {
            address: ec,
            addresses: el,
            chain: ed,
            chainId: eo?.chainId,
            connector: eo?.connector,
            isConnected: !1,
            isConnecting: !0,
            isDisconnected: !1,
            isReconnecting: !1,
            status: eh
          };
        case "disconnected":
          return {
            address: void 0,
            addresses: void 0,
            chain: void 0,
            chainId: void 0,
            connector: void 0,
            isConnected: !1,
            isConnecting: !1,
            isDisconnected: !0,
            isReconnecting: !1,
            status: eh
          }
      }
    }
    var ew = eo(16693)
      , e_ = eo(47864)
      , ex = eo(21746)
      , eE = eo(62027)
      , eC = eo(97405);
    function isNullUniversalResolverError(J, et) {
      if (!(J instanceof eE.G))
        return !1;
      let eo = J.walk(J => J instanceof eC.Lu);
      return eo instanceof eC.Lu && (!!(eo.data?.errorName === "ResolverNotFound" || eo.data?.errorName === "ResolverWildcardNotSupported" || eo.data?.errorName === "ResolverNotContract" || eo.data?.errorName === "ResolverError" || eo.data?.errorName === "HttpError" || eo.reason?.includes("Wildcard on non-extended resolvers is not supported")) || "reverse" === et && eo.reason === ex.$[50])
    }
    var eS = eo(11187)
      , ek = eo(56254)
      , eT = eo(15102);
    function encodedLabelToLabelhash(J) {
      if (66 !== J.length || 0 !== J.indexOf("[") || 65 !== J.indexOf("]"))
        return null;
      let et = `0x${J.slice(1, 65)}`;
      return (0,
        eT.v)(et) ? et : null
    }
    function packetToBytes(J) {
      let et = J.replace(/^\.|\.$/gm, "");
      if (0 === et.length)
        return new Uint8Array(1);
      let eo = new Uint8Array((0,
        eS.qX)(et).byteLength + 2)
        , el = 0
        , ec = et.split(".");
      for (let J = 0; J < ec.length; J++) {
        let et = (0,
          eS.qX)(ec[J]);
        if (et.byteLength > 255) {
          var ed;
          et = (0,
            eS.qX)((ed = function (J) {
              let et = new Uint8Array(32).fill(0);
              return J ? encodedLabelToLabelhash(J) || (0,
                ek.w)((0,
                  eS.qX)(J)) : (0,
                    em.ci)(et)
            }(ec[J]),
              `[${ed.slice(2)}]`))
        }
        eo[el] = et.length,
          eo.set(et, el + 1),
          el += et.length + 1
      }
      return eo.byteLength !== el + 1 ? eo.slice(0, el + 1) : eo
    }
    var eA = eo(93714)
      , eP = eo(88819);
    async function getEnsName(J, { address: et, blockNumber: eo, blockTag: el, gatewayUrls: ec, strict: ed, universalResolverAddress: eh }) {
      let ep = eh;
      if (!ep) {
        if (!J.chain)
          throw Error("client chain not configured. universalResolverAddress is required.");
        ep = (0,
          e_.L)({
            blockNumber: eo,
            chain: J.chain,
            contract: "ensUniversalResolver"
          })
      }
      let ef = `${et.toLowerCase().substring(2)}.addr.reverse`;
      try {
        let ed = {
          address: ep,
          abi: ew.du,
          functionName: "reverse",
          args: [(0,
            em.NC)(packetToBytes(ef))],
          blockNumber: eo,
          blockTag: el
        }
          , eh = (0,
            eA.s)(J, eP.L, "readContract")
          , [eg, ey] = ec ? await eh({
            ...ed,
            args: [...ed.args, ec]
          }) : await eh(ed);
        if (et.toLowerCase() !== ey.toLowerCase())
          return null;
        return eg
      } catch (J) {
        if (ed)
          throw J;
        if (isNullUniversalResolverError(J, "reverse"))
          return null;
        throw J
      }
    }
    let EnsAvatarInvalidMetadataError = class EnsAvatarInvalidMetadataError extends eE.G {
      constructor({ data: J }) {
        super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
          metaMessages: ["- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.", "", `Provided data: ${JSON.stringify(J)}`]
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "EnsAvatarInvalidMetadataError"
          })
      }
    }
      ;
    let EnsAvatarInvalidNftUriError = class EnsAvatarInvalidNftUriError extends eE.G {
      constructor({ reason: J }) {
        super(`ENS NFT avatar URI is invalid. ${J}`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "EnsAvatarInvalidNftUriError"
          })
      }
    }
      ;
    let EnsAvatarUriResolutionError = class EnsAvatarUriResolutionError extends eE.G {
      constructor({ uri: J }) {
        super(`Unable to resolve ENS avatar URI "${J}". The URI may be malformed, invalid, or does not respond with a valid image.`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "EnsAvatarUriResolutionError"
          })
      }
    }
      ;
    let EnsAvatarUnsupportedNamespaceError = class EnsAvatarUnsupportedNamespaceError extends eE.G {
      constructor({ namespace: J }) {
        super(`ENS NFT avatar namespace "${J}" is not supported. Must be "erc721" or "erc1155".`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "EnsAvatarUnsupportedNamespaceError"
          })
      }
    }
      ;
    let eR = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/
      , eI = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/
      , eO = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/
      , eN = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
    async function isImageUri(J) {
      try {
        let et = await fetch(J, {
          method: "HEAD"
        });
        if (200 === et.status) {
          let J = et.headers.get("content-type");
          return J?.startsWith("image/")
        }
        return !1
      } catch (et) {
        if ("object" == typeof et && void 0 !== et.response || !globalThis.hasOwnProperty("Image"))
          return !1;
        return new Promise(et => {
          let eo = new Image;
          eo.onload = () => {
            et(!0)
          }
            ,
            eo.onerror = () => {
              et(!1)
            }
            ,
            eo.src = J
        }
        )
      }
    }
    function getGateway(J, et) {
      return J ? J.endsWith("/") ? J.slice(0, -1) : J : et
    }
    function resolveAvatarUri({ uri: J, gatewayUrls: et }) {
      let eo = eO.test(J);
      if (eo)
        return {
          uri: J,
          isOnChain: !0,
          isEncoded: eo
        };
      let el = getGateway(et?.ipfs, "https://ipfs.io")
        , ec = getGateway(et?.arweave, "https://arweave.net")
        , ed = J.match(eR)
        , { protocol: eh, subpath: ep, target: ef, subtarget: em = "" } = ed?.groups || {}
        , eg = "ipns:/" === eh || "ipns/" === ep
        , ey = "ipfs:/" === eh || "ipfs/" === ep || eI.test(J);
      if (J.startsWith("http") && !eg && !ey) {
        let eo = J;
        return et?.arweave && (eo = J.replace(/https:\/\/arweave.net/g, et?.arweave)),
        {
          uri: eo,
          isOnChain: !1,
          isEncoded: !1
        }
      }
      if ((eg || ey) && ef)
        return {
          uri: `${el}/${eg ? "ipns" : "ipfs"}/${ef}${em}`,
          isOnChain: !1,
          isEncoded: !1
        };
      if ("ar:/" === eh && ef)
        return {
          uri: `${ec}/${ef}${em || ""}`,
          isOnChain: !1,
          isEncoded: !1
        };
      let eb = J.replace(eN, "");
      if (eb.startsWith("<svg") && (eb = `data:image/svg+xml;base64,${btoa(eb)}`),
        eb.startsWith("data:") || eb.startsWith("{"))
        return {
          uri: eb,
          isOnChain: !0,
          isEncoded: !1
        };
      throw new EnsAvatarUriResolutionError({
        uri: J
      })
    }
    function getJsonImage(J) {
      if ("object" != typeof J || !("image" in J) && !("image_url" in J) && !("image_data" in J))
        throw new EnsAvatarInvalidMetadataError({
          data: J
        });
      return J.image || J.image_url || J.image_data
    }
    async function getMetadataAvatarUri({ gatewayUrls: J, uri: et }) {
      try {
        let eo = await fetch(et).then(J => J.json())
          , el = await parseAvatarUri({
            gatewayUrls: J,
            uri: getJsonImage(eo)
          });
        return el
      } catch {
        throw new EnsAvatarUriResolutionError({
          uri: et
        })
      }
    }
    async function parseAvatarUri({ gatewayUrls: J, uri: et }) {
      let { uri: eo, isOnChain: el } = resolveAvatarUri({
        uri: et,
        gatewayUrls: J
      });
      if (el)
        return eo;
      let ec = await isImageUri(eo);
      if (ec)
        return eo;
      throw new EnsAvatarUriResolutionError({
        uri: et
      })
    }
    async function getNftTokenUri(J, { nft: et }) {
      if ("erc721" === et.namespace)
        return (0,
          eP.L)(J, {
            address: et.contractAddress,
            abi: [{
              name: "tokenURI",
              type: "function",
              stateMutability: "view",
              inputs: [{
                name: "tokenId",
                type: "uint256"
              }],
              outputs: [{
                name: "",
                type: "string"
              }]
            }],
            functionName: "tokenURI",
            args: [BigInt(et.tokenID)]
          });
      if ("erc1155" === et.namespace)
        return (0,
          eP.L)(J, {
            address: et.contractAddress,
            abi: [{
              name: "uri",
              type: "function",
              stateMutability: "view",
              inputs: [{
                name: "_id",
                type: "uint256"
              }],
              outputs: [{
                name: "",
                type: "string"
              }]
            }],
            functionName: "uri",
            args: [BigInt(et.tokenID)]
          });
      throw new EnsAvatarUnsupportedNamespaceError({
        namespace: et.namespace
      })
    }
    async function parseAvatarRecord(J, { gatewayUrls: et, record: eo }) {
      return /eip155:/i.test(eo) ? parseNftAvatarUri(J, {
        gatewayUrls: et,
        record: eo
      }) : parseAvatarUri({
        uri: eo,
        gatewayUrls: et
      })
    }
    async function parseNftAvatarUri(J, { gatewayUrls: et, record: eo }) {
      let el = function (J) {
        let et = J;
        et.startsWith("did:nft:") && (et = et.replace("did:nft:", "").replace(/_/g, "/"));
        let [eo, el, ec] = et.split("/")
          , [ed, eh] = eo.split(":")
          , [ep, ef] = el.split(":");
        if (!ed || "eip155" !== ed.toLowerCase())
          throw new EnsAvatarInvalidNftUriError({
            reason: "Only EIP-155 supported"
          });
        if (!eh)
          throw new EnsAvatarInvalidNftUriError({
            reason: "Chain ID not found"
          });
        if (!ef)
          throw new EnsAvatarInvalidNftUriError({
            reason: "Contract address not found"
          });
        if (!ec)
          throw new EnsAvatarInvalidNftUriError({
            reason: "Token ID not found"
          });
        if (!ep)
          throw new EnsAvatarInvalidNftUriError({
            reason: "ERC namespace not found"
          });
        return {
          chainID: parseInt(eh),
          namespace: ep.toLowerCase(),
          contractAddress: ef,
          tokenID: ec
        }
      }(eo)
        , ec = await getNftTokenUri(J, {
          nft: el
        })
        , { uri: ed, isOnChain: eh, isEncoded: ep } = resolveAvatarUri({
          uri: ec,
          gatewayUrls: et
        });
      if (eh && (ed.includes("data:application/json;base64,") || ed.startsWith("{"))) {
        let J = ep ? atob(ed.replace("data:application/json;base64,", "")) : ed
          , eo = JSON.parse(J);
        return parseAvatarUri({
          uri: getJsonImage(eo),
          gatewayUrls: et
        })
      }
      let ef = el.tokenID;
      return "erc1155" === el.namespace && (ef = ef.replace("0x", "").padStart(64, "0")),
        getMetadataAvatarUri({
          gatewayUrls: et,
          uri: ed.replace(/(?:0x)?{id}/, ef)
        })
    }
    var eM = eo(7210)
      , eD = eo(77799)
      , ej = eo(57040);
    async function getEnsText(J, { blockNumber: et, blockTag: eo, name: el, key: ec, gatewayUrls: ed, strict: eh, universalResolverAddress: ep }) {
      let ef = ep;
      if (!ef) {
        if (!J.chain)
          throw Error("client chain not configured. universalResolverAddress is required.");
        ef = (0,
          e_.L)({
            blockNumber: et,
            chain: J.chain,
            contract: "ensUniversalResolver"
          })
      }
      try {
        let eh = {
          address: ef,
          abi: ew.k3,
          functionName: "resolve",
          args: [(0,
            em.NC)(packetToBytes(el)), (0,
              eD.R)({
                abi: ew.nZ,
                functionName: "text",
                args: [function (J) {
                  let et = new Uint8Array(32).fill(0);
                  if (!J)
                    return (0,
                      em.ci)(et);
                  let eo = J.split(".");
                  for (let J = eo.length - 1; J >= 0; J -= 1) {
                    let el = encodedLabelToLabelhash(eo[J])
                      , ec = el ? (0,
                        eS.O0)(el) : (0,
                          ek.w)((0,
                            eS.qX)(eo[J]), "bytes");
                    et = (0,
                      ek.w)((0,
                        ej.zo)([et, ec]), "bytes")
                  }
                  return (0,
                    em.ci)(et)
                }(el), ec]
              })],
          blockNumber: et,
          blockTag: eo
        }
          , ep = (0,
            eA.s)(J, eP.L, "readContract")
          , eg = ed ? await ep({
            ...eh,
            args: [...eh.args, ed]
          }) : await ep(eh);
        if ("0x" === eg[0])
          return null;
        let ey = (0,
          eM.k)({
            abi: ew.nZ,
            functionName: "text",
            data: eg[0]
          });
        return "" === ey ? null : ey
      } catch (J) {
        if (eh)
          throw J;
        if (isNullUniversalResolverError(J, "resolve"))
          return null;
        throw J
      }
    }
    async function getEnsAvatar(J, { blockNumber: et, blockTag: eo, assetGatewayUrls: el, name: ec, gatewayUrls: ed, strict: eh, universalResolverAddress: ep }) {
      let ef = await (0,
        eA.s)(J, getEnsText, "getEnsText")({
          blockNumber: et,
          blockTag: eo,
          key: "avatar",
          name: ec,
          universalResolverAddress: ep,
          gatewayUrls: ed,
          strict: eh
        });
      if (!ef)
        return null;
      try {
        return await parseAvatarRecord(J, {
          record: ef,
          gatewayUrls: el
        })
      } catch {
        return null
      }
    }
    var eL = eo(95946)
      , e$ = eo(61836)
      , eB = eo(15229)
      , eF = eo(88930)
      , eU = eo(84192);
    function getUnit(J) {
      return "number" == typeof J ? J : "wei" === J ? 0 : Math.abs(eU.Bd[J])
    }
    var ez = eo(9884);
    async function multicall_multicall(J, et) {
      let { allowFailure: eo = !0, chainId: el, contracts: ec, ...ed } = et
        , eh = J.getClient({
          chainId: el
        })
        , ep = (0,
          eg.s)(eh, ez.A, "multicall");
      return ep({
        allowFailure: eo,
        contracts: ec,
        ...ed
      })
    }
    var eH = eo(37003);
    async function readContracts(J, et) {
      let { allowFailure: eo = !0, blockNumber: el, blockTag: ec, ...ed } = et
        , eh = et.contracts;
      try {
        let et = eh.reduce((et, eo, el) => {
          let ec = eo.chainId ?? J.state.chainId;
          return {
            ...et,
            [ec]: [...et[ec] || [], {
              contract: eo,
              index: el
            }]
          }
        }
          , {})
          , el = (await Promise.all(Object.entries(et).map(([et, el]) => multicall_multicall(J, {
            ...ed,
            allowFailure: eo,
            chainId: parseInt(et),
            contracts: el.map(({ contract: J }) => J)
          })))).flat()
          , ec = Object.values(et).flatMap(J => J.map(({ index: J }) => J));
        return el.reduce((J, et, eo) => (J && (J[ec[eo]] = et),
          J), [])
      } catch (et) {
        if (et instanceof eC.uq)
          throw et;
        let promises = () => eh.map(et => (0,
          eH.L)(J, {
            ...et,
            blockNumber: el,
            blockTag: ec
          }));
        if (eo)
          return (await Promise.allSettled(promises())).map(J => "fulfilled" === J.status ? {
            result: J.value,
            status: "success"
          } : {
            error: J.reason,
            result: void 0,
            status: "failure"
          });
        return await Promise.all(promises())
      }
    }
    async function getBalance_getBalance(J, et) {
      let { address: eo, blockNumber: el, blockTag: ec, chainId: ed, token: eh, unit: ep = "ether" } = et;
      if (eh)
        try {
          return getTokenBalance(J, {
            balanceAddress: eo,
            chainId: ed,
            symbolType: "string",
            tokenAddress: eh
          })
        } catch (et) {
          if (et instanceof eC.uq) {
            let et = await getTokenBalance(J, {
              balanceAddress: eo,
              chainId: ed,
              symbolType: "bytes32",
              tokenAddress: eh
            })
              , el = (0,
                eL.rR)((0,
                  e$.f)(et.symbol, {
                    dir: "right"
                  }));
            return {
              ...et,
              symbol: el
            }
          }
          throw et
        }
      let ef = J.getClient({
        chainId: ed
      })
        , em = (0,
          eg.s)(ef, eF.s, "getBalance")
        , ey = await em(el ? {
          address: eo,
          blockNumber: el
        } : {
          address: eo,
          blockTag: ec
        })
        , eb = J.chains.find(J => J.id === ed) ?? ef.chain;
      return {
        decimals: eb.nativeCurrency.decimals,
        formatted: (0,
          eB.b)(ey, getUnit(ep)),
        symbol: eb.nativeCurrency.symbol,
        value: ey
      }
    }
    async function getTokenBalance(J, et) {
      let { balanceAddress: eo, chainId: el, symbolType: ec, tokenAddress: ed, unit: eh } = et
        , ep = {
          abi: [{
            type: "function",
            name: "balanceOf",
            stateMutability: "view",
            inputs: [{
              type: "address"
            }],
            outputs: [{
              type: "uint256"
            }]
          }, {
            type: "function",
            name: "decimals",
            stateMutability: "view",
            inputs: [],
            outputs: [{
              type: "uint8"
            }]
          }, {
            type: "function",
            name: "symbol",
            stateMutability: "view",
            inputs: [],
            outputs: [{
              type: ec
            }]
          }],
          address: ed
        }
        , [ef, em, eg] = await readContracts(J, {
          allowFailure: !1,
          contracts: [{
            ...ep,
            functionName: "balanceOf",
            args: [eo],
            chainId: el
          }, {
            ...ep,
            functionName: "decimals",
            chainId: el
          }, {
            ...ep,
            functionName: "symbol",
            chainId: el
          }]
        })
        , ey = (0,
          eB.b)(ef ?? "0", getUnit(eh ?? em));
      return {
        decimals: em,
        formatted: ey,
        symbol: eg,
        value: ef
      }
    }
    var eV = eo(86164);
    let eW = (0,
      eV.a)({
        id: 1,
        name: "Ethereum",
        nativeCurrency: {
          name: "Ether",
          symbol: "ETH",
          decimals: 18
        },
        rpcUrls: {
          default: {
            http: ["https://cloudflare-eth.com"]
          }
        },
        blockExplorers: {
          default: {
            name: "Etherscan",
            url: "https://etherscan.io",
            apiUrl: "https://api.etherscan.io/api"
          }
        },
        contracts: {
          ensRegistry: {
            address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
          },
          ensUniversalResolver: {
            address: "0x8cab227b1162f03b8338331adaad7aadc83b895e",
            blockCreated: 18958930
          },
          multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 14353601
          }
        }
      });
    var eZ = eo(76472)
      , eG = eo(87214)
      , eY = eo(77996)
      , eK = eo(37380)
      , eJ = eo(35592)
      , __decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let eQ = class extends eY.oi {
      constructor() {
        super(),
          this.unsubscribe = [],
          this.disabled = !1,
          this.balance = "show",
          this.charsStart = 4,
          this.charsEnd = 6,
          this.address = eZ.AccountController.state.address,
          this.balanceVal = eZ.AccountController.state.balance,
          this.balanceSymbol = eZ.AccountController.state.balanceSymbol,
          this.profileName = eZ.AccountController.state.profileName,
          this.profileImage = eZ.AccountController.state.profileImage,
          this.network = eZ.NetworkController.state.caipNetwork,
          this.unsubscribe.push(...[eZ.AccountController.subscribe(J => {
            J.isConnected ? (this.address = J.address,
              this.balanceVal = J.balance,
              this.profileName = J.profileName,
              this.profileImage = J.profileImage,
              this.balanceSymbol = J.balanceSymbol) : (this.address = "",
                this.balanceVal = "",
                this.profileName = "",
                this.profileImage = "",
                this.balanceSymbol = "")
          }
          ), eZ.NetworkController.subscribeKey("caipNetwork", J => this.network = J)])
      }
      disconnectedCallback() {
        this.unsubscribe.forEach(J => J())
      }
      render() {
        let J = eZ.fz.getNetworkImage(this.network)
          , et = "show" === this.balance;
        return eY.dy`
    <wui-account-button
      .disabled=${!!this.disabled}
      address=${(0,
            eJ.o)(this.profileName ?? this.address)}
      ?isProfileName=${!!this.profileName}
      networkSrc=${(0,
            eJ.o)(J)}
      avatarSrc=${(0,
            eJ.o)(this.profileImage)}
      balance=${et ? eZ.j1.formatBalance(this.balanceVal, this.balanceSymbol) : ""}
      @click=${this.onClick.bind(this)}
      data-testid="account-button"
      .charsStart=${this.charsStart}
      .charsEnd=${this.charsEnd}
    >
    </wui-account-button>
  `
      }
      onClick() {
        eZ.IN.open()
      }
    }
      ;
    __decorate([(0,
      eK.Cb)({
        type: Boolean
      })], eQ.prototype, "disabled", void 0),
      __decorate([(0,
        eK.Cb)()], eQ.prototype, "balance", void 0),
      __decorate([(0,
        eK.Cb)()], eQ.prototype, "charsStart", void 0),
      __decorate([(0,
        eK.Cb)()], eQ.prototype, "charsEnd", void 0),
      __decorate([(0,
        eK.SB)()], eQ.prototype, "address", void 0),
      __decorate([(0,
        eK.SB)()], eQ.prototype, "balanceVal", void 0),
      __decorate([(0,
        eK.SB)()], eQ.prototype, "balanceSymbol", void 0),
      __decorate([(0,
        eK.SB)()], eQ.prototype, "profileName", void 0),
      __decorate([(0,
        eK.SB)()], eQ.prototype, "profileImage", void 0),
      __decorate([(0,
        eK.SB)()], eQ.prototype, "network", void 0),
      eQ = __decorate([(0,
        eG.customElement)("w3m-account-button")], eQ);
    var eX = eY.iv`
:host {
  display: block;
  width: max-content;
}
`
      , w3m_button_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let e0 = class extends eY.oi {
      constructor() {
        super(),
          this.unsubscribe = [],
          this.disabled = !1,
          this.balance = void 0,
          this.size = void 0,
          this.label = void 0,
          this.loadingLabel = void 0,
          this.charsStart = 4,
          this.charsEnd = 6,
          this.isAccount = eZ.AccountController.state.isConnected,
          this.unsubscribe.push(eZ.AccountController.subscribeKey("isConnected", J => {
            this.isAccount = J
          }
          ))
      }
      disconnectedCallback() {
        this.unsubscribe.forEach(J => J())
      }
      render() {
        return this.isAccount ? eY.dy`
        <w3m-account-button
          .disabled=${!!this.disabled}
          balance=${(0,
            eJ.o)(this.balance)}
          .charsStart=${(0,
            eJ.o)(this.charsStart)}
          .charsEnd=${(0,
            eJ.o)(this.charsEnd)}
        >
        </w3m-account-button>
      ` : eY.dy`
        <w3m-connect-button
          size=${(0,
            eJ.o)(this.size)}
          label=${(0,
            eJ.o)(this.label)}
          loadingLabel=${(0,
            eJ.o)(this.loadingLabel)}
        ></w3m-connect-button>
      `
      }
    }
      ;
    e0.styles = eX,
      w3m_button_decorate([(0,
        eK.Cb)({
          type: Boolean
        })], e0.prototype, "disabled", void 0),
      w3m_button_decorate([(0,
        eK.Cb)()], e0.prototype, "balance", void 0),
      w3m_button_decorate([(0,
        eK.Cb)()], e0.prototype, "size", void 0),
      w3m_button_decorate([(0,
        eK.Cb)()], e0.prototype, "label", void 0),
      w3m_button_decorate([(0,
        eK.Cb)()], e0.prototype, "loadingLabel", void 0),
      w3m_button_decorate([(0,
        eK.Cb)()], e0.prototype, "charsStart", void 0),
      w3m_button_decorate([(0,
        eK.Cb)()], e0.prototype, "charsEnd", void 0),
      w3m_button_decorate([(0,
        eK.SB)()], e0.prototype, "isAccount", void 0),
      e0 = w3m_button_decorate([(0,
        eG.customElement)("w3m-button")], e0);
    var w3m_connect_button_decorate = function (J, et, eo, el) {
      var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        eh = Reflect.decorate(J, et, eo, el);
      else
        for (var ep = J.length - 1; ep >= 0; ep--)
          (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
      return ed > 3 && eh && Object.defineProperty(et, eo, eh),
        eh
    };
    let e1 = class extends eY.oi {
      constructor() {
        super(),
          this.unsubscribe = [],
          this.size = "md",
          this.label = "Connect Wallet",
          this.loadingLabel = "Connecting...",
          this.open = eZ.IN.state.open,
          this.loading = eZ.IN.state.loading,
          this.unsubscribe.push(eZ.IN.subscribe(J => {
            this.open = J.open,
              this.loading = J.loading
          }
          ))
      }
      disconnectedCallback() {
        this.unsubscribe.forEach(J => J())
      }
      render() {
        let J = this.loading || this.open;
        return eY.dy`
    <wui-connect-button
      size=${(0,
            eJ.o)(this.size)}
      .loading=${J}
      @click=${this.onClick.bind(this)}
      data-testid="connect-button"
    >
      ${J ? this.loadingLabel : this.label}
    </wui-connect-button>
  `
      }
      onClick() {
        this.open ? eZ.IN.close() : this.loading || eZ.IN.open()
      }
    }
      ;
    w3m_connect_button_decorate([(0,
      eK.Cb)()], e1.prototype, "size", void 0),
      w3m_connect_button_decorate([(0,
        eK.Cb)()], e1.prototype, "label", void 0),
      w3m_connect_button_decorate([(0,
        eK.Cb)()], e1.prototype, "loadingLabel", void 0),
      w3m_connect_button_decorate([(0,
        eK.SB)()], e1.prototype, "open", void 0),
      w3m_connect_button_decorate([(0,
        eK.SB)()], e1.prototype, "loading", void 0),
      e1 = w3m_connect_button_decorate([(0,
        eG.customElement)("w3m-connect-button")], e1),
      eo(90078);
    var e2 = eY.iv`
:host {
  display: block;
  width: max-content;
}
`
      , w3m_network_button_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let e3 = class extends eY.oi {
      constructor() {
        super(),
          this.unsubscribe = [],
          this.disabled = !1,
          this.network = eZ.NetworkController.state.caipNetwork,
          this.connected = eZ.AccountController.state.isConnected,
          this.loading = eZ.IN.state.loading,
          this.unsubscribe.push(...[eZ.NetworkController.subscribeKey("caipNetwork", J => this.network = J), eZ.AccountController.subscribeKey("isConnected", J => this.connected = J), eZ.IN.subscribeKey("loading", J => this.loading = J)])
      }
      disconnectedCallback() {
        this.unsubscribe.forEach(J => J())
      }
      render() {
        return eY.dy`
    <wui-network-button
      .disabled=${!!(this.disabled || this.loading)}
      imageSrc=${(0,
            eJ.o)(eZ.fz.getNetworkImage(this.network))}
      @click=${this.onClick.bind(this)}
    >
      ${this.network?.name ?? (this.connected ? "Unknown Network" : "Select Network")}
    </wui-network-button>
  `
      }
      onClick() {
        this.loading || eZ.IN.open({
          view: "Networks"
        })
      }
    }
      ;
    e3.styles = e2,
      w3m_network_button_decorate([(0,
        eK.Cb)({
          type: Boolean
        })], e3.prototype, "disabled", void 0),
      w3m_network_button_decorate([(0,
        eK.SB)()], e3.prototype, "network", void 0),
      w3m_network_button_decorate([(0,
        eK.SB)()], e3.prototype, "connected", void 0),
      w3m_network_button_decorate([(0,
        eK.SB)()], e3.prototype, "loading", void 0),
      e3 = w3m_network_button_decorate([(0,
        eG.customElement)("w3m-network-button")], e3);
    var e5 = eY.iv`
:host {
  display: block;
  will-change: transform, opacity;
}
`
      , w3m_router_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let e6 = class extends eY.oi {
      constructor() {
        super(),
          this.resizeObserver = void 0,
          this.prevHeight = "0px",
          this.prevHistoryLength = 1,
          this.unsubscribe = [],
          this.view = eZ.RouterController.state.view,
          this.unsubscribe.push(eZ.RouterController.subscribeKey("view", J => this.onViewChange(J)))
      }
      firstUpdated() {
        this.resizeObserver = new ResizeObserver(async ([J]) => {
          let et = `${J?.contentRect.height}px`;
          "0px" !== this.prevHeight && (await this.animate([{
            height: this.prevHeight
          }, {
            height: et
          }], {
            duration: 150,
            easing: "ease",
            fill: "forwards"
          }).finished,
            this.style.height = "auto"),
            this.prevHeight = et
        }
        ),
          this.resizeObserver.observe(this.getWrapper())
      }
      disconnectedCallback() {
        this.resizeObserver?.unobserve(this.getWrapper()),
          this.unsubscribe.forEach(J => J())
      }
      render() {
        return eY.dy`<div>${this.viewTemplate()}</div>`
      }
      viewTemplate() {
        switch (this.view) {
          case "Connect":
          default:
            return eY.dy`<w3m-connect-view></w3m-connect-view>`;
          case "ConnectingWalletConnect":
            return eY.dy`<w3m-connecting-wc-view></w3m-connecting-wc-view>`;
          case "ConnectingExternal":
            return eY.dy`<w3m-connecting-external-view></w3m-connecting-external-view>`;
          case "ConnectingSiwe":
            return eY.dy`<w3m-connecting-siwe-view></w3m-connecting-siwe-view>`;
          case "AllWallets":
            return eY.dy`<w3m-all-wallets-view></w3m-all-wallets-view>`;
          case "Networks":
            return eY.dy`<w3m-networks-view></w3m-networks-view>`;
          case "SwitchNetwork":
            return eY.dy`<w3m-network-switch-view></w3m-network-switch-view>`;
          case "Account":
            return eY.dy`<w3m-account-view></w3m-account-view>`;
          case "WhatIsAWallet":
            return eY.dy`<w3m-what-is-a-wallet-view></w3m-what-is-a-wallet-view>`;
          case "WhatIsANetwork":
            return eY.dy`<w3m-what-is-a-network-view></w3m-what-is-a-network-view>`;
          case "GetWallet":
            return eY.dy`<w3m-get-wallet-view></w3m-get-wallet-view>`;
          case "Downloads":
            return eY.dy`<w3m-downloads-view></w3m-downloads-view>`;
          case "EmailVerifyOtp":
            return eY.dy`<w3m-email-verify-otp-view></w3m-email-verify-otp-view>`;
          case "EmailVerifyDevice":
            return eY.dy`<w3m-email-verify-device-view></w3m-email-verify-device-view>`;
          case "ApproveTransaction":
            return eY.dy`<w3m-approve-transaction-view></w3m-approve-transaction-view>`;
          case "Transactions":
            return eY.dy`<w3m-transactions-view></w3m-transactions-view>`;
          case "UpgradeEmailWallet":
            return eY.dy`<w3m-upgrade-wallet-view></w3m-upgrade-wallet-view>`;
          case "UpdateEmailWallet":
            return eY.dy`<w3m-update-email-wallet-view></w3m-update-email-wallet-view>`;
          case "UpdateEmailPrimaryOtp":
            return eY.dy`<w3m-update-email-primary-otp-view></w3m-update-email-primary-otp-view>`;
          case "UpdateEmailSecondaryOtp":
            return eY.dy`<w3m-update-email-secondary-otp-view></w3m-update-email-secondary-otp-view>`
        }
      }
      async onViewChange(J) {
        let { history: et } = eZ.RouterController.state
          , eo = -10
          , el = 10;
        et.length < this.prevHistoryLength && (eo = 10,
          el = -10),
          this.prevHistoryLength = et.length,
          await this.animate([{
            opacity: 1,
            transform: "translateX(0px)"
          }, {
            opacity: 0,
            transform: `translateX(${eo}px)`
          }], {
            duration: 150,
            easing: "ease",
            fill: "forwards"
          }).finished,
          this.view = J,
          await this.animate([{
            opacity: 0,
            transform: `translateX(${el}px)`
          }, {
            opacity: 1,
            transform: "translateX(0px)"
          }], {
            duration: 150,
            easing: "ease",
            fill: "forwards",
            delay: 50
          }).finished
      }
      getWrapper() {
        return this.shadowRoot?.querySelector("div")
      }
    }
      ;
    e6.styles = e5,
      w3m_router_decorate([(0,
        eK.SB)()], e6.prototype, "view", void 0),
      e6 = w3m_router_decorate([(0,
        eG.customElement)("w3m-router")], e6);
    var e4 = eY.iv`
wui-flex {
  width: 100%;
}

:host > wui-flex:first-child {
  transform: translateY(calc(var(--wui-spacing-xxs) * -1));
}

wui-icon-link {
  margin-right: calc(var(--wui-icon-box-size-md) * -1);
}

wui-notice-card {
  margin-bottom: var(--wui-spacing-3xs);
}
`
      , w3m_account_view_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let e8 = class extends eY.oi {
      constructor() {
        super(),
          this.usubscribe = [],
          this.address = eZ.AccountController.state.address,
          this.profileImage = eZ.AccountController.state.profileImage,
          this.profileName = eZ.AccountController.state.profileName,
          this.balance = eZ.AccountController.state.balance,
          this.balanceSymbol = eZ.AccountController.state.balanceSymbol,
          this.network = eZ.NetworkController.state.caipNetwork,
          this.disconecting = !1,
          this.usubscribe.push(...[eZ.AccountController.subscribe(J => {
            J.address ? (this.address = J.address,
              this.profileImage = J.profileImage,
              this.profileName = J.profileName,
              this.balance = J.balance,
              this.balanceSymbol = J.balanceSymbol) : eZ.IN.close()
          }
          )], eZ.NetworkController.subscribeKey("caipNetwork", J => {
            J?.id && (this.network = J)
          }
          ))
      }
      disconnectedCallback() {
        this.usubscribe.forEach(J => J())
      }
      render() {
        if (!this.address)
          throw Error("w3m-account-view: No account provided");
        let J = eZ.fz.getNetworkImage(this.network);
        return eY.dy`
    <wui-flex
      flexDirection="column"
      .padding=${["0", "s", "m", "s"]}
      alignItems="center"
      gap="l"
    >
      <wui-avatar
        alt=${this.address}
        address=${this.address}
        imageSrc=${(0,
            eJ.o)(null === this.profileImage ? void 0 : this.profileImage)}
      ></wui-avatar>

      <wui-flex flexDirection="column" alignItems="center">
        <wui-flex gap="3xs" alignItems="center" justifyContent="center">
          <wui-text variant="large-600" color="fg-100">
            ${this.profileName ? eG.UiHelperUtil.getTruncateString({
              string: this.profileName,
              charsStart: 20,
              charsEnd: 0,
              truncate: "end"
            }) : eG.UiHelperUtil.getTruncateString({
              string: this.address,
              charsStart: 4,
              charsEnd: 6,
              truncate: "middle"
            })}
          </wui-text>
          <wui-icon-link
            size="md"
            icon="copy"
            iconColor="fg-200"
            @click=${this.onCopyAddress}
          ></wui-icon-link>
        </wui-flex>
        <wui-flex gap="s" flexDirection="column" alignItems="center">
          <wui-text variant="paragraph-500" color="fg-200">
            ${eZ.j1.formatBalance(this.balance, this.balanceSymbol)}
          </wui-text>

          ${this.explorerBtnTemplate()}
        </wui-flex>
      </wui-flex>
    </wui-flex>

    <wui-flex flexDirection="column" gap="xs" .padding=${["0", "s", "s", "s"]}>
      ${this.emailCardTemplate()} ${this.emailBtnTemplate()}

      <wui-list-item
        .variant=${J ? "image" : "icon"}
        iconVariant="overlay"
        icon="networkPlaceholder"
        imageSrc=${(0,
            eJ.o)(J)}
        ?chevron=${this.isAllowedNetworkSwitch()}
        @click=${this.onNetworks.bind(this)}
        data-testid="w3m-account-select-network"
      >
        <wui-text variant="paragraph-500" color="fg-100">
          ${this.network?.name ?? "Unknown"}
        </wui-text>
      </wui-list-item>
      <wui-list-item
        iconVariant="blue"
        icon="swapHorizontalBold"
        iconSize="sm"
        ?chevron=${!0}
        @click=${this.onTransactions.bind(this)}
      >
        <wui-text variant="paragraph-500" color="fg-100">Activity</wui-text>
      </wui-list-item>
      <wui-list-item
        variant="icon"
        iconVariant="overlay"
        icon="disconnect"
        ?chevron=${!1}
        .loading=${this.disconecting}
        @click=${this.onDisconnect.bind(this)}
        data-testid="disconnect-button"
      >
        <wui-text variant="paragraph-500" color="fg-200">Disconnect</wui-text>
      </wui-list-item>
    </wui-flex>
  `
      }
      emailCardTemplate() {
        let J = eZ.MO.getConnectedConnector()
          , et = eZ.ConnectorController.getEmailConnector()
          , { origin: eo } = location;
        return !et || "EMAIL" !== J || eo.includes(eZ.bq.SECURE_SITE) ? null : eY.dy`
    <wui-notice-card
      @click=${this.onGoToUpgradeView.bind(this)}
      label="Upgrade your wallet"
      description="Transition to a non-custodial wallet"
      icon="wallet"
    ></wui-notice-card>
  `
      }
      emailBtnTemplate() {
        let J = eZ.MO.getConnectedConnector()
          , et = eZ.ConnectorController.getEmailConnector();
        if (!et || "EMAIL" !== J)
          return null;
        let eo = et.provider.getEmail() ?? "";
        return eY.dy`
    <wui-list-item
      variant="icon"
      iconVariant="overlay"
      icon="mail"
      iconSize="sm"
      ?chevron=${!0}
      @click=${() => this.onGoToUpdateEmail(eo)}
    >
      <wui-text variant="paragraph-500" color="fg-100">${eo}</wui-text>
    </wui-list-item>
  `
      }
      explorerBtnTemplate() {
        let { addressExplorerUrl: J } = eZ.AccountController.state;
        return J ? eY.dy`
    <wui-button size="sm" variant="shade" @click=${this.onExplorer.bind(this)}>
      <wui-icon size="sm" color="inherit" slot="iconLeft" name="compass"></wui-icon>
      Block Explorer
      <wui-icon size="sm" color="inherit" slot="iconRight" name="externalLink"></wui-icon>
    </wui-button>
  ` : null
      }
      isAllowedNetworkSwitch() {
        let { requestedCaipNetworks: J } = eZ.NetworkController.state
          , et = !!J && J.length > 1
          , eo = J?.find(({ id: J }) => J === this.network?.id);
        return et || !eo
      }
      onCopyAddress() {
        try {
          this.address && (eZ.j1.copyToClopboard(this.address),
            eZ.SnackController.showSuccess("Address copied"))
        } catch {
          eZ.SnackController.showError("Failed to copy")
        }
      }
      onNetworks() {
        this.isAllowedNetworkSwitch() && eZ.RouterController.push("Networks")
      }
      onTransactions() {
        eZ.Xs.sendEvent({
          type: "track",
          event: "CLICK_TRANSACTIONS"
        }),
          eZ.RouterController.push("Transactions")
      }
      async onDisconnect() {
        try {
          this.disconecting = !0,
            await eZ.ConnectionController.disconnect(),
            eZ.Xs.sendEvent({
              type: "track",
              event: "DISCONNECT_SUCCESS"
            }),
            eZ.IN.close()
        } catch {
          eZ.Xs.sendEvent({
            type: "track",
            event: "DISCONNECT_ERROR"
          }),
            eZ.SnackController.showError("Failed to disconnect")
        } finally {
          this.disconecting = !1
        }
      }
      onExplorer() {
        let { addressExplorerUrl: J } = eZ.AccountController.state;
        J && eZ.j1.openHref(J, "_blank")
      }
      onGoToUpgradeView() {
        eZ.Xs.sendEvent({
          type: "track",
          event: "EMAIL_UPGRADE_FROM_MODAL"
        }),
          eZ.RouterController.push("UpgradeEmailWallet")
      }
      onGoToUpdateEmail(J) {
        eZ.RouterController.push("UpdateEmailWallet", {
          email: J
        })
      }
    }
      ;
    e8.styles = e4,
      w3m_account_view_decorate([(0,
        eK.SB)()], e8.prototype, "address", void 0),
      w3m_account_view_decorate([(0,
        eK.SB)()], e8.prototype, "profileImage", void 0),
      w3m_account_view_decorate([(0,
        eK.SB)()], e8.prototype, "profileName", void 0),
      w3m_account_view_decorate([(0,
        eK.SB)()], e8.prototype, "balance", void 0),
      w3m_account_view_decorate([(0,
        eK.SB)()], e8.prototype, "balanceSymbol", void 0),
      w3m_account_view_decorate([(0,
        eK.SB)()], e8.prototype, "network", void 0),
      w3m_account_view_decorate([(0,
        eK.SB)()], e8.prototype, "disconecting", void 0),
      e8 = w3m_account_view_decorate([(0,
        eG.customElement)("w3m-account-view")], e8);
    var w3m_all_wallets_view_decorate = function (J, et, eo, el) {
      var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        eh = Reflect.decorate(J, et, eo, el);
      else
        for (var ep = J.length - 1; ep >= 0; ep--)
          (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
      return ed > 3 && eh && Object.defineProperty(et, eo, eh),
        eh
    };
    let e7 = class extends eY.oi {
      constructor() {
        super(...arguments),
          this.search = "",
          this.onDebouncedSearch = eZ.j1.debounce(J => {
            this.search = J
          }
          )
      }
      render() {
        let J = this.search.length >= 2;
        return eY.dy`
    <wui-flex padding="s" gap="s">
      <wui-search-bar @inputChange=${this.onInputChange.bind(this)}></wui-search-bar>
      ${this.qrButtonTemplate()}
    </wui-flex>
    ${J ? eY.dy`<w3m-all-wallets-search query=${this.search}></w3m-all-wallets-search>` : eY.dy`<w3m-all-wallets-list></w3m-all-wallets-list>`}
  `
      }
      onInputChange(J) {
        this.onDebouncedSearch(J.detail)
      }
      qrButtonTemplate() {
        return eZ.j1.isMobile() ? eY.dy`
      <wui-icon-box
        size="lg"
        iconSize="xl"
        iconColor="accent-100"
        backgroundColor="accent-100"
        icon="qrCode"
        background="transparent"
        border
        borderColor="wui-accent-glass-010"
        @click=${this.onWalletConnectQr.bind(this)}
      ></wui-icon-box>
    ` : null
      }
      onWalletConnectQr() {
        eZ.RouterController.push("ConnectingWalletConnect")
      }
    }
      ;
    w3m_all_wallets_view_decorate([(0,
      eK.SB)()], e7.prototype, "search", void 0),
      e7 = w3m_all_wallets_view_decorate([(0,
        eG.customElement)("w3m-all-wallets-view")], e7);
    var e9 = eY.iv`
wui-flex {
  max-height: clamp(360px, 540px, 80vh);
  overflow: scroll;
  scrollbar-width: none;
}

wui-flex::-webkit-scrollbar {
  display: none;
}
`
      , w3m_connect_view_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let tn = class extends eY.oi {
      constructor() {
        super(),
          this.unsubscribe = [],
          this.connectors = eZ.ConnectorController.state.connectors,
          this.unsubscribe.push(eZ.ConnectorController.subscribeKey("connectors", J => this.connectors = J))
      }
      disconnectedCallback() {
        this.unsubscribe.forEach(J => J())
      }
      render() {
        return eY.dy`
    <wui-flex flexDirection="column" padding="s" gap="xs">
      <w3m-email-login-widget></w3m-email-login-widget>

      ${this.walletConnectConnectorTemplate()} ${this.recentTemplate()}
      ${this.announcedTemplate()} ${this.injectedTemplate()} ${this.featuredTemplate()}
      ${this.customTemplate()} ${this.recommendedTemplate()} ${this.externalTemplate()}
      ${this.allWalletsTemplate()}
    </wui-flex>
    <w3m-legal-footer></w3m-legal-footer>
  `
      }
      walletConnectConnectorTemplate() {
        if (eZ.j1.isMobile())
          return null;
        let J = this.connectors.find(J => "WALLET_CONNECT" === J.type);
        return J ? eY.dy`
    <wui-list-wallet
      imageSrc=${(0,
            eJ.o)(eZ.fz.getConnectorImage(J))}
      name=${J.name ?? "Unknown"}
      @click=${() => this.onConnector(J)}
      tagLabel="qr code"
      tagVariant="main"
      data-testid="wallet-selector-walletconnect"
    >
    </wui-list-wallet>
  ` : null
      }
      customTemplate() {
        let { customWallets: J } = eZ.OptionsController.state;
        if (!J?.length)
          return null;
        let et = this.filterOutDuplicateWallets(J);
        return et.map(J => eY.dy`
      <wui-list-wallet
        imageSrc=${(0,
            eJ.o)(eZ.fz.getWalletImage(J))}
        name=${J.name ?? "Unknown"}
        @click=${() => this.onConnectWallet(J)}
      >
      </wui-list-wallet>
    `)
      }
      featuredTemplate() {
        let J = this.connectors.find(J => "WALLET_CONNECT" === J.type);
        if (!J)
          return null;
        let { featured: et } = eZ.ApiController.state;
        if (!et.length)
          return null;
        let eo = this.filterOutDuplicateWallets(et);
        return eo.map(J => eY.dy`
      <wui-list-wallet
        imageSrc=${(0,
            eJ.o)(eZ.fz.getWalletImage(J))}
        name=${J.name ?? "Unknown"}
        @click=${() => this.onConnectWallet(J)}
      >
      </wui-list-wallet>
    `)
      }
      recentTemplate() {
        let J = eZ.MO.getRecentWallets();
        return J.map(J => eY.dy`
      <wui-list-wallet
        imageSrc=${(0,
            eJ.o)(eZ.fz.getWalletImage(J))}
        name=${J.name ?? "Unknown"}
        @click=${() => this.onConnectWallet(J)}
        tagLabel="recent"
        tagVariant="shade"
      >
      </wui-list-wallet>
    `)
      }
      announcedTemplate() {
        return this.connectors.map(J => "ANNOUNCED" !== J.type ? null : eY.dy`
      <wui-list-wallet
        imageSrc=${(0,
            eJ.o)(eZ.fz.getConnectorImage(J))}
        name=${J.name ?? "Unknown"}
        @click=${() => this.onConnector(J)}
        tagVariant="success"
        .installed=${!0}
      >
      </wui-list-wallet>
    `)
      }
      injectedTemplate() {
        return this.connectors.map(J => "INJECTED" === J.type && eZ.ConnectionController.checkInstalled() ? eY.dy`
      <wui-list-wallet
        imageSrc=${(0,
            eJ.o)(eZ.fz.getConnectorImage(J))}
        .installed=${!0}
        name=${J.name ?? "Unknown"}
        @click=${() => this.onConnector(J)}
      >
      </wui-list-wallet>
    ` : null)
      }
      externalTemplate() {
        let J = eZ.ConnectorController.getAnnouncedConnectorRdns();
        return this.connectors.map(et => ["WALLET_CONNECT", "INJECTED", "ANNOUNCED", "EMAIL"].includes(et.type) || J.includes(eZ.bq.CONNECTOR_RDNS_MAP[et.id]) ? null : eY.dy`
      <wui-list-wallet
        imageSrc=${(0,
            eJ.o)(eZ.fz.getConnectorImage(et))}
        name=${et.name ?? "Unknown"}
        @click=${() => this.onConnector(et)}
      >
      </wui-list-wallet>
    `)
      }
      allWalletsTemplate() {
        let J = this.connectors.find(J => "WALLET_CONNECT" === J.type)
          , { allWallets: et } = eZ.OptionsController.state;
        if (!J || "HIDE" === et || "ONLY_MOBILE" === et && !eZ.j1.isMobile())
          return null;
        let eo = eZ.ApiController.state.count
          , el = eZ.ApiController.state.featured.length
          , ec = eo + el
          , ed = ec < 10 ? ec : 10 * Math.floor(ec / 10)
          , eh = ed < ec ? `${ed}+` : `${ed}`;
        return eY.dy`
    <wui-list-wallet
      name="All Wallets"
      walletIcon="allWallets"
      showAllWallets
      @click=${this.onAllWallets.bind(this)}
      tagLabel=${eh}
      tagVariant="shade"
      data-testid="all-wallets"
    ></wui-list-wallet>
  `
      }
      recommendedTemplate() {
        let J = this.connectors.find(J => "WALLET_CONNECT" === J.type);
        if (!J)
          return null;
        let { recommended: et } = eZ.ApiController.state
          , { customWallets: eo, featuredWalletIds: el } = eZ.OptionsController.state
          , { connectors: ec } = eZ.ConnectorController.state
          , ed = eZ.MO.getRecentWallets()
          , eh = ec.filter(J => "INJECTED" === J.type)
          , ep = ec.filter(J => "ANNOUNCED" === J.type);
        if (el || eo || !et.length)
          return null;
        let ef = ep.length || Math.max(0, eh.length - 1)
          , em = ef + ed.length
          , eg = Math.max(0, 2 - em)
          , ey = this.filterOutDuplicateWallets(et).slice(0, eg);
        return ey.map(J => eY.dy`
      <wui-list-wallet
        imageSrc=${(0,
            eJ.o)(eZ.fz.getWalletImage(J))}
        name=${J?.name ?? "Unknown"}
        @click=${() => this.onConnectWallet(J)}
      >
      </wui-list-wallet>
    `)
      }
      onConnector(J) {
        "WALLET_CONNECT" === J.type ? eZ.j1.isMobile() ? eZ.RouterController.push("AllWallets") : eZ.RouterController.push("ConnectingWalletConnect") : eZ.RouterController.push("ConnectingExternal", {
          connector: J
        })
      }
      filterOutDuplicateWallets(J) {
        let { connectors: et } = eZ.ConnectorController.state
          , eo = eZ.MO.getRecentWallets()
          , el = eo.map(J => J.id)
          , ec = J.filter(J => !el.includes(J.id) && !et.find(et => et.id === J.rdns || et?.info?.rdns === J.rdns));
        return ec
      }
      onAllWallets() {
        eZ.Xs.sendEvent({
          type: "track",
          event: "CLICK_ALL_WALLETS"
        }),
          eZ.RouterController.push("AllWallets")
      }
      onConnectWallet(J) {
        eZ.RouterController.push("ConnectingWalletConnect", {
          wallet: J
        })
      }
    }
      ;
    tn.styles = e9,
      w3m_connect_view_decorate([(0,
        eK.SB)()], tn.prototype, "connectors", void 0),
      tn = w3m_connect_view_decorate([(0,
        eG.customElement)("w3m-connect-view")], tn);
    var to = eY.iv`
@keyframes shake {
  0% {
    transform: translateX(0);
  }
  25% {
    transform: translateX(3px);
  }
  50% {
    transform: translateX(-3px);
  }
  75% {
    transform: translateX(3px);
  }
  100% {
    transform: translateX(0);
  }
}

wui-flex:first-child:not(:only-child) {
  position: relative;
}

wui-loading-thumbnail {
  position: absolute;
}

wui-icon-box {
  position: absolute;
  right: calc(var(--wui-spacing-3xs) * -1);
  bottom: calc(var(--wui-spacing-3xs) * -1);
  opacity: 0;
  transform: scale(0.5);
  transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
}

wui-text[align='center'] {
  width: 100%;
  padding: 0px var(--wui-spacing-l);
}

[data-error='true'] wui-icon-box {
  opacity: 1;
  transform: scale(1);
}

[data-error='true'] > wui-flex:first-child {
  animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
}

[data-retry='false'] wui-link {
  display: none;
}

[data-retry='true'] wui-link {
  display: block;
  opacity: 1;
}
`
      , w3m_connecting_widget_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let W3mConnectingWidget = class W3mConnectingWidget extends eY.oi {
      constructor() {
        super(),
          this.wallet = eZ.RouterController.state.data?.wallet,
          this.connector = eZ.RouterController.state.data?.connector,
          this.timeout = void 0,
          this.secondaryBtnLabel = "Try again",
          this.secondaryBtnIcon = "refresh",
          this.secondaryLabel = "Accept connection request in the wallet",
          this.onConnect = void 0,
          this.onRender = void 0,
          this.onAutoConnect = void 0,
          this.isWalletConnect = !0,
          this.unsubscribe = [],
          this.imageSrc = eZ.fz.getWalletImage(this.wallet) ?? eZ.fz.getConnectorImage(this.connector),
          this.name = this.wallet?.name ?? this.connector?.name ?? "Wallet",
          this.isRetrying = !1,
          this.uri = eZ.ConnectionController.state.wcUri,
          this.error = eZ.ConnectionController.state.wcError,
          this.ready = !1,
          this.showRetry = !1,
          this.buffering = !1,
          this.isMobile = !1,
          this.onRetry = void 0,
          this.unsubscribe.push(...[eZ.ConnectionController.subscribeKey("wcUri", J => {
            this.uri = J,
              this.isRetrying && this.onRetry && (this.isRetrying = !1,
                this.onConnect?.())
          }
          ), eZ.ConnectionController.subscribeKey("wcError", J => this.error = J), eZ.ConnectionController.subscribeKey("buffering", J => this.buffering = J)])
      }
      firstUpdated() {
        this.onAutoConnect?.(),
          this.showRetry = !this.onAutoConnect
      }
      disconnectedCallback() {
        this.unsubscribe.forEach(J => J()),
          clearTimeout(this.timeout)
      }
      render() {
        this.onRender?.(),
          this.onShowRetry();
        let J = this.error ? "Connection can be declined if a previous request is still active" : this.secondaryLabel
          , et = `Continue in ${this.name}`;
        return this.buffering && (et = "Connecting..."),
          this.error && (et = "Connection declined"),
          eY.dy`
    <wui-flex
      data-error=${(0,
              eJ.o)(this.error)}
      data-retry=${this.showRetry}
      flexDirection="column"
      alignItems="center"
      .padding=${["3xl", "xl", "xl", "xl"]}
      gap="xl"
    >
      <wui-flex justifyContent="center" alignItems="center">
        <wui-wallet-image size="lg" imageSrc=${(0,
              eJ.o)(this.imageSrc)}></wui-wallet-image>

        ${this.error ? null : this.loaderTemplate()}

        <wui-icon-box
          backgroundColor="error-100"
          background="opaque"
          iconColor="error-100"
          icon="close"
          size="sm"
          border
          borderColor="wui-color-bg-125"
        ></wui-icon-box>
      </wui-flex>

      <wui-flex flexDirection="column" alignItems="center" gap="xs">
        <wui-text variant="paragraph-500" color=${this.error ? "error-100" : "fg-100"}>
          ${et}
        </wui-text>
        <wui-text align="center" variant="small-500" color="fg-200">${J}</wui-text>
      </wui-flex>

      <wui-button
        variant="accent"
        ?disabled=${!this.error && this.buffering}
        @click=${this.onTryAgain.bind(this)}
      >
        <wui-icon color="inherit" slot="iconLeft" name=${this.secondaryBtnIcon}></wui-icon>
        ${this.secondaryBtnLabel}
      </wui-button>
    </wui-flex>

    ${this.isWalletConnect ? eY.dy`
          <wui-flex .padding=${["0", "xl", "xl", "xl"]} justifyContent="center">
            <wui-link @click=${this.onCopyUri} color="fg-200">
              <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
              Copy link
            </wui-link>
          </wui-flex>
        ` : null}

    <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
  `
      }
      onShowRetry() {
        if (this.error && !this.showRetry) {
          this.showRetry = !0;
          let J = this.shadowRoot?.querySelector("wui-button");
          J?.animate([{
            opacity: 0
          }, {
            opacity: 1
          }], {
            fill: "forwards",
            easing: "ease"
          })
        }
      }
      onTryAgain() {
        this.buffering || (eZ.ConnectionController.setWcError(!1),
          this.onRetry ? (this.isRetrying = !0,
            this.onRetry?.()) : this.onConnect?.())
      }
      loaderTemplate() {
        let J = eZ.ThemeController.state.themeVariables["--w3m-border-radius-master"]
          , et = J ? parseInt(J.replace("px", ""), 10) : 4;
        return eY.dy`<wui-loading-thumbnail radius=${9 * et}></wui-loading-thumbnail>`
      }
      onCopyUri() {
        try {
          this.uri && (eZ.j1.copyToClopboard(this.uri),
            eZ.SnackController.showSuccess("Link copied"))
        } catch {
          eZ.SnackController.showError("Failed to copy")
        }
      }
    }
      ;
    W3mConnectingWidget.styles = to,
      w3m_connecting_widget_decorate([(0,
        eK.SB)()], W3mConnectingWidget.prototype, "uri", void 0),
      w3m_connecting_widget_decorate([(0,
        eK.SB)()], W3mConnectingWidget.prototype, "error", void 0),
      w3m_connecting_widget_decorate([(0,
        eK.SB)()], W3mConnectingWidget.prototype, "ready", void 0),
      w3m_connecting_widget_decorate([(0,
        eK.SB)()], W3mConnectingWidget.prototype, "showRetry", void 0),
      w3m_connecting_widget_decorate([(0,
        eK.SB)()], W3mConnectingWidget.prototype, "buffering", void 0),
      w3m_connecting_widget_decorate([(0,
        eK.Cb)({
          type: Boolean
        })], W3mConnectingWidget.prototype, "isMobile", void 0),
      w3m_connecting_widget_decorate([(0,
        eK.Cb)()], W3mConnectingWidget.prototype, "onRetry", void 0);
    let ta = {
      INJECTED: "browser",
      ANNOUNCED: "browser"
    }
      , tl = class extends W3mConnectingWidget {
        constructor() {
          if (super(),
            !this.connector)
            throw Error("w3m-connecting-view: No connector provided");
          eZ.Xs.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: {
              name: this.connector.name ?? "Unknown",
              platform: ta[this.connector.type] ?? "external"
            }
          }),
            this.onConnect = this.onConnectProxy.bind(this),
            this.onAutoConnect = this.onConnectProxy.bind(this),
            this.isWalletConnect = !1
        }
        async onConnectProxy() {
          try {
            this.error = !1,
              this.connector && (this.connector.imageUrl && eZ.MO.setConnectedWalletImageUrl(this.connector.imageUrl),
                await eZ.ConnectionController.connectExternal(this.connector),
                eZ.yD.state.isSiweEnabled ? eZ.RouterController.push("ConnectingSiwe") : eZ.IN.close(),
                eZ.Xs.sendEvent({
                  type: "track",
                  event: "CONNECT_SUCCESS",
                  properties: {
                    method: "external"
                  }
                }))
          } catch (J) {
            eZ.Xs.sendEvent({
              type: "track",
              event: "CONNECT_ERROR",
              properties: {
                message: J?.message ?? "Unknown"
              }
            }),
              this.error = !0
          }
        }
      }
      ;
    tl = function (J, et, eo, el) {
      var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        eh = Reflect.decorate(J, et, eo, el);
      else
        for (var ep = J.length - 1; ep >= 0; ep--)
          (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
      return ed > 3 && eh && Object.defineProperty(et, eo, eh),
        eh
    }([(0,
      eG.customElement)("w3m-connecting-external-view")], tl);
    var w3m_connecting_siwe_view_decorate = function (J, et, eo, el) {
      var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        eh = Reflect.decorate(J, et, eo, el);
      else
        for (var ep = J.length - 1; ep >= 0; ep--)
          (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
      return ed > 3 && eh && Object.defineProperty(et, eo, eh),
        eh
    };
    let tc = class extends eY.oi {
      constructor() {
        super(...arguments),
          this.dappName = eZ.OptionsController.state.metadata?.name,
          this.isSigning = !1
      }
      render() {
        return eY.dy`
    <wui-flex justifyContent="center" .padding=${["2xl", "0", "xxl", "0"]}>
      <w3m-connecting-siwe></w3m-connecting-siwe>
    </wui-flex>
    <wui-flex
      .padding=${["0", "4xl", "l", "4xl"]}
      gap="s"
      justifyContent="space-between"
    >
      <wui-text variant="paragraph-500" align="center" color="fg-100"
        >${this.dappName ?? "Dapp"} needs to connect to your wallet</wui-text
      >
    </wui-flex>
    <wui-flex
      .padding=${["0", "3xl", "l", "3xl"]}
      gap="s"
      justifyContent="space-between"
    >
      <wui-text variant="small-400" align="center" color="fg-200"
        >Sign this message to prove you own this wallet and proceed. Canceling will disconnect
        you.</wui-text
      >
    </wui-flex>
    <wui-flex .padding=${["l", "xl", "xl", "xl"]} gap="s" justifyContent="space-between">
      <wui-button
        size="md"
        ?fullwidth=${!0}
        variant="shade"
        @click=${this.onCancel.bind(this)}
        data-testid="w3m-connecting-siwe-cancel"
      >
        Cancel
      </wui-button>
      <wui-button
        size="md"
        ?fullwidth=${!0}
        variant="fill"
        @click=${this.onSign.bind(this)}
        ?loading=${this.isSigning}
        data-testid="w3m-connecting-siwe-sign"
      >
        ${this.isSigning ? "Signing..." : "Sign"}
      </wui-button>
    </wui-flex>
  `
      }
      async onSign() {
        this.isSigning = !0,
          eZ.Xs.sendEvent({
            event: "CLICK_SIGN_SIWE_MESSAGE",
            type: "track"
          });
        try {
          eZ.yD.setStatus("loading");
          let J = await eZ.yD.signIn();
          return eZ.yD.setStatus("success"),
            eZ.Xs.sendEvent({
              event: "SIWE_AUTH_SUCCESS",
              type: "track"
            }),
            J
        } catch (J) {
          return eZ.SnackController.showError("Signature declined"),
            eZ.yD.setStatus("error"),
            eZ.Xs.sendEvent({
              event: "SIWE_AUTH_ERROR",
              type: "track"
            })
        } finally {
          this.isSigning = !1
        }
      }
      async onCancel() {
        let { isConnected: J } = eZ.AccountController.state;
        J ? (await eZ.ConnectionController.disconnect(),
          eZ.IN.close()) : eZ.RouterController.push("Connect"),
          eZ.Xs.sendEvent({
            event: "CLICK_CANCEL_SIWE",
            type: "track"
          })
      }
    }
      ;
    w3m_connecting_siwe_view_decorate([(0,
      eK.SB)()], tc.prototype, "isSigning", void 0),
      tc = w3m_connecting_siwe_view_decorate([(0,
        eG.customElement)("w3m-connecting-siwe-view")], tc);
    var w3m_connecting_wc_view_decorate = function (J, et, eo, el) {
      var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        eh = Reflect.decorate(J, et, eo, el);
      else
        for (var ep = J.length - 1; ep >= 0; ep--)
          (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
      return ed > 3 && eh && Object.defineProperty(et, eo, eh),
        eh
    };
    let td = class extends eY.oi {
      constructor() {
        super(),
          this.interval = void 0,
          this.lastRetry = Date.now(),
          this.wallet = eZ.RouterController.state.data?.wallet,
          this.platform = void 0,
          this.platforms = [],
          this.initializeConnection(),
          this.interval = setInterval(this.initializeConnection.bind(this), eZ.bq.TEN_SEC_MS)
      }
      disconnectedCallback() {
        clearTimeout(this.interval)
      }
      render() {
        return this.wallet ? (this.determinePlatforms(),
          eY.dy`
    ${this.headerTemplate()}
    <div>${this.platformTemplate()}</div>
  `) : eY.dy`<w3m-connecting-wc-qrcode></w3m-connecting-wc-qrcode>`
      }
      async initializeConnection(J = !1) {
        try {
          let { wcPairingExpiry: et } = eZ.ConnectionController.state;
          if (J || eZ.j1.isPairingExpired(et)) {
            if (eZ.ConnectionController.connectWalletConnect(),
              this.wallet) {
              let J = eZ.fz.getWalletImage(this.wallet);
              J && eZ.MO.setConnectedWalletImageUrl(J)
            } else {
              let J = eZ.ConnectorController.state.connectors
                , et = J.find(J => "WALLET_CONNECT" === J.type)
                , eo = eZ.fz.getConnectorImage(et);
              eo && eZ.MO.setConnectedWalletImageUrl(eo)
            }
            await eZ.ConnectionController.state.wcPromise,
              this.finalizeConnection(),
              eZ.yD.state.isSiweEnabled ? eZ.RouterController.push("ConnectingSiwe") : eZ.IN.close()
          }
        } catch (J) {
          eZ.Xs.sendEvent({
            type: "track",
            event: "CONNECT_ERROR",
            properties: {
              message: J?.message ?? "Unknown"
            }
          }),
            eZ.ConnectionController.setWcError(!0),
            eZ.j1.isAllowedRetry(this.lastRetry) && (eZ.SnackController.showError("Declined"),
              this.lastRetry = Date.now(),
              this.initializeConnection(!0))
        }
      }
      finalizeConnection() {
        let { wcLinking: J, recentWallet: et } = eZ.ConnectionController.state;
        J && eZ.MO.setWalletConnectDeepLink(J),
          et && eZ.MO.setWeb3ModalRecent(et),
          eZ.Xs.sendEvent({
            type: "track",
            event: "CONNECT_SUCCESS",
            properties: {
              method: J ? "mobile" : "qrcode"
            }
          })
      }
      determinePlatforms() {
        if (!this.wallet)
          throw Error("w3m-connecting-wc-view:determinePlatforms No wallet");
        if (this.platform)
          return;
        let { mobile_link: J, desktop_link: et, webapp_link: eo, injected: el, rdns: ec } = this.wallet
          , ed = el?.map(({ injected_id: J }) => J).filter(Boolean)
          , eh = ec ? [ec] : ed ?? []
          , ep = eh.length
          , ef = eZ.ConnectionController.checkInstalled(eh)
          , em = ep && ef
          , eg = et && !eZ.j1.isMobile();
        em && this.platforms.push("browser"),
          J && this.platforms.push(eZ.j1.isMobile() ? "mobile" : "qrcode"),
          eo && this.platforms.push("web"),
          eg && this.platforms.push("desktop"),
          !em && ep && this.platforms.push("unsupported"),
          this.platform = this.platforms[0]
      }
      platformTemplate() {
        switch (this.platform) {
          case "browser":
            return eY.dy`<w3m-connecting-wc-browser></w3m-connecting-wc-browser>`;
          case "desktop":
            return eY.dy`
        <w3m-connecting-wc-desktop .onRetry=${() => this.initializeConnection(!0)}>
        </w3m-connecting-wc-desktop>
      `;
          case "web":
            return eY.dy`
        <w3m-connecting-wc-web .onRetry=${() => this.initializeConnection(!0)}>
        </w3m-connecting-wc-web>
      `;
          case "mobile":
            return eY.dy`
        <w3m-connecting-wc-mobile isMobile .onRetry=${() => this.initializeConnection(!0)}>
        </w3m-connecting-wc-mobile>
      `;
          case "qrcode":
            return eY.dy`<w3m-connecting-wc-qrcode></w3m-connecting-wc-qrcode>`;
          default:
            return eY.dy`<w3m-connecting-wc-unsupported></w3m-connecting-wc-unsupported>`
        }
      }
      headerTemplate() {
        let J = this.platforms.length > 1;
        return J ? eY.dy`
    <w3m-connecting-header
      .platforms=${this.platforms}
      .onSelectPlatfrom=${this.onSelectPlatform.bind(this)}
    >
    </w3m-connecting-header>
  ` : null
      }
      async onSelectPlatform(J) {
        let et = this.shadowRoot?.querySelector("div");
        et && (await et.animate([{
          opacity: 1
        }, {
          opacity: 0
        }], {
          duration: 200,
          fill: "forwards",
          easing: "ease"
        }).finished,
          this.platform = J,
          et.animate([{
            opacity: 0
          }, {
            opacity: 1
          }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
          }))
      }
    }
      ;
    w3m_connecting_wc_view_decorate([(0,
      eK.SB)()], td.prototype, "platform", void 0),
      w3m_connecting_wc_view_decorate([(0,
        eK.SB)()], td.prototype, "platforms", void 0),
      td = w3m_connecting_wc_view_decorate([(0,
        eG.customElement)("w3m-connecting-wc-view")], td);
    let th = class extends eY.oi {
      constructor() {
        super(...arguments),
          this.wallet = eZ.RouterController.state.data?.wallet
      }
      render() {
        if (!this.wallet)
          throw Error("w3m-downloads-view");
        return eY.dy`
    <wui-flex gap="xs" flexDirection="column" .padding=${["s", "s", "l", "s"]}>
      ${this.chromeTemplate()} ${this.iosTemplate()} ${this.androidTemplate()}
      ${this.homepageTemplate()}
    </wui-flex>
  `
      }
      chromeTemplate() {
        return this.wallet?.chrome_store ? eY.dy`<wui-list-item
    variant="icon"
    icon="chromeStore"
    iconVariant="square"
    @click=${this.onChromeStore.bind(this)}
    chevron
  >
    <wui-text variant="paragraph-500" color="fg-100">Chrome Extension</wui-text>
  </wui-list-item>` : null
      }
      iosTemplate() {
        return this.wallet?.app_store ? eY.dy`<wui-list-item
    variant="icon"
    icon="appStore"
    iconVariant="square"
    @click=${this.onAppStore.bind(this)}
    chevron
  >
    <wui-text variant="paragraph-500" color="fg-100">iOS App</wui-text>
  </wui-list-item>` : null
      }
      androidTemplate() {
        return this.wallet?.play_store ? eY.dy`<wui-list-item
    variant="icon"
    icon="playStore"
    iconVariant="square"
    @click=${this.onPlayStore.bind(this)}
    chevron
  >
    <wui-text variant="paragraph-500" color="fg-100">Android App</wui-text>
  </wui-list-item>` : null
      }
      homepageTemplate() {
        return this.wallet?.homepage ? eY.dy`
    <wui-list-item
      variant="icon"
      icon="browser"
      iconVariant="square-blue"
      @click=${this.onHomePage.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">Website</wui-text>
    </wui-list-item>
  ` : null
      }
      onChromeStore() {
        this.wallet?.chrome_store && eZ.j1.openHref(this.wallet.chrome_store, "_blank")
      }
      onAppStore() {
        this.wallet?.app_store && eZ.j1.openHref(this.wallet.app_store, "_blank")
      }
      onPlayStore() {
        this.wallet?.play_store && eZ.j1.openHref(this.wallet.play_store, "_blank")
      }
      onHomePage() {
        this.wallet?.homepage && eZ.j1.openHref(this.wallet.homepage, "_blank")
      }
    }
      ;
    th = function (J, et, eo, el) {
      var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        eh = Reflect.decorate(J, et, eo, el);
      else
        for (var ep = J.length - 1; ep >= 0; ep--)
          (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
      return ed > 3 && eh && Object.defineProperty(et, eo, eh),
        eh
    }([(0,
      eG.customElement)("w3m-downloads-view")], th);
    let tp = class extends eY.oi {
      render() {
        return eY.dy`
    <wui-flex flexDirection="column" padding="s" gap="xs">
      ${this.recommendedWalletsTemplate()}
      <wui-list-wallet
        name="Explore all"
        showAllWallets
        walletIcon="allWallets"
        icon="externalLink"
        @click=${() => {
            eZ.j1.openHref("https://walletconnect.com/explorer?type=wallet", "_blank")
          }
          }
      ></wui-list-wallet>
    </wui-flex>
  `
      }
      recommendedWalletsTemplate() {
        let { recommended: J, featured: et } = eZ.ApiController.state
          , { customWallets: eo } = eZ.OptionsController.state
          , el = [...et, ...eo ?? [], ...J].slice(0, 4);
        return el.map(J => eY.dy`
      <wui-list-wallet
        name=${J.name ?? "Unknown"}
        tagVariant="main"
        imageSrc=${(0,
            eJ.o)(eZ.fz.getWalletImage(J))}
        @click=${() => {
            eZ.j1.openHref(J.homepage ?? "https://walletconnect.com/explorer", "_blank")
          }
          }
      ></wui-list-wallet>
    `)
      }
    }
      ;
    tp = function (J, et, eo, el) {
      var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        eh = Reflect.decorate(J, et, eo, el);
      else
        for (var ep = J.length - 1; ep >= 0; ep--)
          (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
      return ed > 3 && eh && Object.defineProperty(et, eo, eh),
        eh
    }([(0,
      eG.customElement)("w3m-get-wallet-view")], tp);
    var tf = eY.iv`
@keyframes shake {
  0% {
    transform: translateX(0);
  }
  25% {
    transform: translateX(3px);
  }
  50% {
    transform: translateX(-3px);
  }
  75% {
    transform: translateX(3px);
  }
  100% {
    transform: translateX(0);
  }
}

wui-flex:first-child:not(:only-child) {
  position: relative;
}

wui-loading-hexagon {
  position: absolute;
}

wui-icon-box {
  position: absolute;
  right: 4px;
  bottom: 0;
  opacity: 0;
  transform: scale(0.5);
  z-index: 1;
  transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
}

wui-button {
  display: none;
}

[data-error='true'] wui-icon-box {
  opacity: 1;
  transform: scale(1);
}

[data-error='true'] > wui-flex:first-child {
  animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
}

wui-button[data-retry='true'] {
  display: block;
  opacity: 1;
}
`
      , w3m_network_switch_view_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let tm = class extends eY.oi {
      constructor() {
        super(),
          this.network = eZ.RouterController.state.data?.network,
          this.unsubscribe = [],
          this.showRetry = !1,
          this.error = !1
      }
      disconnectedCallback() {
        this.unsubscribe.forEach(J => J())
      }
      firstUpdated() {
        this.onSwitchNetwork()
      }
      render() {
        if (!this.network)
          throw Error("w3m-network-switch-view: No network provided");
        this.onShowRetry();
        let J = this.error ? "Switch declined" : "Approve in wallet"
          , et = this.error ? "Switch can be declined if chain is not supported by a wallet or previous request is still active" : "Accept connection request in your wallet";
        return eY.dy`
    <wui-flex
      data-error=${this.error}
      flexDirection="column"
      alignItems="center"
      .padding=${["3xl", "xl", "3xl", "xl"]}
      gap="xl"
    >
      <wui-flex justifyContent="center" alignItems="center">
        <wui-network-image
          size="lg"
          imageSrc=${(0,
            eJ.o)(eZ.fz.getNetworkImage(this.network))}
        ></wui-network-image>

        ${this.error ? null : eY.dy`<wui-loading-hexagon></wui-loading-hexagon>`}

        <wui-icon-box
          backgroundColor="error-100"
          background="opaque"
          iconColor="error-100"
          icon="close"
          size="sm"
          ?border=${!0}
          borderColor="wui-color-bg-125"
        ></wui-icon-box>
      </wui-flex>

      <wui-flex flexDirection="column" alignItems="center" gap="xs">
        <wui-text align="center" variant="paragraph-500" color="fg-100">${J}</wui-text>
        <wui-text align="center" variant="small-500" color="fg-200">${et}</wui-text>
      </wui-flex>

      <wui-button
        data-retry=${this.showRetry}
        variant="fill"
        .disabled=${!this.error}
        @click=${this.onSwitchNetwork.bind(this)}
      >
        <wui-icon color="inherit" slot="iconLeft" name="refresh"></wui-icon>
        Try again
      </wui-button>
    </wui-flex>
  `
      }
      onShowRetry() {
        if (this.error && !this.showRetry) {
          this.showRetry = !0;
          let J = this.shadowRoot?.querySelector("wui-button");
          J?.animate([{
            opacity: 0
          }, {
            opacity: 1
          }], {
            fill: "forwards",
            easing: "ease"
          })
        }
      }
      async onSwitchNetwork() {
        try {
          this.error = !1,
            this.network && (await eZ.NetworkController.switchActiveNetwork(this.network),
              eZ.yD.state.isSiweEnabled || eZ._4.navigateAfterNetworkSwitch())
        } catch {
          this.error = !0
        }
      }
    }
      ;
    tm.styles = tf,
      w3m_network_switch_view_decorate([(0,
        eK.SB)()], tm.prototype, "showRetry", void 0),
      w3m_network_switch_view_decorate([(0,
        eK.SB)()], tm.prototype, "error", void 0),
      tm = w3m_network_switch_view_decorate([(0,
        eG.customElement)("w3m-network-switch-view")], tm);
    var tg = eY.iv`
:host > wui-grid {
  max-height: 360px;
  overflow: auto;
}

wui-grid::-webkit-scrollbar {
  display: none;
}
`
      , w3m_networks_view_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let ty = class extends eY.oi {
      constructor() {
        super(),
          this.unsubscribe = [],
          this.caipNetwork = eZ.NetworkController.state.caipNetwork,
          this.unsubscribe.push(eZ.NetworkController.subscribeKey("caipNetwork", J => this.caipNetwork = J))
      }
      disconnectedCallback() {
        this.unsubscribe.forEach(J => J())
      }
      render() {
        return eY.dy`
    <wui-grid padding="s" gridTemplateColumns="repeat(4, 1fr)" rowGap="l" columnGap="xs">
      ${this.networksTemplate()}
    </wui-grid>

    <wui-separator></wui-separator>

    <wui-flex padding="s" flexDirection="column" gap="m" alignItems="center">
      <wui-text variant="small-400" color="fg-300" align="center">
        Your connected wallet may not support some of the networks available for this dApp
      </wui-text>
      <wui-link @click=${this.onNetworkHelp.bind(this)}>
        <wui-icon size="xs" color="accent-100" slot="iconLeft" name="helpCircle"></wui-icon>
        What is a network
      </wui-link>
    </wui-flex>
  `
      }
      onNetworkHelp() {
        eZ.Xs.sendEvent({
          type: "track",
          event: "CLICK_NETWORK_HELP"
        }),
          eZ.RouterController.push("WhatIsANetwork")
      }
      networksTemplate() {
        let { approvedCaipNetworkIds: J, requestedCaipNetworks: et, supportsAllNetworks: eo } = eZ.NetworkController.state
          , el = {};
        return et && J && (J.forEach((J, et) => {
          el[J] = et
        }
        ),
          et.sort((J, et) => {
            let eo = el[J.id]
              , ec = el[et.id];
            return void 0 !== eo && void 0 !== ec ? eo - ec : void 0 !== eo ? -1 : void 0 !== ec ? 1 : 0
          }
          )),
          et?.map(et => eY.dy`
      <wui-card-select
        .selected=${this.caipNetwork?.id === et.id}
        imageSrc=${eJ.o(eZ.fz.getNetworkImage(et))}
        type="network"
        name=${et.name ?? et.id}
        @click=${() => this.onSwitchNetwork(et)}
        .disabled=${!eo && !J?.includes(et.id)}
        data-testid=${`w3m-network-switch-${et.name ?? et.id}`}
      ></wui-card-select>
    `)
      }
      async onSwitchNetwork(J) {
        let { isConnected: et } = eZ.AccountController.state
          , { approvedCaipNetworkIds: eo, supportsAllNetworks: el, caipNetwork: ec } = eZ.NetworkController.state
          , { data: ed } = eZ.RouterController.state;
        et && ec?.id !== J.id ? eo?.includes(J.id) ? (await eZ.NetworkController.switchActiveNetwork(J),
          eZ._4.navigateAfterNetworkSwitch()) : el && eZ.RouterController.push("SwitchNetwork", {
            ...ed,
            network: J
          }) : et || (eZ.NetworkController.setCaipNetwork(J),
            eZ.RouterController.push("Connect"))
      }
    }
      ;
    ty.styles = tg,
      w3m_networks_view_decorate([(0,
        eK.SB)()], ty.prototype, "caipNetwork", void 0),
      ty = w3m_networks_view_decorate([(0,
        eG.customElement)("w3m-networks-view")], ty);
    var tb = eo(88598)
      , tw = eY.iv`
:host > wui-flex:first-child {
  height: 500px;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-width: none;
}
`
      , w3m_transactions_view_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let t_ = "last-transaction"
      , tx = class extends eY.oi {
        constructor() {
          super(),
            this.unsubscribe = [],
            this.paginationObserver = void 0,
            this.address = eZ.AccountController.state.address,
            this.transactions = eZ.sl.state.transactions,
            this.transactionsByYear = eZ.sl.state.transactionsByYear,
            this.loading = eZ.sl.state.loading,
            this.empty = eZ.sl.state.empty,
            this.next = eZ.sl.state.next,
            this.unsubscribe.push(...[eZ.AccountController.subscribe(J => {
              J.isConnected && this.address !== J.address && (this.address = J.address,
                eZ.sl.resetTransactions(),
                eZ.sl.fetchTransactions(J.address))
            }
            ), eZ.sl.subscribe(J => {
              this.transactions = J.transactions,
                this.transactionsByYear = J.transactionsByYear,
                this.loading = J.loading,
                this.empty = J.empty,
                this.next = J.next
            }
            )])
        }
        firstUpdated() {
          0 === this.transactions.length && eZ.sl.fetchTransactions(this.address),
            this.createPaginationObserver()
        }
        updated() {
          this.setPaginationObserver()
        }
        disconnectedCallback() {
          this.unsubscribe.forEach(J => J())
        }
        render() {
          return eY.dy`
    <wui-flex flexDirection="column" padding="s" gap="s">
      ${this.empty ? null : this.templateTransactionsByYear()}
      ${this.loading ? this.templateLoading() : null}
      ${!this.loading && this.empty ? this.templateEmpty() : null}
    </wui-flex>
  `
        }
        templateTransactionsByYear() {
          let J = Object.keys(this.transactionsByYear).sort().reverse();
          return J.map((et, eo) => {
            let el = eo === J.length - 1
              , ec = parseInt(et, 10)
              , ed = eG.TransactionUtil.getTransactionGroupTitle(ec)
              , eh = this.transactionsByYear[ec];
            return eh ? eY.dy`
      <wui-flex flexDirection="column" gap="s">
        <wui-flex
          alignItems="center"
          flexDirection="row"
          .padding=${["xs", "s", "s", "s"]}
        >
          <wui-text variant="paragraph-500" color="fg-200">${ed}</wui-text>
        </wui-flex>
        <wui-flex flexDirection="column" gap="xs">
          ${this.templateTransactions(eh, el)}
        </wui-flex>
      </wui-flex>
    ` : null
          }
          )
        }
        templateRenderTransaction(J, et) {
          let { date: eo, descriptions: el, direction: ec, isAllNFT: ed, images: eh, status: ep, transfers: ef, type: em } = this.getTransactionListItemProps(J)
            , eg = ef?.length > 1
            , ey = ef?.length === 2;
          return ey && !ed ? eY.dy`
      <wui-transaction-list-item
        date=${eo}
        .direction=${ec}
        id=${et && this.next ? t_ : ""}
        status=${ep}
        type=${em}
        .images=${eh}
        .descriptions=${el}
      ></wui-transaction-list-item>
    ` : eg ? ef.map((J, el) => {
            let ec = eG.TransactionUtil.getTransferDescription(J)
              , ed = et && el === ef.length - 1;
            return eY.dy` <wui-transaction-list-item
        date=${eo}
        direction=${J.direction}
        id=${ed && this.next ? t_ : ""}
        status=${ep}
        type=${em}
        .onlyDirectionIcon=${!0}
        .images=${[eh?.[el]]}
        .descriptions=${[ec]}
      ></wui-transaction-list-item>`
          }
          ) : eY.dy`
    <wui-transaction-list-item
      date=${eo}
      .direction=${ec}
      id=${et && this.next ? t_ : ""}
      status=${ep}
      type=${em}
      .images=${eh}
      .descriptions=${el}
    ></wui-transaction-list-item>
  `
        }
        templateTransactions(J, et) {
          return J.map((eo, el) => {
            let ec = et && el === J.length - 1;
            return eY.dy`${this.templateRenderTransaction(eo, ec)}`
          }
          )
        }
        templateEmpty() {
          return eY.dy`
    <wui-flex
      flexGrow="1"
      flexDirection="column"
      justifyContent="center"
      alignItems="center"
      .padding=${["3xl", "xl", "3xl", "xl"]}
      gap="xl"
    >
      <wui-icon-box
        backgroundColor="glass-005"
        background="gray"
        iconColor="fg-200"
        icon="wallet"
        size="lg"
        ?border=${!0}
        borderColor="wui-color-bg-125"
      ></wui-icon-box>
      <wui-flex flexDirection="column" alignItems="center" gap="xs">
        <wui-text align="center" variant="paragraph-500" color="fg-100"
          >No Transactions yet</wui-text
        >
        <wui-text align="center" variant="small-500" color="fg-200"
          >Start trading on dApps <br />
          to grow your wallet!</wui-text
        >
      </wui-flex>
    </wui-flex>
  `
        }
        templateLoading() {
          return Array(7).fill(eY.dy` <wui-transaction-list-item-loader></wui-transaction-list-item-loader> `).map(J => J)
        }
        createPaginationObserver() {
          let { projectId: J } = eZ.OptionsController.state;
          this.paginationObserver = new IntersectionObserver(([et]) => {
            et?.isIntersecting && !this.loading && (eZ.sl.fetchTransactions(this.address),
              eZ.Xs.sendEvent({
                type: "track",
                event: "LOAD_MORE_TRANSACTIONS",
                properties: {
                  address: this.address,
                  projectId: J,
                  cursor: this.next
                }
              }))
          }
            , {}),
            this.setPaginationObserver()
        }
        setPaginationObserver() {
          this.paginationObserver?.disconnect();
          let J = this.shadowRoot?.querySelector(`#${t_}`);
          J && this.paginationObserver?.observe(J)
        }
        getTransactionListItemProps(J) {
          let et = tb.E.getRelativeDateFromNow(J?.metadata?.minedAt)
            , eo = eG.TransactionUtil.getTransactionDescriptions(J)
            , el = J?.transfers
            , ec = J?.transfers?.[0]
            , ed = !!ec && J?.transfers?.every(J => !!J.nft_info)
            , eh = eG.TransactionUtil.getTransactionImages(el);
          return {
            date: et,
            direction: ec?.direction,
            descriptions: eo,
            isAllNFT: ed,
            images: eh,
            status: J.metadata?.status,
            transfers: el,
            type: J.metadata?.operationType
          }
        }
      }
      ;
    tx.styles = tw,
      w3m_transactions_view_decorate([(0,
        eK.SB)()], tx.prototype, "address", void 0),
      w3m_transactions_view_decorate([(0,
        eK.SB)()], tx.prototype, "transactions", void 0),
      w3m_transactions_view_decorate([(0,
        eK.SB)()], tx.prototype, "transactionsByYear", void 0),
      w3m_transactions_view_decorate([(0,
        eK.SB)()], tx.prototype, "loading", void 0),
      w3m_transactions_view_decorate([(0,
        eK.SB)()], tx.prototype, "empty", void 0),
      w3m_transactions_view_decorate([(0,
        eK.SB)()], tx.prototype, "next", void 0),
      tx = w3m_transactions_view_decorate([(0,
        eG.customElement)("w3m-transactions-view")], tx);
    let tE = [{
      images: ["network", "layers", "system"],
      title: "The system’s nuts and bolts",
      text: "A network is what brings the blockchain to life, as this technical infrastructure allows apps to access the ledger and smart contract services."
    }, {
      images: ["noun", "defiAlt", "dao"],
      title: "Designed for different uses",
      text: "Each network is designed differently, and may therefore suit certain apps and experiences."
    }]
      , tC = class extends eY.oi {
        render() {
          return eY.dy`
    <wui-flex
      flexDirection="column"
      .padding=${["xxl", "xl", "xl", "xl"]}
      alignItems="center"
      gap="xl"
    >
      <w3m-help-widget .data=${tE}></w3m-help-widget>
      <wui-button
        variant="fill"
        size="sm"
        @click=${() => {
              eZ.j1.openHref("https://ethereum.org/en/developers/docs/networks/", "_blank")
            }
            }
      >
        Learn more
        <wui-icon color="inherit" slot="iconRight" name="externalLink"></wui-icon>
      </wui-button>
    </wui-flex>
  `
        }
      }
      ;
    tC = function (J, et, eo, el) {
      var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        eh = Reflect.decorate(J, et, eo, el);
      else
        for (var ep = J.length - 1; ep >= 0; ep--)
          (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
      return ed > 3 && eh && Object.defineProperty(et, eo, eh),
        eh
    }([(0,
      eG.customElement)("w3m-what-is-a-network-view")], tC);
    let tS = [{
      images: ["login", "profile", "lock"],
      title: "One login for all of web3",
      text: "Log in to any app by connecting your wallet. Say goodbye to countless passwords!"
    }, {
      images: ["defi", "nft", "eth"],
      title: "A home for your digital assets",
      text: "A wallet lets you store, send and receive digital assets like cryptocurrencies and NFTs."
    }, {
      images: ["browser", "noun", "dao"],
      title: "Your gateway to a new web",
      text: "With your wallet, you can explore and interact with DeFi, NFTs, DAOs, and much more."
    }]
      , tk = class extends eY.oi {
        render() {
          return eY.dy`
    <wui-flex
      flexDirection="column"
      .padding=${["xxl", "xl", "xl", "xl"]}
      alignItems="center"
      gap="xl"
    >
      <w3m-help-widget .data=${tS}></w3m-help-widget>
      <wui-button variant="fill" size="sm" @click=${this.onGetWallet.bind(this)}>
        <wui-icon color="inherit" slot="iconLeft" name="wallet"></wui-icon>
        Get a wallet
      </wui-button>
    </wui-flex>
  `
        }
        onGetWallet() {
          eZ.Xs.sendEvent({
            type: "track",
            event: "CLICK_GET_WALLET"
          }),
            eZ.RouterController.push("GetWallet")
        }
      }
      ;
    tk = function (J, et, eo, el) {
      var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        eh = Reflect.decorate(J, et, eo, el);
      else
        for (var ep = J.length - 1; ep >= 0; ep--)
          (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
      return ed > 3 && eh && Object.defineProperty(et, eo, eh),
        eh
    }([(0,
      eG.customElement)("w3m-what-is-a-wallet-view")], tk);
    var tT = eY.iv`
wui-loading-spinner {
  margin: 9px auto;
}
`
      , tA = eo(89481)
      , w3m_email_otp_widget_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let tP = class extends eY.oi {
      firstUpdated() {
        this.startOTPTimeout()
      }
      disconnectedCallback() {
        clearTimeout(this.OTPTimeout)
      }
      constructor() {
        super(),
          this.email = eZ.RouterController.state.data?.email,
          this.loading = !1,
          this.timeoutTimeLeft = tA.$D.getTimeToNextEmailLogin(),
          this.error = "",
          this.otp = "",
          this.emailConnector = eZ.ConnectorController.getEmailConnector()
      }
      render() {
        if (!this.email)
          throw Error("w3m-email-otp-widget: No email provided");
        let J = !!this.timeoutTimeLeft;
        return eY.dy`
    <wui-flex
      flexDirection="column"
      alignItems="center"
      .padding=${["l", "0", "l", "0"]}
      gap="l"
    >
      <wui-flex flexDirection="column" alignItems="center">
        <wui-text variant="paragraph-400" color="fg-100"> Enter the code we sent to </wui-text>
        <wui-text variant="paragraph-500" color="fg-100">${this.email}</wui-text>
      </wui-flex>

      <wui-text variant="small-400" color="fg-200">The code expires in 20 minutes</wui-text>

      ${this.loading ? eY.dy`<wui-loading-spinner size="xl" color="accent-100"></wui-loading-spinner>` : eY.dy` <wui-flex flexDirection="column" alignItems="center" gap="xs">
            <wui-otp
              dissabled
              length="6"
              @inputChange=${this.onOtpInputChange.bind(this)}
              .otp=${this.otp}
            ></wui-otp>
            ${this.error ? eY.dy`
                  <wui-text variant="small-400" color="error-100">
                    ${this.error}. Try Again
                  </wui-text>
                ` : null}
          </wui-flex>`}

      <wui-flex alignItems="center">
        <wui-text variant="small-400" color="fg-200">Didn't receive it?</wui-text>
        <wui-link @click=${this.onResendCode.bind(this)} .disabled=${J}>
          Resend ${J ? `in ${this.timeoutTimeLeft}s` : "Code"}
        </wui-link>
      </wui-flex>
    </wui-flex>
  `
      }
      startOTPTimeout() {
        this.timeoutTimeLeft = tA.$D.getTimeToNextEmailLogin(),
          this.OTPTimeout = setInterval(() => {
            this.timeoutTimeLeft > 0 ? this.timeoutTimeLeft = tA.$D.getTimeToNextEmailLogin() : clearInterval(this.OTPTimeout)
          }
            , 1e3)
      }
      async onOtpInputChange(J) {
        try {
          !this.loading && (this.otp = J.detail,
            this.emailConnector && 6 === this.otp.length && (this.loading = !0,
              await this.onOtpSubmit?.(this.otp)))
        } catch (J) {
          this.error = eZ.j1.parseError(J),
            this.loading = !1
        }
      }
      async onResendCode() {
        try {
          if (!this.loading && !this.timeoutTimeLeft) {
            this.error = "",
              this.otp = "";
            let J = eZ.ConnectorController.getEmailConnector();
            if (!J || !this.email)
              throw Error("w3m-email-otp-widget: Unable to resend email");
            this.loading = !0,
              await this.onOtpResend?.(this.email),
              this.startOTPTimeout(),
              eZ.SnackController.showSuccess("Code email resent")
          }
        } catch (J) {
          eZ.SnackController.showError(J)
        } finally {
          this.loading = !1
        }
      }
    }
      ;
    tP.styles = tT,
      w3m_email_otp_widget_decorate([(0,
        eK.SB)()], tP.prototype, "loading", void 0),
      w3m_email_otp_widget_decorate([(0,
        eK.SB)()], tP.prototype, "timeoutTimeLeft", void 0),
      w3m_email_otp_widget_decorate([(0,
        eK.SB)()], tP.prototype, "error", void 0),
      tP = w3m_email_otp_widget_decorate([(0,
        eG.customElement)("w3m-email-otp-widget")], tP);
    let tR = class extends tP {
      constructor() {
        super(),
          this.onOtpSubmit = async J => {
            try {
              this.emailConnector && (await this.emailConnector.provider.connectOtp({
                otp: J
              }),
                eZ.Xs.sendEvent({
                  type: "track",
                  event: "EMAIL_VERIFICATION_CODE_PASS"
                }),
                await eZ.ConnectionController.connectExternal(this.emailConnector),
                eZ.IN.close(),
                eZ.Xs.sendEvent({
                  type: "track",
                  event: "CONNECT_SUCCESS",
                  properties: {
                    method: "email"
                  }
                }))
            } catch (J) {
              throw eZ.Xs.sendEvent({
                type: "track",
                event: "EMAIL_VERIFICATION_CODE_FAIL"
              }),
              J
            }
          }
          ,
          this.onOtpResend = async J => {
            this.emailConnector && (await this.emailConnector.provider.connectEmail({
              email: J
            }),
              eZ.Xs.sendEvent({
                type: "track",
                event: "EMAIL_VERIFICATION_CODE_SENT"
              }))
          }
      }
    }
      ;
    tR = function (J, et, eo, el) {
      var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        eh = Reflect.decorate(J, et, eo, el);
      else
        for (var ep = J.length - 1; ep >= 0; ep--)
          (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
      return ed > 3 && eh && Object.defineProperty(et, eo, eh),
        eh
    }([(0,
      eG.customElement)("w3m-email-verify-otp-view")], tR);
    var tI = eY.iv`
wui-icon-box {
  height: var(--wui-icon-box-size-xl);
  width: var(--wui-icon-box-size-xl);
}
`
      , w3m_email_verify_device_view_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let tO = class extends eY.oi {
      constructor() {
        super(),
          this.email = eZ.RouterController.state.data?.email,
          this.emailConnector = eZ.ConnectorController.getEmailConnector(),
          this.loading = !1,
          this.listenForDeviceApproval()
      }
      render() {
        if (!this.email)
          throw Error("w3m-email-verify-device-view: No email provided");
        if (!this.emailConnector)
          throw Error("w3m-email-verify-device-view: No email connector provided");
        return eY.dy`
    <wui-flex
      flexDirection="column"
      alignItems="center"
      .padding=${["xxl", "s", "xxl", "s"]}
      gap="l"
    >
      <wui-icon-box
        size="xl"
        iconcolor="accent-100"
        backgroundcolor="accent-100"
        icon="verify"
        background="opaque"
      ></wui-icon-box>

      <wui-flex flexDirection="column" alignItems="center" gap="s">
        <wui-flex flexDirection="column" alignItems="center">
          <wui-text variant="paragraph-400" color="fg-100">
            Approve the login link we sent to
          </wui-text>
          <wui-text variant="paragraph-400" color="fg-100"><b>${this.email}</b></wui-text>
        </wui-flex>

        <wui-text variant="small-400" color="fg-200" align="center">
          The code expires in 20 minutes
        </wui-text>

        <wui-flex alignItems="center" id="w3m-resend-section">
          <wui-text variant="small-400" color="fg-100" align="center">
            Didn't receive it?
          </wui-text>
          <wui-link @click=${this.onResendCode.bind(this)} .disabled=${this.loading}>
            Resend email
          </wui-link>
        </wui-flex>
      </wui-flex>
    </wui-flex>
  `
      }
      async listenForDeviceApproval() {
        this.emailConnector && (await this.emailConnector.provider.connectDevice(),
          eZ.Xs.sendEvent({
            type: "track",
            event: "DEVICE_REGISTERED_FOR_EMAIL"
          }),
          eZ.Xs.sendEvent({
            type: "track",
            event: "EMAIL_VERIFICATION_CODE_SENT"
          }),
          eZ.RouterController.replace("EmailVerifyOtp", {
            email: this.email
          }))
      }
      async onResendCode() {
        try {
          if (!this.loading) {
            if (!this.emailConnector || !this.email)
              throw Error("w3m-email-login-widget: Unable to resend email");
            this.loading = !0,
              await this.emailConnector.provider.connectEmail({
                email: this.email
              }),
              eZ.SnackController.showSuccess("Code email resent")
          }
        } catch (J) {
          eZ.SnackController.showError(J)
        } finally {
          this.loading = !1
        }
      }
    }
      ;
    tO.styles = tI,
      w3m_email_verify_device_view_decorate([(0,
        eK.SB)()], tO.prototype, "loading", void 0),
      tO = w3m_email_verify_device_view_decorate([(0,
        eG.customElement)("w3m-email-verify-device-view")], tO);
    var tN = eY.iv`
div {
  width: 100%;
  height: 400px;
}

[data-ready='false'] {
  transform: scale(1.05);
}

@media (max-width: 430px) {
  [data-ready='false'] {
    transform: translateY(-50px);
  }
}
`
      , w3m_approve_transaction_view_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let tM = class extends eY.oi {
      constructor() {
        super(),
          this.bodyObserver = void 0,
          this.unsubscribe = [],
          this.iframe = document.getElementById("w3m-iframe"),
          this.ready = !1,
          this.unsubscribe.push(eZ.IN.subscribeKey("open", J => {
            J || this.onHideIframe()
          }
          ))
      }
      disconnectedCallback() {
        this.unsubscribe.forEach(J => J()),
          this.bodyObserver?.unobserve(window.document.body)
      }
      firstUpdated() {
        this.iframe.style.display = "block";
        let J = this.renderRoot.querySelector("div");
        this.bodyObserver = new ResizeObserver(() => {
          let et = J?.getBoundingClientRect()
            , eo = et ?? {
              left: 0,
              top: 0,
              width: 0,
              height: 0
            };
          this.iframe.style.width = `${eo.width}px`,
            this.iframe.style.height = `${eo.height - 10}px`,
            this.iframe.style.left = `${eo.left}px`,
            this.iframe.style.top = `${eo.top + 5}px`,
            this.ready = !0
        }
        ),
          this.bodyObserver.observe(window.document.body)
      }
      render() {
        return this.ready && this.onShowIframe(),
          eY.dy`<div data-ready=${this.ready}></div>`
      }
      onShowIframe() {
        let J = window.innerWidth <= 430;
        this.iframe.animate([{
          opacity: 0,
          transform: J ? "translateY(50px)" : "scale(.95)"
        }, {
          opacity: 1,
          transform: J ? "translateY(0)" : "scale(1)"
        }], {
          duration: 200,
          easing: "ease",
          fill: "forwards",
          delay: 300
        })
      }
      async onHideIframe() {
        await this.iframe.animate([{
          opacity: 1
        }, {
          opacity: 0
        }], {
          duration: 200,
          easing: "ease",
          fill: "forwards"
        }).finished,
          this.iframe.style.display = "none"
      }
    }
      ;
    tM.styles = tN,
      w3m_approve_transaction_view_decorate([(0,
        eK.SB)()], tM.prototype, "ready", void 0),
      tM = w3m_approve_transaction_view_decorate([(0,
        eG.customElement)("w3m-approve-transaction-view")], tM);
    let tD = class extends eY.oi {
      render() {
        return eY.dy`
    <wui-flex flexDirection="column" alignItems="center" gap="xl" padding="xl">
      <wui-text variant="paragraph-400" color="fg-100">Follow the instructions on</wui-text>
      <wui-chip
        icon="externalLink"
        variant="fill"
        href=${eZ.bq.SECURE_SITE_DASHBOARD}
        imageSrc=${eZ.bq.SECURE_SITE_FAVICON}
      >
      </wui-chip>
      <wui-text variant="small-400" color="fg-200">
        You will have to reconnect for security reasons
      </wui-text>
    </wui-flex>
  `
      }
    }
      ;
    tD = function (J, et, eo, el) {
      var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        eh = Reflect.decorate(J, et, eo, el);
      else
        for (var ep = J.length - 1; ep >= 0; ep--)
          (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
      return ed > 3 && eh && Object.defineProperty(et, eo, eh),
        eh
    }([(0,
      eG.customElement)("w3m-upgrade-wallet-view")], tD);
    var tj = eo(69178)
      , tL = eY.iv`
wui-email-input {
  width: 100%;
}

form {
  width: 100%;
  display: block;
  position: relative;
}
`
      , w3m_update_email_wallet_view_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let t$ = class extends eY.oi {
      constructor() {
        super(...arguments),
          this.formRef = (0,
            tj.V)(),
          this.initialValue = eZ.RouterController.state.data?.email ?? "",
          this.email = "",
          this.loading = !1
      }
      firstUpdated() {
        this.formRef.value?.addEventListener("keydown", J => {
          "Enter" === J.key && this.onSubmitEmail(J)
        }
        )
      }
      render() {
        let J = !this.loading && this.email.length > 3 && this.email !== this.initialValue;
        return eY.dy`
    <wui-flex flexDirection="column" padding="m" gap="m">
      <form ${(0,
            tj.i)(this.formRef)} @submit=${this.onSubmitEmail.bind(this)}>
        <wui-email-input
          value=${this.initialValue}
          .disabled=${this.loading}
          @inputChange=${this.onEmailInputChange.bind(this)}
        >
        </wui-email-input>
        <input type="submit" hidden />
      </form>

      <wui-flex gap="s">
        <wui-button size="md" variant="shade" fullWidth @click=${eZ.RouterController.goBack}>
          Cancel
        </wui-button>

        <wui-button
          size="md"
          variant="fill"
          fullWidth
          @click=${this.onSubmitEmail.bind(this)}
          .disabled=${!J}
          .loading=${this.loading}
        >
          Save
        </wui-button>
      </wui-flex>
    </wui-flex>
  `
      }
      onEmailInputChange(J) {
        this.email = J.detail
      }
      async onSubmitEmail(J) {
        try {
          if (this.loading)
            return;
          this.loading = !0,
            J.preventDefault();
          let et = eZ.ConnectorController.getEmailConnector();
          if (!et)
            throw Error("w3m-update-email-wallet: Email connector not found");
          await et.provider.updateEmail({
            email: this.email
          }),
            eZ.Xs.sendEvent({
              type: "track",
              event: "EMAIL_EDIT"
            })
        } catch (J) {
          eZ.SnackController.showError(J),
            this.loading = !1
        }
      }
    }
      ;
    t$.styles = tL,
      w3m_update_email_wallet_view_decorate([(0,
        eK.SB)()], t$.prototype, "email", void 0),
      w3m_update_email_wallet_view_decorate([(0,
        eK.SB)()], t$.prototype, "loading", void 0),
      t$ = w3m_update_email_wallet_view_decorate([(0,
        eG.customElement)("w3m-update-email-wallet-view")], t$);
    let tB = class extends tP {
      constructor() {
        super(),
          this.onOtpSubmit = async J => {
            try {
              this.emailConnector && (await this.emailConnector.provider.connectOtp({
                otp: J
              }),
                eZ.Xs.sendEvent({
                  type: "track",
                  event: "EMAIL_VERIFICATION_CODE_PASS"
                }),
                await eZ.ConnectionController.connectExternal(this.emailConnector),
                eZ.IN.close(),
                eZ.Xs.sendEvent({
                  type: "track",
                  event: "CONNECT_SUCCESS",
                  properties: {
                    method: "email"
                  }
                }))
            } catch (J) {
              throw eZ.Xs.sendEvent({
                type: "track",
                event: "EMAIL_VERIFICATION_CODE_FAIL"
              }),
              J
            }
          }
          ,
          this.onOtpResend = async J => {
            this.emailConnector && (await this.emailConnector.provider.connectEmail({
              email: J
            }),
              eZ.Xs.sendEvent({
                type: "track",
                event: "EMAIL_VERIFICATION_CODE_SENT"
              }))
          }
      }
    }
      ;
    tB = function (J, et, eo, el) {
      var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        eh = Reflect.decorate(J, et, eo, el);
      else
        for (var ep = J.length - 1; ep >= 0; ep--)
          (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
      return ed > 3 && eh && Object.defineProperty(et, eo, eh),
        eh
    }([(0,
      eG.customElement)("w3m-update-email-primary-otp-view")], tB);
    let tF = class extends tP {
      constructor() {
        super(),
          this.onOtpSubmit = async J => {
            try {
              this.emailConnector && (await this.emailConnector.provider.connectOtp({
                otp: J
              }),
                eZ.Xs.sendEvent({
                  type: "track",
                  event: "EMAIL_VERIFICATION_CODE_PASS"
                }),
                await eZ.ConnectionController.connectExternal(this.emailConnector),
                eZ.IN.close(),
                eZ.Xs.sendEvent({
                  type: "track",
                  event: "CONNECT_SUCCESS",
                  properties: {
                    method: "email"
                  }
                }))
            } catch (J) {
              throw eZ.Xs.sendEvent({
                type: "track",
                event: "EMAIL_VERIFICATION_CODE_FAIL"
              }),
              J
            }
          }
          ,
          this.onOtpResend = async J => {
            this.emailConnector && (await this.emailConnector.provider.connectEmail({
              email: J
            }),
              eZ.Xs.sendEvent({
                type: "track",
                event: "EMAIL_VERIFICATION_CODE_SENT"
              }))
          }
      }
    }
      ;
    tF = function (J, et, eo, el) {
      var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        eh = Reflect.decorate(J, et, eo, el);
      else
        for (var ep = J.length - 1; ep >= 0; ep--)
          (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
      return ed > 3 && eh && Object.defineProperty(et, eo, eh),
        eh
    }([(0,
      eG.customElement)("w3m-update-email-secondary-otp-view")], tF);
    var tU = eY.iv`
wui-grid {
  max-height: clamp(360px, 400px, 80vh);
  overflow: scroll;
  scrollbar-width: none;
  grid-auto-rows: min-content;
  grid-template-columns: repeat(auto-fill, 76px);
}

@media (max-width: 435px) {
  wui-grid {
    grid-template-columns: repeat(auto-fill, 77px);
  }
}

wui-grid[data-scroll='false'] {
  overflow: hidden;
}

wui-grid::-webkit-scrollbar {
  display: none;
}

wui-loading-spinner {
  padding-top: var(--wui-spacing-l);
  padding-bottom: var(--wui-spacing-l);
  justify-content: center;
  grid-column: 1 / span 4;
}
`;
    function markWalletsAsInstalled(J) {
      let { connectors: et } = eZ.ConnectorController.state
        , eo = et.filter(J => "ANNOUNCED" === J.type).reduce((J, et) => (et.info?.rdns && (J[et.info.rdns] = !0),
          J), {})
        , el = J.map(J => ({
          ...J,
          installed: !!J.rdns && !!eo[J.rdns ?? ""]
        }))
        , ec = el.sort((J, et) => Number(et.installed) - Number(J.installed));
      return ec
    }
    var w3m_all_wallets_list_decorate = function (J, et, eo, el) {
      var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        eh = Reflect.decorate(J, et, eo, el);
      else
        for (var ep = J.length - 1; ep >= 0; ep--)
          (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
      return ed > 3 && eh && Object.defineProperty(et, eo, eh),
        eh
    };
    let tz = "local-paginator"
      , tH = class extends eY.oi {
        constructor() {
          super(),
            this.unsubscribe = [],
            this.paginationObserver = void 0,
            this.initial = !eZ.ApiController.state.wallets.length,
            this.wallets = eZ.ApiController.state.wallets,
            this.recommended = eZ.ApiController.state.recommended,
            this.featured = eZ.ApiController.state.featured,
            this.unsubscribe.push(...[eZ.ApiController.subscribeKey("wallets", J => this.wallets = J), eZ.ApiController.subscribeKey("recommended", J => this.recommended = J), eZ.ApiController.subscribeKey("featured", J => this.featured = J)])
        }
        firstUpdated() {
          this.initialFetch(),
            this.createPaginationObserver()
        }
        disconnectedCallback() {
          this.unsubscribe.forEach(J => J()),
            this.paginationObserver?.disconnect()
        }
        render() {
          return eY.dy`
    <wui-grid
      data-scroll=${!this.initial}
      .padding=${["0", "s", "s", "s"]}
      columnGap="xxs"
      rowGap="l"
      justifyContent="space-between"
    >
      ${this.initial ? this.shimmerTemplate(16) : this.walletsTemplate()}
      ${this.paginationLoaderTemplate()}
    </wui-grid>
  `
        }
        async initialFetch() {
          let J = this.shadowRoot?.querySelector("wui-grid");
          this.initial && J && (await eZ.ApiController.fetchWallets({
            page: 1
          }),
            await J.animate([{
              opacity: 1
            }, {
              opacity: 0
            }], {
              duration: 200,
              fill: "forwards",
              easing: "ease"
            }).finished,
            this.initial = !1,
            J.animate([{
              opacity: 0
            }, {
              opacity: 1
            }], {
              duration: 200,
              fill: "forwards",
              easing: "ease"
            }))
        }
        shimmerTemplate(J, et) {
          return [...Array(J)].map(() => eY.dy`
      <wui-card-select-loader type="wallet" id=${(0,
              eJ.o)(et)}></wui-card-select-loader>
    `)
        }
        walletsTemplate() {
          let J = [...this.featured, ...this.recommended, ...this.wallets]
            , et = markWalletsAsInstalled(J);
          return et.map(J => eY.dy`
      <wui-card-select
        imageSrc=${(0,
              eJ.o)(eZ.fz.getWalletImage(J))}
        type="wallet"
        name=${J.name}
        @click=${() => this.onConnectWallet(J)}
        .installed=${J.installed}
      ></wui-card-select>
    `)
        }
        paginationLoaderTemplate() {
          let { wallets: J, recommended: et, featured: eo, count: el } = eZ.ApiController.state
            , ec = window.innerWidth < 352 ? 3 : 4
            , ed = J.length + et.length
            , eh = Math.ceil(ed / ec)
            , ep = eh * ec - ed + ec;
          return (ep -= J.length ? eo.length % ec : 0,
            0 === el && eo.length > 0) ? null : 0 === el || [...eo, ...J, ...et].length < el ? this.shimmerTemplate(ep, tz) : null
        }
        createPaginationObserver() {
          let J = this.shadowRoot?.querySelector(`#${tz}`);
          J && (this.paginationObserver = new IntersectionObserver(([J]) => {
            if (J?.isIntersecting && !this.initial) {
              let { page: J, count: et, wallets: eo } = eZ.ApiController.state;
              eo.length < et && eZ.ApiController.fetchWallets({
                page: J + 1
              })
            }
          }
          ),
            this.paginationObserver.observe(J))
        }
        onConnectWallet(J) {
          let { connectors: et } = eZ.ConnectorController.state
            , eo = et.find(({ explorerId: et }) => et === J.id);
          eo ? eZ.RouterController.push("ConnectingExternal", {
            connector: eo
          }) : eZ.RouterController.push("ConnectingWalletConnect", {
            wallet: J
          })
        }
      }
      ;
    tH.styles = tU,
      w3m_all_wallets_list_decorate([(0,
        eK.SB)()], tH.prototype, "initial", void 0),
      w3m_all_wallets_list_decorate([(0,
        eK.SB)()], tH.prototype, "wallets", void 0),
      w3m_all_wallets_list_decorate([(0,
        eK.SB)()], tH.prototype, "recommended", void 0),
      w3m_all_wallets_list_decorate([(0,
        eK.SB)()], tH.prototype, "featured", void 0),
      tH = w3m_all_wallets_list_decorate([(0,
        eG.customElement)("w3m-all-wallets-list")], tH);
    var tV = eY.iv`
wui-grid,
wui-loading-spinner,
wui-flex {
  height: 360px;
}

wui-grid {
  overflow: scroll;
  scrollbar-width: none;
  grid-auto-rows: min-content;
}

wui-grid[data-scroll='false'] {
  overflow: hidden;
}

wui-grid::-webkit-scrollbar {
  display: none;
}

wui-loading-spinner {
  justify-content: center;
  align-items: center;
}
`
      , w3m_all_wallets_search_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let tW = class extends eY.oi {
      constructor() {
        super(...arguments),
          this.prevQuery = "",
          this.loading = !0,
          this.query = ""
      }
      render() {
        return this.onSearch(),
          this.loading ? eY.dy`<wui-loading-spinner color="accent-100"></wui-loading-spinner>` : this.walletsTemplate()
      }
      async onSearch() {
        this.query !== this.prevQuery && (this.prevQuery = this.query,
          this.loading = !0,
          await eZ.ApiController.searchWallet({
            search: this.query
          }),
          this.loading = !1)
      }
      walletsTemplate() {
        let { search: J } = eZ.ApiController.state
          , et = markWalletsAsInstalled(J);
        return J.length ? eY.dy`
    <wui-grid
      .padding=${["0", "s", "s", "s"]}
      gridTemplateColumns="repeat(4, 1fr)"
      rowGap="l"
      columnGap="xs"
    >
      ${et.map(J => eY.dy`
          <wui-card-select
            imageSrc=${(0,
            eJ.o)(eZ.fz.getWalletImage(J))}
            type="wallet"
            name=${J.name}
            @click=${() => this.onConnectWallet(J)}
            .installed=${J.installed}
          ></wui-card-select>
        `)}
    </wui-grid>
  ` : eY.dy`
      <wui-flex justifyContent="center" alignItems="center" gap="s" flexDirection="column">
        <wui-icon-box
          size="lg"
          iconColor="fg-200"
          backgroundColor="fg-300"
          icon="wallet"
          background="transparent"
        ></wui-icon-box>
        <wui-text color="fg-200" variant="paragraph-500">No Wallet found</wui-text>
      </wui-flex>
    `
      }
      onConnectWallet(J) {
        let { connectors: et } = eZ.ConnectorController.state
          , eo = et.find(({ explorerId: et }) => et === J.id);
        eo ? eZ.RouterController.push("ConnectingExternal", {
          connector: eo
        }) : eZ.RouterController.push("ConnectingWalletConnect", {
          wallet: J
        })
      }
    }
      ;
    tW.styles = tV,
      w3m_all_wallets_search_decorate([(0,
        eK.SB)()], tW.prototype, "loading", void 0),
      w3m_all_wallets_search_decorate([(0,
        eK.Cb)()], tW.prototype, "query", void 0),
      tW = w3m_all_wallets_search_decorate([(0,
        eG.customElement)("w3m-all-wallets-search")], tW);
    var w3m_connecting_header_decorate = function (J, et, eo, el) {
      var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        eh = Reflect.decorate(J, et, eo, el);
      else
        for (var ep = J.length - 1; ep >= 0; ep--)
          (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
      return ed > 3 && eh && Object.defineProperty(et, eo, eh),
        eh
    };
    let tq = class extends eY.oi {
      constructor() {
        super(),
          this.platformTabs = [],
          this.unsubscribe = [],
          this.platforms = [],
          this.onSelectPlatfrom = void 0,
          this.buffering = !1,
          this.unsubscribe.push(eZ.ConnectionController.subscribeKey("buffering", J => this.buffering = J))
      }
      disconnectCallback() {
        this.unsubscribe.forEach(J => J())
      }
      render() {
        let J = this.generateTabs();
        return eY.dy`
    <wui-flex justifyContent="center" .padding=${["l", "0", "0", "0"]}>
      <wui-tabs
        ?disabled=${this.buffering}
        .tabs=${J}
        .onTabChange=${this.onTabChange.bind(this)}
      ></wui-tabs>
    </wui-flex>
  `
      }
      generateTabs() {
        let J = this.platforms.map(J => "browser" === J ? {
          label: "Browser",
          icon: "extension",
          platform: "browser"
        } : "mobile" === J ? {
          label: "Mobile",
          icon: "mobile",
          platform: "mobile"
        } : "qrcode" === J ? {
          label: "Mobile",
          icon: "mobile",
          platform: "qrcode"
        } : "web" === J ? {
          label: "Webapp",
          icon: "browser",
          platform: "web"
        } : "desktop" === J ? {
          label: "Desktop",
          icon: "desktop",
          platform: "desktop"
        } : {
          label: "Browser",
          icon: "extension",
          platform: "unsupported"
        });
        return this.platformTabs = J.map(({ platform: J }) => J),
          J
      }
      onTabChange(J) {
        let et = this.platformTabs[J];
        et && this.onSelectPlatfrom?.(et)
      }
    }
      ;
    w3m_connecting_header_decorate([(0,
      eK.Cb)({
        type: Array
      })], tq.prototype, "platforms", void 0),
      w3m_connecting_header_decorate([(0,
        eK.Cb)()], tq.prototype, "onSelectPlatfrom", void 0),
      w3m_connecting_header_decorate([(0,
        eK.SB)()], tq.prototype, "buffering", void 0),
      tq = w3m_connecting_header_decorate([(0,
        eG.customElement)("w3m-connecting-header")], tq);
    let tZ = class extends W3mConnectingWidget {
      constructor() {
        if (super(),
          !this.wallet)
          throw Error("w3m-connecting-wc-browser: No wallet provided");
        this.onConnect = this.onConnectProxy.bind(this),
          this.onAutoConnect = this.onConnectProxy.bind(this),
          eZ.Xs.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: {
              name: this.wallet.name,
              platform: "browser"
            }
          })
      }
      async onConnectProxy() {
        try {
          this.error = !1;
          let { connectors: J } = eZ.ConnectorController.state
            , et = J.find(J => "ANNOUNCED" === J.type && J.info?.rdns === this.wallet?.rdns)
            , eo = J.find(J => "INJECTED" === J.type);
          et ? await eZ.ConnectionController.connectExternal(et) : eo && await eZ.ConnectionController.connectExternal(eo),
            eZ.IN.close(),
            eZ.Xs.sendEvent({
              type: "track",
              event: "CONNECT_SUCCESS",
              properties: {
                method: "browser"
              }
            })
        } catch (J) {
          eZ.Xs.sendEvent({
            type: "track",
            event: "CONNECT_ERROR",
            properties: {
              message: J?.message ?? "Unknown"
            }
          }),
            this.error = !0
        }
      }
    }
      ;
    tZ = function (J, et, eo, el) {
      var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        eh = Reflect.decorate(J, et, eo, el);
      else
        for (var ep = J.length - 1; ep >= 0; ep--)
          (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
      return ed > 3 && eh && Object.defineProperty(et, eo, eh),
        eh
    }([(0,
      eG.customElement)("w3m-connecting-wc-browser")], tZ);
    let tG = class extends W3mConnectingWidget {
      constructor() {
        if (super(),
          !this.wallet)
          throw Error("w3m-connecting-wc-desktop: No wallet provided");
        this.onConnect = this.onConnectProxy.bind(this),
          this.onRender = this.onRenderProxy.bind(this),
          eZ.Xs.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: {
              name: this.wallet.name,
              platform: "desktop"
            }
          })
      }
      onRenderProxy() {
        !this.ready && this.uri && (this.ready = !0,
          this.timeout = setTimeout(() => {
            this.onConnect?.()
          }
            , 200))
      }
      onConnectProxy() {
        if (this.wallet?.desktop_link && this.uri)
          try {
            this.error = !1;
            let { desktop_link: J, name: et } = this.wallet
              , { redirect: eo, href: el } = eZ.j1.formatNativeUrl(J, this.uri);
            eZ.ConnectionController.setWcLinking({
              name: et,
              href: el
            }),
              eZ.ConnectionController.setRecentWallet(this.wallet),
              eZ.j1.openHref(eo, "_blank")
          } catch {
            this.error = !0
          }
      }
    }
      ;
    tG = function (J, et, eo, el) {
      var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        eh = Reflect.decorate(J, et, eo, el);
      else
        for (var ep = J.length - 1; ep >= 0; ep--)
          (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
      return ed > 3 && eh && Object.defineProperty(et, eo, eh),
        eh
    }([(0,
      eG.customElement)("w3m-connecting-wc-desktop")], tG);
    let tY = class extends W3mConnectingWidget {
      constructor() {
        if (super(),
          !this.wallet)
          throw Error("w3m-connecting-wc-mobile: No wallet provided");
        this.onConnect = this.onConnectProxy.bind(this),
          this.onRender = this.onRenderProxy.bind(this),
          document.addEventListener("visibilitychange", this.onBuffering.bind(this)),
          eZ.Xs.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: {
              name: this.wallet.name,
              platform: "mobile"
            }
          })
      }
      disconnectedCallback() {
        super.disconnectedCallback(),
          document.removeEventListener("visibilitychange", this.onBuffering.bind(this))
      }
      onRenderProxy() {
        !this.ready && this.uri && (this.ready = !0,
          this.onConnect?.())
      }
      onConnectProxy() {
        if (this.wallet?.mobile_link && this.uri)
          try {
            this.error = !1;
            let { mobile_link: J, name: et } = this.wallet
              , { redirect: eo, href: el } = eZ.j1.formatNativeUrl(J, this.uri);
            eZ.ConnectionController.setWcLinking({
              name: et,
              href: el
            }),
              eZ.ConnectionController.setRecentWallet(this.wallet),
              eZ.j1.openHref(eo, "_self")
          } catch {
            this.error = !0
          }
      }
      onBuffering() {
        let J = eZ.j1.isIos();
        document?.visibilityState === "visible" && !this.error && J && (eZ.ConnectionController.setBuffering(!0),
          setTimeout(() => {
            eZ.ConnectionController.setBuffering(!1)
          }
            , 5e3))
      }
    }
      ;
    tY = function (J, et, eo, el) {
      var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        eh = Reflect.decorate(J, et, eo, el);
      else
        for (var ep = J.length - 1; ep >= 0; ep--)
          (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
      return ed > 3 && eh && Object.defineProperty(et, eo, eh),
        eh
    }([(0,
      eG.customElement)("w3m-connecting-wc-mobile")], tY);
    var tK = eY.iv`
@keyframes fadein {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

wui-shimmer {
  width: 100%;
  aspect-ratio: 1 / 1;
  border-radius: clamp(0px, var(--wui-border-radius-l), 40px) !important;
}

wui-qr-code {
  opacity: 0;
  animation-duration: 200ms;
  animation-timing-function: ease;
  animation-name: fadein;
  animation-fill-mode: forwards;
}
`;
    let tJ = class extends W3mConnectingWidget {
      constructor() {
        super(),
          this.forceUpdate = () => {
            this.requestUpdate()
          }
          ,
          window.addEventListener("resize", this.forceUpdate),
          eZ.Xs.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: {
              name: this.wallet?.name ?? "WalletConnect",
              platform: "qrcode"
            }
          })
      }
      disconnectedCallback() {
        super.disconnectedCallback(),
          window.removeEventListener("resize", this.forceUpdate)
      }
      render() {
        return this.onRenderProxy(),
          eY.dy`
    <wui-flex padding="xl" flexDirection="column" gap="xl" alignItems="center">
      <wui-shimmer borderRadius="l" width="100%"> ${this.qrCodeTemplate()} </wui-shimmer>

      <wui-text variant="paragraph-500" color="fg-100">
        Scan this QR Code with your phone
      </wui-text>
      ${this.copyTemplate()}
    </wui-flex>

    <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
  `
      }
      onRenderProxy() {
        !this.ready && this.uri && (this.timeout = setTimeout(() => {
          this.ready = !0
        }
          , 200))
      }
      qrCodeTemplate() {
        if (!this.uri || !this.ready)
          return null;
        let J = this.getBoundingClientRect().width - 40
          , et = this.wallet ? this.wallet.name : void 0;
        return eZ.ConnectionController.setWcLinking(void 0),
          eZ.ConnectionController.setRecentWallet(this.wallet),
          eY.dy` <wui-qr-code
    size=${J}
    theme=${eZ.ThemeController.state.themeMode}
    uri=${this.uri}
    imageSrc=${(0,
              eJ.o)(eZ.fz.getWalletImage(this.wallet))}
    alt=${(0,
              eJ.o)(et)}
  ></wui-qr-code>`
      }
      copyTemplate() {
        let J = !this.uri || !this.ready;
        return eY.dy`<wui-link
    .disabled=${J}
    @click=${this.onCopyUri}
    color="fg-200"
    data-testid="copy-wc2-uri"
  >
    <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
    Copy link
  </wui-link>`
      }
    }
      ;
    tJ.styles = tK,
      tJ = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      }([(0,
        eG.customElement)("w3m-connecting-wc-qrcode")], tJ);
    var tQ = eY.iv`
:host {
  display: flex;
  justify-content: center;
  gap: var(--wui-spacing-2xl);
}

wui-visual-thumbnail:nth-child(1) {
  z-index: 1;
}
`;
    let tX = class extends eY.oi {
      constructor() {
        super(...arguments),
          this.dappImageUrl = eZ.OptionsController.state.metadata?.icons,
          this.walletImageUrl = eZ.MO.getConnectedWalletImageUrl()
      }
      firstUpdated() {
        let J = this.shadowRoot?.querySelectorAll("wui-visual-thumbnail");
        J?.[0] && this.createAnimation(J[0], "translate(18px)"),
          J?.[1] && this.createAnimation(J[1], "translate(-18px)")
      }
      render() {
        return eY.dy`
    <wui-visual-thumbnail
      ?borderRadiusFull=${!0}
      .imageSrc=${this.dappImageUrl?.[0]}
    ></wui-visual-thumbnail>
    <wui-visual-thumbnail .imageSrc=${this.walletImageUrl}></wui-visual-thumbnail>
  `
      }
      createAnimation(J, et) {
        J.animate([{
          transform: "translateX(0px)"
        }, {
          transform: et
        }], {
          duration: 1600,
          easing: "cubic-bezier(0.56, 0, 0.48, 1)",
          direction: "alternate",
          iterations: 1 / 0
        })
      }
    }
      ;
    tX.styles = tQ,
      tX = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      }([(0,
        eG.customElement)("w3m-connecting-siwe")], tX);
    let t0 = class extends eY.oi {
      constructor() {
        if (super(),
          this.wallet = eZ.RouterController.state.data?.wallet,
          !this.wallet)
          throw Error("w3m-connecting-wc-unsupported: No wallet provided");
        eZ.Xs.sendEvent({
          type: "track",
          event: "SELECT_WALLET",
          properties: {
            name: this.wallet.name,
            platform: "browser"
          }
        })
      }
      render() {
        return eY.dy`
    <wui-flex
      flexDirection="column"
      alignItems="center"
      .padding=${["3xl", "xl", "xl", "xl"]}
      gap="xl"
    >
      <wui-wallet-image
        size="lg"
        imageSrc=${(0,
            eJ.o)(eZ.fz.getWalletImage(this.wallet))}
      ></wui-wallet-image>

      <wui-text variant="paragraph-500" color="fg-100">Not Detected</wui-text>
    </wui-flex>

    <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
  `
      }
    }
      ;
    t0 = function (J, et, eo, el) {
      var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        eh = Reflect.decorate(J, et, eo, el);
      else
        for (var ep = J.length - 1; ep >= 0; ep--)
          (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
      return ed > 3 && eh && Object.defineProperty(et, eo, eh),
        eh
    }([(0,
      eG.customElement)("w3m-connecting-wc-unsupported")], t0);
    let t1 = class extends W3mConnectingWidget {
      constructor() {
        if (super(),
          !this.wallet)
          throw Error("w3m-connecting-wc-web: No wallet provided");
        this.onConnect = this.onConnectProxy.bind(this),
          this.secondaryBtnLabel = "Open",
          this.secondaryLabel = "Open and continue in a new browser tab",
          this.secondaryBtnIcon = "externalLink",
          eZ.Xs.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: {
              name: this.wallet.name,
              platform: "web"
            }
          })
      }
      onConnectProxy() {
        if (this.wallet?.webapp_link && this.uri)
          try {
            this.error = !1;
            let { webapp_link: J, name: et } = this.wallet
              , { redirect: eo, href: el } = eZ.j1.formatUniversalUrl(J, this.uri);
            eZ.ConnectionController.setWcLinking({
              name: et,
              href: el
            }),
              eZ.ConnectionController.setRecentWallet(this.wallet),
              eZ.j1.openHref(eo, "_blank")
          } catch {
            this.error = !0
          }
      }
    }
      ;
    t1 = function (J, et, eo, el) {
      var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        eh = Reflect.decorate(J, et, eo, el);
      else
        for (var ep = J.length - 1; ep >= 0; ep--)
          (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
      return ed > 3 && eh && Object.defineProperty(et, eo, eh),
        eh
    }([(0,
      eG.customElement)("w3m-connecting-wc-web")], t1);
    var t2 = eY.iv`
wui-icon-link[data-hidden='true'] {
  opacity: 0 !important;
  pointer-events: none;
}
`
      , w3m_header_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    function headings() {
      let J = eZ.RouterController.state.data?.connector?.name
        , et = eZ.RouterController.state.data?.wallet?.name
        , eo = eZ.RouterController.state.data?.network?.name
        , el = et ?? J
        , ec = eZ.ConnectorController.getConnectors()
        , ed = 1 === ec.length && ec[0]?.id === "w3m-email";
      return {
        Connect: `Connect ${ed ? "Email" : ""} Wallet`,
        Account: void 0,
        ConnectingExternal: el ?? "Connect Wallet",
        ConnectingWalletConnect: el ?? "WalletConnect",
        ConnectingSiwe: "Sign In",
        Networks: "Choose Network",
        SwitchNetwork: eo ?? "Switch Network",
        AllWallets: "All Wallets",
        WhatIsANetwork: "What is a network?",
        WhatIsAWallet: "What is a wallet?",
        GetWallet: "Get a wallet",
        Downloads: el ? `Get ${el}` : "Downloads",
        EmailVerifyOtp: "Confirm Email",
        EmailVerifyDevice: "Register Device",
        ApproveTransaction: "Approve Transaction",
        Transactions: "Activity",
        UpgradeEmailWallet: "Upgrade your Wallet",
        UpdateEmailWallet: "Edit Email",
        UpdateEmailPrimaryOtp: "Confirm Current Email",
        UpdateEmailSecondaryOtp: "Confirm New Email"
      }
    }
    let t3 = class extends eY.oi {
      constructor() {
        super(),
          this.unsubscribe = [],
          this.heading = headings()[eZ.RouterController.state.view],
          this.buffering = !1,
          this.showBack = !1,
          this.unsubscribe.push(eZ.RouterController.subscribeKey("view", J => {
            this.onViewChange(J),
              this.onHistoryChange()
          }
          ), eZ.ConnectionController.subscribeKey("buffering", J => this.buffering = J))
      }
      disconnectCallback() {
        this.unsubscribe.forEach(J => J())
      }
      render() {
        return eY.dy`
    <wui-flex .padding=${this.getPadding()} justifyContent="space-between" alignItems="center">
      ${this.dynamicButtonTemplate()} ${this.titleTemplate()}
      <wui-icon-link
        ?disabled=${this.buffering}
        icon="close"
        @click=${this.onClose.bind(this)}
        data-testid="w3m-header-close"
      ></wui-icon-link>
    </wui-flex>
    ${this.separatorTemplate()}
  `
      }
      onWalletHelp() {
        eZ.Xs.sendEvent({
          type: "track",
          event: "CLICK_WALLET_HELP"
        }),
          eZ.RouterController.push("WhatIsAWallet")
      }
      async onClose() {
        eZ.yD.state.isSiweEnabled && "success" !== eZ.yD.state.status && await eZ.ConnectionController.disconnect(),
          eZ.IN.close()
      }
      titleTemplate() {
        return eY.dy`<wui-text variant="paragraph-700" color="fg-100">${this.heading}</wui-text>`
      }
      dynamicButtonTemplate() {
        let { view: J } = eZ.RouterController.state;
        return this.showBack && "ApproveTransaction" !== J ? eY.dy`<wui-icon-link
      id="dynamic"
      icon="chevronLeft"
      ?disabled=${this.buffering}
      @click=${this.onGoBack.bind(this)}
    ></wui-icon-link>` : eY.dy`<wui-icon-link
    data-hidden=${"Connect" !== J}
    id="dynamic"
    icon="helpCircle"
    @click=${this.onWalletHelp.bind(this)}
  ></wui-icon-link>`
      }
      separatorTemplate() {
        return this.heading ? eY.dy`<wui-separator></wui-separator>` : null
      }
      getPadding() {
        return this.heading ? ["l", "2l", "l", "2l"] : ["l", "2l", "0", "2l"]
      }
      async onViewChange(J) {
        let et = this.shadowRoot?.querySelector("wui-text");
        if (et) {
          let eo = headings()[J];
          await et.animate([{
            opacity: 1
          }, {
            opacity: 0
          }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
          }).finished,
            this.heading = eo,
            et.animate([{
              opacity: 0
            }, {
              opacity: 1
            }], {
              duration: 200,
              fill: "forwards",
              easing: "ease"
            })
        }
      }
      async onHistoryChange() {
        let { history: J } = eZ.RouterController.state
          , et = this.shadowRoot?.querySelector("#dynamic");
        J.length > 1 && !this.showBack && et ? (await et.animate([{
          opacity: 1
        }, {
          opacity: 0
        }], {
          duration: 200,
          fill: "forwards",
          easing: "ease"
        }).finished,
          this.showBack = !0,
          et.animate([{
            opacity: 0
          }, {
            opacity: 1
          }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
          })) : J.length <= 1 && this.showBack && et && (await et.animate([{
            opacity: 1
          }, {
            opacity: 0
          }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
          }).finished,
            this.showBack = !1,
            et.animate([{
              opacity: 0
            }, {
              opacity: 1
            }], {
              duration: 200,
              fill: "forwards",
              easing: "ease"
            }))
      }
      onGoBack() {
        "ConnectingSiwe" === eZ.RouterController.state.view ? eZ.RouterController.push("Connect") : eZ.RouterController.goBack()
      }
    }
      ;
    t3.styles = [t2],
      w3m_header_decorate([(0,
        eK.SB)()], t3.prototype, "heading", void 0),
      w3m_header_decorate([(0,
        eK.SB)()], t3.prototype, "buffering", void 0),
      w3m_header_decorate([(0,
        eK.SB)()], t3.prototype, "showBack", void 0),
      t3 = w3m_header_decorate([(0,
        eG.customElement)("w3m-header")], t3);
    var w3m_help_widget_decorate = function (J, et, eo, el) {
      var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        eh = Reflect.decorate(J, et, eo, el);
      else
        for (var ep = J.length - 1; ep >= 0; ep--)
          (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
      return ed > 3 && eh && Object.defineProperty(et, eo, eh),
        eh
    };
    let t5 = class extends eY.oi {
      constructor() {
        super(...arguments),
          this.data = []
      }
      render() {
        return eY.dy`
    <wui-flex flexDirection="column" alignItems="center" gap="l">
      ${this.data.map(J => eY.dy`
          <wui-flex flexDirection="column" alignItems="center" gap="xl">
            <wui-flex flexDirection="row" justifyContent="center" gap="1xs">
              ${J.images.map(J => eY.dy`<wui-visual name=${J}></wui-visual>`)}
            </wui-flex>
          </wui-flex>
          <wui-flex flexDirection="column" alignItems="center" gap="xxs">
            <wui-text variant="paragraph-500" color="fg-100" align="center">
              ${J.title}
            </wui-text>
            <wui-text variant="small-500" color="fg-200" align="center">${J.text}</wui-text>
          </wui-flex>
        `)}
    </wui-flex>
  `
      }
    }
      ;
    w3m_help_widget_decorate([(0,
      eK.Cb)({
        type: Array
      })], t5.prototype, "data", void 0),
      t5 = w3m_help_widget_decorate([(0,
        eG.customElement)("w3m-help-widget")], t5);
    var t6 = eY.iv`
wui-flex {
  background-color: var(--wui-gray-glass-005);
}

a {
  text-decoration: none;
  color: var(--wui-color-fg-175);
  font-weight: 500;
}
`;
    let t4 = class extends eY.oi {
      render() {
        let { termsConditionsUrl: J, privacyPolicyUrl: et } = eZ.OptionsController.state;
        return J || et ? eY.dy`
    <wui-flex .padding=${["m", "s", "s", "s"]} justifyContent="center">
      <wui-text color="fg-250" variant="small-400" align="center">
        By connecting your wallet, you agree to our <br />
        ${this.termsTemplate()} ${this.andTemplate()} ${this.privacyTemplate()}
      </wui-text>
    </wui-flex>
  ` : null
      }
      andTemplate() {
        let { termsConditionsUrl: J, privacyPolicyUrl: et } = eZ.OptionsController.state;
        return J && et ? "and" : ""
      }
      termsTemplate() {
        let { termsConditionsUrl: J } = eZ.OptionsController.state;
        return J ? eY.dy`<a href=${J}>Terms of Service</a>` : null
      }
      privacyTemplate() {
        let { privacyPolicyUrl: J } = eZ.OptionsController.state;
        return J ? eY.dy`<a href=${J}>Privacy Policy</a>` : null
      }
    }
      ;
    t4.styles = [t6],
      t4 = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      }([(0,
        eG.customElement)("w3m-legal-footer")], t4);
    var t8 = eY.iv`
:host {
  display: block;
  padding: 0 var(--wui-spacing-xl) var(--wui-spacing-xl);
}
`
      , w3m_mobile_download_links_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let t7 = class extends eY.oi {
      constructor() {
        super(...arguments),
          this.wallet = void 0
      }
      render() {
        if (!this.wallet)
          return this.style.display = "none",
            null;
        let { name: J, app_store: et, play_store: eo, chrome_store: el, homepage: ec } = this.wallet
          , ed = eZ.j1.isMobile()
          , eh = eZ.j1.isIos()
          , ep = eZ.j1.isAndroid()
          , ef = [et, eo, ec, el].filter(Boolean).length > 1
          , em = eG.UiHelperUtil.getTruncateString({
            string: J,
            charsStart: 12,
            charsEnd: 0,
            truncate: "end"
          });
        return ef && !ed ? eY.dy`
      <wui-cta-button
        label=${`Don't have ${em}?`}
        buttonLabel="Get"
        @click=${() => eZ.RouterController.push("Downloads", {
          wallet: this.wallet
        })}
      ></wui-cta-button>
    ` : !ef && ec ? eY.dy`
      <wui-cta-button
        label=${`Don't have ${em}?`}
        buttonLabel="Get"
        @click=${this.onHomePage.bind(this)}
      ></wui-cta-button>
    ` : et && eh ? eY.dy`
      <wui-cta-button
        label=${`Don't have ${em}?`}
        buttonLabel="Get"
        @click=${this.onAppStore.bind(this)}
      ></wui-cta-button>
    ` : eo && ep ? eY.dy`
      <wui-cta-button
        label=${`Don't have ${em}?`}
        buttonLabel="Get"
        @click=${this.onPlayStore.bind(this)}
      ></wui-cta-button>
    ` : (this.style.display = "none",
          null)
      }
      onAppStore() {
        this.wallet?.app_store && eZ.j1.openHref(this.wallet.app_store, "_blank")
      }
      onPlayStore() {
        this.wallet?.play_store && eZ.j1.openHref(this.wallet.play_store, "_blank")
      }
      onHomePage() {
        this.wallet?.homepage && eZ.j1.openHref(this.wallet.homepage, "_blank")
      }
    }
      ;
    t7.styles = [t8],
      w3m_mobile_download_links_decorate([(0,
        eK.Cb)({
          type: Object
        })], t7.prototype, "wallet", void 0),
      t7 = w3m_mobile_download_links_decorate([(0,
        eG.customElement)("w3m-mobile-download-links")], t7);
    var t9 = eY.iv`
:host {
  display: block;
  position: absolute;
  opacity: 0;
  pointer-events: none;
  top: 11px;
  left: 50%;
  width: max-content;
}
`
      , w3m_snackbar_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let ro = {
      success: {
        backgroundColor: "success-100",
        iconColor: "success-100",
        icon: "checkmark"
      },
      error: {
        backgroundColor: "error-100",
        iconColor: "error-100",
        icon: "close"
      }
    }
      , ra = class extends eY.oi {
        constructor() {
          super(),
            this.unsubscribe = [],
            this.timeout = void 0,
            this.open = eZ.SnackController.state.open,
            this.unsubscribe.push(eZ.SnackController.subscribeKey("open", J => {
              this.open = J,
                this.onOpen()
            }
            ))
        }
        disconnectedCallback() {
          clearTimeout(this.timeout),
            this.unsubscribe.forEach(J => J())
        }
        render() {
          let { message: J, variant: et } = eZ.SnackController.state
            , eo = ro[et];
          return eY.dy`
    <wui-snackbar
      message=${J}
      backgroundColor=${eo.backgroundColor}
      iconColor=${eo.iconColor}
      icon=${eo.icon}
    ></wui-snackbar>
  `
        }
        onOpen() {
          clearTimeout(this.timeout),
            this.open ? (this.animate([{
              opacity: 0,
              transform: "translateX(-50%) scale(0.85)"
            }, {
              opacity: 1,
              transform: "translateX(-50%) scale(1)"
            }], {
              duration: 150,
              fill: "forwards",
              easing: "ease"
            }),
              this.timeout = setTimeout(() => eZ.SnackController.hide(), 2500)) : this.animate([{
                opacity: 1,
                transform: "translateX(-50%) scale(1)"
              }, {
                opacity: 0,
                transform: "translateX(-50%) scale(0.85)"
              }], {
                duration: 150,
                fill: "forwards",
                easing: "ease"
              })
        }
      }
      ;
    ra.styles = t9,
      w3m_snackbar_decorate([(0,
        eK.SB)()], ra.prototype, "open", void 0),
      ra = w3m_snackbar_decorate([(0,
        eG.customElement)("w3m-snackbar")], ra);
    var rl = eY.iv`
wui-separator {
  margin: var(--wui-spacing-s) calc(var(--wui-spacing-s) * -1);
  width: calc(100% + var(--wui-spacing-s) * 2);
}

wui-email-input {
  width: 100%;
}

form {
  width: 100%;
  display: block;
  position: relative;
}

wui-icon-link,
wui-loading-spinner {
  position: absolute;
  top: 21px;
  transform: translateY(-50%);
}

wui-icon-link {
  right: var(--wui-spacing-xs);
}

wui-loading-spinner {
  right: var(--wui-spacing-m);
}

.alphaBanner {
  padding: 10px 12px 10px 10px;
  border-radius: var(--wui-border-radius-s);
  background: var(--wui-accent-glass-010);
  margin-bottom: var(--wui-spacing-s);
}
`
      , w3m_email_login_widget_decorate = function (J, et, eo, el) {
        var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          eh = Reflect.decorate(J, et, eo, el);
        else
          for (var ep = J.length - 1; ep >= 0; ep--)
            (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
        return ed > 3 && eh && Object.defineProperty(et, eo, eh),
          eh
      };
    let rc = class extends eY.oi {
      constructor() {
        super(),
          this.unsubscribe = [],
          this.formRef = (0,
            tj.V)(),
          this.connectors = eZ.ConnectorController.state.connectors,
          this.email = "",
          this.loading = !1,
          this.error = "",
          this.unsubscribe.push(eZ.ConnectorController.subscribeKey("connectors", J => this.connectors = J))
      }
      disconnectedCallback() {
        this.unsubscribe.forEach(J => J())
      }
      firstUpdated() {
        this.formRef.value?.addEventListener("keydown", J => {
          "Enter" === J.key && this.onSubmitEmail(J)
        }
        )
      }
      render() {
        let J = this.connectors.length > 1
          , et = this.connectors.find(J => "EMAIL" === J.type);
        return et ? eY.dy`
    ${this.alphaWarningTemplate()}
    <form ${(0,
            tj.i)(this.formRef)} @submit=${this.onSubmitEmail.bind(this)}>
      <wui-email-input
        @focus=${this.onFocusEvent.bind(this)}
        .disabled=${this.loading}
        @inputChange=${this.onEmailInputChange.bind(this)}
        .errorMessage=${this.error}
      >
      </wui-email-input>

      ${this.submitButtonTemplate()}${this.loadingTemplate()}
      <input type="submit" hidden />
    </form>

    ${J ? eY.dy`<wui-separator text="or"></wui-separator>` : null}
  ` : null
      }
      alphaWarningTemplate() {
        return eY.dy`
        <wui-flex class="alphaBanner" gap="xs" alignItems="center" justifyContent="center">
          <wui-icon-box
            size="sm"
            icon="alpha"
            iconColor="accent-100"
            background="opaque"
            backgroundColor="accent-100"
          ></wui-icon-box>
          <wui-text variant="small-400" color="accent-100">Email login is in alpha</wui-text>
        </wui-flex>
      `
      }
      submitButtonTemplate() {
        let J = !this.loading && this.email.length > 3;
        return J ? eY.dy`
        <wui-icon-link
          size="sm"
          icon="chevronRight"
          iconcolor="accent-100"
          @click=${this.onSubmitEmail.bind(this)}
        >
        </wui-icon-link>
      ` : null
      }
      loadingTemplate() {
        return this.loading ? eY.dy`<wui-loading-spinner size="md" color="accent-100"></wui-loading-spinner>` : null
      }
      onEmailInputChange(J) {
        this.email = J.detail,
          this.error = ""
      }
      async onSubmitEmail(J) {
        try {
          if (this.loading)
            return;
          this.loading = !0,
            J.preventDefault();
          let et = eZ.ConnectorController.getEmailConnector();
          if (!et)
            throw Error("w3m-email-login-widget: Email connector not found");
          let { action: eo } = await et.provider.connectEmail({
            email: this.email
          });
          eZ.Xs.sendEvent({
            type: "track",
            event: "EMAIL_SUBMITTED"
          }),
            "VERIFY_OTP" === eo ? (eZ.Xs.sendEvent({
              type: "track",
              event: "EMAIL_VERIFICATION_CODE_SENT"
            }),
              eZ.RouterController.push("EmailVerifyOtp", {
                email: this.email
              })) : "VERIFY_DEVICE" === eo && eZ.RouterController.push("EmailVerifyDevice", {
                email: this.email
              })
        } catch (et) {
          let J = eZ.j1.parseError(et);
          J?.includes("Invalid email") ? this.error = "Invalid email. Try again." : eZ.SnackController.showError(et)
        } finally {
          this.loading = !1
        }
      }
      onFocusEvent() {
        eZ.Xs.sendEvent({
          type: "track",
          event: "EMAIL_LOGIN_SELECTED"
        })
      }
    }
      ;
    rc.styles = rl,
      w3m_email_login_widget_decorate([(0,
        eK.SB)()], rc.prototype, "connectors", void 0),
      w3m_email_login_widget_decorate([(0,
        eK.SB)()], rc.prototype, "email", void 0),
      w3m_email_login_widget_decorate([(0,
        eK.SB)()], rc.prototype, "loading", void 0),
      w3m_email_login_widget_decorate([(0,
        eK.SB)()], rc.prototype, "error", void 0),
      rc = w3m_email_login_widget_decorate([(0,
        eG.customElement)("w3m-email-login-widget")], rc);
    let rd = !1;
    let Web3ModalScaffold = class Web3ModalScaffold {
      constructor(J) {
        this.initPromise = void 0,
          this.setIsConnected = J => {
            eZ.AccountController.setIsConnected(J)
          }
          ,
          this.setCaipAddress = J => {
            eZ.AccountController.setCaipAddress(J)
          }
          ,
          this.setBalance = (J, et) => {
            eZ.AccountController.setBalance(J, et)
          }
          ,
          this.setProfileName = J => {
            eZ.AccountController.setProfileName(J)
          }
          ,
          this.setProfileImage = J => {
            eZ.AccountController.setProfileImage(J)
          }
          ,
          this.resetAccount = () => {
            eZ.AccountController.resetAccount()
          }
          ,
          this.setCaipNetwork = J => {
            eZ.NetworkController.setCaipNetwork(J)
          }
          ,
          this.getCaipNetwork = () => eZ.NetworkController.state.caipNetwork,
          this.setRequestedCaipNetworks = J => {
            eZ.NetworkController.setRequestedCaipNetworks(J)
          }
          ,
          this.getApprovedCaipNetworksData = () => eZ.NetworkController.getApprovedCaipNetworksData(),
          this.resetNetwork = () => {
            eZ.NetworkController.resetNetwork()
          }
          ,
          this.setConnectors = J => {
            eZ.ConnectorController.setConnectors(J)
          }
          ,
          this.addConnector = J => {
            eZ.ConnectorController.addConnector(J)
          }
          ,
          this.getConnectors = () => eZ.ConnectorController.getConnectors(),
          this.resetWcConnection = () => {
            eZ.ConnectionController.resetWcConnection()
          }
          ,
          this.fetchIdentity = J => eZ.Lr.fetchIdentity(J),
          this.setAddressExplorerUrl = J => {
            eZ.AccountController.setAddressExplorerUrl(J)
          }
          ,
          this.setSIWENonce = J => {
            eZ.yD.setNonce(J)
          }
          ,
          this.setSIWESession = J => {
            eZ.yD.setSession(J)
          }
          ,
          this.setSIWEStatus = J => {
            eZ.yD.setStatus(J)
          }
          ,
          this.setSIWEMessage = J => {
            eZ.yD.setMessage(J)
          }
          ,
          this.initControllers(J),
          this.initOrContinue()
      }
      async open(J) {
        await this.initOrContinue(),
          eZ.IN.open(J)
      }
      async close() {
        await this.initOrContinue(),
          eZ.IN.close()
      }
      setLoading(J) {
        eZ.IN.setLoading(J)
      }
      getThemeMode() {
        return eZ.ThemeController.state.themeMode
      }
      getThemeVariables() {
        return eZ.ThemeController.state.themeVariables
      }
      setThemeMode(J) {
        eZ.ThemeController.setThemeMode(J),
          (0,
            eG.setColorTheme)(eZ.ThemeController.state.themeMode);
        try {
          let J = eZ.ConnectorController.getEmailConnector();
          J && J.provider.syncTheme({
            themeMode: eZ.ThemeController.getSnapshot().themeMode
          })
        } catch {
          console.info("Unable to sync theme to email connector")
        }
      }
      setThemeVariables(J) {
        eZ.ThemeController.setThemeVariables(J),
          (0,
            eG.setThemeVariables)(eZ.ThemeController.state.themeVariables);
        try {
          let J = eZ.ConnectorController.getEmailConnector();
          J && J.provider.syncTheme({
            themeVariables: eZ.ThemeController.getSnapshot().themeVariables
          })
        } catch {
          console.info("Unable to sync theme to email connector")
        }
      }
      subscribeTheme(J) {
        return eZ.ThemeController.subscribe(J)
      }
      getState() {
        return {
          ...eZ.Ie.state
        }
      }
      subscribeState(J) {
        return eZ.Ie.subscribe(J)
      }
      getEvent() {
        return {
          ...eZ.Xs.state
        }
      }
      subscribeEvents(J) {
        return eZ.Xs.subscribe(J)
      }
      subscribeSIWEState(J) {
        return eZ.yD.subscribe(J)
      }
      initControllers(J) {
        if (eZ.NetworkController.setClient(J.networkControllerClient),
          eZ.NetworkController.setDefaultCaipNetwork(J.defaultChain),
          eZ.OptionsController.setProjectId(J.projectId),
          eZ.OptionsController.setAllWallets(J.allWallets),
          eZ.OptionsController.setIncludeWalletIds(J.includeWalletIds),
          eZ.OptionsController.setExcludeWalletIds(J.excludeWalletIds),
          eZ.OptionsController.setFeaturedWalletIds(J.featuredWalletIds),
          eZ.OptionsController.setTokens(J.tokens),
          eZ.OptionsController.setTermsConditionsUrl(J.termsConditionsUrl),
          eZ.OptionsController.setPrivacyPolicyUrl(J.privacyPolicyUrl),
          eZ.OptionsController.setCustomWallets(J.customWallets),
          eZ.OptionsController.setEnableAnalytics(J.enableAnalytics),
          eZ.OptionsController.setSdkVersion(J._sdkVersion),
          eZ.ConnectionController.setClient(J.connectionControllerClient),
          J.siweControllerClient) {
          let et = J.siweControllerClient;
          eZ.yD.setSIWEClient(et)
        }
        J.metadata && eZ.OptionsController.setMetadata(J.metadata),
          J.themeMode && eZ.ThemeController.setThemeMode(J.themeMode),
          J.themeVariables && eZ.ThemeController.setThemeVariables(J.themeVariables)
      }
      async initOrContinue() {
        return !this.initPromise && !rd && eZ.j1.isClient() && (rd = !0,
          this.initPromise = new Promise(async J => {
            await Promise.all([Promise.resolve().then(eo.bind(eo, 87214)), Promise.resolve().then(eo.bind(eo, 90078))]);
            let et = document.createElement("w3m-modal");
            document.body.insertAdjacentElement("beforeend", et),
              J()
          }
          )),
          this.initPromise
      }
    }
      ;
    var rh = eo(52408);
    async function getWalletConnectCaipNetworks(J) {
      if (!J)
        throw Error("networkControllerClient:getApprovedCaipNetworks - connector is undefined");
      let et = await J?.getProvider()
        , eo = et?.signer?.session?.namespaces
        , el = eo?.[rh.bq.EIP155]?.methods
        , ec = eo?.[rh.bq.EIP155]?.chains;
      return {
        supportsAllNetworks: !!el?.includes(rh.bq.ADD_CHAIN_METHOD),
        approvedCaipNetworkIds: ec
      }
    }
    let Web3Modal = class Web3Modal extends Web3ModalScaffold {
      constructor(J) {
        let { wagmiConfig: et, siweConfig: eo, defaultChain: el, tokens: ec, _sdkVersion: ed, ...eh } = J;
        if (!et)
          throw Error("web3modal:constructor - wagmiConfig is undefined");
        if (!eh.projectId)
          throw Error("web3modal:constructor - projectId is undefined");
        super({
          networkControllerClient: {
            switchCaipNetwork: async J => {
              let et = rh.gk.caipNetworkIdToNumber(J?.id);
              et && await switchChain(this.wagmiConfig, {
                chainId: et
              })
            }
            ,
            getApprovedCaipNetworksData: async () => new Promise(J => {
              let eo = new Map(et.state.connections)
                , el = eo.get(et.state.current || "");
              if (el?.connector?.id === rh.bq.EMAIL_CONNECTOR_ID)
                J({
                  supportsAllNetworks: !1,
                  approvedCaipNetworkIds: rh.CK.WalletConnectRpcChainIds.map(J => `${rh.bq.EIP155}:${J}`)
                });
              else if (el?.connector?.id === rh.bq.WALLET_CONNECT_CONNECTOR_ID) {
                let eo = et.connectors.find(J => J.id === rh.bq.WALLET_CONNECT_CONNECTOR_ID);
                J(getWalletConnectCaipNetworks(eo))
              }
              J({
                approvedCaipNetworkIds: void 0,
                supportsAllNetworks: !0
              })
            }
            )
          },
          connectionControllerClient: {
            connectWalletConnect: async J => {
              let eo = et.connectors.find(J => J.id === rh.bq.WALLET_CONNECT_CONNECTOR_ID);
              if (!eo)
                throw Error("connectionControllerClient:getWalletConnectUri - connector is undefined");
              let el = await eo.getProvider();
              el.on("display_uri", et => {
                J(et)
              }
              );
              let ec = rh.gk.caipNetworkIdToNumber(this.getCaipNetwork()?.id);
              await connect(this.wagmiConfig, {
                connector: eo,
                chainId: ec
              })
            }
            ,
            connectExternal: async ({ id: J, provider: eo, info: el }) => {
              let ec = et.connectors.find(et => et.id === J);
              if (!ec)
                throw Error("connectionControllerClient:connectExternal - connector is undefined");
              eo && el && ec.id === rh.bq.EIP6963_CONNECTOR_ID && ec.setEip6963Wallet?.({
                provider: eo,
                info: el
              });
              let ed = rh.gk.caipNetworkIdToNumber(this.getCaipNetwork()?.id);
              await connect(this.wagmiConfig, {
                connector: ec,
                chainId: ed
              })
            }
            ,
            checkInstalled: J => {
              let et = this.getConnectors().find(J => "INJECTED" === J.type);
              return J ? !!et && !!window?.ethereum && J.some(J => !!window.ethereum?.[String(J)]) : !!window.ethereum
            }
            ,
            disconnect: async () => {
              await disconnect(this.wagmiConfig),
                eo?.options?.signOutOnDisconnect && await eo.signOut()
            }
            ,
            signMessage: async J => signMessage_signMessage(this.wagmiConfig, {
              message: J
            })
          },
          siweControllerClient: eo,
          defaultChain: function (J) {
            if (J)
              return {
                id: `${rh.bq.EIP155}:${J.id}`,
                name: J.name,
                imageId: rh.CK.EIP155NetworkImageIds[J.id]
              }
          }(el),
          tokens: rh.gk.getCaipTokens(ec),
          _sdkVersion: ed ?? `html-wagmi-${rh.bq.VERSION}`,
          ...eh
        }),
          this.hasSyncedConnectedAccount = !1,
          this.options = void 0,
          this.options = J,
          this.wagmiConfig = et,
          this.syncRequestedNetworks([...et.chains]),
          this.syncConnectors([...et.connectors]),
          function (J, et) {
            let { onChange: eo } = et;
            J._internal.connectors.subscribe((J, et) => {
              eo(Object.values(J), et)
            }
            )
          }(this.wagmiConfig, {
            onChange: J => this.syncConnectors(J)
          }),
          function (J, et) {
            let { onChange: eo } = et;
            J.subscribe(() => getAccount(J), eo, {
              equalityFn(J, et) {
                let { connector: eo, ...el } = J
                  , { connector: ec, ...ed } = et;
                return function deepEqual(J, et) {
                  if (J === et)
                    return !0;
                  if (J && et && "object" == typeof J && "object" == typeof et) {
                    let eo, el;
                    if (J.constructor !== et.constructor)
                      return !1;
                    if (Array.isArray(J) && Array.isArray(et)) {
                      if ((eo = J.length) !== et.length)
                        return !1;
                      for (el = eo; 0 != el--;)
                        if (!deepEqual(J[el], et[el]))
                          return !1;
                      return !0
                    }
                    if (J.valueOf !== Object.prototype.valueOf)
                      return J.valueOf() === et.valueOf();
                    if (J.toString !== Object.prototype.toString)
                      return J.toString() === et.toString();
                    let ec = Object.keys(J);
                    if ((eo = ec.length) !== Object.keys(et).length)
                      return !1;
                    for (el = eo; 0 != el--;)
                      if (!Object.prototype.hasOwnProperty.call(et, ec[el]))
                        return !1;
                    for (el = eo; 0 != el--;) {
                      let eo = ec[el];
                      if (eo && !deepEqual(J[eo], et[eo]))
                        return !1
                    }
                    return !0
                  }
                  return J != J && et != et
                }(el, ed) && eo?.id === ec?.id && eo?.uid === ec?.uid
              }
            })
          }(this.wagmiConfig, {
            onChange: J => this.syncAccount({
              ...J,
              config: et
            })
          })
      }
      getState() {
        let J = super.getState();
        return {
          ...J,
          selectedNetworkId: rh.gk.caipNetworkIdToNumber(J.selectedNetworkId)
        }
      }
      subscribeState(J) {
        return super.subscribeState(et => J({
          ...et,
          selectedNetworkId: rh.gk.caipNetworkIdToNumber(et.selectedNetworkId)
        }))
      }
      syncRequestedNetworks(J) {
        let et = J?.map(J => ({
          id: `${rh.bq.EIP155}:${J.id}`,
          name: J.name,
          imageId: rh.CK.EIP155NetworkImageIds[J.id],
          imageUrl: this.options?.chainImages?.[J.id]
        }));
        this.setRequestedCaipNetworks(et ?? [])
      }
      async syncAccount({ address: J, isConnected: et, chainId: eo }) {
        if (this.resetAccount(),
          this.syncNetwork(),
          et && J && eo) {
          let el = `${rh.bq.EIP155}:${eo}:${J}`;
          this.setIsConnected(et),
            this.setCaipAddress(el),
            await Promise.all([this.syncProfile(J, eo), this.syncBalance(J, eo), this.getApprovedCaipNetworksData()]),
            this.hasSyncedConnectedAccount = !0
        } else
          !et && this.hasSyncedConnectedAccount && (this.resetWcConnection(),
            this.resetNetwork())
      }
      async syncNetwork() {
        let { address: J, isConnected: et, chainId: eo } = getAccount(this.wagmiConfig)
          , el = this.wagmiConfig.chains.find(J => J.id === eo);
        if (el || eo) {
          let ec = el?.name ?? eo?.toString()
            , ed = Number(el?.id ?? eo)
            , eh = `${rh.bq.EIP155}:${ed}`;
          if (this.setCaipNetwork({
            id: eh,
            name: ec,
            imageId: rh.CK.EIP155NetworkImageIds[ed],
            imageUrl: this.options?.chainImages?.[ed]
          }),
            et && J && eo) {
            let et = `${rh.bq.EIP155}:${ed}:${J}`;
            if (this.setCaipAddress(et),
              el?.blockExplorers?.default?.url) {
              let et = `${el.blockExplorers.default.url}/address/${J}`;
              this.setAddressExplorerUrl(et)
            } else
              this.setAddressExplorerUrl(void 0);
            this.hasSyncedConnectedAccount && (await this.syncProfile(J, eo),
              await this.syncBalance(J, eo))
          }
        }
      }
      async syncProfile(J, et) {
        if (et !== eW.id) {
          this.setProfileName(null),
            this.setProfileImage(null);
          return
        }
        try {
          let { name: eo, avatar: el } = await this.fetchIdentity({
            caipChainId: `${rh.bq.EIP155}:${et}`,
            address: J
          });
          this.setProfileName(eo),
            this.setProfileImage(el)
        } catch {
          let eo = await function (J, et) {
            let { chainId: eo, ...el } = et
              , ec = J.getClient({
                chainId: eo
              })
              , ed = (0,
                eg.s)(ec, getEnsName, "getEnsName");
            return ed(el)
          }(this.wagmiConfig, {
            address: J,
            chainId: et
          });
          if (eo) {
            this.setProfileName(eo);
            let J = await function (J, et) {
              let { chainId: eo, ...el } = et
                , ec = J.getClient({
                  chainId: eo
                })
                , ed = (0,
                  eg.s)(ec, getEnsAvatar, "getEnsAvatar");
              return ed(el)
            }(this.wagmiConfig, {
              name: eo,
              chainId: et
            });
            J && this.setProfileImage(J)
          }
        }
      }
      async syncBalance(J, et) {
        let eo = this.wagmiConfig.chains.find(J => J.id === et)
          , el = eo?.id || this.options?.defaultChain?.id || this.wagmiConfig?.chains?.[0]?.id
          , ec = await getBalance_getBalance(this.wagmiConfig, {
            address: J,
            chainId: el,
            token: this.options?.tokens?.[el]?.address
          });
        this.setBalance(ec.formatted, ec.symbol)
      }
      syncConnectors(J) {
        let et = []
          , eo = rh.bq.COINBASE_SDK_CONNECTOR_ID
          , el = J.find(J => J.id === eZ.bq.CONNECTOR_RDNS_MAP[eo]);
        J.forEach(({ id: J, name: ec, type: ed, icon: eh }) => {
          let ep = el && J === eo || rh.bq.EMAIL_CONNECTOR_ID === J;
          ep || et.push({
            id: J,
            explorerId: rh.CK.ConnectorExplorerIds[J],
            imageUrl: this.options?.connectorImages?.[J] ?? eh,
            name: rh.CK.ConnectorNamesMap[J] ?? ec,
            imageId: rh.CK.ConnectorImageIds[J],
            type: rh.CK.ConnectorTypesMap[ed] ?? "EXTERNAL"
          })
        }
        ),
          this.setConnectors(et),
          this.syncEmailConnector(J)
      }
      async syncEmailConnector(J) {
        let et = J.find(({ id: J }) => J === rh.bq.EMAIL_CONNECTOR_ID);
        if (et) {
          let J = await et.getProvider();
          this.addConnector({
            id: rh.bq.EMAIL_CONNECTOR_ID,
            type: "EMAIL",
            name: "Email",
            provider: J
          }),
            this.listenEmailConnector(et)
        }
      }
      async listenEmailConnector(J) {
        if ("undefined" != typeof window && J) {
          super.setLoading(!0);
          let et = await J.getProvider()
            , eo = et.getLoginEmailUsed();
          super.setLoading(eo),
            et.onRpcRequest(() => {
              super.open({
                view: "ApproveTransaction"
              })
            }
            ),
            et.onRpcResponse(() => {
              super.close()
            }
            ),
            et.onIsConnected(() => {
              super.setLoading(!1)
            }
            )
        }
      }
    }
      ;
    function createWeb3Modal(J) {
      return !ec && (el = ec = new Web3Modal({
        ...J,
        _sdkVersion: `react-wagmi-${rh.bq.VERSION}`
      })),
        ec
    }
  },
  89481: function (J, et, eo) {
    "use strict";
    let el;
    eo.d(et, {
      $D: function () {
        return tz
      },
      Sd: function () {
        return W3mFrameProvider
      }
    });
    let ec = {
      SECURE_SITE_SDK: "https://secure.web3modal.com/sdk",
      APP_EVENT_KEY: "@w3m-app/",
      FRAME_EVENT_KEY: "@w3m-frame/",
      RPC_METHOD_KEY: "RPC_",
      STORAGE_KEY: "@w3m-storage/",
      SESSION_TOKEN_KEY: "SESSION_TOKEN_KEY",
      EMAIL_LOGIN_USED_KEY: "EMAIL_LOGIN_USED_KEY",
      LAST_USED_CHAIN_KEY: "LAST_USED_CHAIN_KEY",
      LAST_EMAIL_LOGIN_TIME: "LAST_EMAIL_LOGIN_TIME",
      EMAIL: "EMAIL",
      APP_SWITCH_NETWORK: "@w3m-app/SWITCH_NETWORK",
      APP_CONNECT_EMAIL: "@w3m-app/CONNECT_EMAIL",
      APP_CONNECT_DEVICE: "@w3m-app/CONNECT_DEVICE",
      APP_CONNECT_OTP: "@w3m-app/CONNECT_OTP",
      APP_GET_USER: "@w3m-app/GET_USER",
      APP_SIGN_OUT: "@w3m-app/SIGN_OUT",
      APP_IS_CONNECTED: "@w3m-app/IS_CONNECTED",
      APP_GET_CHAIN_ID: "@w3m-app/GET_CHAIN_ID",
      APP_RPC_REQUEST: "@w3m-app/RPC_REQUEST",
      APP_UPDATE_EMAIL: "@w3m-app/UPDATE_EMAIL",
      APP_UPDATE_EMAIL_PRIMARY_OTP: "@w3m-app/UPDATE_EMAIL_PRIMARY_OTP",
      APP_UPDATE_EMAIL_SECONDARY_OTP: "@w3m-app/UPDATE_EMAIL_SECONDARY_OTP",
      APP_AWAIT_UPDATE_EMAIL: "@w3m-app/AWAIT_UPDATE_EMAIL",
      APP_SYNC_THEME: "@w3m-app/SYNC_THEME",
      APP_SYNC_DAPP_DATA: "@w3m-app/SYNC_DAPP_DATA",
      FRAME_SWITCH_NETWORK_ERROR: "@w3m-frame/SWITCH_NETWORK_ERROR",
      FRAME_SWITCH_NETWORK_SUCCESS: "@w3m-frame/SWITCH_NETWORK_SUCCESS",
      FRAME_CONNECT_EMAIL_ERROR: "@w3m-frame/CONNECT_EMAIL_ERROR",
      FRAME_CONNECT_EMAIL_SUCCESS: "@w3m-frame/CONNECT_EMAIL_SUCCESS",
      FRAME_CONNECT_DEVICE_ERROR: "@w3m-frame/CONNECT_DEVICE_ERROR",
      FRAME_CONNECT_DEVICE_SUCCESS: "@w3m-frame/CONNECT_DEVICE_SUCCESS",
      FRAME_CONNECT_OTP_SUCCESS: "@w3m-frame/CONNECT_OTP_SUCCESS",
      FRAME_CONNECT_OTP_ERROR: "@w3m-frame/CONNECT_OTP_ERROR",
      FRAME_GET_USER_SUCCESS: "@w3m-frame/GET_USER_SUCCESS",
      FRAME_GET_USER_ERROR: "@w3m-frame/GET_USER_ERROR",
      FRAME_SIGN_OUT_SUCCESS: "@w3m-frame/SIGN_OUT_SUCCESS",
      FRAME_SIGN_OUT_ERROR: "@w3m-frame/SIGN_OUT_ERROR",
      FRAME_IS_CONNECTED_SUCCESS: "@w3m-frame/IS_CONNECTED_SUCCESS",
      FRAME_IS_CONNECTED_ERROR: "@w3m-frame/IS_CONNECTED_ERROR",
      FRAME_GET_CHAIN_ID_SUCCESS: "@w3m-frame/GET_CHAIN_ID_SUCCESS",
      FRAME_GET_CHAIN_ID_ERROR: "@w3m-frame/GET_CHAIN_ID_ERROR",
      FRAME_RPC_REQUEST_SUCCESS: "@w3m-frame/RPC_REQUEST_SUCCESS",
      FRAME_RPC_REQUEST_ERROR: "@w3m-frame/RPC_REQUEST_ERROR",
      FRAME_SESSION_UPDATE: "@w3m-frame/SESSION_UPDATE",
      FRAME_UPDATE_EMAIL_SUCCESS: "@w3m-frame/UPDATE_EMAIL_SUCCESS",
      FRAME_UPDATE_EMAIL_ERROR: "@w3m-frame/UPDATE_EMAIL_ERROR",
      FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS: "@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_SUCCESS",
      FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR: "@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_ERROR",
      FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS: "@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_SUCCESS",
      FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR: "@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_ERROR",
      FRAME_SYNC_THEME_SUCCESS: "@w3m-frame/SYNC_THEME_SUCCESS",
      FRAME_SYNC_THEME_ERROR: "@w3m-frame/SYNC_THEME_ERROR",
      FRAME_SYNC_DAPP_DATA_SUCCESS: "@w3m-frame/SYNC_DAPP_DATA_SUCCESS",
      FRAME_SYNC_DAPP_DATA_ERROR: "@w3m-frame/SYNC_DAPP_DATA_ERROR"
    };
    (e4 = e9 || (e9 = {})).assertEqual = J => J,
      e4.assertIs = function (J) { }
      ,
      e4.assertNever = function (J) {
        throw Error()
      }
      ,
      e4.arrayToEnum = J => {
        let et = {};
        for (let eo of J)
          et[eo] = eo;
        return et
      }
      ,
      e4.getValidEnumValues = J => {
        let et = e4.objectKeys(J).filter(et => "number" != typeof J[J[et]])
          , eo = {};
        for (let el of et)
          eo[el] = J[el];
        return e4.objectValues(eo)
      }
      ,
      e4.objectValues = J => e4.objectKeys(J).map(function (et) {
        return J[et]
      }),
      e4.objectKeys = "function" == typeof Object.keys ? J => Object.keys(J) : J => {
        let et = [];
        for (let eo in J)
          Object.prototype.hasOwnProperty.call(J, eo) && et.push(eo);
        return et
      }
      ,
      e4.find = (J, et) => {
        for (let eo of J)
          if (et(eo))
            return eo
      }
      ,
      e4.isInteger = "function" == typeof Number.isInteger ? J => Number.isInteger(J) : J => "number" == typeof J && isFinite(J) && Math.floor(J) === J,
      e4.joinValues = function (J, et = " | ") {
        return J.map(J => "string" == typeof J ? `'${J}'` : J).join(et)
      }
      ,
      e4.jsonStringifyReplacer = (J, et) => "bigint" == typeof et ? et.toString() : et,
      (tn || (tn = {})).mergeShapes = (J, et) => ({
        ...J,
        ...et
      });
    let ed = e9.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"])
      , getParsedType = J => {
        let et = typeof J;
        switch (et) {
          case "undefined":
            return ed.undefined;
          case "string":
            return ed.string;
          case "number":
            return isNaN(J) ? ed.nan : ed.number;
          case "boolean":
            return ed.boolean;
          case "function":
            return ed.function;
          case "bigint":
            return ed.bigint;
          case "symbol":
            return ed.symbol;
          case "object":
            if (Array.isArray(J))
              return ed.array;
            if (null === J)
              return ed.null;
            if (J.then && "function" == typeof J.then && J.catch && "function" == typeof J.catch)
              return ed.promise;
            if ("undefined" != typeof Map && J instanceof Map)
              return ed.map;
            if ("undefined" != typeof Set && J instanceof Set)
              return ed.set;
            if ("undefined" != typeof Date && J instanceof Date)
              return ed.date;
            return ed.object;
          default:
            return ed.unknown
        }
      }
      , eh = e9.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]);
    let ZodError = class ZodError extends Error {
      constructor(J) {
        super(),
          this.issues = [],
          this.addIssue = J => {
            this.issues = [...this.issues, J]
          }
          ,
          this.addIssues = (J = []) => {
            this.issues = [...this.issues, ...J]
          }
          ;
        let et = new.target.prototype;
        Object.setPrototypeOf ? Object.setPrototypeOf(this, et) : this.__proto__ = et,
          this.name = "ZodError",
          this.issues = J
      }
      get errors() {
        return this.issues
      }
      format(J) {
        let et = J || function (J) {
          return J.message
        }
          , eo = {
            _errors: []
          }
          , processError = J => {
            for (let el of J.issues)
              if ("invalid_union" === el.code)
                el.unionErrors.map(processError);
              else if ("invalid_return_type" === el.code)
                processError(el.returnTypeError);
              else if ("invalid_arguments" === el.code)
                processError(el.argumentsError);
              else if (0 === el.path.length)
                eo._errors.push(et(el));
              else {
                let J = eo
                  , ec = 0;
                for (; ec < el.path.length;) {
                  let eo = el.path[ec]
                    , ed = ec === el.path.length - 1;
                  ed ? (J[eo] = J[eo] || {
                    _errors: []
                  },
                    J[eo]._errors.push(et(el))) : J[eo] = J[eo] || {
                      _errors: []
                    },
                    J = J[eo],
                    ec++
                }
              }
          }
          ;
        return processError(this),
          eo
      }
      toString() {
        return this.message
      }
      get message() {
        return JSON.stringify(this.issues, e9.jsonStringifyReplacer, 2)
      }
      get isEmpty() {
        return 0 === this.issues.length
      }
      flatten(J = J => J.message) {
        let et = {}
          , eo = [];
        for (let el of this.issues)
          el.path.length > 0 ? (et[el.path[0]] = et[el.path[0]] || [],
            et[el.path[0]].push(J(el))) : eo.push(J(el));
        return {
          formErrors: eo,
          fieldErrors: et
        }
      }
      get formErrors() {
        return this.flatten()
      }
    }
      ;
    ZodError.create = J => {
      let et = new ZodError(J);
      return et
    }
      ;
    let errorMap = (J, et) => {
      let eo;
      switch (J.code) {
        case eh.invalid_type:
          eo = J.received === ed.undefined ? "Required" : `Expected ${J.expected}, received ${J.received}`;
          break;
        case eh.invalid_literal:
          eo = `Invalid literal value, expected ${JSON.stringify(J.expected, e9.jsonStringifyReplacer)}`;
          break;
        case eh.unrecognized_keys:
          eo = `Unrecognized key(s) in object: ${e9.joinValues(J.keys, ", ")}`;
          break;
        case eh.invalid_union:
          eo = "Invalid input";
          break;
        case eh.invalid_union_discriminator:
          eo = `Invalid discriminator value. Expected ${e9.joinValues(J.options)}`;
          break;
        case eh.invalid_enum_value:
          eo = `Invalid enum value. Expected ${e9.joinValues(J.options)}, received '${J.received}'`;
          break;
        case eh.invalid_arguments:
          eo = "Invalid function arguments";
          break;
        case eh.invalid_return_type:
          eo = "Invalid function return type";
          break;
        case eh.invalid_date:
          eo = "Invalid date";
          break;
        case eh.invalid_string:
          "object" == typeof J.validation ? "includes" in J.validation ? (eo = `Invalid input: must include "${J.validation.includes}"`,
            "number" == typeof J.validation.position && (eo = `${eo} at one or more positions greater than or equal to ${J.validation.position}`)) : "startsWith" in J.validation ? eo = `Invalid input: must start with "${J.validation.startsWith}"` : "endsWith" in J.validation ? eo = `Invalid input: must end with "${J.validation.endsWith}"` : e9.assertNever(J.validation) : eo = "regex" !== J.validation ? `Invalid ${J.validation}` : "Invalid";
          break;
        case eh.too_small:
          eo = "array" === J.type ? `Array must contain ${J.exact ? "exactly" : J.inclusive ? "at least" : "more than"} ${J.minimum} element(s)` : "string" === J.type ? `String must contain ${J.exact ? "exactly" : J.inclusive ? "at least" : "over"} ${J.minimum} character(s)` : "number" === J.type ? `Number must be ${J.exact ? "exactly equal to " : J.inclusive ? "greater than or equal to " : "greater than "}${J.minimum}` : "date" === J.type ? `Date must be ${J.exact ? "exactly equal to " : J.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(J.minimum))}` : "Invalid input";
          break;
        case eh.too_big:
          eo = "array" === J.type ? `Array must contain ${J.exact ? "exactly" : J.inclusive ? "at most" : "less than"} ${J.maximum} element(s)` : "string" === J.type ? `String must contain ${J.exact ? "exactly" : J.inclusive ? "at most" : "under"} ${J.maximum} character(s)` : "number" === J.type ? `Number must be ${J.exact ? "exactly" : J.inclusive ? "less than or equal to" : "less than"} ${J.maximum}` : "bigint" === J.type ? `BigInt must be ${J.exact ? "exactly" : J.inclusive ? "less than or equal to" : "less than"} ${J.maximum}` : "date" === J.type ? `Date must be ${J.exact ? "exactly" : J.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(J.maximum))}` : "Invalid input";
          break;
        case eh.custom:
          eo = "Invalid input";
          break;
        case eh.invalid_intersection_types:
          eo = "Intersection results could not be merged";
          break;
        case eh.not_multiple_of:
          eo = `Number must be a multiple of ${J.multipleOf}`;
          break;
        case eh.not_finite:
          eo = "Number must be finite";
          break;
        default:
          eo = et.defaultError,
            e9.assertNever(J)
      }
      return {
        message: eo
      }
    }
      , ep = errorMap;
    function getErrorMap() {
      return ep
    }
    let makeIssue = J => {
      let { data: et, path: eo, errorMaps: el, issueData: ec } = J
        , ed = [...eo, ...ec.path || []]
        , eh = {
          ...ec,
          path: ed
        }
        , ep = ""
        , ef = el.filter(J => !!J).slice().reverse();
      for (let J of ef)
        ep = J(eh, {
          data: et,
          defaultError: ep
        }).message;
      return {
        ...ec,
        path: ed,
        message: ec.message || ep
      }
    }
      ;
    function addIssueToContext(J, et) {
      let eo = makeIssue({
        issueData: et,
        data: J.data,
        path: J.path,
        errorMaps: [J.common.contextualErrorMap, J.schemaErrorMap, getErrorMap(), errorMap].filter(J => !!J)
      });
      J.common.issues.push(eo)
    }
    let ParseStatus = class ParseStatus {
      constructor() {
        this.value = "valid"
      }
      dirty() {
        "valid" === this.value && (this.value = "dirty")
      }
      abort() {
        "aborted" !== this.value && (this.value = "aborted")
      }
      static mergeArray(J, et) {
        let eo = [];
        for (let el of et) {
          if ("aborted" === el.status)
            return ef;
          "dirty" === el.status && J.dirty(),
            eo.push(el.value)
        }
        return {
          status: J.value,
          value: eo
        }
      }
      static async mergeObjectAsync(J, et) {
        let eo = [];
        for (let J of et)
          eo.push({
            key: await J.key,
            value: await J.value
          });
        return ParseStatus.mergeObjectSync(J, eo)
      }
      static mergeObjectSync(J, et) {
        let eo = {};
        for (let el of et) {
          let { key: et, value: ec } = el;
          if ("aborted" === et.status || "aborted" === ec.status)
            return ef;
          "dirty" === et.status && J.dirty(),
            "dirty" === ec.status && J.dirty(),
            "__proto__" !== et.value && (void 0 !== ec.value || el.alwaysSet) && (eo[et.value] = ec.value)
        }
        return {
          status: J.value,
          value: eo
        }
      }
    }
      ;
    let ef = Object.freeze({
      status: "aborted"
    })
      , DIRTY = J => ({
        status: "dirty",
        value: J
      })
      , OK = J => ({
        status: "valid",
        value: J
      })
      , isAborted = J => "aborted" === J.status
      , isDirty = J => "dirty" === J.status
      , isValid = J => "valid" === J.status
      , isAsync = J => "undefined" != typeof Promise && J instanceof Promise;
    (e8 = to || (to = {})).errToObj = J => "string" == typeof J ? {
      message: J
    } : J || {},
      e8.toString = J => "string" == typeof J ? J : null == J ? void 0 : J.message;
    let ParseInputLazyPath = class ParseInputLazyPath {
      constructor(J, et, eo, el) {
        this._cachedPath = [],
          this.parent = J,
          this.data = et,
          this._path = eo,
          this._key = el
      }
      get path() {
        return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)),
          this._cachedPath
      }
    }
      ;
    let handleResult = (J, et) => {
      if (isValid(et))
        return {
          success: !0,
          data: et.value
        };
      if (!J.common.issues.length)
        throw Error("Validation failed but no issues detected.");
      return {
        success: !1,
        get error() {
          if (this._error)
            return this._error;
          let et = new ZodError(J.common.issues);
          return this._error = et,
            this._error
        }
      }
    }
      ;
    function processCreateParams(J) {
      if (!J)
        return {};
      let { errorMap: et, invalid_type_error: eo, required_error: el, description: ec } = J;
      if (et && (eo || el))
        throw Error('Can\'t use "invalid_type_error" or "required_error" in conjunction with custom error map.');
      return et ? {
        errorMap: et,
        description: ec
      } : {
        errorMap: (J, et) => "invalid_type" !== J.code ? {
          message: et.defaultError
        } : void 0 === et.data ? {
          message: null != el ? el : et.defaultError
        } : {
          message: null != eo ? eo : et.defaultError
        },
        description: ec
      }
    }
    let ZodType = class ZodType {
      constructor(J) {
        this.spa = this.safeParseAsync,
          this._def = J,
          this.parse = this.parse.bind(this),
          this.safeParse = this.safeParse.bind(this),
          this.parseAsync = this.parseAsync.bind(this),
          this.safeParseAsync = this.safeParseAsync.bind(this),
          this.spa = this.spa.bind(this),
          this.refine = this.refine.bind(this),
          this.refinement = this.refinement.bind(this),
          this.superRefine = this.superRefine.bind(this),
          this.optional = this.optional.bind(this),
          this.nullable = this.nullable.bind(this),
          this.nullish = this.nullish.bind(this),
          this.array = this.array.bind(this),
          this.promise = this.promise.bind(this),
          this.or = this.or.bind(this),
          this.and = this.and.bind(this),
          this.transform = this.transform.bind(this),
          this.brand = this.brand.bind(this),
          this.default = this.default.bind(this),
          this.catch = this.catch.bind(this),
          this.describe = this.describe.bind(this),
          this.pipe = this.pipe.bind(this),
          this.readonly = this.readonly.bind(this),
          this.isNullable = this.isNullable.bind(this),
          this.isOptional = this.isOptional.bind(this)
      }
      get description() {
        return this._def.description
      }
      _getType(J) {
        return getParsedType(J.data)
      }
      _getOrReturnCtx(J, et) {
        return et || {
          common: J.parent.common,
          data: J.data,
          parsedType: getParsedType(J.data),
          schemaErrorMap: this._def.errorMap,
          path: J.path,
          parent: J.parent
        }
      }
      _processInputParams(J) {
        return {
          status: new ParseStatus,
          ctx: {
            common: J.parent.common,
            data: J.data,
            parsedType: getParsedType(J.data),
            schemaErrorMap: this._def.errorMap,
            path: J.path,
            parent: J.parent
          }
        }
      }
      _parseSync(J) {
        let et = this._parse(J);
        if (isAsync(et))
          throw Error("Synchronous parse encountered promise.");
        return et
      }
      _parseAsync(J) {
        let et = this._parse(J);
        return Promise.resolve(et)
      }
      parse(J, et) {
        let eo = this.safeParse(J, et);
        if (eo.success)
          return eo.data;
        throw eo.error
      }
      safeParse(J, et) {
        var eo;
        let el = {
          common: {
            issues: [],
            async: null !== (eo = null == et ? void 0 : et.async) && void 0 !== eo && eo,
            contextualErrorMap: null == et ? void 0 : et.errorMap
          },
          path: (null == et ? void 0 : et.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data: J,
          parsedType: getParsedType(J)
        }
          , ec = this._parseSync({
            data: J,
            path: el.path,
            parent: el
          });
        return handleResult(el, ec)
      }
      async parseAsync(J, et) {
        let eo = await this.safeParseAsync(J, et);
        if (eo.success)
          return eo.data;
        throw eo.error
      }
      async safeParseAsync(J, et) {
        let eo = {
          common: {
            issues: [],
            contextualErrorMap: null == et ? void 0 : et.errorMap,
            async: !0
          },
          path: (null == et ? void 0 : et.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data: J,
          parsedType: getParsedType(J)
        }
          , el = this._parse({
            data: J,
            path: eo.path,
            parent: eo
          })
          , ec = await (isAsync(el) ? el : Promise.resolve(el));
        return handleResult(eo, ec)
      }
      refine(J, et) {
        let getIssueProperties = J => "string" == typeof et || void 0 === et ? {
          message: et
        } : "function" == typeof et ? et(J) : et;
        return this._refinement((et, eo) => {
          let el = J(et)
            , setError = () => eo.addIssue({
              code: eh.custom,
              ...getIssueProperties(et)
            });
          return "undefined" != typeof Promise && el instanceof Promise ? el.then(J => !!J || (setError(),
            !1)) : !!el || (setError(),
              !1)
        }
        )
      }
      refinement(J, et) {
        return this._refinement((eo, el) => !!J(eo) || (el.addIssue("function" == typeof et ? et(eo, el) : et),
          !1))
      }
      _refinement(J) {
        return new ZodEffects({
          schema: this,
          typeName: ta.ZodEffects,
          effect: {
            type: "refinement",
            refinement: J
          }
        })
      }
      superRefine(J) {
        return this._refinement(J)
      }
      optional() {
        return ZodOptional.create(this, this._def)
      }
      nullable() {
        return ZodNullable.create(this, this._def)
      }
      nullish() {
        return this.nullable().optional()
      }
      array() {
        return ZodArray.create(this, this._def)
      }
      promise() {
        return ZodPromise.create(this, this._def)
      }
      or(J) {
        return ZodUnion.create([this, J], this._def)
      }
      and(J) {
        return ZodIntersection.create(this, J, this._def)
      }
      transform(J) {
        return new ZodEffects({
          ...processCreateParams(this._def),
          schema: this,
          typeName: ta.ZodEffects,
          effect: {
            type: "transform",
            transform: J
          }
        })
      }
      default(J) {
        return new ZodDefault({
          ...processCreateParams(this._def),
          innerType: this,
          defaultValue: "function" == typeof J ? J : () => J,
          typeName: ta.ZodDefault
        })
      }
      brand() {
        return new ZodBranded({
          typeName: ta.ZodBranded,
          type: this,
          ...processCreateParams(this._def)
        })
      }
      catch(J) {
        return new ZodCatch({
          ...processCreateParams(this._def),
          innerType: this,
          catchValue: "function" == typeof J ? J : () => J,
          typeName: ta.ZodCatch
        })
      }
      describe(J) {
        let et = this.constructor;
        return new et({
          ...this._def,
          description: J
        })
      }
      pipe(J) {
        return ZodPipeline.create(this, J)
      }
      readonly() {
        return ZodReadonly.create(this)
      }
      isOptional() {
        return this.safeParse(void 0).success
      }
      isNullable() {
        return this.safeParse(null).success
      }
    }
      ;
    let em = /^c[^\s-]{8,}$/i
      , eg = /^[a-z][a-z0-9]*$/
      , ey = /^[0-9A-HJKMNP-TV-Z]{26}$/
      , eb = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i
      , ew = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i
      , e_ = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/
      , ex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/
      , datetimeRegex = J => J.precision ? J.offset ? RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${J.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${J.precision}}Z$`) : 0 === J.precision ? J.offset ? RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : J.offset ? RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
    let ZodString = class ZodString extends ZodType {
      _parse(J) {
        let et;
        this._def.coerce && (J.data = String(J.data));
        let eo = this._getType(J);
        if (eo !== ed.string) {
          let et = this._getOrReturnCtx(J);
          return addIssueToContext(et, {
            code: eh.invalid_type,
            expected: ed.string,
            received: et.parsedType
          }),
            ef
        }
        let ec = new ParseStatus;
        for (let eo of this._def.checks)
          if ("min" === eo.kind)
            J.data.length < eo.value && (addIssueToContext(et = this._getOrReturnCtx(J, et), {
              code: eh.too_small,
              minimum: eo.value,
              type: "string",
              inclusive: !0,
              exact: !1,
              message: eo.message
            }),
              ec.dirty());
          else if ("max" === eo.kind)
            J.data.length > eo.value && (addIssueToContext(et = this._getOrReturnCtx(J, et), {
              code: eh.too_big,
              maximum: eo.value,
              type: "string",
              inclusive: !0,
              exact: !1,
              message: eo.message
            }),
              ec.dirty());
          else if ("length" === eo.kind) {
            let el = J.data.length > eo.value
              , ed = J.data.length < eo.value;
            (el || ed) && (et = this._getOrReturnCtx(J, et),
              el ? addIssueToContext(et, {
                code: eh.too_big,
                maximum: eo.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: eo.message
              }) : ed && addIssueToContext(et, {
                code: eh.too_small,
                minimum: eo.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: eo.message
              }),
              ec.dirty())
          } else if ("email" === eo.kind)
            ew.test(J.data) || (addIssueToContext(et = this._getOrReturnCtx(J, et), {
              validation: "email",
              code: eh.invalid_string,
              message: eo.message
            }),
              ec.dirty());
          else if ("emoji" === eo.kind)
            el || (el = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")),
              el.test(J.data) || (addIssueToContext(et = this._getOrReturnCtx(J, et), {
                validation: "emoji",
                code: eh.invalid_string,
                message: eo.message
              }),
                ec.dirty());
          else if ("uuid" === eo.kind)
            eb.test(J.data) || (addIssueToContext(et = this._getOrReturnCtx(J, et), {
              validation: "uuid",
              code: eh.invalid_string,
              message: eo.message
            }),
              ec.dirty());
          else if ("cuid" === eo.kind)
            em.test(J.data) || (addIssueToContext(et = this._getOrReturnCtx(J, et), {
              validation: "cuid",
              code: eh.invalid_string,
              message: eo.message
            }),
              ec.dirty());
          else if ("cuid2" === eo.kind)
            eg.test(J.data) || (addIssueToContext(et = this._getOrReturnCtx(J, et), {
              validation: "cuid2",
              code: eh.invalid_string,
              message: eo.message
            }),
              ec.dirty());
          else if ("ulid" === eo.kind)
            ey.test(J.data) || (addIssueToContext(et = this._getOrReturnCtx(J, et), {
              validation: "ulid",
              code: eh.invalid_string,
              message: eo.message
            }),
              ec.dirty());
          else if ("url" === eo.kind)
            try {
              new URL(J.data)
            } catch (el) {
              addIssueToContext(et = this._getOrReturnCtx(J, et), {
                validation: "url",
                code: eh.invalid_string,
                message: eo.message
              }),
                ec.dirty()
            }
          else if ("regex" === eo.kind) {
            eo.regex.lastIndex = 0;
            let el = eo.regex.test(J.data);
            el || (addIssueToContext(et = this._getOrReturnCtx(J, et), {
              validation: "regex",
              code: eh.invalid_string,
              message: eo.message
            }),
              ec.dirty())
          } else if ("trim" === eo.kind)
            J.data = J.data.trim();
          else if ("includes" === eo.kind)
            J.data.includes(eo.value, eo.position) || (addIssueToContext(et = this._getOrReturnCtx(J, et), {
              code: eh.invalid_string,
              validation: {
                includes: eo.value,
                position: eo.position
              },
              message: eo.message
            }),
              ec.dirty());
          else if ("toLowerCase" === eo.kind)
            J.data = J.data.toLowerCase();
          else if ("toUpperCase" === eo.kind)
            J.data = J.data.toUpperCase();
          else if ("startsWith" === eo.kind)
            J.data.startsWith(eo.value) || (addIssueToContext(et = this._getOrReturnCtx(J, et), {
              code: eh.invalid_string,
              validation: {
                startsWith: eo.value
              },
              message: eo.message
            }),
              ec.dirty());
          else if ("endsWith" === eo.kind)
            J.data.endsWith(eo.value) || (addIssueToContext(et = this._getOrReturnCtx(J, et), {
              code: eh.invalid_string,
              validation: {
                endsWith: eo.value
              },
              message: eo.message
            }),
              ec.dirty());
          else if ("datetime" === eo.kind) {
            let el = datetimeRegex(eo);
            el.test(J.data) || (addIssueToContext(et = this._getOrReturnCtx(J, et), {
              code: eh.invalid_string,
              validation: "datetime",
              message: eo.message
            }),
              ec.dirty())
          } else if ("ip" === eo.kind) {
            var ep, eE;
            ep = J.data,
              ("v4" === (eE = eo.version) || !eE) && e_.test(ep) || ("v6" === eE || !eE) && ex.test(ep) || (addIssueToContext(et = this._getOrReturnCtx(J, et), {
                validation: "ip",
                code: eh.invalid_string,
                message: eo.message
              }),
                ec.dirty())
          } else
            e9.assertNever(eo);
        return {
          status: ec.value,
          value: J.data
        }
      }
      _regex(J, et, eo) {
        return this.refinement(et => J.test(et), {
          validation: et,
          code: eh.invalid_string,
          ...to.errToObj(eo)
        })
      }
      _addCheck(J) {
        return new ZodString({
          ...this._def,
          checks: [...this._def.checks, J]
        })
      }
      email(J) {
        return this._addCheck({
          kind: "email",
          ...to.errToObj(J)
        })
      }
      url(J) {
        return this._addCheck({
          kind: "url",
          ...to.errToObj(J)
        })
      }
      emoji(J) {
        return this._addCheck({
          kind: "emoji",
          ...to.errToObj(J)
        })
      }
      uuid(J) {
        return this._addCheck({
          kind: "uuid",
          ...to.errToObj(J)
        })
      }
      cuid(J) {
        return this._addCheck({
          kind: "cuid",
          ...to.errToObj(J)
        })
      }
      cuid2(J) {
        return this._addCheck({
          kind: "cuid2",
          ...to.errToObj(J)
        })
      }
      ulid(J) {
        return this._addCheck({
          kind: "ulid",
          ...to.errToObj(J)
        })
      }
      ip(J) {
        return this._addCheck({
          kind: "ip",
          ...to.errToObj(J)
        })
      }
      datetime(J) {
        var et;
        return "string" == typeof J ? this._addCheck({
          kind: "datetime",
          precision: null,
          offset: !1,
          message: J
        }) : this._addCheck({
          kind: "datetime",
          precision: void 0 === (null == J ? void 0 : J.precision) ? null : null == J ? void 0 : J.precision,
          offset: null !== (et = null == J ? void 0 : J.offset) && void 0 !== et && et,
          ...to.errToObj(null == J ? void 0 : J.message)
        })
      }
      regex(J, et) {
        return this._addCheck({
          kind: "regex",
          regex: J,
          ...to.errToObj(et)
        })
      }
      includes(J, et) {
        return this._addCheck({
          kind: "includes",
          value: J,
          position: null == et ? void 0 : et.position,
          ...to.errToObj(null == et ? void 0 : et.message)
        })
      }
      startsWith(J, et) {
        return this._addCheck({
          kind: "startsWith",
          value: J,
          ...to.errToObj(et)
        })
      }
      endsWith(J, et) {
        return this._addCheck({
          kind: "endsWith",
          value: J,
          ...to.errToObj(et)
        })
      }
      min(J, et) {
        return this._addCheck({
          kind: "min",
          value: J,
          ...to.errToObj(et)
        })
      }
      max(J, et) {
        return this._addCheck({
          kind: "max",
          value: J,
          ...to.errToObj(et)
        })
      }
      length(J, et) {
        return this._addCheck({
          kind: "length",
          value: J,
          ...to.errToObj(et)
        })
      }
      nonempty(J) {
        return this.min(1, to.errToObj(J))
      }
      trim() {
        return new ZodString({
          ...this._def,
          checks: [...this._def.checks, {
            kind: "trim"
          }]
        })
      }
      toLowerCase() {
        return new ZodString({
          ...this._def,
          checks: [...this._def.checks, {
            kind: "toLowerCase"
          }]
        })
      }
      toUpperCase() {
        return new ZodString({
          ...this._def,
          checks: [...this._def.checks, {
            kind: "toUpperCase"
          }]
        })
      }
      get isDatetime() {
        return !!this._def.checks.find(J => "datetime" === J.kind)
      }
      get isEmail() {
        return !!this._def.checks.find(J => "email" === J.kind)
      }
      get isURL() {
        return !!this._def.checks.find(J => "url" === J.kind)
      }
      get isEmoji() {
        return !!this._def.checks.find(J => "emoji" === J.kind)
      }
      get isUUID() {
        return !!this._def.checks.find(J => "uuid" === J.kind)
      }
      get isCUID() {
        return !!this._def.checks.find(J => "cuid" === J.kind)
      }
      get isCUID2() {
        return !!this._def.checks.find(J => "cuid2" === J.kind)
      }
      get isULID() {
        return !!this._def.checks.find(J => "ulid" === J.kind)
      }
      get isIP() {
        return !!this._def.checks.find(J => "ip" === J.kind)
      }
      get minLength() {
        let J = null;
        for (let et of this._def.checks)
          "min" === et.kind && (null === J || et.value > J) && (J = et.value);
        return J
      }
      get maxLength() {
        let J = null;
        for (let et of this._def.checks)
          "max" === et.kind && (null === J || et.value < J) && (J = et.value);
        return J
      }
    }
      ;
    ZodString.create = J => {
      var et;
      return new ZodString({
        checks: [],
        typeName: ta.ZodString,
        coerce: null !== (et = null == J ? void 0 : J.coerce) && void 0 !== et && et,
        ...processCreateParams(J)
      })
    }
      ;
    let ZodNumber = class ZodNumber extends ZodType {
      constructor() {
        super(...arguments),
          this.min = this.gte,
          this.max = this.lte,
          this.step = this.multipleOf
      }
      _parse(J) {
        let et;
        this._def.coerce && (J.data = Number(J.data));
        let eo = this._getType(J);
        if (eo !== ed.number) {
          let et = this._getOrReturnCtx(J);
          return addIssueToContext(et, {
            code: eh.invalid_type,
            expected: ed.number,
            received: et.parsedType
          }),
            ef
        }
        let el = new ParseStatus;
        for (let eo of this._def.checks)
          if ("int" === eo.kind)
            e9.isInteger(J.data) || (addIssueToContext(et = this._getOrReturnCtx(J, et), {
              code: eh.invalid_type,
              expected: "integer",
              received: "float",
              message: eo.message
            }),
              el.dirty());
          else if ("min" === eo.kind) {
            let ec = eo.inclusive ? J.data < eo.value : J.data <= eo.value;
            ec && (addIssueToContext(et = this._getOrReturnCtx(J, et), {
              code: eh.too_small,
              minimum: eo.value,
              type: "number",
              inclusive: eo.inclusive,
              exact: !1,
              message: eo.message
            }),
              el.dirty())
          } else if ("max" === eo.kind) {
            let ec = eo.inclusive ? J.data > eo.value : J.data >= eo.value;
            ec && (addIssueToContext(et = this._getOrReturnCtx(J, et), {
              code: eh.too_big,
              maximum: eo.value,
              type: "number",
              inclusive: eo.inclusive,
              exact: !1,
              message: eo.message
            }),
              el.dirty())
          } else
            "multipleOf" === eo.kind ? 0 !== function (J, et) {
              let eo = (J.toString().split(".")[1] || "").length
                , el = (et.toString().split(".")[1] || "").length
                , ec = eo > el ? eo : el
                , ed = parseInt(J.toFixed(ec).replace(".", ""))
                , eh = parseInt(et.toFixed(ec).replace(".", ""));
              return ed % eh / Math.pow(10, ec)
            }(J.data, eo.value) && (addIssueToContext(et = this._getOrReturnCtx(J, et), {
              code: eh.not_multiple_of,
              multipleOf: eo.value,
              message: eo.message
            }),
              el.dirty()) : "finite" === eo.kind ? Number.isFinite(J.data) || (addIssueToContext(et = this._getOrReturnCtx(J, et), {
                code: eh.not_finite,
                message: eo.message
              }),
                el.dirty()) : e9.assertNever(eo);
        return {
          status: el.value,
          value: J.data
        }
      }
      gte(J, et) {
        return this.setLimit("min", J, !0, to.toString(et))
      }
      gt(J, et) {
        return this.setLimit("min", J, !1, to.toString(et))
      }
      lte(J, et) {
        return this.setLimit("max", J, !0, to.toString(et))
      }
      lt(J, et) {
        return this.setLimit("max", J, !1, to.toString(et))
      }
      setLimit(J, et, eo, el) {
        return new ZodNumber({
          ...this._def,
          checks: [...this._def.checks, {
            kind: J,
            value: et,
            inclusive: eo,
            message: to.toString(el)
          }]
        })
      }
      _addCheck(J) {
        return new ZodNumber({
          ...this._def,
          checks: [...this._def.checks, J]
        })
      }
      int(J) {
        return this._addCheck({
          kind: "int",
          message: to.toString(J)
        })
      }
      positive(J) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: !1,
          message: to.toString(J)
        })
      }
      negative(J) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: !1,
          message: to.toString(J)
        })
      }
      nonpositive(J) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: !0,
          message: to.toString(J)
        })
      }
      nonnegative(J) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: !0,
          message: to.toString(J)
        })
      }
      multipleOf(J, et) {
        return this._addCheck({
          kind: "multipleOf",
          value: J,
          message: to.toString(et)
        })
      }
      finite(J) {
        return this._addCheck({
          kind: "finite",
          message: to.toString(J)
        })
      }
      safe(J) {
        return this._addCheck({
          kind: "min",
          inclusive: !0,
          value: Number.MIN_SAFE_INTEGER,
          message: to.toString(J)
        })._addCheck({
          kind: "max",
          inclusive: !0,
          value: Number.MAX_SAFE_INTEGER,
          message: to.toString(J)
        })
      }
      get minValue() {
        let J = null;
        for (let et of this._def.checks)
          "min" === et.kind && (null === J || et.value > J) && (J = et.value);
        return J
      }
      get maxValue() {
        let J = null;
        for (let et of this._def.checks)
          "max" === et.kind && (null === J || et.value < J) && (J = et.value);
        return J
      }
      get isInt() {
        return !!this._def.checks.find(J => "int" === J.kind || "multipleOf" === J.kind && e9.isInteger(J.value))
      }
      get isFinite() {
        let J = null
          , et = null;
        for (let eo of this._def.checks) {
          if ("finite" === eo.kind || "int" === eo.kind || "multipleOf" === eo.kind)
            return !0;
          "min" === eo.kind ? (null === et || eo.value > et) && (et = eo.value) : "max" === eo.kind && (null === J || eo.value < J) && (J = eo.value)
        }
        return Number.isFinite(et) && Number.isFinite(J)
      }
    }
      ;
    ZodNumber.create = J => new ZodNumber({
      checks: [],
      typeName: ta.ZodNumber,
      coerce: (null == J ? void 0 : J.coerce) || !1,
      ...processCreateParams(J)
    });
    let ZodBigInt = class ZodBigInt extends ZodType {
      constructor() {
        super(...arguments),
          this.min = this.gte,
          this.max = this.lte
      }
      _parse(J) {
        let et;
        this._def.coerce && (J.data = BigInt(J.data));
        let eo = this._getType(J);
        if (eo !== ed.bigint) {
          let et = this._getOrReturnCtx(J);
          return addIssueToContext(et, {
            code: eh.invalid_type,
            expected: ed.bigint,
            received: et.parsedType
          }),
            ef
        }
        let el = new ParseStatus;
        for (let eo of this._def.checks)
          if ("min" === eo.kind) {
            let ec = eo.inclusive ? J.data < eo.value : J.data <= eo.value;
            ec && (addIssueToContext(et = this._getOrReturnCtx(J, et), {
              code: eh.too_small,
              type: "bigint",
              minimum: eo.value,
              inclusive: eo.inclusive,
              message: eo.message
            }),
              el.dirty())
          } else if ("max" === eo.kind) {
            let ec = eo.inclusive ? J.data > eo.value : J.data >= eo.value;
            ec && (addIssueToContext(et = this._getOrReturnCtx(J, et), {
              code: eh.too_big,
              type: "bigint",
              maximum: eo.value,
              inclusive: eo.inclusive,
              message: eo.message
            }),
              el.dirty())
          } else
            "multipleOf" === eo.kind ? J.data % eo.value !== BigInt(0) && (addIssueToContext(et = this._getOrReturnCtx(J, et), {
              code: eh.not_multiple_of,
              multipleOf: eo.value,
              message: eo.message
            }),
              el.dirty()) : e9.assertNever(eo);
        return {
          status: el.value,
          value: J.data
        }
      }
      gte(J, et) {
        return this.setLimit("min", J, !0, to.toString(et))
      }
      gt(J, et) {
        return this.setLimit("min", J, !1, to.toString(et))
      }
      lte(J, et) {
        return this.setLimit("max", J, !0, to.toString(et))
      }
      lt(J, et) {
        return this.setLimit("max", J, !1, to.toString(et))
      }
      setLimit(J, et, eo, el) {
        return new ZodBigInt({
          ...this._def,
          checks: [...this._def.checks, {
            kind: J,
            value: et,
            inclusive: eo,
            message: to.toString(el)
          }]
        })
      }
      _addCheck(J) {
        return new ZodBigInt({
          ...this._def,
          checks: [...this._def.checks, J]
        })
      }
      positive(J) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: !1,
          message: to.toString(J)
        })
      }
      negative(J) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: !1,
          message: to.toString(J)
        })
      }
      nonpositive(J) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: !0,
          message: to.toString(J)
        })
      }
      nonnegative(J) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: !0,
          message: to.toString(J)
        })
      }
      multipleOf(J, et) {
        return this._addCheck({
          kind: "multipleOf",
          value: J,
          message: to.toString(et)
        })
      }
      get minValue() {
        let J = null;
        for (let et of this._def.checks)
          "min" === et.kind && (null === J || et.value > J) && (J = et.value);
        return J
      }
      get maxValue() {
        let J = null;
        for (let et of this._def.checks)
          "max" === et.kind && (null === J || et.value < J) && (J = et.value);
        return J
      }
    }
      ;
    ZodBigInt.create = J => {
      var et;
      return new ZodBigInt({
        checks: [],
        typeName: ta.ZodBigInt,
        coerce: null !== (et = null == J ? void 0 : J.coerce) && void 0 !== et && et,
        ...processCreateParams(J)
      })
    }
      ;
    let ZodBoolean = class ZodBoolean extends ZodType {
      _parse(J) {
        this._def.coerce && (J.data = !!J.data);
        let et = this._getType(J);
        if (et !== ed.boolean) {
          let et = this._getOrReturnCtx(J);
          return addIssueToContext(et, {
            code: eh.invalid_type,
            expected: ed.boolean,
            received: et.parsedType
          }),
            ef
        }
        return OK(J.data)
      }
    }
      ;
    ZodBoolean.create = J => new ZodBoolean({
      typeName: ta.ZodBoolean,
      coerce: (null == J ? void 0 : J.coerce) || !1,
      ...processCreateParams(J)
    });
    let ZodDate = class ZodDate extends ZodType {
      _parse(J) {
        let et;
        this._def.coerce && (J.data = new Date(J.data));
        let eo = this._getType(J);
        if (eo !== ed.date) {
          let et = this._getOrReturnCtx(J);
          return addIssueToContext(et, {
            code: eh.invalid_type,
            expected: ed.date,
            received: et.parsedType
          }),
            ef
        }
        if (isNaN(J.data.getTime())) {
          let et = this._getOrReturnCtx(J);
          return addIssueToContext(et, {
            code: eh.invalid_date
          }),
            ef
        }
        let el = new ParseStatus;
        for (let eo of this._def.checks)
          "min" === eo.kind ? J.data.getTime() < eo.value && (addIssueToContext(et = this._getOrReturnCtx(J, et), {
            code: eh.too_small,
            message: eo.message,
            inclusive: !0,
            exact: !1,
            minimum: eo.value,
            type: "date"
          }),
            el.dirty()) : "max" === eo.kind ? J.data.getTime() > eo.value && (addIssueToContext(et = this._getOrReturnCtx(J, et), {
              code: eh.too_big,
              message: eo.message,
              inclusive: !0,
              exact: !1,
              maximum: eo.value,
              type: "date"
            }),
              el.dirty()) : e9.assertNever(eo);
        return {
          status: el.value,
          value: new Date(J.data.getTime())
        }
      }
      _addCheck(J) {
        return new ZodDate({
          ...this._def,
          checks: [...this._def.checks, J]
        })
      }
      min(J, et) {
        return this._addCheck({
          kind: "min",
          value: J.getTime(),
          message: to.toString(et)
        })
      }
      max(J, et) {
        return this._addCheck({
          kind: "max",
          value: J.getTime(),
          message: to.toString(et)
        })
      }
      get minDate() {
        let J = null;
        for (let et of this._def.checks)
          "min" === et.kind && (null === J || et.value > J) && (J = et.value);
        return null != J ? new Date(J) : null
      }
      get maxDate() {
        let J = null;
        for (let et of this._def.checks)
          "max" === et.kind && (null === J || et.value < J) && (J = et.value);
        return null != J ? new Date(J) : null
      }
    }
      ;
    ZodDate.create = J => new ZodDate({
      checks: [],
      coerce: (null == J ? void 0 : J.coerce) || !1,
      typeName: ta.ZodDate,
      ...processCreateParams(J)
    });
    let ZodSymbol = class ZodSymbol extends ZodType {
      _parse(J) {
        let et = this._getType(J);
        if (et !== ed.symbol) {
          let et = this._getOrReturnCtx(J);
          return addIssueToContext(et, {
            code: eh.invalid_type,
            expected: ed.symbol,
            received: et.parsedType
          }),
            ef
        }
        return OK(J.data)
      }
    }
      ;
    ZodSymbol.create = J => new ZodSymbol({
      typeName: ta.ZodSymbol,
      ...processCreateParams(J)
    });
    let ZodUndefined = class ZodUndefined extends ZodType {
      _parse(J) {
        let et = this._getType(J);
        if (et !== ed.undefined) {
          let et = this._getOrReturnCtx(J);
          return addIssueToContext(et, {
            code: eh.invalid_type,
            expected: ed.undefined,
            received: et.parsedType
          }),
            ef
        }
        return OK(J.data)
      }
    }
      ;
    ZodUndefined.create = J => new ZodUndefined({
      typeName: ta.ZodUndefined,
      ...processCreateParams(J)
    });
    let ZodNull = class ZodNull extends ZodType {
      _parse(J) {
        let et = this._getType(J);
        if (et !== ed.null) {
          let et = this._getOrReturnCtx(J);
          return addIssueToContext(et, {
            code: eh.invalid_type,
            expected: ed.null,
            received: et.parsedType
          }),
            ef
        }
        return OK(J.data)
      }
    }
      ;
    ZodNull.create = J => new ZodNull({
      typeName: ta.ZodNull,
      ...processCreateParams(J)
    });
    let ZodAny = class ZodAny extends ZodType {
      constructor() {
        super(...arguments),
          this._any = !0
      }
      _parse(J) {
        return OK(J.data)
      }
    }
      ;
    ZodAny.create = J => new ZodAny({
      typeName: ta.ZodAny,
      ...processCreateParams(J)
    });
    let ZodUnknown = class ZodUnknown extends ZodType {
      constructor() {
        super(...arguments),
          this._unknown = !0
      }
      _parse(J) {
        return OK(J.data)
      }
    }
      ;
    ZodUnknown.create = J => new ZodUnknown({
      typeName: ta.ZodUnknown,
      ...processCreateParams(J)
    });
    let ZodNever = class ZodNever extends ZodType {
      _parse(J) {
        let et = this._getOrReturnCtx(J);
        return addIssueToContext(et, {
          code: eh.invalid_type,
          expected: ed.never,
          received: et.parsedType
        }),
          ef
      }
    }
      ;
    ZodNever.create = J => new ZodNever({
      typeName: ta.ZodNever,
      ...processCreateParams(J)
    });
    let ZodVoid = class ZodVoid extends ZodType {
      _parse(J) {
        let et = this._getType(J);
        if (et !== ed.undefined) {
          let et = this._getOrReturnCtx(J);
          return addIssueToContext(et, {
            code: eh.invalid_type,
            expected: ed.void,
            received: et.parsedType
          }),
            ef
        }
        return OK(J.data)
      }
    }
      ;
    ZodVoid.create = J => new ZodVoid({
      typeName: ta.ZodVoid,
      ...processCreateParams(J)
    });
    let ZodArray = class ZodArray extends ZodType {
      _parse(J) {
        let { ctx: et, status: eo } = this._processInputParams(J)
          , el = this._def;
        if (et.parsedType !== ed.array)
          return addIssueToContext(et, {
            code: eh.invalid_type,
            expected: ed.array,
            received: et.parsedType
          }),
            ef;
        if (null !== el.exactLength) {
          let J = et.data.length > el.exactLength.value
            , ec = et.data.length < el.exactLength.value;
          (J || ec) && (addIssueToContext(et, {
            code: J ? eh.too_big : eh.too_small,
            minimum: ec ? el.exactLength.value : void 0,
            maximum: J ? el.exactLength.value : void 0,
            type: "array",
            inclusive: !0,
            exact: !0,
            message: el.exactLength.message
          }),
            eo.dirty())
        }
        if (null !== el.minLength && et.data.length < el.minLength.value && (addIssueToContext(et, {
          code: eh.too_small,
          minimum: el.minLength.value,
          type: "array",
          inclusive: !0,
          exact: !1,
          message: el.minLength.message
        }),
          eo.dirty()),
          null !== el.maxLength && et.data.length > el.maxLength.value && (addIssueToContext(et, {
            code: eh.too_big,
            maximum: el.maxLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: el.maxLength.message
          }),
            eo.dirty()),
          et.common.async)
          return Promise.all([...et.data].map((J, eo) => el.type._parseAsync(new ParseInputLazyPath(et, J, et.path, eo)))).then(J => ParseStatus.mergeArray(eo, J));
        let ec = [...et.data].map((J, eo) => el.type._parseSync(new ParseInputLazyPath(et, J, et.path, eo)));
        return ParseStatus.mergeArray(eo, ec)
      }
      get element() {
        return this._def.type
      }
      min(J, et) {
        return new ZodArray({
          ...this._def,
          minLength: {
            value: J,
            message: to.toString(et)
          }
        })
      }
      max(J, et) {
        return new ZodArray({
          ...this._def,
          maxLength: {
            value: J,
            message: to.toString(et)
          }
        })
      }
      length(J, et) {
        return new ZodArray({
          ...this._def,
          exactLength: {
            value: J,
            message: to.toString(et)
          }
        })
      }
      nonempty(J) {
        return this.min(1, J)
      }
    }
      ;
    ZodArray.create = (J, et) => new ZodArray({
      type: J,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ta.ZodArray,
      ...processCreateParams(et)
    });
    let ZodObject = class ZodObject extends ZodType {
      constructor() {
        super(...arguments),
          this._cached = null,
          this.nonstrict = this.passthrough,
          this.augment = this.extend
      }
      _getCached() {
        if (null !== this._cached)
          return this._cached;
        let J = this._def.shape()
          , et = e9.objectKeys(J);
        return this._cached = {
          shape: J,
          keys: et
        }
      }
      _parse(J) {
        let et = this._getType(J);
        if (et !== ed.object) {
          let et = this._getOrReturnCtx(J);
          return addIssueToContext(et, {
            code: eh.invalid_type,
            expected: ed.object,
            received: et.parsedType
          }),
            ef
        }
        let { status: eo, ctx: el } = this._processInputParams(J)
          , { shape: ec, keys: ep } = this._getCached()
          , em = [];
        if (!(this._def.catchall instanceof ZodNever && "strip" === this._def.unknownKeys))
          for (let J in el.data)
            ep.includes(J) || em.push(J);
        let eg = [];
        for (let J of ep) {
          let et = ec[J]
            , eo = el.data[J];
          eg.push({
            key: {
              status: "valid",
              value: J
            },
            value: et._parse(new ParseInputLazyPath(el, eo, el.path, J)),
            alwaysSet: J in el.data
          })
        }
        if (this._def.catchall instanceof ZodNever) {
          let J = this._def.unknownKeys;
          if ("passthrough" === J)
            for (let J of em)
              eg.push({
                key: {
                  status: "valid",
                  value: J
                },
                value: {
                  status: "valid",
                  value: el.data[J]
                }
              });
          else if ("strict" === J)
            em.length > 0 && (addIssueToContext(el, {
              code: eh.unrecognized_keys,
              keys: em
            }),
              eo.dirty());
          else if ("strip" === J)
            ;
          else
            throw Error("Internal ZodObject error: invalid unknownKeys value.")
        } else {
          let J = this._def.catchall;
          for (let et of em) {
            let eo = el.data[et];
            eg.push({
              key: {
                status: "valid",
                value: et
              },
              value: J._parse(new ParseInputLazyPath(el, eo, el.path, et)),
              alwaysSet: et in el.data
            })
          }
        }
        return el.common.async ? Promise.resolve().then(async () => {
          let J = [];
          for (let et of eg) {
            let eo = await et.key;
            J.push({
              key: eo,
              value: await et.value,
              alwaysSet: et.alwaysSet
            })
          }
          return J
        }
        ).then(J => ParseStatus.mergeObjectSync(eo, J)) : ParseStatus.mergeObjectSync(eo, eg)
      }
      get shape() {
        return this._def.shape()
      }
      strict(J) {
        return to.errToObj,
          new ZodObject({
            ...this._def,
            unknownKeys: "strict",
            ...void 0 !== J ? {
              errorMap: (et, eo) => {
                var el, ec, ed, eh;
                let ep = null !== (ed = null === (ec = (el = this._def).errorMap) || void 0 === ec ? void 0 : ec.call(el, et, eo).message) && void 0 !== ed ? ed : eo.defaultError;
                return "unrecognized_keys" === et.code ? {
                  message: null !== (eh = to.errToObj(J).message) && void 0 !== eh ? eh : ep
                } : {
                  message: ep
                }
              }
            } : {}
          })
      }
      strip() {
        return new ZodObject({
          ...this._def,
          unknownKeys: "strip"
        })
      }
      passthrough() {
        return new ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        })
      }
      extend(J) {
        return new ZodObject({
          ...this._def,
          shape: () => ({
            ...this._def.shape(),
            ...J
          })
        })
      }
      merge(J) {
        let et = new ZodObject({
          unknownKeys: J._def.unknownKeys,
          catchall: J._def.catchall,
          shape: () => ({
            ...this._def.shape(),
            ...J._def.shape()
          }),
          typeName: ta.ZodObject
        });
        return et
      }
      setKey(J, et) {
        return this.augment({
          [J]: et
        })
      }
      catchall(J) {
        return new ZodObject({
          ...this._def,
          catchall: J
        })
      }
      pick(J) {
        let et = {};
        return e9.objectKeys(J).forEach(eo => {
          J[eo] && this.shape[eo] && (et[eo] = this.shape[eo])
        }
        ),
          new ZodObject({
            ...this._def,
            shape: () => et
          })
      }
      omit(J) {
        let et = {};
        return e9.objectKeys(this.shape).forEach(eo => {
          J[eo] || (et[eo] = this.shape[eo])
        }
        ),
          new ZodObject({
            ...this._def,
            shape: () => et
          })
      }
      deepPartial() {
        return function deepPartialify(J) {
          if (J instanceof ZodObject) {
            let et = {};
            for (let eo in J.shape) {
              let el = J.shape[eo];
              et[eo] = ZodOptional.create(deepPartialify(el))
            }
            return new ZodObject({
              ...J._def,
              shape: () => et
            })
          }
          return J instanceof ZodArray ? new ZodArray({
            ...J._def,
            type: deepPartialify(J.element)
          }) : J instanceof ZodOptional ? ZodOptional.create(deepPartialify(J.unwrap())) : J instanceof ZodNullable ? ZodNullable.create(deepPartialify(J.unwrap())) : J instanceof ZodTuple ? ZodTuple.create(J.items.map(J => deepPartialify(J))) : J
        }(this)
      }
      partial(J) {
        let et = {};
        return e9.objectKeys(this.shape).forEach(eo => {
          let el = this.shape[eo];
          J && !J[eo] ? et[eo] = el : et[eo] = el.optional()
        }
        ),
          new ZodObject({
            ...this._def,
            shape: () => et
          })
      }
      required(J) {
        let et = {};
        return e9.objectKeys(this.shape).forEach(eo => {
          if (J && !J[eo])
            et[eo] = this.shape[eo];
          else {
            let J = this.shape[eo]
              , el = J;
            for (; el instanceof ZodOptional;)
              el = el._def.innerType;
            et[eo] = el
          }
        }
        ),
          new ZodObject({
            ...this._def,
            shape: () => et
          })
      }
      keyof() {
        return createZodEnum(e9.objectKeys(this.shape))
      }
    }
      ;
    ZodObject.create = (J, et) => new ZodObject({
      shape: () => J,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ta.ZodObject,
      ...processCreateParams(et)
    }),
      ZodObject.strictCreate = (J, et) => new ZodObject({
        shape: () => J,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ta.ZodObject,
        ...processCreateParams(et)
      }),
      ZodObject.lazycreate = (J, et) => new ZodObject({
        shape: J,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ta.ZodObject,
        ...processCreateParams(et)
      });
    let ZodUnion = class ZodUnion extends ZodType {
      _parse(J) {
        let { ctx: et } = this._processInputParams(J)
          , eo = this._def.options;
        if (et.common.async)
          return Promise.all(eo.map(async J => {
            let eo = {
              ...et,
              common: {
                ...et.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await J._parseAsync({
                data: et.data,
                path: et.path,
                parent: eo
              }),
              ctx: eo
            }
          }
          )).then(function (J) {
            for (let et of J)
              if ("valid" === et.result.status)
                return et.result;
            for (let eo of J)
              if ("dirty" === eo.result.status)
                return et.common.issues.push(...eo.ctx.common.issues),
                  eo.result;
            let eo = J.map(J => new ZodError(J.ctx.common.issues));
            return addIssueToContext(et, {
              code: eh.invalid_union,
              unionErrors: eo
            }),
              ef
          });
        {
          let J;
          let el = [];
          for (let ec of eo) {
            let eo = {
              ...et,
              common: {
                ...et.common,
                issues: []
              },
              parent: null
            }
              , ed = ec._parseSync({
                data: et.data,
                path: et.path,
                parent: eo
              });
            if ("valid" === ed.status)
              return ed;
            "dirty" !== ed.status || J || (J = {
              result: ed,
              ctx: eo
            }),
              eo.common.issues.length && el.push(eo.common.issues)
          }
          if (J)
            return et.common.issues.push(...J.ctx.common.issues),
              J.result;
          let ec = el.map(J => new ZodError(J));
          return addIssueToContext(et, {
            code: eh.invalid_union,
            unionErrors: ec
          }),
            ef
        }
      }
      get options() {
        return this._def.options
      }
    }
      ;
    ZodUnion.create = (J, et) => new ZodUnion({
      options: J,
      typeName: ta.ZodUnion,
      ...processCreateParams(et)
    });
    let getDiscriminator = J => {
      if (J instanceof ZodLazy)
        return getDiscriminator(J.schema);
      if (J instanceof ZodEffects)
        return getDiscriminator(J.innerType());
      if (J instanceof ZodLiteral)
        return [J.value];
      if (J instanceof ZodEnum)
        return J.options;
      if (J instanceof ZodNativeEnum)
        return Object.keys(J.enum);
      if (J instanceof ZodDefault)
        return getDiscriminator(J._def.innerType);
      if (J instanceof ZodUndefined)
        return [void 0];
      else if (J instanceof ZodNull)
        return [null];
      else
        return null
    }
      ;
    let ZodDiscriminatedUnion = class ZodDiscriminatedUnion extends ZodType {
      _parse(J) {
        let { ctx: et } = this._processInputParams(J);
        if (et.parsedType !== ed.object)
          return addIssueToContext(et, {
            code: eh.invalid_type,
            expected: ed.object,
            received: et.parsedType
          }),
            ef;
        let eo = this.discriminator
          , el = et.data[eo]
          , ec = this.optionsMap.get(el);
        return ec ? et.common.async ? ec._parseAsync({
          data: et.data,
          path: et.path,
          parent: et
        }) : ec._parseSync({
          data: et.data,
          path: et.path,
          parent: et
        }) : (addIssueToContext(et, {
          code: eh.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [eo]
        }),
          ef)
      }
      get discriminator() {
        return this._def.discriminator
      }
      get options() {
        return this._def.options
      }
      get optionsMap() {
        return this._def.optionsMap
      }
      static create(J, et, eo) {
        let el = new Map;
        for (let eo of et) {
          let et = getDiscriminator(eo.shape[J]);
          if (!et)
            throw Error(`A discriminator value for key \`${J}\` could not be extracted from all schema options`);
          for (let ec of et) {
            if (el.has(ec))
              throw Error(`Discriminator property ${String(J)} has duplicate value ${String(ec)}`);
            el.set(ec, eo)
          }
        }
        return new ZodDiscriminatedUnion({
          typeName: ta.ZodDiscriminatedUnion,
          discriminator: J,
          options: et,
          optionsMap: el,
          ...processCreateParams(eo)
        })
      }
    }
      ;
    let ZodIntersection = class ZodIntersection extends ZodType {
      _parse(J) {
        let { status: et, ctx: eo } = this._processInputParams(J)
          , handleParsed = (J, el) => {
            if (isAborted(J) || isAborted(el))
              return ef;
            let ec = function mergeValues(J, et) {
              let eo = getParsedType(J)
                , el = getParsedType(et);
              if (J === et)
                return {
                  valid: !0,
                  data: J
                };
              if (eo === ed.object && el === ed.object) {
                let eo = e9.objectKeys(et)
                  , el = e9.objectKeys(J).filter(J => -1 !== eo.indexOf(J))
                  , ec = {
                    ...J,
                    ...et
                  };
                for (let eo of el) {
                  let el = mergeValues(J[eo], et[eo]);
                  if (!el.valid)
                    return {
                      valid: !1
                    };
                  ec[eo] = el.data
                }
                return {
                  valid: !0,
                  data: ec
                }
              }
              if (eo === ed.array && el === ed.array) {
                if (J.length !== et.length)
                  return {
                    valid: !1
                  };
                let eo = [];
                for (let el = 0; el < J.length; el++) {
                  let ec = J[el]
                    , ed = et[el]
                    , eh = mergeValues(ec, ed);
                  if (!eh.valid)
                    return {
                      valid: !1
                    };
                  eo.push(eh.data)
                }
                return {
                  valid: !0,
                  data: eo
                }
              }
              return eo === ed.date && el === ed.date && +J == +et ? {
                valid: !0,
                data: J
              } : {
                valid: !1
              }
            }(J.value, el.value);
            return ec.valid ? ((isDirty(J) || isDirty(el)) && et.dirty(),
            {
              status: et.value,
              value: ec.data
            }) : (addIssueToContext(eo, {
              code: eh.invalid_intersection_types
            }),
              ef)
          }
          ;
        return eo.common.async ? Promise.all([this._def.left._parseAsync({
          data: eo.data,
          path: eo.path,
          parent: eo
        }), this._def.right._parseAsync({
          data: eo.data,
          path: eo.path,
          parent: eo
        })]).then(([J, et]) => handleParsed(J, et)) : handleParsed(this._def.left._parseSync({
          data: eo.data,
          path: eo.path,
          parent: eo
        }), this._def.right._parseSync({
          data: eo.data,
          path: eo.path,
          parent: eo
        }))
      }
    }
      ;
    ZodIntersection.create = (J, et, eo) => new ZodIntersection({
      left: J,
      right: et,
      typeName: ta.ZodIntersection,
      ...processCreateParams(eo)
    });
    let ZodTuple = class ZodTuple extends ZodType {
      _parse(J) {
        let { status: et, ctx: eo } = this._processInputParams(J);
        if (eo.parsedType !== ed.array)
          return addIssueToContext(eo, {
            code: eh.invalid_type,
            expected: ed.array,
            received: eo.parsedType
          }),
            ef;
        if (eo.data.length < this._def.items.length)
          return addIssueToContext(eo, {
            code: eh.too_small,
            minimum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
          }),
            ef;
        let el = this._def.rest;
        !el && eo.data.length > this._def.items.length && (addIssueToContext(eo, {
          code: eh.too_big,
          maximum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: "array"
        }),
          et.dirty());
        let ec = [...eo.data].map((J, et) => {
          let el = this._def.items[et] || this._def.rest;
          return el ? el._parse(new ParseInputLazyPath(eo, J, eo.path, et)) : null
        }
        ).filter(J => !!J);
        return eo.common.async ? Promise.all(ec).then(J => ParseStatus.mergeArray(et, J)) : ParseStatus.mergeArray(et, ec)
      }
      get items() {
        return this._def.items
      }
      rest(J) {
        return new ZodTuple({
          ...this._def,
          rest: J
        })
      }
    }
      ;
    ZodTuple.create = (J, et) => {
      if (!Array.isArray(J))
        throw Error("You must pass an array of schemas to z.tuple([ ... ])");
      return new ZodTuple({
        items: J,
        typeName: ta.ZodTuple,
        rest: null,
        ...processCreateParams(et)
      })
    }
      ;
    let ZodRecord = class ZodRecord extends ZodType {
      get keySchema() {
        return this._def.keyType
      }
      get valueSchema() {
        return this._def.valueType
      }
      _parse(J) {
        let { status: et, ctx: eo } = this._processInputParams(J);
        if (eo.parsedType !== ed.object)
          return addIssueToContext(eo, {
            code: eh.invalid_type,
            expected: ed.object,
            received: eo.parsedType
          }),
            ef;
        let el = []
          , ec = this._def.keyType
          , ep = this._def.valueType;
        for (let J in eo.data)
          el.push({
            key: ec._parse(new ParseInputLazyPath(eo, J, eo.path, J)),
            value: ep._parse(new ParseInputLazyPath(eo, eo.data[J], eo.path, J))
          });
        return eo.common.async ? ParseStatus.mergeObjectAsync(et, el) : ParseStatus.mergeObjectSync(et, el)
      }
      get element() {
        return this._def.valueType
      }
      static create(J, et, eo) {
        return new ZodRecord(et instanceof ZodType ? {
          keyType: J,
          valueType: et,
          typeName: ta.ZodRecord,
          ...processCreateParams(eo)
        } : {
          keyType: ZodString.create(),
          valueType: J,
          typeName: ta.ZodRecord,
          ...processCreateParams(et)
        })
      }
    }
      ;
    let ZodMap = class ZodMap extends ZodType {
      get keySchema() {
        return this._def.keyType
      }
      get valueSchema() {
        return this._def.valueType
      }
      _parse(J) {
        let { status: et, ctx: eo } = this._processInputParams(J);
        if (eo.parsedType !== ed.map)
          return addIssueToContext(eo, {
            code: eh.invalid_type,
            expected: ed.map,
            received: eo.parsedType
          }),
            ef;
        let el = this._def.keyType
          , ec = this._def.valueType
          , ep = [...eo.data.entries()].map(([J, et], ed) => ({
            key: el._parse(new ParseInputLazyPath(eo, J, eo.path, [ed, "key"])),
            value: ec._parse(new ParseInputLazyPath(eo, et, eo.path, [ed, "value"]))
          }));
        if (eo.common.async) {
          let J = new Map;
          return Promise.resolve().then(async () => {
            for (let eo of ep) {
              let el = await eo.key
                , ec = await eo.value;
              if ("aborted" === el.status || "aborted" === ec.status)
                return ef;
              ("dirty" === el.status || "dirty" === ec.status) && et.dirty(),
                J.set(el.value, ec.value)
            }
            return {
              status: et.value,
              value: J
            }
          }
          )
        }
        {
          let J = new Map;
          for (let eo of ep) {
            let el = eo.key
              , ec = eo.value;
            if ("aborted" === el.status || "aborted" === ec.status)
              return ef;
            ("dirty" === el.status || "dirty" === ec.status) && et.dirty(),
              J.set(el.value, ec.value)
          }
          return {
            status: et.value,
            value: J
          }
        }
      }
    }
      ;
    ZodMap.create = (J, et, eo) => new ZodMap({
      valueType: et,
      keyType: J,
      typeName: ta.ZodMap,
      ...processCreateParams(eo)
    });
    let ZodSet = class ZodSet extends ZodType {
      _parse(J) {
        let { status: et, ctx: eo } = this._processInputParams(J);
        if (eo.parsedType !== ed.set)
          return addIssueToContext(eo, {
            code: eh.invalid_type,
            expected: ed.set,
            received: eo.parsedType
          }),
            ef;
        let el = this._def;
        null !== el.minSize && eo.data.size < el.minSize.value && (addIssueToContext(eo, {
          code: eh.too_small,
          minimum: el.minSize.value,
          type: "set",
          inclusive: !0,
          exact: !1,
          message: el.minSize.message
        }),
          et.dirty()),
          null !== el.maxSize && eo.data.size > el.maxSize.value && (addIssueToContext(eo, {
            code: eh.too_big,
            maximum: el.maxSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: el.maxSize.message
          }),
            et.dirty());
        let ec = this._def.valueType;
        function finalizeSet(J) {
          let eo = new Set;
          for (let el of J) {
            if ("aborted" === el.status)
              return ef;
            "dirty" === el.status && et.dirty(),
              eo.add(el.value)
          }
          return {
            status: et.value,
            value: eo
          }
        }
        let ep = [...eo.data.values()].map((J, et) => ec._parse(new ParseInputLazyPath(eo, J, eo.path, et)));
        return eo.common.async ? Promise.all(ep).then(J => finalizeSet(J)) : finalizeSet(ep)
      }
      min(J, et) {
        return new ZodSet({
          ...this._def,
          minSize: {
            value: J,
            message: to.toString(et)
          }
        })
      }
      max(J, et) {
        return new ZodSet({
          ...this._def,
          maxSize: {
            value: J,
            message: to.toString(et)
          }
        })
      }
      size(J, et) {
        return this.min(J, et).max(J, et)
      }
      nonempty(J) {
        return this.min(1, J)
      }
    }
      ;
    ZodSet.create = (J, et) => new ZodSet({
      valueType: J,
      minSize: null,
      maxSize: null,
      typeName: ta.ZodSet,
      ...processCreateParams(et)
    });
    let ZodFunction = class ZodFunction extends ZodType {
      constructor() {
        super(...arguments),
          this.validate = this.implement
      }
      _parse(J) {
        let { ctx: et } = this._processInputParams(J);
        if (et.parsedType !== ed.function)
          return addIssueToContext(et, {
            code: eh.invalid_type,
            expected: ed.function,
            received: et.parsedType
          }),
            ef;
        function makeArgsIssue(J, eo) {
          return makeIssue({
            data: J,
            path: et.path,
            errorMaps: [et.common.contextualErrorMap, et.schemaErrorMap, getErrorMap(), errorMap].filter(J => !!J),
            issueData: {
              code: eh.invalid_arguments,
              argumentsError: eo
            }
          })
        }
        function makeReturnsIssue(J, eo) {
          return makeIssue({
            data: J,
            path: et.path,
            errorMaps: [et.common.contextualErrorMap, et.schemaErrorMap, getErrorMap(), errorMap].filter(J => !!J),
            issueData: {
              code: eh.invalid_return_type,
              returnTypeError: eo
            }
          })
        }
        let eo = {
          errorMap: et.common.contextualErrorMap
        }
          , el = et.data;
        if (this._def.returns instanceof ZodPromise) {
          let J = this;
          return OK(async function (...et) {
            let ec = new ZodError([])
              , ed = await J._def.args.parseAsync(et, eo).catch(J => {
                throw ec.addIssue(makeArgsIssue(et, J)),
                ec
              }
              )
              , eh = await Reflect.apply(el, this, ed)
              , ep = await J._def.returns._def.type.parseAsync(eh, eo).catch(J => {
                throw ec.addIssue(makeReturnsIssue(eh, J)),
                ec
              }
              );
            return ep
          })
        }
        {
          let J = this;
          return OK(function (...et) {
            let ec = J._def.args.safeParse(et, eo);
            if (!ec.success)
              throw new ZodError([makeArgsIssue(et, ec.error)]);
            let ed = Reflect.apply(el, this, ec.data)
              , eh = J._def.returns.safeParse(ed, eo);
            if (!eh.success)
              throw new ZodError([makeReturnsIssue(ed, eh.error)]);
            return eh.data
          })
        }
      }
      parameters() {
        return this._def.args
      }
      returnType() {
        return this._def.returns
      }
      args(...J) {
        return new ZodFunction({
          ...this._def,
          args: ZodTuple.create(J).rest(ZodUnknown.create())
        })
      }
      returns(J) {
        return new ZodFunction({
          ...this._def,
          returns: J
        })
      }
      implement(J) {
        let et = this.parse(J);
        return et
      }
      strictImplement(J) {
        let et = this.parse(J);
        return et
      }
      static create(J, et, eo) {
        return new ZodFunction({
          args: J || ZodTuple.create([]).rest(ZodUnknown.create()),
          returns: et || ZodUnknown.create(),
          typeName: ta.ZodFunction,
          ...processCreateParams(eo)
        })
      }
    }
      ;
    let ZodLazy = class ZodLazy extends ZodType {
      get schema() {
        return this._def.getter()
      }
      _parse(J) {
        let { ctx: et } = this._processInputParams(J)
          , eo = this._def.getter();
        return eo._parse({
          data: et.data,
          path: et.path,
          parent: et
        })
      }
    }
      ;
    ZodLazy.create = (J, et) => new ZodLazy({
      getter: J,
      typeName: ta.ZodLazy,
      ...processCreateParams(et)
    });
    let ZodLiteral = class ZodLiteral extends ZodType {
      _parse(J) {
        if (J.data !== this._def.value) {
          let et = this._getOrReturnCtx(J);
          return addIssueToContext(et, {
            received: et.data,
            code: eh.invalid_literal,
            expected: this._def.value
          }),
            ef
        }
        return {
          status: "valid",
          value: J.data
        }
      }
      get value() {
        return this._def.value
      }
    }
      ;
    function createZodEnum(J, et) {
      return new ZodEnum({
        values: J,
        typeName: ta.ZodEnum,
        ...processCreateParams(et)
      })
    }
    ZodLiteral.create = (J, et) => new ZodLiteral({
      value: J,
      typeName: ta.ZodLiteral,
      ...processCreateParams(et)
    });
    let ZodEnum = class ZodEnum extends ZodType {
      _parse(J) {
        if ("string" != typeof J.data) {
          let et = this._getOrReturnCtx(J)
            , eo = this._def.values;
          return addIssueToContext(et, {
            expected: e9.joinValues(eo),
            received: et.parsedType,
            code: eh.invalid_type
          }),
            ef
        }
        if (-1 === this._def.values.indexOf(J.data)) {
          let et = this._getOrReturnCtx(J)
            , eo = this._def.values;
          return addIssueToContext(et, {
            received: et.data,
            code: eh.invalid_enum_value,
            options: eo
          }),
            ef
        }
        return OK(J.data)
      }
      get options() {
        return this._def.values
      }
      get enum() {
        let J = {};
        for (let et of this._def.values)
          J[et] = et;
        return J
      }
      get Values() {
        let J = {};
        for (let et of this._def.values)
          J[et] = et;
        return J
      }
      get Enum() {
        let J = {};
        for (let et of this._def.values)
          J[et] = et;
        return J
      }
      extract(J) {
        return ZodEnum.create(J)
      }
      exclude(J) {
        return ZodEnum.create(this.options.filter(et => !J.includes(et)))
      }
    }
      ;
    ZodEnum.create = createZodEnum;
    let ZodNativeEnum = class ZodNativeEnum extends ZodType {
      _parse(J) {
        let et = e9.getValidEnumValues(this._def.values)
          , eo = this._getOrReturnCtx(J);
        if (eo.parsedType !== ed.string && eo.parsedType !== ed.number) {
          let J = e9.objectValues(et);
          return addIssueToContext(eo, {
            expected: e9.joinValues(J),
            received: eo.parsedType,
            code: eh.invalid_type
          }),
            ef
        }
        if (-1 === et.indexOf(J.data)) {
          let J = e9.objectValues(et);
          return addIssueToContext(eo, {
            received: eo.data,
            code: eh.invalid_enum_value,
            options: J
          }),
            ef
        }
        return OK(J.data)
      }
      get enum() {
        return this._def.values
      }
    }
      ;
    ZodNativeEnum.create = (J, et) => new ZodNativeEnum({
      values: J,
      typeName: ta.ZodNativeEnum,
      ...processCreateParams(et)
    });
    let ZodPromise = class ZodPromise extends ZodType {
      unwrap() {
        return this._def.type
      }
      _parse(J) {
        let { ctx: et } = this._processInputParams(J);
        if (et.parsedType !== ed.promise && !1 === et.common.async)
          return addIssueToContext(et, {
            code: eh.invalid_type,
            expected: ed.promise,
            received: et.parsedType
          }),
            ef;
        let eo = et.parsedType === ed.promise ? et.data : Promise.resolve(et.data);
        return OK(eo.then(J => this._def.type.parseAsync(J, {
          path: et.path,
          errorMap: et.common.contextualErrorMap
        })))
      }
    }
      ;
    ZodPromise.create = (J, et) => new ZodPromise({
      type: J,
      typeName: ta.ZodPromise,
      ...processCreateParams(et)
    });
    let ZodEffects = class ZodEffects extends ZodType {
      innerType() {
        return this._def.schema
      }
      sourceType() {
        return this._def.schema._def.typeName === ta.ZodEffects ? this._def.schema.sourceType() : this._def.schema
      }
      _parse(J) {
        let { status: et, ctx: eo } = this._processInputParams(J)
          , el = this._def.effect || null
          , ec = {
            addIssue: J => {
              addIssueToContext(eo, J),
                J.fatal ? et.abort() : et.dirty()
            }
            ,
            get path() {
              return eo.path
            }
          };
        if (ec.addIssue = ec.addIssue.bind(ec),
          "preprocess" === el.type) {
          let J = el.transform(eo.data, ec);
          return eo.common.issues.length ? {
            status: "dirty",
            value: eo.data
          } : eo.common.async ? Promise.resolve(J).then(J => this._def.schema._parseAsync({
            data: J,
            path: eo.path,
            parent: eo
          })) : this._def.schema._parseSync({
            data: J,
            path: eo.path,
            parent: eo
          })
        }
        if ("refinement" === el.type) {
          let executeRefinement = J => {
            let et = el.refinement(J, ec);
            if (eo.common.async)
              return Promise.resolve(et);
            if (et instanceof Promise)
              throw Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            return J
          }
            ;
          if (!1 !== eo.common.async)
            return this._def.schema._parseAsync({
              data: eo.data,
              path: eo.path,
              parent: eo
            }).then(J => "aborted" === J.status ? ef : ("dirty" === J.status && et.dirty(),
              executeRefinement(J.value).then(() => ({
                status: et.value,
                value: J.value
              }))));
          {
            let J = this._def.schema._parseSync({
              data: eo.data,
              path: eo.path,
              parent: eo
            });
            return "aborted" === J.status ? ef : ("dirty" === J.status && et.dirty(),
              executeRefinement(J.value),
            {
              status: et.value,
              value: J.value
            })
          }
        }
        if ("transform" === el.type) {
          if (!1 !== eo.common.async)
            return this._def.schema._parseAsync({
              data: eo.data,
              path: eo.path,
              parent: eo
            }).then(J => isValid(J) ? Promise.resolve(el.transform(J.value, ec)).then(J => ({
              status: et.value,
              value: J
            })) : J);
          {
            let J = this._def.schema._parseSync({
              data: eo.data,
              path: eo.path,
              parent: eo
            });
            if (!isValid(J))
              return J;
            let ed = el.transform(J.value, ec);
            if (ed instanceof Promise)
              throw Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
            return {
              status: et.value,
              value: ed
            }
          }
        }
        e9.assertNever(el)
      }
    }
      ;
    ZodEffects.create = (J, et, eo) => new ZodEffects({
      schema: J,
      typeName: ta.ZodEffects,
      effect: et,
      ...processCreateParams(eo)
    }),
      ZodEffects.createWithPreprocess = (J, et, eo) => new ZodEffects({
        schema: et,
        effect: {
          type: "preprocess",
          transform: J
        },
        typeName: ta.ZodEffects,
        ...processCreateParams(eo)
      });
    let ZodOptional = class ZodOptional extends ZodType {
      _parse(J) {
        let et = this._getType(J);
        return et === ed.undefined ? OK(void 0) : this._def.innerType._parse(J)
      }
      unwrap() {
        return this._def.innerType
      }
    }
      ;
    ZodOptional.create = (J, et) => new ZodOptional({
      innerType: J,
      typeName: ta.ZodOptional,
      ...processCreateParams(et)
    });
    let ZodNullable = class ZodNullable extends ZodType {
      _parse(J) {
        let et = this._getType(J);
        return et === ed.null ? OK(null) : this._def.innerType._parse(J)
      }
      unwrap() {
        return this._def.innerType
      }
    }
      ;
    ZodNullable.create = (J, et) => new ZodNullable({
      innerType: J,
      typeName: ta.ZodNullable,
      ...processCreateParams(et)
    });
    let ZodDefault = class ZodDefault extends ZodType {
      _parse(J) {
        let { ctx: et } = this._processInputParams(J)
          , eo = et.data;
        return et.parsedType === ed.undefined && (eo = this._def.defaultValue()),
          this._def.innerType._parse({
            data: eo,
            path: et.path,
            parent: et
          })
      }
      removeDefault() {
        return this._def.innerType
      }
    }
      ;
    ZodDefault.create = (J, et) => new ZodDefault({
      innerType: J,
      typeName: ta.ZodDefault,
      defaultValue: "function" == typeof et.default ? et.default : () => et.default,
      ...processCreateParams(et)
    });
    let ZodCatch = class ZodCatch extends ZodType {
      _parse(J) {
        let { ctx: et } = this._processInputParams(J)
          , eo = {
            ...et,
            common: {
              ...et.common,
              issues: []
            }
          }
          , el = this._def.innerType._parse({
            data: eo.data,
            path: eo.path,
            parent: {
              ...eo
            }
          });
        return isAsync(el) ? el.then(J => ({
          status: "valid",
          value: "valid" === J.status ? J.value : this._def.catchValue({
            get error() {
              return new ZodError(eo.common.issues)
            },
            input: eo.data
          })
        })) : {
          status: "valid",
          value: "valid" === el.status ? el.value : this._def.catchValue({
            get error() {
              return new ZodError(eo.common.issues)
            },
            input: eo.data
          })
        }
      }
      removeCatch() {
        return this._def.innerType
      }
    }
      ;
    ZodCatch.create = (J, et) => new ZodCatch({
      innerType: J,
      typeName: ta.ZodCatch,
      catchValue: "function" == typeof et.catch ? et.catch : () => et.catch,
      ...processCreateParams(et)
    });
    let ZodNaN = class ZodNaN extends ZodType {
      _parse(J) {
        let et = this._getType(J);
        if (et !== ed.nan) {
          let et = this._getOrReturnCtx(J);
          return addIssueToContext(et, {
            code: eh.invalid_type,
            expected: ed.nan,
            received: et.parsedType
          }),
            ef
        }
        return {
          status: "valid",
          value: J.data
        }
      }
    }
      ;
    ZodNaN.create = J => new ZodNaN({
      typeName: ta.ZodNaN,
      ...processCreateParams(J)
    });
    let eE = Symbol("zod_brand");
    let ZodBranded = class ZodBranded extends ZodType {
      _parse(J) {
        let { ctx: et } = this._processInputParams(J)
          , eo = et.data;
        return this._def.type._parse({
          data: eo,
          path: et.path,
          parent: et
        })
      }
      unwrap() {
        return this._def.type
      }
    }
      ;
    let ZodPipeline = class ZodPipeline extends ZodType {
      _parse(J) {
        let { status: et, ctx: eo } = this._processInputParams(J);
        if (eo.common.async) {
          let handleAsync = async () => {
            let J = await this._def.in._parseAsync({
              data: eo.data,
              path: eo.path,
              parent: eo
            });
            return "aborted" === J.status ? ef : "dirty" === J.status ? (et.dirty(),
              DIRTY(J.value)) : this._def.out._parseAsync({
                data: J.value,
                path: eo.path,
                parent: eo
              })
          }
            ;
          return handleAsync()
        }
        {
          let J = this._def.in._parseSync({
            data: eo.data,
            path: eo.path,
            parent: eo
          });
          return "aborted" === J.status ? ef : "dirty" === J.status ? (et.dirty(),
          {
            status: "dirty",
            value: J.value
          }) : this._def.out._parseSync({
            data: J.value,
            path: eo.path,
            parent: eo
          })
        }
      }
      static create(J, et) {
        return new ZodPipeline({
          in: J,
          out: et,
          typeName: ta.ZodPipeline
        })
      }
    }
      ;
    let ZodReadonly = class ZodReadonly extends ZodType {
      _parse(J) {
        let et = this._def.innerType._parse(J);
        return isValid(et) && (et.value = Object.freeze(et.value)),
          et
      }
    }
      ;
    ZodReadonly.create = (J, et) => new ZodReadonly({
      innerType: J,
      typeName: ta.ZodReadonly,
      ...processCreateParams(et)
    });
    let custom = (J, et = {}, eo) => J ? ZodAny.create().superRefine((el, ec) => {
      var ed, eh;
      if (!J(el)) {
        let J = "function" == typeof et ? et(el) : "string" == typeof et ? {
          message: et
        } : et
          , ep = null === (eh = null !== (ed = J.fatal) && void 0 !== ed ? ed : eo) || void 0 === eh || eh
          , ef = "string" == typeof J ? {
            message: J
          } : J;
        ec.addIssue({
          code: "custom",
          ...ef,
          fatal: ep
        })
      }
    }
    ) : ZodAny.create()
      , eC = {
        object: ZodObject.lazycreate
      };
    (e7 = ta || (ta = {})).ZodString = "ZodString",
      e7.ZodNumber = "ZodNumber",
      e7.ZodNaN = "ZodNaN",
      e7.ZodBigInt = "ZodBigInt",
      e7.ZodBoolean = "ZodBoolean",
      e7.ZodDate = "ZodDate",
      e7.ZodSymbol = "ZodSymbol",
      e7.ZodUndefined = "ZodUndefined",
      e7.ZodNull = "ZodNull",
      e7.ZodAny = "ZodAny",
      e7.ZodUnknown = "ZodUnknown",
      e7.ZodNever = "ZodNever",
      e7.ZodVoid = "ZodVoid",
      e7.ZodArray = "ZodArray",
      e7.ZodObject = "ZodObject",
      e7.ZodUnion = "ZodUnion",
      e7.ZodDiscriminatedUnion = "ZodDiscriminatedUnion",
      e7.ZodIntersection = "ZodIntersection",
      e7.ZodTuple = "ZodTuple",
      e7.ZodRecord = "ZodRecord",
      e7.ZodMap = "ZodMap",
      e7.ZodSet = "ZodSet",
      e7.ZodFunction = "ZodFunction",
      e7.ZodLazy = "ZodLazy",
      e7.ZodLiteral = "ZodLiteral",
      e7.ZodEnum = "ZodEnum",
      e7.ZodEffects = "ZodEffects",
      e7.ZodNativeEnum = "ZodNativeEnum",
      e7.ZodOptional = "ZodOptional",
      e7.ZodNullable = "ZodNullable",
      e7.ZodDefault = "ZodDefault",
      e7.ZodCatch = "ZodCatch",
      e7.ZodPromise = "ZodPromise",
      e7.ZodBranded = "ZodBranded",
      e7.ZodPipeline = "ZodPipeline",
      e7.ZodReadonly = "ZodReadonly";
    let eS = ZodString.create
      , ek = ZodNumber.create
      , eT = ZodNaN.create
      , eA = ZodBigInt.create
      , eP = ZodBoolean.create
      , eR = ZodDate.create
      , eI = ZodSymbol.create
      , eO = ZodUndefined.create
      , eN = ZodNull.create
      , eM = ZodAny.create
      , eD = ZodUnknown.create
      , ej = ZodNever.create
      , eL = ZodVoid.create
      , e$ = ZodArray.create
      , eB = ZodObject.create
      , eF = ZodObject.strictCreate
      , eU = ZodUnion.create
      , ez = ZodDiscriminatedUnion.create
      , eH = ZodIntersection.create
      , eV = ZodTuple.create
      , eW = ZodRecord.create
      , eZ = ZodMap.create
      , eG = ZodSet.create
      , eY = ZodFunction.create
      , eK = ZodLazy.create
      , eJ = ZodLiteral.create
      , eQ = ZodEnum.create
      , eX = ZodNativeEnum.create
      , e0 = ZodPromise.create
      , e1 = ZodEffects.create
      , e2 = ZodOptional.create
      , e3 = ZodNullable.create
      , e5 = ZodEffects.createWithPreprocess
      , e6 = ZodPipeline.create;
    var e4, e8, e7, e9, tn, to, ta, tl = Object.freeze({
      __proto__: null,
      defaultErrorMap: errorMap,
      setErrorMap: function (J) {
        ep = J
      },
      getErrorMap: getErrorMap,
      makeIssue: makeIssue,
      EMPTY_PATH: [],
      addIssueToContext: addIssueToContext,
      ParseStatus: ParseStatus,
      INVALID: ef,
      DIRTY: DIRTY,
      OK: OK,
      isAborted: isAborted,
      isDirty: isDirty,
      isValid: isValid,
      isAsync: isAsync,
      get util() {
        return e9
      },
      get objectUtil() {
        return tn
      },
      ZodParsedType: ed,
      getParsedType: getParsedType,
      ZodType: ZodType,
      ZodString: ZodString,
      ZodNumber: ZodNumber,
      ZodBigInt: ZodBigInt,
      ZodBoolean: ZodBoolean,
      ZodDate: ZodDate,
      ZodSymbol: ZodSymbol,
      ZodUndefined: ZodUndefined,
      ZodNull: ZodNull,
      ZodAny: ZodAny,
      ZodUnknown: ZodUnknown,
      ZodNever: ZodNever,
      ZodVoid: ZodVoid,
      ZodArray: ZodArray,
      ZodObject: ZodObject,
      ZodUnion: ZodUnion,
      ZodDiscriminatedUnion: ZodDiscriminatedUnion,
      ZodIntersection: ZodIntersection,
      ZodTuple: ZodTuple,
      ZodRecord: ZodRecord,
      ZodMap: ZodMap,
      ZodSet: ZodSet,
      ZodFunction: ZodFunction,
      ZodLazy: ZodLazy,
      ZodLiteral: ZodLiteral,
      ZodEnum: ZodEnum,
      ZodNativeEnum: ZodNativeEnum,
      ZodPromise: ZodPromise,
      ZodEffects: ZodEffects,
      ZodTransformer: ZodEffects,
      ZodOptional: ZodOptional,
      ZodNullable: ZodNullable,
      ZodDefault: ZodDefault,
      ZodCatch: ZodCatch,
      ZodNaN: ZodNaN,
      BRAND: eE,
      ZodBranded: ZodBranded,
      ZodPipeline: ZodPipeline,
      ZodReadonly: ZodReadonly,
      custom: custom,
      Schema: ZodType,
      ZodSchema: ZodType,
      late: eC,
      get ZodFirstPartyTypeKind() {
        return ta
      },
      coerce: {
        string: J => ZodString.create({
          ...J,
          coerce: !0
        }),
        number: J => ZodNumber.create({
          ...J,
          coerce: !0
        }),
        boolean: J => ZodBoolean.create({
          ...J,
          coerce: !0
        }),
        bigint: J => ZodBigInt.create({
          ...J,
          coerce: !0
        }),
        date: J => ZodDate.create({
          ...J,
          coerce: !0
        })
      },
      any: eM,
      array: e$,
      bigint: eA,
      boolean: eP,
      date: eR,
      discriminatedUnion: ez,
      effect: e1,
      enum: eQ,
      function: eY,
      instanceof: (J, et = {
        message: `Input not instance of ${J.name}`
      }) => custom(et => et instanceof J, et),
      intersection: eH,
      lazy: eK,
      literal: eJ,
      map: eZ,
      nan: eT,
      nativeEnum: eX,
      never: ej,
      null: eN,
      nullable: e3,
      number: ek,
      object: eB,
      oboolean: () => eP().optional(),
      onumber: () => ek().optional(),
      optional: e2,
      ostring: () => eS().optional(),
      pipeline: e6,
      preprocess: e5,
      promise: e0,
      record: eW,
      set: eG,
      strictObject: eF,
      string: eS,
      symbol: eI,
      transformer: e1,
      tuple: eV,
      undefined: eO,
      union: eU,
      unknown: eD,
      void: eL,
      NEVER: ef,
      ZodIssueCode: eh,
      quotelessJson: J => {
        let et = JSON.stringify(J, null, 2);
        return et.replace(/"([^"]+)":/g, "$1:")
      }
      ,
      ZodError: ZodError
    });
    let tc = tl.object({
      message: tl.string()
    });
    function zType(J) {
      return tl.literal(ec[J])
    }
    tl.object({
      accessList: tl.array(tl.string()),
      blockHash: tl.string().nullable(),
      blockNumber: tl.string().nullable(),
      chainId: tl.string(),
      from: tl.string(),
      gas: tl.string(),
      hash: tl.string(),
      input: tl.string().nullable(),
      maxFeePerGas: tl.string(),
      maxPriorityFeePerGas: tl.string(),
      nonce: tl.string(),
      r: tl.string(),
      s: tl.string(),
      to: tl.string(),
      transactionIndex: tl.string().nullable(),
      type: tl.string(),
      v: tl.string(),
      value: tl.string()
    });
    let td = tl.object({
      chainId: tl.number()
    })
      , th = tl.object({
        email: tl.string().email()
      })
      , tp = tl.object({
        otp: tl.string()
      })
      , tf = tl.object({
        chainId: tl.optional(tl.number())
      })
      , tm = tl.object({
        email: tl.string().email()
      })
      , tg = tl.object({
        otp: tl.string()
      })
      , ty = tl.object({
        otp: tl.string()
      })
      , tb = tl.object({
        themeMode: tl.optional(tl.enum(["light", "dark"])),
        themeVariables: tl.optional(tl.record(tl.string(), tl.string().or(tl.number())))
      })
      , tw = tl.object({
        metadata: tl.object({
          name: tl.string(),
          description: tl.string(),
          url: tl.string(),
          icons: tl.array(tl.string())
        }).optional(),
        sdkVersion: tl.string(),
        projectId: tl.string()
      })
      , t_ = tl.object({
        action: tl.enum(["VERIFY_DEVICE", "VERIFY_OTP"])
      })
      , tx = tl.object({
        email: tl.string().email(),
        address: tl.string(),
        chainId: tl.number()
      })
      , tE = tl.object({
        isConnected: tl.boolean()
      })
      , tC = tl.object({
        chainId: tl.number()
      })
      , tS = tl.object({
        chainId: tl.number()
      })
      , tk = tl.object({
        newEmail: tl.string().email()
      })
      , tT = tl.any()
      , tA = tl.object({
        method: tl.literal("personal_sign"),
        params: tl.array(tl.any())
      })
      , tP = tl.object({
        method: tl.literal("eth_sendTransaction"),
        params: tl.array(tl.any())
      })
      , tR = tl.object({
        method: tl.literal("eth_accounts")
      })
      , tI = tl.object({
        method: tl.literal("eth_getBalance"),
        params: tl.array(tl.any())
      })
      , tO = tl.object({
        method: tl.literal("eth_estimateGas"),
        params: tl.array(tl.any())
      })
      , tN = tl.object({
        method: tl.literal("eth_gasPrice")
      })
      , tM = tl.object({
        method: tl.literal("eth_signTypedData_v4"),
        params: tl.array(tl.any())
      })
      , tD = tl.object({
        method: tl.literal("eth_getTransactionByHash"),
        params: tl.array(tl.any())
      })
      , tj = tl.object({
        method: tl.literal("eth_blockNumber")
      })
      , tL = tl.object({
        method: tl.literal("eth_chainId")
      })
      , t$ = tl.object({
        token: tl.string()
      })
      , tB = {
        appEvent: tl.object({
          type: zType("APP_SWITCH_NETWORK"),
          payload: td
        }).or(tl.object({
          type: zType("APP_CONNECT_EMAIL"),
          payload: th
        })).or(tl.object({
          type: zType("APP_CONNECT_DEVICE")
        })).or(tl.object({
          type: zType("APP_CONNECT_OTP"),
          payload: tp
        })).or(tl.object({
          type: zType("APP_GET_USER"),
          payload: tl.optional(tf)
        })).or(tl.object({
          type: zType("APP_SIGN_OUT")
        })).or(tl.object({
          type: zType("APP_IS_CONNECTED"),
          payload: tl.optional(t$)
        })).or(tl.object({
          type: zType("APP_GET_CHAIN_ID")
        })).or(tl.object({
          type: zType("APP_RPC_REQUEST"),
          payload: tA.or(tP).or(tR).or(tI).or(tO).or(tN).or(tM).or(tj).or(tL).or(tD)
        })).or(tl.object({
          type: zType("APP_UPDATE_EMAIL"),
          payload: tm
        })).or(tl.object({
          type: zType("APP_UPDATE_EMAIL_PRIMARY_OTP"),
          payload: tg
        })).or(tl.object({
          type: zType("APP_UPDATE_EMAIL_SECONDARY_OTP"),
          payload: ty
        })).or(tl.object({
          type: zType("APP_SYNC_THEME"),
          payload: tb
        })).or(tl.object({
          type: zType("APP_SYNC_DAPP_DATA"),
          payload: tw
        })),
        frameEvent: tl.object({
          type: zType("FRAME_SWITCH_NETWORK_ERROR"),
          payload: tc
        }).or(tl.object({
          type: zType("FRAME_SWITCH_NETWORK_SUCCESS"),
          payload: tS
        })).or(tl.object({
          type: zType("FRAME_CONNECT_EMAIL_ERROR"),
          payload: tc
        })).or(tl.object({
          type: zType("FRAME_CONNECT_EMAIL_SUCCESS"),
          payload: t_
        })).or(tl.object({
          type: zType("FRAME_CONNECT_OTP_ERROR"),
          payload: tc
        })).or(tl.object({
          type: zType("FRAME_CONNECT_OTP_SUCCESS")
        })).or(tl.object({
          type: zType("FRAME_CONNECT_DEVICE_ERROR"),
          payload: tc
        })).or(tl.object({
          type: zType("FRAME_CONNECT_DEVICE_SUCCESS")
        })).or(tl.object({
          type: zType("FRAME_GET_USER_ERROR"),
          payload: tc
        })).or(tl.object({
          type: zType("FRAME_GET_USER_SUCCESS"),
          payload: tx
        })).or(tl.object({
          type: zType("FRAME_SIGN_OUT_ERROR"),
          payload: tc
        })).or(tl.object({
          type: zType("FRAME_SIGN_OUT_SUCCESS")
        })).or(tl.object({
          type: zType("FRAME_IS_CONNECTED_ERROR"),
          payload: tc
        })).or(tl.object({
          type: zType("FRAME_IS_CONNECTED_SUCCESS"),
          payload: tE
        })).or(tl.object({
          type: zType("FRAME_GET_CHAIN_ID_ERROR"),
          payload: tc
        })).or(tl.object({
          type: zType("FRAME_GET_CHAIN_ID_SUCCESS"),
          payload: tC
        })).or(tl.object({
          type: zType("FRAME_RPC_REQUEST_ERROR"),
          payload: tc
        })).or(tl.object({
          type: zType("FRAME_RPC_REQUEST_SUCCESS"),
          payload: tT
        })).or(tl.object({
          type: zType("FRAME_SESSION_UPDATE"),
          payload: t$
        })).or(tl.object({
          type: zType("FRAME_UPDATE_EMAIL_ERROR"),
          payload: tc
        })).or(tl.object({
          type: zType("FRAME_UPDATE_EMAIL_SUCCESS")
        })).or(tl.object({
          type: zType("FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR"),
          payload: tc
        })).or(tl.object({
          type: zType("FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS")
        })).or(tl.object({
          type: zType("FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR"),
          payload: tc
        })).or(tl.object({
          type: zType("FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS"),
          payload: tk
        })).or(tl.object({
          type: zType("FRAME_SYNC_THEME_ERROR"),
          payload: tc
        })).or(tl.object({
          type: zType("FRAME_SYNC_THEME_SUCCESS")
        })).or(tl.object({
          type: zType("FRAME_SYNC_DAPP_DATA_ERROR"),
          payload: tc
        })).or(tl.object({
          type: zType("FRAME_SYNC_DAPP_DATA_SUCCESS")
        }))
      }
      , tF = {
        set(J, et) {
          localStorage.setItem(`${ec.STORAGE_KEY}${J}`, et)
        },
        get: J => localStorage.getItem(`${ec.STORAGE_KEY}${J}`),
        delete(J) {
          localStorage.removeItem(`${ec.STORAGE_KEY}${J}`)
        }
      }
      , tU = ["ASIA/SHANGHAI", "ASIA/URUMQI", "ASIA/CHONGQING", "ASIA/HARBIN", "ASIA/KASHGAR", "ASIA/MACAU", "ASIA/HONG_KONG", "ASIA/MACAO", "ASIA/BEIJING", "ASIA/HARBIN"]
      , tz = {
        getBlockchainApiUrl() {
          try {
            let { timeZone: J } = new Intl.DateTimeFormat().resolvedOptions()
              , et = J.toUpperCase();
            return tU.includes(et) ? "https://rpc.walletconnect.org" : "https://rpc.walletconnect.com"
          } catch {
            return !1
          }
        },
        checkIfAllowedToTriggerEmail() {
          let J = tF.get(ec.LAST_EMAIL_LOGIN_TIME);
          if (J) {
            let et = Date.now() - Number(J);
            if (et < 3e4) {
              let J = Math.ceil((3e4 - et) / 1e3);
              throw Error(`Please try again after ${J} seconds`)
            }
          }
        },
        getTimeToNextEmailLogin() {
          let J = tF.get(ec.LAST_EMAIL_LOGIN_TIME);
          if (J) {
            let et = Date.now() - Number(J);
            if (et < 3e4)
              return Math.ceil((3e4 - et) / 1e3)
          }
          return 0
        }
      };
    let W3mFrame = class W3mFrame {
      constructor(J, et = !1) {
        if (this.iframe = null,
          this.rpcUrl = tz.getBlockchainApiUrl(),
          this.events = {
            onFrameEvent: J => {
              window.addEventListener("message", ({ data: et }) => {
                if (!et.type?.includes(ec.FRAME_EVENT_KEY))
                  return;
                let eo = tB.frameEvent.parse(et);
                J(eo)
              }
              )
            }
            ,
            onAppEvent: J => {
              window.addEventListener("message", ({ data: et }) => {
                if (!et.type?.includes(ec.APP_EVENT_KEY))
                  return;
                let eo = tB.appEvent.parse(et);
                J(eo)
              }
              )
            }
            ,
            postAppEvent: J => {
              if (!this.iframe?.contentWindow)
                throw Error("W3mFrame: iframe is not set");
              tB.appEvent.parse(J),
                window.postMessage(J),
                this.iframe.contentWindow.postMessage(J, "*")
            }
            ,
            postFrameEvent: J => {
              if (!parent)
                throw Error("W3mFrame: parent is not set");
              tB.frameEvent.parse(J),
                parent.postMessage(J, "*")
            }
          },
          this.projectId = J,
          this.frameLoadPromise = new Promise((J, et) => {
            this.frameLoadPromiseResolver = {
              resolve: J,
              reject: et
            }
          }
          ),
          et) {
          this.frameLoadPromise = new Promise((J, et) => {
            this.frameLoadPromiseResolver = {
              resolve: J,
              reject: et
            }
          }
          );
          let et = document.createElement("iframe");
          et.id = "w3m-iframe",
            et.src = `${ec.SECURE_SITE_SDK}?projectId=${J}`,
            et.style.position = "fixed",
            et.style.zIndex = "999999",
            et.style.display = "none",
            et.style.opacity = "0",
            et.style.borderRadius = "clamp(0px, var(--wui-border-radius-l), 44px)",
            document.body.appendChild(et),
            this.iframe = et,
            this.iframe.onload = () => {
              this.frameLoadPromiseResolver?.resolve(void 0)
            }
            ,
            this.iframe.onerror = () => {
              this.frameLoadPromiseResolver?.reject("Unable to load email login dependency")
            }
        }
      }
      get networks() {
        let J = [1, 5, 11155111, 10, 420, 42161, 421613, 137, 80001, 42220, 1313161554, 1313161555, 56, 97, 43114, 43113, 324, 280, 100, 8453, 84531, 7777777, 999].map(J => ({
          [J]: {
            rpcUrl: `${this.rpcUrl}/v1/?chainId=eip155:${J}&projectId=${this.projectId}`,
            chainId: J
          }
        }));
        return Object.assign({}, ...J)
      }
    }
      ;
    let W3mFrameProvider = class W3mFrameProvider {
      constructor(J) {
        this.connectEmailResolver = void 0,
          this.connectDeviceResolver = void 0,
          this.connectOtpResolver = void 0,
          this.connectResolver = void 0,
          this.disconnectResolver = void 0,
          this.isConnectedResolver = void 0,
          this.getChainIdResolver = void 0,
          this.switchChainResolver = void 0,
          this.rpcRequestResolver = void 0,
          this.updateEmailResolver = void 0,
          this.updateEmailPrimaryOtpResolver = void 0,
          this.updateEmailSecondaryOtpResolver = void 0,
          this.syncThemeResolver = void 0,
          this.syncDappDataResolver = void 0,
          this.w3mFrame = new W3mFrame(J, !0),
          this.w3mFrame.events.onFrameEvent(J => {
            switch (console.log("\uD83D\uDCBB received", J),
            J.type) {
              case ec.FRAME_CONNECT_EMAIL_SUCCESS:
                return this.onConnectEmailSuccess(J);
              case ec.FRAME_CONNECT_EMAIL_ERROR:
                return this.onConnectEmailError(J);
              case ec.FRAME_CONNECT_DEVICE_SUCCESS:
                return this.onConnectDeviceSuccess();
              case ec.FRAME_CONNECT_DEVICE_ERROR:
                return this.onConnectDeviceError(J);
              case ec.FRAME_CONNECT_OTP_SUCCESS:
                return this.onConnectOtpSuccess();
              case ec.FRAME_CONNECT_OTP_ERROR:
                return this.onConnectOtpError(J);
              case ec.FRAME_GET_USER_SUCCESS:
                return this.onConnectSuccess(J);
              case ec.FRAME_GET_USER_ERROR:
                return this.onConnectError(J);
              case ec.FRAME_IS_CONNECTED_SUCCESS:
                return this.onIsConnectedSuccess(J);
              case ec.FRAME_IS_CONNECTED_ERROR:
                return this.onIsConnectedError(J);
              case ec.FRAME_GET_CHAIN_ID_SUCCESS:
                return this.onGetChainIdSuccess(J);
              case ec.FRAME_GET_CHAIN_ID_ERROR:
                return this.onGetChainIdError(J);
              case ec.FRAME_SIGN_OUT_SUCCESS:
                return this.onSignOutSuccess();
              case ec.FRAME_SIGN_OUT_ERROR:
                return this.onSignOutError(J);
              case ec.FRAME_SWITCH_NETWORK_SUCCESS:
                return this.onSwitchChainSuccess(J);
              case ec.FRAME_SWITCH_NETWORK_ERROR:
                return this.onSwitchChainError(J);
              case ec.FRAME_RPC_REQUEST_SUCCESS:
                return this.onRpcRequestSuccess(J);
              case ec.FRAME_RPC_REQUEST_ERROR:
                return this.onRpcRequestError(J);
              case ec.FRAME_SESSION_UPDATE:
                return this.onSessionUpdate(J);
              case ec.FRAME_UPDATE_EMAIL_SUCCESS:
                return this.onUpdateEmailSuccess();
              case ec.FRAME_UPDATE_EMAIL_ERROR:
                return this.onUpdateEmailError(J);
              case ec.FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS:
                return this.onUpdateEmailPrimaryOtpSuccess();
              case ec.FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR:
                return this.onUpdateEmailPrimaryOtpError(J);
              case ec.FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS:
                return this.onUpdateEmailSecondaryOtpSuccess(J);
              case ec.FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR:
                return this.onUpdateEmailSecondaryOtpError(J);
              case ec.FRAME_SYNC_THEME_SUCCESS:
                return this.onSyncThemeSuccess();
              case ec.FRAME_SYNC_THEME_ERROR:
                return this.onSyncThemeError(J);
              case ec.FRAME_SYNC_DAPP_DATA_SUCCESS:
                return this.onSyncDappDataSuccess();
              case ec.FRAME_SYNC_DAPP_DATA_ERROR:
                return this.onSyncDappDataError(J);
              default:
                return null
            }
          }
          )
      }
      getLoginEmailUsed() {
        return !!tF.get(ec.EMAIL_LOGIN_USED_KEY)
      }
      getEmail() {
        return tF.get(ec.EMAIL)
      }
      async connectEmail(J) {
        return await this.w3mFrame.frameLoadPromise,
          tz.checkIfAllowedToTriggerEmail(),
          this.w3mFrame.events.postAppEvent({
            type: ec.APP_CONNECT_EMAIL,
            payload: J
          }),
          new Promise((J, et) => {
            this.connectEmailResolver = {
              resolve: J,
              reject: et
            }
          }
          )
      }
      async connectDevice() {
        return await this.w3mFrame.frameLoadPromise,
          this.w3mFrame.events.postAppEvent({
            type: ec.APP_CONNECT_DEVICE
          }),
          new Promise((J, et) => {
            this.connectDeviceResolver = {
              resolve: J,
              reject: et
            }
          }
          )
      }
      async connectOtp(J) {
        return await this.w3mFrame.frameLoadPromise,
          this.w3mFrame.events.postAppEvent({
            type: ec.APP_CONNECT_OTP,
            payload: J
          }),
          new Promise((J, et) => {
            this.connectOtpResolver = {
              resolve: J,
              reject: et
            }
          }
          )
      }
      async isConnected() {
        return await this.w3mFrame.frameLoadPromise,
          this.w3mFrame.events.postAppEvent({
            type: ec.APP_IS_CONNECTED,
            payload: void 0
          }),
          new Promise((J, et) => {
            this.isConnectedResolver = {
              resolve: J,
              reject: et
            }
          }
          )
      }
      async getChainId() {
        return await this.w3mFrame.frameLoadPromise,
          this.w3mFrame.events.postAppEvent({
            type: ec.APP_GET_CHAIN_ID
          }),
          new Promise((J, et) => {
            this.getChainIdResolver = {
              resolve: J,
              reject: et
            }
          }
          )
      }
      async updateEmail(J) {
        return await this.w3mFrame.frameLoadPromise,
          tz.checkIfAllowedToTriggerEmail(),
          this.w3mFrame.events.postAppEvent({
            type: ec.APP_UPDATE_EMAIL,
            payload: J
          }),
          new Promise((J, et) => {
            this.updateEmailResolver = {
              resolve: J,
              reject: et
            }
          }
          )
      }
      async updateEmailPrimaryOtp(J) {
        return await this.w3mFrame.frameLoadPromise,
          this.w3mFrame.events.postAppEvent({
            type: ec.APP_UPDATE_EMAIL_PRIMARY_OTP,
            payload: J
          }),
          new Promise((J, et) => {
            this.updateEmailPrimaryOtpResolver = {
              resolve: J,
              reject: et
            }
          }
          )
      }
      async updateEmailSecondaryOtp(J) {
        return await this.w3mFrame.frameLoadPromise,
          this.w3mFrame.events.postAppEvent({
            type: ec.APP_UPDATE_EMAIL_SECONDARY_OTP,
            payload: J
          }),
          new Promise((J, et) => {
            this.updateEmailSecondaryOtpResolver = {
              resolve: J,
              reject: et
            }
          }
          )
      }
      async syncTheme(J) {
        return await this.w3mFrame.frameLoadPromise,
          this.w3mFrame.events.postAppEvent({
            type: ec.APP_SYNC_THEME,
            payload: J
          }),
          new Promise((J, et) => {
            this.syncThemeResolver = {
              resolve: J,
              reject: et
            }
          }
          )
      }
      async syncDappData(J) {
        return await this.w3mFrame.frameLoadPromise,
          this.w3mFrame.events.postAppEvent({
            type: ec.APP_SYNC_DAPP_DATA,
            payload: J
          }),
          new Promise((J, et) => {
            this.syncDappDataResolver = {
              resolve: J,
              reject: et
            }
          }
          )
      }
      async connect(J) {
        let et = J?.chainId ?? this.getLastUsedChainId() ?? 1;
        return await this.w3mFrame.frameLoadPromise,
          this.w3mFrame.events.postAppEvent({
            type: ec.APP_GET_USER,
            payload: {
              chainId: et
            }
          }),
          new Promise((J, et) => {
            this.connectResolver = {
              resolve: J,
              reject: et
            }
          }
          )
      }
      async switchNetwork(J) {
        return await this.w3mFrame.frameLoadPromise,
          this.w3mFrame.events.postAppEvent({
            type: ec.APP_SWITCH_NETWORK,
            payload: {
              chainId: J
            }
          }),
          new Promise((J, et) => {
            this.switchChainResolver = {
              resolve: J,
              reject: et
            }
          }
          )
      }
      async disconnect() {
        return await this.w3mFrame.frameLoadPromise,
          this.w3mFrame.events.postAppEvent({
            type: ec.APP_SIGN_OUT
          }),
          new Promise((J, et) => {
            this.disconnectResolver = {
              resolve: J,
              reject: et
            }
          }
          )
      }
      async request(J) {
        return (await this.w3mFrame.frameLoadPromise,
          "eth_chainId" === J.method) ? this.getLastUsedChainId() : (this.w3mFrame.events.postAppEvent({
            type: ec.APP_RPC_REQUEST,
            payload: J
          }),
            new Promise((J, et) => {
              this.rpcRequestResolver = {
                resolve: J,
                reject: et
              }
            }
            ))
      }
      onRpcRequest(J) {
        this.w3mFrame.events.onAppEvent(et => {
          et.type.includes(ec.RPC_METHOD_KEY) && J(et)
        }
        )
      }
      onRpcResponse(J) {
        this.w3mFrame.events.onFrameEvent(et => {
          et.type.includes(ec.RPC_METHOD_KEY) && J(et)
        }
        )
      }
      onIsConnected(J) {
        this.w3mFrame.events.onFrameEvent(et => {
          et.type === ec.FRAME_GET_USER_SUCCESS && J()
        }
        )
      }
      onConnectEmailSuccess(J) {
        this.connectEmailResolver?.resolve(J.payload),
          this.setNewLastEmailLoginTime()
      }
      onConnectEmailError(J) {
        this.connectEmailResolver?.reject(J.payload.message)
      }
      onConnectDeviceSuccess() {
        this.connectDeviceResolver?.resolve(void 0)
      }
      onConnectDeviceError(J) {
        this.connectDeviceResolver?.reject(J.payload.message)
      }
      onConnectOtpSuccess() {
        this.connectOtpResolver?.resolve(void 0)
      }
      onConnectOtpError(J) {
        this.connectOtpResolver?.reject(J.payload.message)
      }
      onConnectSuccess(J) {
        this.setEmailLoginSuccess(J.payload.email),
          this.setLastUsedChainId(J.payload.chainId),
          this.connectResolver?.resolve(J.payload)
      }
      onConnectError(J) {
        this.connectResolver?.reject(J.payload.message)
      }
      onIsConnectedSuccess(J) {
        J.payload.isConnected || this.deleteEmailLoginCache(),
          this.isConnectedResolver?.resolve(J.payload)
      }
      onIsConnectedError(J) {
        this.isConnectedResolver?.reject(J.payload.message)
      }
      onGetChainIdSuccess(J) {
        this.setLastUsedChainId(J.payload.chainId),
          this.getChainIdResolver?.resolve(J.payload)
      }
      onGetChainIdError(J) {
        this.getChainIdResolver?.reject(J.payload.message)
      }
      onSignOutSuccess() {
        this.disconnectResolver?.resolve(void 0),
          this.deleteEmailLoginCache()
      }
      onSignOutError(J) {
        this.disconnectResolver?.reject(J.payload.message)
      }
      onSwitchChainSuccess(J) {
        this.setLastUsedChainId(J.payload.chainId),
          this.switchChainResolver?.resolve(J.payload)
      }
      onSwitchChainError(J) {
        this.switchChainResolver?.reject(J.payload.message)
      }
      onRpcRequestSuccess(J) {
        this.rpcRequestResolver?.resolve(J.payload)
      }
      onRpcRequestError(J) {
        this.rpcRequestResolver?.reject(J.payload.message)
      }
      onSessionUpdate(J) {
        let { payload: et } = J
      }
      onUpdateEmailSuccess() {
        this.updateEmailResolver?.resolve(void 0),
          this.setNewLastEmailLoginTime()
      }
      onUpdateEmailError(J) {
        this.updateEmailResolver?.reject(J.payload.message)
      }
      onUpdateEmailPrimaryOtpSuccess() {
        this.updateEmailPrimaryOtpResolver?.resolve(void 0)
      }
      onUpdateEmailPrimaryOtpError(J) {
        this.updateEmailPrimaryOtpResolver?.reject(J.payload.message)
      }
      onUpdateEmailSecondaryOtpSuccess(J) {
        let { newEmail: et } = J.payload;
        this.setEmailLoginSuccess(et),
          this.updateEmailSecondaryOtpResolver?.resolve({
            newEmail: et
          })
      }
      onUpdateEmailSecondaryOtpError(J) {
        this.updateEmailSecondaryOtpResolver?.reject(J.payload.message)
      }
      onSyncThemeSuccess() {
        this.syncThemeResolver?.resolve(void 0)
      }
      onSyncThemeError(J) {
        this.syncThemeResolver?.reject(J.payload.message)
      }
      onSyncDappDataSuccess() {
        this.syncDappDataResolver?.resolve(void 0)
      }
      onSyncDappDataError(J) {
        this.syncDappDataResolver?.reject(J.payload.message)
      }
      setNewLastEmailLoginTime() {
        tF.set(ec.LAST_EMAIL_LOGIN_TIME, Date.now().toString())
      }
      setEmailLoginSuccess(J) {
        tF.set(ec.EMAIL, J),
          tF.set(ec.EMAIL_LOGIN_USED_KEY, "true"),
          tF.delete(ec.LAST_EMAIL_LOGIN_TIME)
      }
      deleteEmailLoginCache() {
        tF.delete(ec.EMAIL_LOGIN_USED_KEY),
          tF.delete(ec.EMAIL),
          tF.delete(ec.LAST_USED_CHAIN_KEY)
      }
      setLastUsedChainId(J) {
        tF.set(ec.LAST_USED_CHAIN_KEY, `${J}`)
      }
      getLastUsedChainId() {
        return Number(tF.get(ec.LAST_USED_CHAIN_KEY))
      }
    }
  },
  33649: function (J, et, eo) {
    "use strict";
    eo.r(et),
      eo.d(et, {
        __addDisposableResource: function () {
          return __addDisposableResource
        },
        __assign: function () {
          return __assign
        },
        __asyncDelegator: function () {
          return __asyncDelegator
        },
        __asyncGenerator: function () {
          return __asyncGenerator
        },
        __asyncValues: function () {
          return __asyncValues
        },
        __await: function () {
          return __await
        },
        __awaiter: function () {
          return __awaiter
        },
        __classPrivateFieldGet: function () {
          return __classPrivateFieldGet
        },
        __classPrivateFieldIn: function () {
          return __classPrivateFieldIn
        },
        __classPrivateFieldSet: function () {
          return __classPrivateFieldSet
        },
        __createBinding: function () {
          return el
        },
        __decorate: function () {
          return __decorate
        },
        __disposeResources: function () {
          return __disposeResources
        },
        __esDecorate: function () {
          return __esDecorate
        },
        __exportStar: function () {
          return __exportStar
        },
        __extends: function () {
          return __extends
        },
        __generator: function () {
          return __generator
        },
        __importDefault: function () {
          return __importDefault
        },
        __importStar: function () {
          return __importStar
        },
        __makeTemplateObject: function () {
          return __makeTemplateObject
        },
        __metadata: function () {
          return __metadata
        },
        __param: function () {
          return __param
        },
        __propKey: function () {
          return __propKey
        },
        __read: function () {
          return __read
        },
        __rest: function () {
          return __rest
        },
        __runInitializers: function () {
          return __runInitializers
        },
        __setFunctionName: function () {
          return __setFunctionName
        },
        __spread: function () {
          return __spread
        },
        __spreadArray: function () {
          return __spreadArray
        },
        __spreadArrays: function () {
          return __spreadArrays
        },
        __values: function () {
          return __values
        }
      });
    var extendStatics = function (J, et) {
      return (extendStatics = Object.setPrototypeOf || ({
        __proto__: []
      }) instanceof Array && function (J, et) {
        J.__proto__ = et
      }
        || function (J, et) {
          for (var eo in et)
            Object.prototype.hasOwnProperty.call(et, eo) && (J[eo] = et[eo])
        }
      )(J, et)
    };
    function __extends(J, et) {
      if ("function" != typeof et && null !== et)
        throw TypeError("Class extends value " + String(et) + " is not a constructor or null");
      function __() {
        this.constructor = J
      }
      extendStatics(J, et),
        J.prototype = null === et ? Object.create(et) : (__.prototype = et.prototype,
          new __)
    }
    var __assign = function () {
      return (__assign = Object.assign || function (J) {
        for (var et, eo = 1, el = arguments.length; eo < el; eo++)
          for (var ec in et = arguments[eo])
            Object.prototype.hasOwnProperty.call(et, ec) && (J[ec] = et[ec]);
        return J
      }
      ).apply(this, arguments)
    };
    function __rest(J, et) {
      var eo = {};
      for (var el in J)
        Object.prototype.hasOwnProperty.call(J, el) && 0 > et.indexOf(el) && (eo[el] = J[el]);
      if (null != J && "function" == typeof Object.getOwnPropertySymbols)
        for (var ec = 0, el = Object.getOwnPropertySymbols(J); ec < el.length; ec++)
          0 > et.indexOf(el[ec]) && Object.prototype.propertyIsEnumerable.call(J, el[ec]) && (eo[el[ec]] = J[el[ec]]);
      return eo
    }
    function __decorate(J, et, eo, el) {
      var ec, ed = arguments.length, eh = ed < 3 ? et : null === el ? el = Object.getOwnPropertyDescriptor(et, eo) : el;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        eh = Reflect.decorate(J, et, eo, el);
      else
        for (var ep = J.length - 1; ep >= 0; ep--)
          (ec = J[ep]) && (eh = (ed < 3 ? ec(eh) : ed > 3 ? ec(et, eo, eh) : ec(et, eo)) || eh);
      return ed > 3 && eh && Object.defineProperty(et, eo, eh),
        eh
    }
    function __param(J, et) {
      return function (eo, el) {
        et(eo, el, J)
      }
    }
    function __esDecorate(J, et, eo, el, ec, ed) {
      function accept(J) {
        if (void 0 !== J && "function" != typeof J)
          throw TypeError("Function expected");
        return J
      }
      for (var eh, ep = el.kind, ef = "getter" === ep ? "get" : "setter" === ep ? "set" : "value", em = !et && J ? el.static ? J : J.prototype : null, eg = et || (em ? Object.getOwnPropertyDescriptor(em, el.name) : {}), ey = !1, eb = eo.length - 1; eb >= 0; eb--) {
        var ew = {};
        for (var e_ in el)
          ew[e_] = "access" === e_ ? {} : el[e_];
        for (var e_ in el.access)
          ew.access[e_] = el.access[e_];
        ew.addInitializer = function (J) {
          if (ey)
            throw TypeError("Cannot add initializers after decoration has completed");
          ed.push(accept(J || null))
        }
          ;
        var ex = (0,
          eo[eb])("accessor" === ep ? {
            get: eg.get,
            set: eg.set
          } : eg[ef], ew);
        if ("accessor" === ep) {
          if (void 0 === ex)
            continue;
          if (null === ex || "object" != typeof ex)
            throw TypeError("Object expected");
          (eh = accept(ex.get)) && (eg.get = eh),
            (eh = accept(ex.set)) && (eg.set = eh),
            (eh = accept(ex.init)) && ec.unshift(eh)
        } else
          (eh = accept(ex)) && ("field" === ep ? ec.unshift(eh) : eg[ef] = eh)
      }
      em && Object.defineProperty(em, el.name, eg),
        ey = !0
    }
    function __runInitializers(J, et, eo) {
      for (var el = arguments.length > 2, ec = 0; ec < et.length; ec++)
        eo = el ? et[ec].call(J, eo) : et[ec].call(J);
      return el ? eo : void 0
    }
    function __propKey(J) {
      return "symbol" == typeof J ? J : "".concat(J)
    }
    function __setFunctionName(J, et, eo) {
      return "symbol" == typeof et && (et = et.description ? "[".concat(et.description, "]") : ""),
        Object.defineProperty(J, "name", {
          configurable: !0,
          value: eo ? "".concat(eo, " ", et) : et
        })
    }
    function __metadata(J, et) {
      if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
        return Reflect.metadata(J, et)
    }
    function __awaiter(J, et, eo, el) {
      return new (eo || (eo = Promise))(function (ec, ed) {
        function fulfilled(J) {
          try {
            step(el.next(J))
          } catch (J) {
            ed(J)
          }
        }
        function rejected(J) {
          try {
            step(el.throw(J))
          } catch (J) {
            ed(J)
          }
        }
        function step(J) {
          var et;
          J.done ? ec(J.value) : ((et = J.value) instanceof eo ? et : new eo(function (J) {
            J(et)
          }
          )).then(fulfilled, rejected)
        }
        step((el = el.apply(J, et || [])).next())
      }
      )
    }
    function __generator(J, et) {
      var eo, el, ec, ed, eh = {
        label: 0,
        sent: function () {
          if (1 & ec[0])
            throw ec[1];
          return ec[1]
        },
        trys: [],
        ops: []
      };
      return ed = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      },
        "function" == typeof Symbol && (ed[Symbol.iterator] = function () {
          return this
        }
        ),
        ed;
      function verb(ep) {
        return function (ef) {
          return function (ep) {
            if (eo)
              throw TypeError("Generator is already executing.");
            for (; ed && (ed = 0,
              ep[0] && (eh = 0)),
              eh;)
              try {
                if (eo = 1,
                  el && (ec = 2 & ep[0] ? el.return : ep[0] ? el.throw || ((ec = el.return) && ec.call(el),
                    0) : el.next) && !(ec = ec.call(el, ep[1])).done)
                  return ec;
                switch (el = 0,
                ec && (ep = [2 & ep[0], ec.value]),
                ep[0]) {
                  case 0:
                  case 1:
                    ec = ep;
                    break;
                  case 4:
                    return eh.label++,
                    {
                      value: ep[1],
                      done: !1
                    };
                  case 5:
                    eh.label++,
                      el = ep[1],
                      ep = [0];
                    continue;
                  case 7:
                    ep = eh.ops.pop(),
                      eh.trys.pop();
                    continue;
                  default:
                    if (!(ec = (ec = eh.trys).length > 0 && ec[ec.length - 1]) && (6 === ep[0] || 2 === ep[0])) {
                      eh = 0;
                      continue
                    }
                    if (3 === ep[0] && (!ec || ep[1] > ec[0] && ep[1] < ec[3])) {
                      eh.label = ep[1];
                      break
                    }
                    if (6 === ep[0] && eh.label < ec[1]) {
                      eh.label = ec[1],
                        ec = ep;
                      break
                    }
                    if (ec && eh.label < ec[2]) {
                      eh.label = ec[2],
                        eh.ops.push(ep);
                      break
                    }
                    ec[2] && eh.ops.pop(),
                      eh.trys.pop();
                    continue
                }
                ep = et.call(J, eh)
              } catch (J) {
                ep = [6, J],
                  el = 0
              } finally {
                eo = ec = 0
              }
            if (5 & ep[0])
              throw ep[1];
            return {
              value: ep[0] ? ep[1] : void 0,
              done: !0
            }
          }([ep, ef])
        }
      }
    }
    var el = Object.create ? function (J, et, eo, el) {
      void 0 === el && (el = eo);
      var ec = Object.getOwnPropertyDescriptor(et, eo);
      (!ec || ("get" in ec ? !et.__esModule : ec.writable || ec.configurable)) && (ec = {
        enumerable: !0,
        get: function () {
          return et[eo]
        }
      }),
        Object.defineProperty(J, el, ec)
    }
      : function (J, et, eo, el) {
        void 0 === el && (el = eo),
          J[el] = et[eo]
      }
      ;
    function __exportStar(J, et) {
      for (var eo in J)
        "default" === eo || Object.prototype.hasOwnProperty.call(et, eo) || el(et, J, eo)
    }
    function __values(J) {
      var et = "function" == typeof Symbol && Symbol.iterator
        , eo = et && J[et]
        , el = 0;
      if (eo)
        return eo.call(J);
      if (J && "number" == typeof J.length)
        return {
          next: function () {
            return J && el >= J.length && (J = void 0),
            {
              value: J && J[el++],
              done: !J
            }
          }
        };
      throw TypeError(et ? "Object is not iterable." : "Symbol.iterator is not defined.")
    }
    function __read(J, et) {
      var eo = "function" == typeof Symbol && J[Symbol.iterator];
      if (!eo)
        return J;
      var el, ec, ed = eo.call(J), eh = [];
      try {
        for (; (void 0 === et || et-- > 0) && !(el = ed.next()).done;)
          eh.push(el.value)
      } catch (J) {
        ec = {
          error: J
        }
      } finally {
        try {
          el && !el.done && (eo = ed.return) && eo.call(ed)
        } finally {
          if (ec)
            throw ec.error
        }
      }
      return eh
    }
    function __spread() {
      for (var J = [], et = 0; et < arguments.length; et++)
        J = J.concat(__read(arguments[et]));
      return J
    }
    function __spreadArrays() {
      for (var J = 0, et = 0, eo = arguments.length; et < eo; et++)
        J += arguments[et].length;
      for (var el = Array(J), ec = 0, et = 0; et < eo; et++)
        for (var ed = arguments[et], eh = 0, ep = ed.length; eh < ep; eh++,
          ec++)
          el[ec] = ed[eh];
      return el
    }
    function __spreadArray(J, et, eo) {
      if (eo || 2 == arguments.length)
        for (var el, ec = 0, ed = et.length; ec < ed; ec++)
          !el && ec in et || (el || (el = Array.prototype.slice.call(et, 0, ec)),
            el[ec] = et[ec]);
      return J.concat(el || Array.prototype.slice.call(et))
    }
    function __await(J) {
      return this instanceof __await ? (this.v = J,
        this) : new __await(J)
    }
    function __asyncGenerator(J, et, eo) {
      if (!Symbol.asyncIterator)
        throw TypeError("Symbol.asyncIterator is not defined.");
      var el, ec = eo.apply(J, et || []), ed = [];
      return el = {},
        verb("next"),
        verb("throw"),
        verb("return"),
        el[Symbol.asyncIterator] = function () {
          return this
        }
        ,
        el;
      function verb(J) {
        ec[J] && (el[J] = function (et) {
          return new Promise(function (eo, el) {
            ed.push([J, et, eo, el]) > 1 || resume(J, et)
          }
          )
        }
        )
      }
      function resume(J, et) {
        try {
          var eo;
          (eo = ec[J](et)).value instanceof __await ? Promise.resolve(eo.value.v).then(fulfill, reject) : settle(ed[0][2], eo)
        } catch (J) {
          settle(ed[0][3], J)
        }
      }
      function fulfill(J) {
        resume("next", J)
      }
      function reject(J) {
        resume("throw", J)
      }
      function settle(J, et) {
        J(et),
          ed.shift(),
          ed.length && resume(ed[0][0], ed[0][1])
      }
    }
    function __asyncDelegator(J) {
      var et, eo;
      return et = {},
        verb("next"),
        verb("throw", function (J) {
          throw J
        }),
        verb("return"),
        et[Symbol.iterator] = function () {
          return this
        }
        ,
        et;
      function verb(el, ec) {
        et[el] = J[el] ? function (et) {
          return (eo = !eo) ? {
            value: __await(J[el](et)),
            done: !1
          } : ec ? ec(et) : et
        }
          : ec
      }
    }
    function __asyncValues(J) {
      if (!Symbol.asyncIterator)
        throw TypeError("Symbol.asyncIterator is not defined.");
      var et, eo = J[Symbol.asyncIterator];
      return eo ? eo.call(J) : (J = __values(J),
        et = {},
        verb("next"),
        verb("throw"),
        verb("return"),
        et[Symbol.asyncIterator] = function () {
          return this
        }
        ,
        et);
      function verb(eo) {
        et[eo] = J[eo] && function (et) {
          return new Promise(function (el, ec) {
            !function (J, et, eo, el) {
              Promise.resolve(el).then(function (et) {
                J({
                  value: et,
                  done: eo
                })
              }, et)
            }(el, ec, (et = J[eo](et)).done, et.value)
          }
          )
        }
      }
    }
    function __makeTemplateObject(J, et) {
      return Object.defineProperty ? Object.defineProperty(J, "raw", {
        value: et
      }) : J.raw = et,
        J
    }
    var ec = Object.create ? function (J, et) {
      Object.defineProperty(J, "default", {
        enumerable: !0,
        value: et
      })
    }
      : function (J, et) {
        J.default = et
      }
      ;
    function __importStar(J) {
      if (J && J.__esModule)
        return J;
      var et = {};
      if (null != J)
        for (var eo in J)
          "default" !== eo && Object.prototype.hasOwnProperty.call(J, eo) && el(et, J, eo);
      return ec(et, J),
        et
    }
    function __importDefault(J) {
      return J && J.__esModule ? J : {
        default: J
      }
    }
    function __classPrivateFieldGet(J, et, eo, el) {
      if ("a" === eo && !el)
        throw TypeError("Private accessor was defined without a getter");
      if ("function" == typeof et ? J !== et || !el : !et.has(J))
        throw TypeError("Cannot read private member from an object whose class did not declare it");
      return "m" === eo ? el : "a" === eo ? el.call(J) : el ? el.value : et.get(J)
    }
    function __classPrivateFieldSet(J, et, eo, el, ec) {
      if ("m" === el)
        throw TypeError("Private method is not writable");
      if ("a" === el && !ec)
        throw TypeError("Private accessor was defined without a setter");
      if ("function" == typeof et ? J !== et || !ec : !et.has(J))
        throw TypeError("Cannot write private member to an object whose class did not declare it");
      return "a" === el ? ec.call(J, eo) : ec ? ec.value = eo : et.set(J, eo),
        eo
    }
    function __classPrivateFieldIn(J, et) {
      if (null === et || "object" != typeof et && "function" != typeof et)
        throw TypeError("Cannot use 'in' operator on non-object");
      return "function" == typeof J ? et === J : J.has(et)
    }
    function __addDisposableResource(J, et, eo) {
      if (null != et) {
        var el;
        if ("object" != typeof et && "function" != typeof et)
          throw TypeError("Object expected.");
        if (eo) {
          if (!Symbol.asyncDispose)
            throw TypeError("Symbol.asyncDispose is not defined.");
          el = et[Symbol.asyncDispose]
        }
        if (void 0 === el) {
          if (!Symbol.dispose)
            throw TypeError("Symbol.dispose is not defined.");
          el = et[Symbol.dispose]
        }
        if ("function" != typeof el)
          throw TypeError("Object not disposable.");
        J.stack.push({
          value: et,
          dispose: el,
          async: eo
        })
      } else
        eo && J.stack.push({
          async: !0
        });
      return et
    }
    var ed = "function" == typeof SuppressedError ? SuppressedError : function (J, et, eo) {
      var el = Error(eo);
      return el.name = "SuppressedError",
        el.error = J,
        el.suppressed = et,
        el
    }
      ;
    function __disposeResources(J) {
      function fail(et) {
        J.error = J.hasError ? new ed(et, J.error, "An error was suppressed during disposal.") : et,
          J.hasError = !0
      }
      return function next() {
        for (; J.stack.length;) {
          var et = J.stack.pop();
          try {
            var eo = et.dispose && et.dispose.call(et.value);
            if (et.async)
              return Promise.resolve(eo).then(next, function (J) {
                return fail(J),
                  next()
              })
          } catch (J) {
            fail(J)
          }
        }
        if (J.hasError)
          throw J.error
      }()
    }
    et.default = {
      __extends,
      __assign,
      __rest,
      __decorate,
      __param,
      __metadata,
      __awaiter,
      __generator,
      __createBinding: el,
      __exportStar,
      __values,
      __read,
      __spread,
      __spreadArrays,
      __spreadArray,
      __await,
      __asyncGenerator,
      __asyncDelegator,
      __asyncValues,
      __makeTemplateObject,
      __importStar,
      __importDefault,
      __classPrivateFieldGet,
      __classPrivateFieldSet,
      __classPrivateFieldIn,
      __addDisposableResource,
      __disposeResources
    }
  },
  96110: function (J, et, eo) {
    "use strict";
    function defineProperties(J, et, eo) {
      for (let el in et) {
        let ec = et[el]
          , ed = eo ? eo[el] : null;
        ed && function (J, et, eo) {
          let el = et.split("|").map(J => J.trim());
          for (let eo = 0; eo < el.length; eo++)
            switch (et) {
              case "any":
                return;
              case "bigint":
              case "boolean":
              case "number":
              case "string":
                if (typeof J === et)
                  return
            }
          let ec = Error(`invalid value for type ${et}`);
          throw ec.code = "INVALID_ARGUMENT",
          ec.argument = `value.${eo}`,
          ec.value = J,
          ec
        }(ec, ed, el),
          Object.defineProperty(J, el, {
            enumerable: !0,
            value: ec,
            writable: !1
          })
      }
    }
    function stringify(J) {
      if (null == J)
        return "null";
      if (Array.isArray(J))
        return "[ " + J.map(stringify).join(", ") + " ]";
      if (J instanceof Uint8Array) {
        let et = "0123456789abcdef"
          , eo = "0x";
        for (let el = 0; el < J.length; el++)
          eo += et[J[el] >> 4] + et[15 & J[el]];
        return eo
      }
      if ("object" == typeof J && "function" == typeof J.toJSON)
        return stringify(J.toJSON());
      switch (typeof J) {
        case "boolean":
        case "symbol":
        case "number":
          return J.toString();
        case "bigint":
          return BigInt(J).toString();
        case "string":
          return JSON.stringify(J);
        case "object":
          {
            let et = Object.keys(J);
            return et.sort(),
              "{ " + et.map(et => `${stringify(et)}: ${stringify(J[et])}`).join(", ") + " }"
          }
      }
      return "[ COULD NOT SERIALIZE ]"
    }
    function errors_assert(J, et, eo, el) {
      if (!J)
        throw function (J, et, eo) {
          let el, ec = J;
          {
            let el = [];
            if (eo) {
              if ("message" in eo || "code" in eo || "name" in eo)
                throw Error(`value will overwrite populated values: ${stringify(eo)}`);
              for (let J in eo) {
                if ("shortMessage" === J)
                  continue;
                let et = eo[J];
                el.push(J + "=" + stringify(et))
              }
            }
            el.push(`code=${et}`),
              el.push("version=6.10.0"),
              el.length && (J += " (" + el.join(", ") + ")")
          }
          switch (et) {
            case "INVALID_ARGUMENT":
              el = TypeError(J);
              break;
            case "NUMERIC_FAULT":
            case "BUFFER_OVERRUN":
              el = RangeError(J);
              break;
            default:
              el = Error(J)
          }
          return defineProperties(el, {
            code: et
          }),
            eo && Object.assign(el, eo),
            null == el.shortMessage && defineProperties(el, {
              shortMessage: ec
            }),
            el
        }(et, eo, el)
    }
    function assertArgument(J, et, eo, el) {
      errors_assert(J, et, "INVALID_ARGUMENT", {
        argument: eo,
        value: el
      })
    }
    eo.d(et, {
      dF: function () {
        return formatEther
      },
      fi: function () {
        return parseEther
      }
    }),
      ["NFD", "NFC", "NFKD", "NFKC"].reduce((J, et) => {
        try {
          if ("test" !== "test".normalize(et))
            throw Error("bad");
          if ("NFD" === et) {
            let J = String.fromCharCode(233).normalize("NFD")
              , et = String.fromCharCode(101, 769);
            if (J !== et)
              throw Error("broken")
          }
          J.push(et)
        } catch (J) { }
        return J
      }
        , []);
    let el = BigInt(0)
      , ec = BigInt(1);
    function fromTwos(J, et) {
      let eo = getUint(J, "value")
        , ed = BigInt(getNumber(et, "width"));
      if (errors_assert(eo >> ed === el, "overflow", "NUMERIC_FAULT", {
        operation: "fromTwos",
        fault: "overflow",
        value: J
      }),
        eo >> ed - ec) {
        let J = (ec << ed) - ec;
        return -((~eo & J) + ec)
      }
      return eo
    }
    function mask(J, et) {
      let eo = getUint(J, "value")
        , el = BigInt(getNumber(et, "bits"));
      return eo & (ec << el) - ec
    }
    function getBigInt(J, et) {
      switch (typeof J) {
        case "bigint":
          return J;
        case "number":
          return assertArgument(Number.isInteger(J), "underflow", et || "value", J),
            assertArgument(J >= -9007199254740991 && J <= 9007199254740991, "overflow", et || "value", J),
            BigInt(J);
        case "string":
          try {
            if ("" === J)
              throw Error("empty string");
            if ("-" === J[0] && "-" !== J[1])
              return -BigInt(J.substring(1));
            return BigInt(J)
          } catch (eo) {
            assertArgument(!1, `invalid BigNumberish string: ${eo.message}`, et || "value", J)
          }
      }
      assertArgument(!1, "invalid BigNumberish value", et || "value", J)
    }
    function getUint(J, et) {
      let eo = getBigInt(J, et);
      return errors_assert(eo >= el, "unsigned value cannot be negative", "NUMERIC_FAULT", {
        fault: "overflow",
        operation: "getUint",
        value: J
      }),
        eo
    }
    let ed = "0123456789abcdef";
    function getNumber(J, et) {
      switch (typeof J) {
        case "bigint":
          return assertArgument(J >= -9007199254740991 && J <= 9007199254740991, "overflow", et || "value", J),
            Number(J);
        case "number":
          return assertArgument(Number.isInteger(J), "underflow", et || "value", J),
            assertArgument(J >= -9007199254740991 && J <= 9007199254740991, "overflow", et || "value", J),
            J;
        case "string":
          try {
            if ("" === J)
              throw Error("empty string");
            return getNumber(BigInt(J), et)
          } catch (eo) {
            assertArgument(!1, `invalid numeric string: ${eo.message}`, et || "value", J)
          }
      }
      assertArgument(!1, "invalid numeric value", et || "value", J)
    }
    let eh = BigInt(-1)
      , ep = BigInt(0)
      , ef = BigInt(1)
      , em = BigInt(5)
      , eg = {}
      , ey = "0000";
    for (; ey.length < 80;)
      ey += ey;
    function getTens(J) {
      let et = ey;
      for (; et.length < J;)
        et += et;
      return BigInt("1" + et.substring(0, J))
    }
    function checkValue(J, et, eo) {
      let el = BigInt(et.width);
      if (et.signed) {
        let et = ef << el - ef;
        errors_assert(null == eo || J >= -et && J < et, "overflow", "NUMERIC_FAULT", {
          operation: eo,
          fault: "overflow",
          value: J
        }),
          J = J > ep ? fromTwos(mask(J, el), el) : -fromTwos(mask(-J, el), el)
      } else {
        let et = ef << el;
        errors_assert(null == eo || J >= 0 && J < et, "overflow", "NUMERIC_FAULT", {
          operation: eo,
          fault: "overflow",
          value: J
        }),
          J = (J % et + et) % et & et - ef
      }
      return J
    }
    function getFormat(J) {
      "number" == typeof J && (J = `fixed128x${J}`);
      let et = !0
        , eo = 128
        , el = 18;
      if ("string" == typeof J) {
        if ("fixed" === J)
          ;
        else if ("ufixed" === J)
          et = !1;
        else {
          let ec = J.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
          assertArgument(ec, "invalid fixed format", "format", J),
            et = "u" !== ec[1],
            eo = parseInt(ec[2]),
            el = parseInt(ec[3])
        }
      } else if (J) {
        let ec = J
          , check = (J, et, eo) => null == ec[J] ? eo : (assertArgument(typeof ec[J] === et, "invalid fixed format (" + J + " not " + et + ")", "format." + J, ec[J]),
            ec[J]);
        et = check("signed", "boolean", et),
          eo = check("width", "number", eo),
          el = check("decimals", "number", el)
      }
      assertArgument(eo % 8 == 0, "invalid FixedNumber width (not byte aligned)", "format.width", eo),
        assertArgument(el <= 80, "invalid FixedNumber decimals (too large)", "format.decimals", el);
      let ec = (et ? "" : "u") + "fixed" + String(eo) + "x" + String(el);
      return {
        signed: et,
        width: eo,
        decimals: el,
        name: ec
      }
    }
    let FixedNumber = class FixedNumber {
      format;
      #Q;
      #X;
      #ee;
      _value;
      constructor(J, et, eo) {
        !function (J, et, eo) {
          if (null == eo && (eo = ""),
            J !== et) {
            let J = eo
              , et = "new";
            eo && (J += ".",
              et += " " + eo),
              errors_assert(!1, `private constructor; use ${J}from* methods`, "UNSUPPORTED_OPERATION", {
                operation: et
              })
          }
        }(J, eg, "FixedNumber"),
          this.#X = et,
          this.#Q = eo;
        let el = function (J, et) {
          let eo = "";
          J < ep && (eo = "-",
            J *= eh);
          let el = J.toString();
          if (0 === et)
            return eo + el;
          for (; el.length <= et;)
            el = ey + el;
          let ec = el.length - et;
          for (el = el.substring(0, ec) + "." + el.substring(ec); "0" === el[0] && "." !== el[1];)
            el = el.substring(1);
          for (; "0" === el[el.length - 1] && "." !== el[el.length - 2];)
            el = el.substring(0, el.length - 1);
          return eo + el
        }(et, eo.decimals);
        defineProperties(this, {
          format: eo.name,
          _value: el
        }),
          this.#ee = getTens(eo.decimals)
      }
      get signed() {
        return this.#Q.signed
      }
      get width() {
        return this.#Q.width
      }
      get decimals() {
        return this.#Q.decimals
      }
      get value() {
        return this.#X
      }
      #et(J) {
        assertArgument(this.format === J.format, "incompatible format; use fixedNumber.toFormat", "other", J)
      }
      #er(J, et) {
        return J = checkValue(J, this.#Q, et),
          new FixedNumber(eg, J, this.#Q)
      }
      #en(J, et) {
        return this.#et(J),
          this.#er(this.#X + J.#X, et)
      }
      addUnsafe(J) {
        return this.#en(J)
      }
      add(J) {
        return this.#en(J, "add")
      }
      #ei(J, et) {
        return this.#et(J),
          this.#er(this.#X - J.#X, et)
      }
      subUnsafe(J) {
        return this.#ei(J)
      }
      sub(J) {
        return this.#ei(J, "sub")
      }
      #es(J, et) {
        return this.#et(J),
          this.#er(this.#X * J.#X / this.#ee, et)
      }
      mulUnsafe(J) {
        return this.#es(J)
      }
      mul(J) {
        return this.#es(J, "mul")
      }
      mulSignal(J) {
        this.#et(J);
        let et = this.#X * J.#X;
        return errors_assert(et % this.#ee === ep, "precision lost during signalling mul", "NUMERIC_FAULT", {
          operation: "mulSignal",
          fault: "underflow",
          value: this
        }),
          this.#er(et / this.#ee, "mulSignal")
      }
      #eo(J, et) {
        return errors_assert(J.#X !== ep, "division by zero", "NUMERIC_FAULT", {
          operation: "div",
          fault: "divide-by-zero",
          value: this
        }),
          this.#et(J),
          this.#er(this.#X * this.#ee / J.#X, et)
      }
      divUnsafe(J) {
        return this.#eo(J)
      }
      div(J) {
        return this.#eo(J, "div")
      }
      divSignal(J) {
        errors_assert(J.#X !== ep, "division by zero", "NUMERIC_FAULT", {
          operation: "div",
          fault: "divide-by-zero",
          value: this
        }),
          this.#et(J);
        let et = this.#X * this.#ee;
        return errors_assert(et % J.#X === ep, "precision lost during signalling div", "NUMERIC_FAULT", {
          operation: "divSignal",
          fault: "underflow",
          value: this
        }),
          this.#er(et / J.#X, "divSignal")
      }
      cmp(J) {
        let et = this.value
          , eo = J.value
          , el = this.decimals - J.decimals;
        return (el > 0 ? eo *= getTens(el) : el < 0 && (et *= getTens(-el)),
          et < eo) ? -1 : et > eo ? 1 : 0
      }
      eq(J) {
        return 0 === this.cmp(J)
      }
      lt(J) {
        return 0 > this.cmp(J)
      }
      lte(J) {
        return 0 >= this.cmp(J)
      }
      gt(J) {
        return this.cmp(J) > 0
      }
      gte(J) {
        return this.cmp(J) >= 0
      }
      floor() {
        let J = this.#X;
        return this.#X < ep && (J -= this.#ee - ef),
          J = this.#X / this.#ee * this.#ee,
          this.#er(J, "floor")
      }
      ceiling() {
        let J = this.#X;
        return this.#X > ep && (J += this.#ee - ef),
          J = this.#X / this.#ee * this.#ee,
          this.#er(J, "ceiling")
      }
      round(J) {
        if (null == J && (J = 0),
          J >= this.decimals)
          return this;
        let et = this.decimals - J
          , eo = em * getTens(et - 1)
          , el = this.value + eo
          , ec = getTens(et);
        return checkValue(el = el / ec * ec, this.#Q, "round"),
          new FixedNumber(eg, el, this.#Q)
      }
      isZero() {
        return this.#X === ep
      }
      isNegative() {
        return this.#X < ep
      }
      toString() {
        return this._value
      }
      toUnsafeFloat() {
        return parseFloat(this.toString())
      }
      toFormat(J) {
        return FixedNumber.fromString(this.toString(), J)
      }
      static fromValue(J, et, eo) {
        let el = null == et ? 0 : getNumber(et)
          , ec = getFormat(eo)
          , ed = getBigInt(J, "value")
          , eh = el - ec.decimals;
        if (eh > 0) {
          let et = getTens(eh);
          errors_assert(ed % et === ep, "value loses precision for format", "NUMERIC_FAULT", {
            operation: "fromValue",
            fault: "underflow",
            value: J
          }),
            ed /= et
        } else
          eh < 0 && (ed *= getTens(-eh));
        return checkValue(ed, ec, "fromValue"),
          new FixedNumber(eg, ed, ec)
      }
      static fromString(J, et) {
        let eo = J.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
        assertArgument(eo && eo[2].length + eo[3].length > 0, "invalid FixedNumber string value", "value", J);
        let el = getFormat(et)
          , ec = eo[2] || "0"
          , ed = eo[3] || "";
        for (; ed.length < el.decimals;)
          ed += ey;
        errors_assert(ed.substring(el.decimals).match(/^0*$/), "too many decimals for format", "NUMERIC_FAULT", {
          operation: "fromString",
          fault: "underflow",
          value: J
        }),
          ed = ed.substring(0, el.decimals);
        let eh = BigInt(eo[1] + ec + ed);
        return checkValue(eh, el, "fromString"),
          new FixedNumber(eg, eh, el)
      }
      static fromBytes(J, et) {
        let eo = function (J) {
          if (J instanceof Uint8Array) {
            let et = "0x0";
            for (let eo of J)
              et += ed[eo >> 4] + ed[15 & eo];
            return BigInt(et)
          }
          return getBigInt(J)
        }(function (J, et, eo) {
          if (J instanceof Uint8Array)
            return eo ? new Uint8Array(J) : J;
          if ("string" == typeof J && J.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
            let et = new Uint8Array((J.length - 2) / 2)
              , eo = 2;
            for (let el = 0; el < et.length; el++)
              et[el] = parseInt(J.substring(eo, eo + 2), 16),
                eo += 2;
            return et
          }
          assertArgument(!1, "invalid BytesLike value", et || "value", J)
        }(J, "value", !1))
          , el = getFormat(et);
        return el.signed && (eo = fromTwos(eo, el.width)),
          checkValue(eo, el, "fromBytes"),
          new FixedNumber(eg, eo, el)
      }
    }
      ;
    let eb = ["wei", "kwei", "mwei", "gwei", "szabo", "finney", "ether"];
    function formatEther(J) {
      return function (J, et) {
        let eo = 18;
        if ("string" == typeof et) {
          let J = eb.indexOf(et);
          assertArgument(J >= 0, "invalid unit", "unit", et),
            eo = 3 * J
        } else
          null != et && (eo = getNumber(et, "unit"));
        return FixedNumber.fromValue(J, eo, {
          decimals: eo,
          width: 512
        }).toString()
      }(J, 18)
    }
    function parseEther(J) {
      return function (J, et) {
        assertArgument("string" == typeof J, "value must be a string", "value", J);
        let eo = 18;
        if ("string" == typeof et) {
          let J = eb.indexOf(et);
          assertArgument(J >= 0, "invalid unit", "unit", et),
            eo = 3 * J
        } else
          null != et && (eo = getNumber(et, "unit"));
        return FixedNumber.fromString(J, {
          decimals: eo,
          width: 512
        }).value
      }(J, 18)
    }
  },
  51526: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      M: function () {
        return AnimatePresence
      }
    });
    var el = eo(67294)
      , ec = eo(58868);
    function useIsMounted() {
      let J = (0,
        el.useRef)(!1);
      return (0,
        ec.L)(() => (J.current = !0,
          () => {
            J.current = !1
          }
        ), []),
        J
    }
    var ed = eo(26166)
      , eh = eo(240)
      , ep = eo(96681);
    let PopChildMeasure = class PopChildMeasure extends el.Component {
      getSnapshotBeforeUpdate(J) {
        let et = this.props.childRef.current;
        if (et && J.isPresent && !this.props.isPresent) {
          let J = this.props.sizeRef.current;
          J.height = et.offsetHeight || 0,
            J.width = et.offsetWidth || 0,
            J.top = et.offsetTop,
            J.left = et.offsetLeft
        }
        return null
      }
      componentDidUpdate() { }
      render() {
        return this.props.children
      }
    }
      ;
    function PopChild({ children: J, isPresent: et }) {
      let eo = (0,
        el.useId)()
        , ec = (0,
          el.useRef)(null)
        , ed = (0,
          el.useRef)({
            width: 0,
            height: 0,
            top: 0,
            left: 0
          });
      return (0,
        el.useInsertionEffect)(() => {
          let { width: J, height: el, top: eh, left: ep } = ed.current;
          if (et || !ec.current || !J || !el)
            return;
          ec.current.dataset.motionPopId = eo;
          let ef = document.createElement("style");
          return document.head.appendChild(ef),
            ef.sheet && ef.sheet.insertRule(`
        [data-motion-pop-id="${eo}"] {
          position: absolute !important;
          width: ${J}px !important;
          height: ${el}px !important;
          top: ${eh}px !important;
          left: ${ep}px !important;
        }
      `),
            () => {
              document.head.removeChild(ef)
            }
        }
          , [et]),
        el.createElement(PopChildMeasure, {
          isPresent: et,
          childRef: ec,
          sizeRef: ed
        }, el.cloneElement(J, {
          ref: ec
        }))
    }
    let PresenceChild = ({ children: J, initial: et, isPresent: eo, onExitComplete: ec, custom: ed, presenceAffectsLayout: ef, mode: em }) => {
      let eg = (0,
        ep.h)(newChildrenMap)
        , ey = (0,
          el.useId)()
        , eb = (0,
          el.useMemo)(() => ({
            id: ey,
            initial: et,
            isPresent: eo,
            custom: ed,
            onExitComplete: J => {
              for (let et of (eg.set(J, !0),
                eg.values()))
                if (!et)
                  return;
              ec && ec()
            }
            ,
            register: J => (eg.set(J, !1),
              () => eg.delete(J))
          }), ef ? void 0 : [eo]);
      return (0,
        el.useMemo)(() => {
          eg.forEach((J, et) => eg.set(et, !1))
        }
          , [eo]),
        el.useEffect(() => {
          eo || eg.size || !ec || ec()
        }
          , [eo]),
        "popLayout" === em && (J = el.createElement(PopChild, {
          isPresent: eo
        }, J)),
        el.createElement(eh.O.Provider, {
          value: eb
        }, J)
    }
      ;
    function newChildrenMap() {
      return new Map
    }
    var ef = eo(25364)
      , em = eo(45487);
    let getChildKey = J => J.key || ""
      , AnimatePresence = ({ children: J, custom: et, initial: eo = !0, onExitComplete: eh, exitBeforeEnter: ep, presenceAffectsLayout: eg = !0, mode: ey = "sync" }) => {
        var eb;
        (0,
          em.k)(!ep, "Replace exitBeforeEnter with mode='wait'");
        let ew = (0,
          el.useContext)(ef.p).forceRender || function () {
            let J = useIsMounted()
              , [et, eo] = (0,
                el.useState)(0)
              , ec = (0,
                el.useCallback)(() => {
                  J.current && eo(et + 1)
                }
                  , [et])
              , eh = (0,
                el.useCallback)(() => ed.Wi.postRender(ec), [ec]);
            return [eh, et]
          }()[0]
          , e_ = useIsMounted()
          , ex = function (J) {
            let et = [];
            return el.Children.forEach(J, J => {
              (0,
                el.isValidElement)(J) && et.push(J)
            }
            ),
              et
          }(J)
          , eE = ex
          , eC = (0,
            el.useRef)(new Map).current
          , eS = (0,
            el.useRef)(eE)
          , ek = (0,
            el.useRef)(new Map).current
          , eT = (0,
            el.useRef)(!0);
        if ((0,
          ec.L)(() => {
            eT.current = !1,
              function (J, et) {
                J.forEach(J => {
                  let eo = getChildKey(J);
                  et.set(eo, J)
                }
                )
              }(ex, ek),
              eS.current = eE
          }
          ),
          eb = () => {
            eT.current = !0,
              ek.clear(),
              eC.clear()
          }
          ,
          (0,
            el.useEffect)(() => () => eb(), []),
          eT.current)
          return el.createElement(el.Fragment, null, eE.map(J => el.createElement(PresenceChild, {
            key: getChildKey(J),
            isPresent: !0,
            initial: !!eo && void 0,
            presenceAffectsLayout: eg,
            mode: ey
          }, J)));
        eE = [...eE];
        let eA = eS.current.map(getChildKey)
          , eP = ex.map(getChildKey)
          , eR = eA.length;
        for (let J = 0; J < eR; J++) {
          let et = eA[J];
          -1 !== eP.indexOf(et) || eC.has(et) || eC.set(et, void 0)
        }
        return "wait" === ey && eC.size && (eE = []),
          eC.forEach((J, eo) => {
            if (-1 !== eP.indexOf(eo))
              return;
            let ec = ek.get(eo);
            if (!ec)
              return;
            let ed = eA.indexOf(eo)
              , ep = J;
            ep || (ep = el.createElement(PresenceChild, {
              key: getChildKey(ec),
              isPresent: !1,
              onExitComplete: () => {
                eC.delete(eo);
                let J = Array.from(ek.keys()).filter(J => !eP.includes(J));
                if (J.forEach(J => ek.delete(J)),
                  eS.current = ex.filter(et => {
                    let el = getChildKey(et);
                    return el === eo || J.includes(el)
                  }
                  ),
                  !eC.size) {
                  if (!1 === e_.current)
                    return;
                  ew(),
                    eh && eh()
                }
              }
              ,
              custom: et,
              presenceAffectsLayout: eg,
              mode: ey
            }, ec),
              eC.set(eo, ep)),
              eE.splice(ed, 0, ep)
          }
          ),
          eE = eE.map(J => {
            let et = J.key;
            return eC.has(et) ? J : el.createElement(PresenceChild, {
              key: getChildKey(J),
              isPresent: !0,
              presenceAffectsLayout: eg,
              mode: ey
            }, J)
          }
          ),
          el.createElement(el.Fragment, null, eC.size ? eE : eE.map(J => (0,
            el.cloneElement)(J)))
      }
  },
  25364: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      p: function () {
        return ec
      }
    });
    var el = eo(67294);
    let ec = (0,
      el.createContext)({})
  },
  240: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      O: function () {
        return ec
      }
    });
    var el = eo(67294);
    let ec = (0,
      el.createContext)(null)
  },
  89727: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      Z: function () {
        return createRenderBatcher
      }
    });
    var el = eo(22081);
    let Queue = class Queue {
      constructor() {
        this.order = [],
          this.scheduled = new Set
      }
      add(J) {
        if (!this.scheduled.has(J))
          return this.scheduled.add(J),
            this.order.push(J),
            !0
      }
      remove(J) {
        let et = this.order.indexOf(J);
        -1 !== et && (this.order.splice(et, 1),
          this.scheduled.delete(J))
      }
      clear() {
        this.order.length = 0,
          this.scheduled.clear()
      }
    }
      ;
    let ec = ["prepare", "read", "update", "preRender", "render", "postRender"];
    function createRenderBatcher(J, et) {
      let eo = !1
        , ed = !0
        , eh = {
          delta: 0,
          timestamp: 0,
          isProcessing: !1
        }
        , ep = ec.reduce((J, et) => (J[et] = function (J) {
          let et = new Queue
            , eo = new Queue
            , el = 0
            , ec = !1
            , ed = !1
            , eh = new WeakSet
            , ep = {
              schedule: (J, ed = !1, ep = !1) => {
                let ef = ep && ec
                  , em = ef ? et : eo;
                return ed && eh.add(J),
                  em.add(J) && ef && ec && (el = et.order.length),
                  J
              }
              ,
              cancel: J => {
                eo.remove(J),
                  eh.delete(J)
              }
              ,
              process: ef => {
                if (ec) {
                  ed = !0;
                  return
                }
                if (ec = !0,
                  [et, eo] = [eo, et],
                  eo.clear(),
                  el = et.order.length)
                  for (let eo = 0; eo < el; eo++) {
                    let el = et.order[eo];
                    eh.has(el) && (ep.schedule(el),
                      J()),
                      el(ef)
                  }
                ec = !1,
                  ed && (ed = !1,
                    ep.process(ef))
              }
            };
          return ep
        }(() => eo = !0),
          J), {})
        , processStep = J => {
          ep[J].process(eh)
        }
        , processBatch = () => {
          let ep = el.c.useManualTiming ? eh.timestamp : performance.now();
          eo = !1,
            eh.delta = ed ? 1e3 / 60 : Math.max(Math.min(ep - eh.timestamp, 40), 1),
            eh.timestamp = ep,
            eh.isProcessing = !0,
            ec.forEach(processStep),
            eh.isProcessing = !1,
            eo && et && (ed = !1,
              J(processBatch))
        }
        , wake = () => {
          eo = !0,
            ed = !0,
            eh.isProcessing || J(processBatch)
        }
        , ef = ec.reduce((J, et) => {
          let el = ep[et];
          return J[et] = (J, et = !1, ec = !1) => (eo || wake(),
            el.schedule(J, et, ec)),
            J
        }
          , {});
      return {
        schedule: ef,
        cancel: J => ec.forEach(et => ep[et].cancel(J)),
        state: eh,
        steps: ep
      }
    }
  },
  26166: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      Pn: function () {
        return eh
      },
      S6: function () {
        return ef
      },
      Wi: function () {
        return ed
      },
      frameData: function () {
        return ep
      }
    });
    var el = eo(81662)
      , ec = eo(89727);
    let { schedule: ed, cancel: eh, state: ep, steps: ef } = (0,
      ec.Z)("undefined" != typeof requestAnimationFrame ? requestAnimationFrame : el.Z, !0)
  },
  16720: function (J, et, eo) {
    "use strict";
    let el, ec;
    eo.d(et, {
      E: function () {
        return rN
      }
    });
    var ed, eh, ep = eo(67294);
    let ef = (0,
      ep.createContext)({
        transformPagePoint: J => J,
        isStatic: !1,
        reducedMotion: "never"
      })
      , em = (0,
        ep.createContext)({});
    var eg = eo(240)
      , ey = eo(58868);
    let eb = (0,
      ep.createContext)({
        strict: !1
      })
      , camelToDash = J => J.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase()
      , ew = "data-" + camelToDash("framerAppearId");
    var e_ = eo(89727);
    let { schedule: ex, cancel: eE } = (0,
      e_.Z)(queueMicrotask, !1);
    function isRefObject(J) {
      return J && "object" == typeof J && Object.prototype.hasOwnProperty.call(J, "current")
    }
    function isVariantLabel(J) {
      return "string" == typeof J || Array.isArray(J)
    }
    function isAnimationControls(J) {
      return null !== J && "object" == typeof J && "function" == typeof J.start
    }
    let eC = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"]
      , eS = ["initial", ...eC];
    function isControllingVariants(J) {
      return isAnimationControls(J.animate) || eS.some(et => isVariantLabel(J[et]))
    }
    function isVariantNode(J) {
      return !!(isControllingVariants(J) || J.variants)
    }
    function variantLabelsAsDependency(J) {
      return Array.isArray(J) ? J.join(" ") : J
    }
    let ek = {
      animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
      exit: ["exit"],
      drag: ["drag", "dragControls"],
      focus: ["whileFocus"],
      hover: ["whileHover", "onHoverStart", "onHoverEnd"],
      tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
      pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
      inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
      layout: ["layout", "layoutId"]
    }
      , eT = {};
    for (let J in ek)
      eT[J] = {
        isEnabled: et => ek[J].some(J => !!et[J])
      };
    var eA = eo(11741)
      , eP = eo(25364);
    let eR = (0,
      ep.createContext)({})
      , eI = Symbol.for("motionComponentSymbol")
      , eO = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];
    function isSVGComponent(J) {
      if ("string" != typeof J || J.includes("-"))
        ;
      else if (eO.indexOf(J) > -1 || /[A-Z]/.test(J))
        return !0;
      return !1
    }
    let eN = {}
      , eM = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"]
      , eD = new Set(eM);
    function isForcedMotionValue(J, { layout: et, layoutId: eo }) {
      return eD.has(J) || J.startsWith("origin") || (et || void 0 !== eo) && (!!eN[J] || "opacity" === J)
    }
    let isMotionValue = J => !!(J && J.getVelocity)
      , ej = {
        x: "translateX",
        y: "translateY",
        z: "translateZ",
        transformPerspective: "perspective"
      }
      , eL = eM.length
      , checkStringStartsWith = J => et => "string" == typeof et && et.startsWith(J)
      , e$ = checkStringStartsWith("--")
      , eB = checkStringStartsWith("var(--")
      , getValueAsType = (J, et) => et && "number" == typeof J ? et.transform(J) : J
      , clamp = (J, et, eo) => Math.min(Math.max(eo, J), et)
      , eF = {
        test: J => "number" == typeof J,
        parse: parseFloat,
        transform: J => J
      }
      , eU = {
        ...eF,
        transform: J => clamp(0, 1, J)
      }
      , ez = {
        ...eF,
        default: 1
      }
      , sanitize = J => Math.round(1e5 * J) / 1e5
      , eH = /(-)?([\d]*\.?[\d])+/g
      , eV = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi
      , eW = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
    function isString(J) {
      return "string" == typeof J
    }
    let createUnitType = J => ({
      test: et => isString(et) && et.endsWith(J) && 1 === et.split(" ").length,
      parse: parseFloat,
      transform: et => `${et}${J}`
    })
      , eZ = createUnitType("deg")
      , eG = createUnitType("%")
      , eY = createUnitType("px")
      , eK = createUnitType("vh")
      , eJ = createUnitType("vw")
      , eQ = {
        ...eG,
        parse: J => eG.parse(J) / 100,
        transform: J => eG.transform(100 * J)
      }
      , eX = {
        ...eF,
        transform: Math.round
      }
      , e0 = {
        borderWidth: eY,
        borderTopWidth: eY,
        borderRightWidth: eY,
        borderBottomWidth: eY,
        borderLeftWidth: eY,
        borderRadius: eY,
        radius: eY,
        borderTopLeftRadius: eY,
        borderTopRightRadius: eY,
        borderBottomRightRadius: eY,
        borderBottomLeftRadius: eY,
        width: eY,
        maxWidth: eY,
        height: eY,
        maxHeight: eY,
        size: eY,
        top: eY,
        right: eY,
        bottom: eY,
        left: eY,
        padding: eY,
        paddingTop: eY,
        paddingRight: eY,
        paddingBottom: eY,
        paddingLeft: eY,
        margin: eY,
        marginTop: eY,
        marginRight: eY,
        marginBottom: eY,
        marginLeft: eY,
        rotate: eZ,
        rotateX: eZ,
        rotateY: eZ,
        rotateZ: eZ,
        scale: ez,
        scaleX: ez,
        scaleY: ez,
        scaleZ: ez,
        skew: eZ,
        skewX: eZ,
        skewY: eZ,
        distance: eY,
        translateX: eY,
        translateY: eY,
        translateZ: eY,
        x: eY,
        y: eY,
        z: eY,
        perspective: eY,
        transformPerspective: eY,
        opacity: eU,
        originX: eQ,
        originY: eQ,
        originZ: eY,
        zIndex: eX,
        fillOpacity: eU,
        strokeOpacity: eU,
        numOctaves: eX
      };
    function buildHTMLStyles(J, et, eo, el) {
      let { style: ec, vars: ed, transform: eh, transformOrigin: ep } = J
        , ef = !1
        , em = !1
        , eg = !0;
      for (let J in et) {
        let eo = et[J];
        if (e$(J)) {
          ed[J] = eo;
          continue
        }
        let el = e0[J]
          , ey = getValueAsType(eo, el);
        if (eD.has(J)) {
          if (ef = !0,
            eh[J] = ey,
            !eg)
            continue;
          eo !== (el.default || 0) && (eg = !1)
        } else
          J.startsWith("origin") ? (em = !0,
            ep[J] = ey) : ec[J] = ey
      }
      if (!et.transform && (ef || el ? ec.transform = function (J, { enableHardwareAcceleration: et = !0, allowTransformNone: eo = !0 }, el, ec) {
        let ed = "";
        for (let et = 0; et < eL; et++) {
          let eo = eM[et];
          if (void 0 !== J[eo]) {
            let et = ej[eo] || eo;
            ed += `${et}(${J[eo]}) `
          }
        }
        return et && !J.z && (ed += "translateZ(0)"),
          ed = ed.trim(),
          ec ? ed = ec(J, el ? "" : ed) : eo && el && (ed = "none"),
          ed
      }(J.transform, eo, eg, el) : ec.transform && (ec.transform = "none")),
        em) {
        let { originX: J = "50%", originY: et = "50%", originZ: eo = 0 } = ep;
        ec.transformOrigin = `${J} ${et} ${eo}`
      }
    }
    let createHtmlRenderState = () => ({
      style: {},
      transform: {},
      transformOrigin: {},
      vars: {}
    });
    function copyRawValuesOnly(J, et, eo) {
      for (let el in et)
        isMotionValue(et[el]) || isForcedMotionValue(el, eo) || (J[el] = et[el])
    }
    function useHTMLProps(J, et, eo) {
      let el = {}
        , ec = function (J, et, eo) {
          let el = J.style || {}
            , ec = {};
          return copyRawValuesOnly(ec, el, J),
            Object.assign(ec, function ({ transformTemplate: J }, et, eo) {
              return (0,
                ep.useMemo)(() => {
                  let el = createHtmlRenderState();
                  return buildHTMLStyles(el, et, {
                    enableHardwareAcceleration: !eo
                  }, J),
                    Object.assign({}, el.vars, el.style)
                }
                  , [et])
            }(J, et, eo)),
            ec
        }(J, et, eo);
      return J.drag && !1 !== J.dragListener && (el.draggable = !1,
        ec.userSelect = ec.WebkitUserSelect = ec.WebkitTouchCallout = "none",
        ec.touchAction = !0 === J.drag ? "none" : `pan-${"x" === J.drag ? "y" : "x"}`),
        void 0 === J.tabIndex && (J.onTap || J.onTapStart || J.whileTap) && (el.tabIndex = 0),
        el.style = ec,
        el
    }
    let e1 = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]);
    function isValidMotionProp(J) {
      return J.startsWith("while") || J.startsWith("drag") && "draggable" !== J || J.startsWith("layout") || J.startsWith("onTap") || J.startsWith("onPan") || J.startsWith("onLayout") || e1.has(J)
    }
    let shouldForward = J => !isValidMotionProp(J);
    try {
      (ed = require("@emotion/is-prop-valid").default) && (shouldForward = J => J.startsWith("on") ? !isValidMotionProp(J) : ed(J))
    } catch (J) { }
    function calcOrigin(J, et, eo) {
      return "string" == typeof J ? J : eY.transform(et + eo * J)
    }
    let e2 = {
      offset: "stroke-dashoffset",
      array: "stroke-dasharray"
    }
      , e3 = {
        offset: "strokeDashoffset",
        array: "strokeDasharray"
      };
    function buildSVGAttrs(J, { attrX: et, attrY: eo, attrScale: el, originX: ec, originY: ed, pathLength: eh, pathSpacing: ep = 1, pathOffset: ef = 0, ...em }, eg, ey, eb) {
      if (buildHTMLStyles(J, em, eg, eb),
        ey) {
        J.style.viewBox && (J.attrs.viewBox = J.style.viewBox);
        return
      }
      J.attrs = J.style,
        J.style = {};
      let { attrs: ew, style: e_, dimensions: ex } = J;
      ew.transform && (ex && (e_.transform = ew.transform),
        delete ew.transform),
        ex && (void 0 !== ec || void 0 !== ed || e_.transform) && (e_.transformOrigin = function (J, et, eo) {
          let el = calcOrigin(et, J.x, J.width)
            , ec = calcOrigin(eo, J.y, J.height);
          return `${el} ${ec}`
        }(ex, void 0 !== ec ? ec : .5, void 0 !== ed ? ed : .5)),
        void 0 !== et && (ew.x = et),
        void 0 !== eo && (ew.y = eo),
        void 0 !== el && (ew.scale = el),
        void 0 !== eh && function (J, et, eo = 1, el = 0, ec = !0) {
          J.pathLength = 1;
          let ed = ec ? e2 : e3;
          J[ed.offset] = eY.transform(-el);
          let eh = eY.transform(et)
            , ep = eY.transform(eo);
          J[ed.array] = `${eh} ${ep}`
        }(ew, eh, ep, ef, !1)
    }
    let createSvgRenderState = () => ({
      ...createHtmlRenderState(),
      attrs: {}
    })
      , isSVGTag = J => "string" == typeof J && "svg" === J.toLowerCase();
    function useSVGProps(J, et, eo, el) {
      let ec = (0,
        ep.useMemo)(() => {
          let eo = createSvgRenderState();
          return buildSVGAttrs(eo, et, {
            enableHardwareAcceleration: !1
          }, isSVGTag(el), J.transformTemplate),
          {
            ...eo.attrs,
            style: {
              ...eo.style
            }
          }
        }
          , [et]);
      if (J.style) {
        let et = {};
        copyRawValuesOnly(et, J.style, J),
          ec.style = {
            ...et,
            ...ec.style
          }
      }
      return ec
    }
    function renderHTML(J, { style: et, vars: eo }, el, ec) {
      for (let ed in Object.assign(J.style, et, ec && ec.getProjectionStyles(el)),
        eo)
        J.style.setProperty(ed, eo[ed])
    }
    let e5 = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);
    function renderSVG(J, et, eo, el) {
      for (let eo in renderHTML(J, et, void 0, el),
        et.attrs)
        J.setAttribute(e5.has(eo) ? eo : camelToDash(eo), et.attrs[eo])
    }
    function scrapeMotionValuesFromProps(J, et) {
      let { style: eo } = J
        , el = {};
      for (let ec in eo)
        (isMotionValue(eo[ec]) || et.style && isMotionValue(et.style[ec]) || isForcedMotionValue(ec, J)) && (el[ec] = eo[ec]);
      return el
    }
    function scrape_motion_values_scrapeMotionValuesFromProps(J, et) {
      let eo = scrapeMotionValuesFromProps(J, et);
      for (let el in J)
        if (isMotionValue(J[el]) || isMotionValue(et[el])) {
          let et = -1 !== eM.indexOf(el) ? "attr" + el.charAt(0).toUpperCase() + el.substring(1) : el;
          eo[et] = J[el]
        }
      return eo
    }
    function resolveVariantFromProps(J, et, eo, el = {}, ec = {}) {
      return "function" == typeof et && (et = et(void 0 !== eo ? eo : J.custom, el, ec)),
        "string" == typeof et && (et = J.variants && J.variants[et]),
        "function" == typeof et && (et = et(void 0 !== eo ? eo : J.custom, el, ec)),
        et
    }
    var e6 = eo(96681);
    let isKeyframesTarget = J => Array.isArray(J)
      , isCustomValue = J => !!(J && "object" == typeof J && J.mix && J.toValue)
      , resolveFinalValueInKeyframes = J => isKeyframesTarget(J) ? J[J.length - 1] || 0 : J;
    function resolveMotionValue(J) {
      let et = isMotionValue(J) ? J.get() : J;
      return isCustomValue(et) ? et.toValue() : et
    }
    let makeUseVisualState = J => (et, eo) => {
      let el = (0,
        ep.useContext)(em)
        , ec = (0,
          ep.useContext)(eg.O)
        , make = () => (function ({ scrapeMotionValuesFromProps: J, createRenderState: et, onMount: eo }, el, ec, ed) {
          let eh = {
            latestValues: function (J, et, eo, el) {
              let ec = {}
                , ed = el(J, {});
              for (let J in ed)
                ec[J] = resolveMotionValue(ed[J]);
              let { initial: eh, animate: ep } = J
                , ef = isControllingVariants(J)
                , em = isVariantNode(J);
              et && em && !ef && !1 !== J.inherit && (void 0 === eh && (eh = et.initial),
                void 0 === ep && (ep = et.animate));
              let eg = !!eo && !1 === eo.initial;
              eg = eg || !1 === eh;
              let ey = eg ? ep : eh;
              if (ey && "boolean" != typeof ey && !isAnimationControls(ey)) {
                let et = Array.isArray(ey) ? ey : [ey];
                et.forEach(et => {
                  let eo = resolveVariantFromProps(J, et);
                  if (!eo)
                    return;
                  let { transitionEnd: el, transition: ed, ...eh } = eo;
                  for (let J in eh) {
                    let et = eh[J];
                    if (Array.isArray(et)) {
                      let J = eg ? et.length - 1 : 0;
                      et = et[J]
                    }
                    null !== et && (ec[J] = et)
                  }
                  for (let J in el)
                    ec[J] = el[J]
                }
                )
              }
              return ec
            }(el, ec, ed, J),
            renderState: et()
          };
          return eo && (eh.mount = J => eo(el, J, eh)),
            eh
        }
        )(J, et, el, ec);
      return eo ? make() : (0,
        e6.h)(make)
    }
      ;
    var e4 = eo(26166);
    let e8 = {
      useVisualState: makeUseVisualState({
        scrapeMotionValuesFromProps: scrape_motion_values_scrapeMotionValuesFromProps,
        createRenderState: createSvgRenderState,
        onMount: (J, et, { renderState: eo, latestValues: el }) => {
          e4.Wi.read(() => {
            try {
              eo.dimensions = "function" == typeof et.getBBox ? et.getBBox() : et.getBoundingClientRect()
            } catch (J) {
              eo.dimensions = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
              }
            }
          }
          ),
            e4.Wi.render(() => {
              buildSVGAttrs(eo, el, {
                enableHardwareAcceleration: !1
              }, isSVGTag(et.tagName), J.transformTemplate),
                renderSVG(et, eo)
            }
            )
        }
      })
    }
      , e7 = {
        useVisualState: makeUseVisualState({
          scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,
          createRenderState: createHtmlRenderState
        })
      };
    function addDomEvent(J, et, eo, el = {
      passive: !0
    }) {
      return J.addEventListener(et, eo, el),
        () => J.removeEventListener(et, eo)
    }
    let isPrimaryPointer = J => "mouse" === J.pointerType ? "number" != typeof J.button || J.button <= 0 : !1 !== J.isPrimary;
    function extractEventInfo(J, et = "page") {
      return {
        point: {
          x: J[et + "X"],
          y: J[et + "Y"]
        }
      }
    }
    let addPointerInfo = J => et => isPrimaryPointer(et) && J(et, extractEventInfo(et));
    function addPointerEvent(J, et, eo, el) {
      return addDomEvent(J, et, addPointerInfo(eo), el)
    }
    let combineFunctions = (J, et) => eo => et(J(eo))
      , pipe = (...J) => J.reduce(combineFunctions);
    function createLock(J) {
      let et = null;
      return () => null === et && (et = J,
        () => {
          et = null
        }
      )
    }
    let e9 = createLock("dragHorizontal")
      , tn = createLock("dragVertical");
    function getGlobalLock(J) {
      let et = !1;
      if ("y" === J)
        et = tn();
      else if ("x" === J)
        et = e9();
      else {
        let J = e9()
          , eo = tn();
        J && eo ? et = () => {
          J(),
            eo()
        }
          : (J && J(),
            eo && eo())
      }
      return et
    }
    function isDragActive() {
      let J = getGlobalLock(!0);
      return !J || (J(),
        !1)
    }
    let Feature = class Feature {
      constructor(J) {
        this.isMounted = !1,
          this.node = J
      }
      update() { }
    }
      ;
    function addHoverEvent(J, et) {
      let eo = "pointer" + (et ? "enter" : "leave")
        , el = "onHover" + (et ? "Start" : "End");
      return addPointerEvent(J.current, eo, (eo, ec) => {
        if ("touch" === eo.pointerType || isDragActive())
          return;
        let ed = J.getProps();
        J.animationState && ed.whileHover && J.animationState.setActive("whileHover", et),
          ed[el] && e4.Wi.update(() => ed[el](eo, ec))
      }
        , {
          passive: !J.getProps()[el]
        })
    }
    let isNodeOrChild = (J, et) => !!et && (J === et || isNodeOrChild(J, et.parentElement));
    var to = eo(81662);
    function fireSyntheticPointerEvent(J, et) {
      if (!et)
        return;
      let eo = new PointerEvent("pointer" + J);
      et(eo, extractEventInfo(eo))
    }
    let ta = new WeakMap
      , tl = new WeakMap
      , fireObserverCallback = J => {
        let et = ta.get(J.target);
        et && et(J)
      }
      , fireAllObserverCallbacks = J => {
        J.forEach(fireObserverCallback)
      }
      , tc = {
        some: 0,
        all: 1
      };
    function shallowCompare(J, et) {
      if (!Array.isArray(et))
        return !1;
      let eo = et.length;
      if (eo !== J.length)
        return !1;
      for (let el = 0; el < eo; el++)
        if (et[el] !== J[el])
          return !1;
      return !0
    }
    function resolveVariant(J, et, eo) {
      let el = J.getProps();
      return resolveVariantFromProps(el, et, void 0 !== eo ? eo : el.custom, function (J) {
        let et = {};
        return J.values.forEach((J, eo) => et[eo] = J.get()),
          et
      }(J), function (J) {
        let et = {};
        return J.values.forEach((J, eo) => et[eo] = J.getVelocity()),
          et
      }(J))
    }
    var td = eo(45487);
    let secondsToMilliseconds = J => 1e3 * J
      , millisecondsToSeconds = J => J / 1e3
      , th = {
        current: !1
      }
      , isBezierDefinition = J => Array.isArray(J) && "number" == typeof J[0]
      , cubicBezierAsString = ([J, et, eo, el]) => `cubic-bezier(${J}, ${et}, ${eo}, ${el})`
      , tp = {
        linear: "linear",
        ease: "ease",
        easeIn: "ease-in",
        easeOut: "ease-out",
        easeInOut: "ease-in-out",
        circIn: cubicBezierAsString([0, .65, .55, 1]),
        circOut: cubicBezierAsString([.55, 0, 1, .45]),
        backIn: cubicBezierAsString([.31, .01, .66, -.59]),
        backOut: cubicBezierAsString([.33, 1.53, .69, .99])
      }
      , calcBezier = (J, et, eo) => (((1 - 3 * eo + 3 * et) * J + (3 * eo - 6 * et)) * J + 3 * et) * J;
    function cubicBezier(J, et, eo, el) {
      if (J === et && eo === el)
        return to.Z;
      let getTForX = et => (function (J, et, eo, el, ec) {
        let ed, eh;
        let ep = 0;
        do
          (ed = calcBezier(eh = et + (eo - et) / 2, el, ec) - J) > 0 ? eo = eh : et = eh;
        while (Math.abs(ed) > 1e-7 && ++ep < 12);
        return eh
      }
      )(et, 0, 1, J, eo);
      return J => 0 === J || 1 === J ? J : calcBezier(getTForX(J), et, el)
    }
    let tf = cubicBezier(.42, 0, 1, 1)
      , tm = cubicBezier(0, 0, .58, 1)
      , tg = cubicBezier(.42, 0, .58, 1)
      , isEasingArray = J => Array.isArray(J) && "number" != typeof J[0]
      , mirrorEasing = J => et => et <= .5 ? J(2 * et) / 2 : (2 - J(2 * (1 - et))) / 2
      , reverseEasing = J => et => 1 - J(1 - et)
      , circIn = J => 1 - Math.sin(Math.acos(J))
      , ty = reverseEasing(circIn)
      , tb = mirrorEasing(circIn)
      , tw = cubicBezier(.33, 1.53, .69, .99)
      , t_ = reverseEasing(tw)
      , tx = mirrorEasing(t_)
      , tE = {
        linear: to.Z,
        easeIn: tf,
        easeInOut: tg,
        easeOut: tm,
        circIn: circIn,
        circInOut: tb,
        circOut: ty,
        backIn: t_,
        backInOut: tx,
        backOut: tw,
        anticipate: J => (J *= 2) < 1 ? .5 * t_(J) : .5 * (2 - Math.pow(2, -10 * (J - 1)))
      }
      , easingDefinitionToFunction = J => {
        if (Array.isArray(J)) {
          (0,
            td.k)(4 === J.length, "Cubic bezier arrays must contain four numerical values.");
          let [et, eo, el, ec] = J;
          return cubicBezier(et, eo, el, ec)
        }
        return "string" == typeof J ? ((0,
          td.k)(void 0 !== tE[J], `Invalid easing type '${J}'`),
          tE[J]) : J
      }
      , isColorString = (J, et) => eo => !!(isString(eo) && eW.test(eo) && eo.startsWith(J) || et && Object.prototype.hasOwnProperty.call(eo, et))
      , splitColor = (J, et, eo) => el => {
        if (!isString(el))
          return el;
        let [ec, ed, eh, ep] = el.match(eH);
        return {
          [J]: parseFloat(ec),
          [et]: parseFloat(ed),
          [eo]: parseFloat(eh),
          alpha: void 0 !== ep ? parseFloat(ep) : 1
        }
      }
      , clampRgbUnit = J => clamp(0, 255, J)
      , tC = {
        ...eF,
        transform: J => Math.round(clampRgbUnit(J))
      }
      , tS = {
        test: isColorString("rgb", "red"),
        parse: splitColor("red", "green", "blue"),
        transform: ({ red: J, green: et, blue: eo, alpha: el = 1 }) => "rgba(" + tC.transform(J) + ", " + tC.transform(et) + ", " + tC.transform(eo) + ", " + sanitize(eU.transform(el)) + ")"
      }
      , tk = {
        test: isColorString("#"),
        parse: function (J) {
          let et = ""
            , eo = ""
            , el = ""
            , ec = "";
          return J.length > 5 ? (et = J.substring(1, 3),
            eo = J.substring(3, 5),
            el = J.substring(5, 7),
            ec = J.substring(7, 9)) : (et = J.substring(1, 2),
              eo = J.substring(2, 3),
              el = J.substring(3, 4),
              ec = J.substring(4, 5),
              et += et,
              eo += eo,
              el += el,
              ec += ec),
          {
            red: parseInt(et, 16),
            green: parseInt(eo, 16),
            blue: parseInt(el, 16),
            alpha: ec ? parseInt(ec, 16) / 255 : 1
          }
        },
        transform: tS.transform
      }
      , tT = {
        test: isColorString("hsl", "hue"),
        parse: splitColor("hue", "saturation", "lightness"),
        transform: ({ hue: J, saturation: et, lightness: eo, alpha: el = 1 }) => "hsla(" + Math.round(J) + ", " + eG.transform(sanitize(et)) + ", " + eG.transform(sanitize(eo)) + ", " + sanitize(eU.transform(el)) + ")"
      }
      , tA = {
        test: J => tS.test(J) || tk.test(J) || tT.test(J),
        parse: J => tS.test(J) ? tS.parse(J) : tT.test(J) ? tT.parse(J) : tk.parse(J),
        transform: J => isString(J) ? J : J.hasOwnProperty("red") ? tS.transform(J) : tT.transform(J)
      }
      , mix = (J, et, eo) => -eo * J + eo * et + J;
    function hueToRgb(J, et, eo) {
      return (eo < 0 && (eo += 1),
        eo > 1 && (eo -= 1),
        eo < 1 / 6) ? J + (et - J) * 6 * eo : eo < .5 ? et : eo < 2 / 3 ? J + (et - J) * (2 / 3 - eo) * 6 : J
    }
    let mixLinearColor = (J, et, eo) => {
      let el = J * J;
      return Math.sqrt(Math.max(0, eo * (et * et - el) + el))
    }
      , tP = [tk, tS, tT]
      , getColorType = J => tP.find(et => et.test(J));
    function asRGBA(J) {
      let et = getColorType(J);
      (0,
        td.k)(!!et, `'${J}' is not an animatable color. Use the equivalent color code instead.`);
      let eo = et.parse(J);
      return et === tT && (eo = function ({ hue: J, saturation: et, lightness: eo, alpha: el }) {
        J /= 360,
          eo /= 100;
        let ec = 0
          , ed = 0
          , eh = 0;
        if (et /= 100) {
          let el = eo < .5 ? eo * (1 + et) : eo + et - eo * et
            , ep = 2 * eo - el;
          ec = hueToRgb(ep, el, J + 1 / 3),
            ed = hueToRgb(ep, el, J),
            eh = hueToRgb(ep, el, J - 1 / 3)
        } else
          ec = ed = eh = eo;
        return {
          red: Math.round(255 * ec),
          green: Math.round(255 * ed),
          blue: Math.round(255 * eh),
          alpha: el
        }
      }(eo)),
        eo
    }
    let mixColor = (J, et) => {
      let eo = asRGBA(J)
        , el = asRGBA(et)
        , ec = {
          ...eo
        };
      return J => (ec.red = mixLinearColor(eo.red, el.red, J),
        ec.green = mixLinearColor(eo.green, el.green, J),
        ec.blue = mixLinearColor(eo.blue, el.blue, J),
        ec.alpha = mix(eo.alpha, el.alpha, J),
        tS.transform(ec))
    }
      , tR = {
        regex: /var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g,
        countKey: "Vars",
        token: "${v}",
        parse: to.Z
      }
      , tI = {
        regex: eV,
        countKey: "Colors",
        token: "${c}",
        parse: tA.parse
      }
      , tO = {
        regex: eH,
        countKey: "Numbers",
        token: "${n}",
        parse: eF.parse
      };
    function tokenise(J, { regex: et, countKey: eo, token: el, parse: ec }) {
      let ed = J.tokenised.match(et);
      ed && (J["num" + eo] = ed.length,
        J.tokenised = J.tokenised.replace(et, el),
        J.values.push(...ed.map(ec)))
    }
    function analyseComplexValue(J) {
      let et = J.toString()
        , eo = {
          value: et,
          tokenised: et,
          values: [],
          numVars: 0,
          numColors: 0,
          numNumbers: 0
        };
      return eo.value.includes("var(--") && tokenise(eo, tR),
        tokenise(eo, tI),
        tokenise(eo, tO),
        eo
    }
    function parseComplexValue(J) {
      return analyseComplexValue(J).values
    }
    function createTransformer(J) {
      let { values: et, numColors: eo, numVars: el, tokenised: ec } = analyseComplexValue(J)
        , ed = et.length;
      return J => {
        let et = ec;
        for (let ec = 0; ec < ed; ec++)
          et = ec < el ? et.replace(tR.token, J[ec]) : ec < el + eo ? et.replace(tI.token, tA.transform(J[ec])) : et.replace(tO.token, sanitize(J[ec]));
        return et
      }
    }
    let convertNumbersToZero = J => "number" == typeof J ? 0 : J
      , tN = {
        test: function (J) {
          var et, eo;
          return isNaN(J) && isString(J) && ((null === (et = J.match(eH)) || void 0 === et ? void 0 : et.length) || 0) + ((null === (eo = J.match(eV)) || void 0 === eo ? void 0 : eo.length) || 0) > 0
        },
        parse: parseComplexValue,
        createTransformer,
        getAnimatableNone: function (J) {
          let et = parseComplexValue(J)
            , eo = createTransformer(J);
          return eo(et.map(convertNumbersToZero))
        }
      }
      , mixImmediate = (J, et) => eo => `${eo > 0 ? et : J}`;
    function getMixer(J, et) {
      return "number" == typeof J ? eo => mix(J, et, eo) : tA.test(J) ? mixColor(J, et) : J.startsWith("var(") ? mixImmediate(J, et) : mixComplex(J, et)
    }
    let mixArray = (J, et) => {
      let eo = [...J]
        , el = eo.length
        , ec = J.map((J, eo) => getMixer(J, et[eo]));
      return J => {
        for (let et = 0; et < el; et++)
          eo[et] = ec[et](J);
        return eo
      }
    }
      , mixObject = (J, et) => {
        let eo = {
          ...J,
          ...et
        }
          , el = {};
        for (let ec in eo)
          void 0 !== J[ec] && void 0 !== et[ec] && (el[ec] = getMixer(J[ec], et[ec]));
        return J => {
          for (let et in el)
            eo[et] = el[et](J);
          return eo
        }
      }
      , mixComplex = (J, et) => {
        let eo = tN.createTransformer(et)
          , el = analyseComplexValue(J)
          , ec = analyseComplexValue(et)
          , ed = el.numVars === ec.numVars && el.numColors === ec.numColors && el.numNumbers >= ec.numNumbers;
        return ed ? pipe(mixArray(el.values, ec.values), eo) : ((0,
          td.K)(!0, `Complex values '${J}' and '${et}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`),
          mixImmediate(J, et))
      }
      , progress = (J, et, eo) => {
        let el = et - J;
        return 0 === el ? 1 : (eo - J) / el
      }
      , mixNumber = (J, et) => eo => mix(J, et, eo);
    function interpolate(J, et, { clamp: eo = !0, ease: el, mixer: ec } = {}) {
      let ed = J.length;
      if ((0,
        td.k)(ed === et.length, "Both input and output ranges must be the same length"),
        1 === ed)
        return () => et[0];
      J[0] > J[ed - 1] && (J = [...J].reverse(),
        et = [...et].reverse());
      let eh = function (J, et, eo) {
        let el = []
          , ec = eo || function (J) {
            if ("number" == typeof J)
              ;
            else if ("string" == typeof J)
              return tA.test(J) ? mixColor : mixComplex;
            else if (Array.isArray(J))
              return mixArray;
            else if ("object" == typeof J)
              return mixObject;
            return mixNumber
          }(J[0])
          , ed = J.length - 1;
        for (let eo = 0; eo < ed; eo++) {
          let ed = ec(J[eo], J[eo + 1]);
          if (et) {
            let J = Array.isArray(et) ? et[eo] || to.Z : et;
            ed = pipe(J, ed)
          }
          el.push(ed)
        }
        return el
      }(et, el, ec)
        , ep = eh.length
        , interpolator = et => {
          let eo = 0;
          if (ep > 1)
            for (; eo < J.length - 2 && !(et < J[eo + 1]); eo++)
              ;
          let el = progress(J[eo], J[eo + 1], et);
          return eh[eo](el)
        }
        ;
      return eo ? et => interpolator(clamp(J[0], J[ed - 1], et)) : interpolator
    }
    function keyframes({ duration: J = 300, keyframes: et, times: eo, ease: el = "easeInOut" }) {
      let ec = isEasingArray(el) ? el.map(easingDefinitionToFunction) : easingDefinitionToFunction(el)
        , ed = {
          done: !1,
          value: et[0]
        }
        , eh = (eo && eo.length === et.length ? eo : function (J) {
          let et = [0];
          return function (J, et) {
            let eo = J[J.length - 1];
            for (let el = 1; el <= et; el++) {
              let ec = progress(0, et, el);
              J.push(mix(eo, 1, ec))
            }
          }(et, J.length - 1),
            et
        }(et)).map(et => et * J)
        , ep = interpolate(eh, et, {
          ease: Array.isArray(ec) ? ec : et.map(() => ec || tg).splice(0, et.length - 1)
        });
      return {
        calculatedDuration: J,
        next: et => (ed.value = ep(et),
          ed.done = et >= J,
          ed)
      }
    }
    function calcGeneratorVelocity(J, et, eo) {
      var el, ec;
      let ed = Math.max(et - 5, 0);
      return el = eo - J(ed),
        (ec = et - ed) ? el * (1e3 / ec) : 0
    }
    function calcAngularFreq(J, et) {
      return J * Math.sqrt(1 - et * et)
    }
    let tM = ["duration", "bounce"]
      , tD = ["stiffness", "damping", "mass"];
    function isSpringType(J, et) {
      return et.some(et => void 0 !== J[et])
    }
    function spring({ keyframes: J, restDelta: et, restSpeed: eo, ...el }) {
      let ec;
      let ed = J[0]
        , eh = J[J.length - 1]
        , ep = {
          done: !1,
          value: ed
        }
        , { stiffness: ef, damping: em, mass: eg, duration: ey, velocity: eb, isResolvedFromDuration: ew } = function (J) {
          let et = {
            velocity: 0,
            stiffness: 100,
            damping: 10,
            mass: 1,
            isResolvedFromDuration: !1,
            ...J
          };
          if (!isSpringType(J, tD) && isSpringType(J, tM)) {
            let eo = function ({ duration: J = 800, bounce: et = .25, velocity: eo = 0, mass: el = 1 }) {
              let ec, ed;
              (0,
                td.K)(J <= secondsToMilliseconds(10), "Spring duration must be 10 seconds or less");
              let eh = 1 - et;
              eh = clamp(.05, 1, eh),
                J = clamp(.01, 10, millisecondsToSeconds(J)),
                eh < 1 ? (ec = et => {
                  let el = et * eh
                    , ec = el * J
                    , ed = calcAngularFreq(et, eh)
                    , ep = Math.exp(-ec);
                  return .001 - (el - eo) / ed * ep
                }
                  ,
                  ed = et => {
                    let el = et * eh
                      , ed = el * J
                      , ep = Math.pow(eh, 2) * Math.pow(et, 2) * J
                      , ef = Math.exp(-ed)
                      , em = calcAngularFreq(Math.pow(et, 2), eh)
                      , eg = -ec(et) + .001 > 0 ? -1 : 1;
                    return eg * ((ed * eo + eo - ep) * ef) / em
                  }
                ) : (ec = et => {
                  let el = Math.exp(-et * J)
                    , ec = (et - eo) * J + 1;
                  return -.001 + el * ec
                }
                  ,
                  ed = et => {
                    let el = Math.exp(-et * J)
                      , ec = (eo - et) * (J * J);
                    return el * ec
                  }
                );
              let ep = 5 / J
                , ef = function (J, et, eo) {
                  let el = eo;
                  for (let eo = 1; eo < 12; eo++)
                    el -= J(el) / et(el);
                  return el
                }(ec, ed, ep);
              if (J = secondsToMilliseconds(J),
                isNaN(ef))
                return {
                  stiffness: 100,
                  damping: 10,
                  duration: J
                };
              {
                let et = Math.pow(ef, 2) * el;
                return {
                  stiffness: et,
                  damping: 2 * eh * Math.sqrt(el * et),
                  duration: J
                }
              }
            }(J);
            (et = {
              ...et,
              ...eo,
              mass: 1
            }).isResolvedFromDuration = !0
          }
          return et
        }({
          ...el,
          velocity: -millisecondsToSeconds(el.velocity || 0)
        })
        , e_ = eb || 0
        , ex = em / (2 * Math.sqrt(ef * eg))
        , eE = eh - ed
        , eC = millisecondsToSeconds(Math.sqrt(ef / eg))
        , eS = 5 > Math.abs(eE);
      if (eo || (eo = eS ? .01 : 2),
        et || (et = eS ? .005 : .5),
        ex < 1) {
        let J = calcAngularFreq(eC, ex);
        ec = et => {
          let eo = Math.exp(-ex * eC * et);
          return eh - eo * ((e_ + ex * eC * eE) / J * Math.sin(J * et) + eE * Math.cos(J * et))
        }
      } else if (1 === ex)
        ec = J => eh - Math.exp(-eC * J) * (eE + (e_ + eC * eE) * J);
      else {
        let J = eC * Math.sqrt(ex * ex - 1);
        ec = et => {
          let eo = Math.exp(-ex * eC * et)
            , el = Math.min(J * et, 300);
          return eh - eo * ((e_ + ex * eC * eE) * Math.sinh(el) + J * eE * Math.cosh(el)) / J
        }
      }
      return {
        calculatedDuration: ew && ey || null,
        next: J => {
          let el = ec(J);
          if (ew)
            ep.done = J >= ey;
          else {
            let ed = e_;
            0 !== J && (ed = ex < 1 ? calcGeneratorVelocity(ec, J, el) : 0);
            let ef = Math.abs(ed) <= eo
              , em = Math.abs(eh - el) <= et;
            ep.done = ef && em
          }
          return ep.value = ep.done ? eh : el,
            ep
        }
      }
    }
    function inertia({ keyframes: J, velocity: et = 0, power: eo = .8, timeConstant: el = 325, bounceDamping: ec = 10, bounceStiffness: ed = 500, modifyTarget: eh, min: ep, max: ef, restDelta: em = .5, restSpeed: eg }) {
      let ey, eb;
      let ew = J[0]
        , e_ = {
          done: !1,
          value: ew
        }
        , isOutOfBounds = J => void 0 !== ep && J < ep || void 0 !== ef && J > ef
        , nearestBoundary = J => void 0 === ep ? ef : void 0 === ef ? ep : Math.abs(ep - J) < Math.abs(ef - J) ? ep : ef
        , ex = eo * et
        , eE = ew + ex
        , eC = void 0 === eh ? eE : eh(eE);
      eC !== eE && (ex = eC - ew);
      let calcDelta = J => -ex * Math.exp(-J / el)
        , calcLatest = J => eC + calcDelta(J)
        , applyFriction = J => {
          let et = calcDelta(J)
            , eo = calcLatest(J);
          e_.done = Math.abs(et) <= em,
            e_.value = e_.done ? eC : eo
        }
        , checkCatchBoundary = J => {
          isOutOfBounds(e_.value) && (ey = J,
            eb = spring({
              keyframes: [e_.value, nearestBoundary(e_.value)],
              velocity: calcGeneratorVelocity(calcLatest, J, e_.value),
              damping: ec,
              stiffness: ed,
              restDelta: em,
              restSpeed: eg
            }))
        }
        ;
      return checkCatchBoundary(0),
      {
        calculatedDuration: null,
        next: J => {
          let et = !1;
          return (eb || void 0 !== ey || (et = !0,
            applyFriction(J),
            checkCatchBoundary(J)),
            void 0 !== ey && J > ey) ? eb.next(J - ey) : (et || applyFriction(J),
              e_)
        }
      }
    }
    var tj = eo(22081);
    function clearTime() {
      el = void 0
    }
    let tL = {
      now: () => (void 0 === el && tL.set(e4.frameData.isProcessing || tj.c.useManualTiming ? e4.frameData.timestamp : performance.now()),
        el),
      set: J => {
        el = J,
          queueMicrotask(clearTime)
      }
    }
      , frameloopDriver = J => {
        let passTimestamp = ({ timestamp: et }) => J(et);
        return {
          start: () => e4.Wi.update(passTimestamp, !0),
          stop: () => (0,
            e4.Pn)(passTimestamp),
          now: () => e4.frameData.isProcessing ? e4.frameData.timestamp : tL.now()
        }
      }
      ;
    function calcGeneratorDuration(J) {
      let et = 0
        , eo = J.next(et);
      for (; !eo.done && et < 2e4;)
        et += 50,
          eo = J.next(et);
      return et >= 2e4 ? 1 / 0 : et
    }
    let t$ = {
      decay: inertia,
      inertia: inertia,
      tween: keyframes,
      keyframes: keyframes,
      spring: spring
    };
    function animateValue({ autoplay: J = !0, delay: et = 0, driver: eo = frameloopDriver, keyframes: el, type: ec = "keyframes", repeat: ed = 0, repeatDelay: eh = 0, repeatType: ep = "loop", onPlay: ef, onStop: em, onComplete: eg, onUpdate: ey, ...eb }) {
      let ew, e_, ex, eE, eC, eS = 1, ek = !1, updateFinishedPromise = () => {
        e_ = new Promise(J => {
          ew = J
        }
        )
      }
        ;
      updateFinishedPromise();
      let eT = t$[ec] || keyframes;
      eT !== keyframes && "number" != typeof el[0] && (eE = interpolate([0, 100], el, {
        clamp: !1
      }),
        el = [0, 100]);
      let eA = eT({
        ...eb,
        keyframes: el
      });
      "mirror" === ep && (eC = eT({
        ...eb,
        keyframes: [...el].reverse(),
        velocity: -(eb.velocity || 0)
      }));
      let eP = "idle"
        , eR = null
        , eI = null
        , eO = null;
      null === eA.calculatedDuration && ed && (eA.calculatedDuration = calcGeneratorDuration(eA));
      let { calculatedDuration: eN } = eA
        , eM = 1 / 0
        , eD = 1 / 0;
      null !== eN && (eD = (eM = eN + eh) * (ed + 1) - eh);
      let ej = 0
        , tick = J => {
          if (null === eI)
            return;
          eS > 0 && (eI = Math.min(eI, J)),
            eS < 0 && (eI = Math.min(J - eD / eS, eI)),
            ej = null !== eR ? eR : Math.round(J - eI) * eS;
          let eo = ej - et * (eS >= 0 ? 1 : -1)
            , ec = eS >= 0 ? eo < 0 : eo > eD;
          ej = Math.max(eo, 0),
            "finished" === eP && null === eR && (ej = eD);
          let ef = ej
            , em = eA;
          if (ed) {
            let J = Math.min(ej, eD) / eM
              , et = Math.floor(J)
              , eo = J % 1;
            !eo && J >= 1 && (eo = 1),
              1 === eo && et--,
              et = Math.min(et, ed + 1);
            let el = !!(et % 2);
            el && ("reverse" === ep ? (eo = 1 - eo,
              eh && (eo -= eh / eM)) : "mirror" === ep && (em = eC)),
              ef = clamp(0, 1, eo) * eM
          }
          let eg = ec ? {
            done: !1,
            value: el[0]
          } : em.next(ef);
          eE && (eg.value = eE(eg.value));
          let { done: eb } = eg;
          ec || null === eN || (eb = eS >= 0 ? ej >= eD : ej <= 0);
          let ew = null === eR && ("finished" === eP || "running" === eP && eb);
          return ey && ey(eg.value),
            ew && finish(),
            eg
        }
        , stopAnimationDriver = () => {
          ex && ex.stop(),
            ex = void 0
        }
        , cancel = () => {
          eP = "idle",
            stopAnimationDriver(),
            ew(),
            updateFinishedPromise(),
            eI = eO = null
        }
        , finish = () => {
          eP = "finished",
            eg && eg(),
            stopAnimationDriver(),
            ew()
        }
        , play = () => {
          if (ek)
            return;
          ex || (ex = eo(tick));
          let J = ex.now();
          ef && ef(),
            null !== eR ? eI = J - eR : eI && "finished" !== eP || (eI = J),
            "finished" === eP && updateFinishedPromise(),
            eO = eI,
            eR = null,
            eP = "running",
            ex.start()
        }
        ;
      J && play();
      let eL = {
        then: (J, et) => e_.then(J, et),
        get time() {
          return millisecondsToSeconds(ej)
        },
        set time(newTime) {
          ej = newTime = secondsToMilliseconds(newTime),
            null === eR && ex && 0 !== eS ? eI = ex.now() - newTime / eS : eR = newTime
        },
        get duration() {
          let J = null === eA.calculatedDuration ? calcGeneratorDuration(eA) : eA.calculatedDuration;
          return millisecondsToSeconds(J)
        },
        get speed() {
          return eS
        },
        set speed(newSpeed) {
          if (newSpeed === eS || !ex)
            return;
          eS = newSpeed,
            eL.time = millisecondsToSeconds(ej)
        },
        get state() {
          return eP
        },
        play,
        pause: () => {
          eP = "paused",
            eR = ej
        }
        ,
        stop: () => {
          ek = !0,
            "idle" !== eP && (eP = "idle",
              em && em(),
              cancel())
        }
        ,
        cancel: () => {
          null !== eO && tick(eO),
            cancel()
        }
        ,
        complete: () => {
          eP = "finished"
        }
        ,
        sample: J => (eI = 0,
          tick(J))
      };
      return eL
    }
    let tB = (eh = () => Object.hasOwnProperty.call(Element.prototype, "animate"),
      () => (void 0 === ec && (ec = eh()),
        ec))
      , tF = new Set(["opacity", "clipPath", "filter", "transform", "backgroundColor"])
      , requiresPregeneratedKeyframes = (J, et) => "spring" === et.type || "backgroundColor" === J || !function isWaapiSupportedEasing(J) {
        return !!(!J || "string" == typeof J && tp[J] || isBezierDefinition(J) || Array.isArray(J) && J.every(isWaapiSupportedEasing))
      }(et.ease)
      , tU = {
        type: "spring",
        stiffness: 500,
        damping: 25,
        restSpeed: 10
      }
      , criticallyDampedSpring = J => ({
        type: "spring",
        stiffness: 550,
        damping: 0 === J ? 2 * Math.sqrt(550) : 30,
        restSpeed: 10
      })
      , tz = {
        type: "keyframes",
        duration: .8
      }
      , tH = {
        type: "keyframes",
        ease: [.25, .1, .35, 1],
        duration: .3
      }
      , getDefaultTransition = (J, { keyframes: et }) => et.length > 2 ? tz : eD.has(J) ? J.startsWith("scale") ? criticallyDampedSpring(et[1]) : tU : tH
      , isAnimatable = (J, et) => "zIndex" !== J && !!("number" == typeof et || Array.isArray(et) || "string" == typeof et && (tN.test(et) || "0" === et) && !et.startsWith("url("))
      , tV = new Set(["brightness", "contrast", "saturate", "opacity"]);
    function applyDefaultFilter(J) {
      let [et, eo] = J.slice(0, -1).split("(");
      if ("drop-shadow" === et)
        return J;
      let [el] = eo.match(eH) || [];
      if (!el)
        return J;
      let ec = eo.replace(el, "")
        , ed = tV.has(et) ? 1 : 0;
      return el !== eo && (ed *= 100),
        et + "(" + ed + ec + ")"
    }
    let tW = /([a-z-]*)\(.*?\)/g
      , tq = {
        ...tN,
        getAnimatableNone: J => {
          let et = J.match(tW);
          return et ? et.map(applyDefaultFilter).join(" ") : J
        }
      }
      , tZ = {
        ...e0,
        color: tA,
        backgroundColor: tA,
        outlineColor: tA,
        fill: tA,
        stroke: tA,
        borderColor: tA,
        borderTopColor: tA,
        borderRightColor: tA,
        borderBottomColor: tA,
        borderLeftColor: tA,
        filter: tq,
        WebkitFilter: tq
      }
      , getDefaultValueType = J => tZ[J];
    function animatable_none_getAnimatableNone(J, et) {
      let eo = getDefaultValueType(J);
      return eo !== tq && (eo = tN),
        eo.getAnimatableNone ? eo.getAnimatableNone(et) : void 0
    }
    let isZeroValueString = J => /^0[^.\s]+$/.test(J);
    function getValueTransition(J, et) {
      return J[et] || J.default || J
    }
    let animateMotionValue = (J, et, eo, el = {}) => ec => {
      let ed = getValueTransition(el, J) || {}
        , eh = ed.delay || el.delay || 0
        , { elapsed: ep = 0 } = el;
      ep -= secondsToMilliseconds(eh);
      let ef = function (J, et, eo, el) {
        let ec, ed;
        let eh = isAnimatable(et, eo);
        ec = Array.isArray(eo) ? [...eo] : [null, eo];
        let ep = void 0 !== el.from ? el.from : J.get()
          , ef = [];
        for (let J = 0; J < ec.length; J++) {
          var em;
          null === ec[J] && (ec[J] = 0 === J ? ep : ec[J - 1]),
            ("number" == typeof (em = ec[J]) ? 0 === em : null !== em ? "none" === em || "0" === em || isZeroValueString(em) : void 0) && ef.push(J),
            "string" == typeof ec[J] && "none" !== ec[J] && "0" !== ec[J] && (ed = ec[J])
        }
        if (eh && ef.length && ed)
          for (let J = 0; J < ef.length; J++) {
            let eo = ef[J];
            ec[eo] = animatable_none_getAnimatableNone(et, ed)
          }
        return ec
      }(et, J, eo, ed)
        , em = ef[0]
        , eg = ef[ef.length - 1]
        , ey = isAnimatable(J, em)
        , eb = isAnimatable(J, eg);
      (0,
        td.K)(ey === eb, `You are trying to animate ${J} from "${em}" to "${eg}". ${em} is not an animatable value - to enable this animation set ${em} to a value animatable to ${eg} via the \`style\` property.`);
      let ew = {
        keyframes: ef,
        velocity: et.getVelocity(),
        ease: "easeOut",
        ...ed,
        delay: -ep,
        onUpdate: J => {
          et.set(J),
            ed.onUpdate && ed.onUpdate(J)
        }
        ,
        onComplete: () => {
          ec(),
            ed.onComplete && ed.onComplete()
        }
      };
      if (!function ({ when: J, delay: et, delayChildren: eo, staggerChildren: el, staggerDirection: ec, repeat: ed, repeatType: eh, repeatDelay: ep, from: ef, elapsed: em, ...eg }) {
        return !!Object.keys(eg).length
      }(ed) && (ew = {
        ...ew,
        ...getDefaultTransition(J, ew)
      }),
        ew.duration && (ew.duration = secondsToMilliseconds(ew.duration)),
        ew.repeatDelay && (ew.repeatDelay = secondsToMilliseconds(ew.repeatDelay)),
        !ey || !eb || th.current || !1 === ed.type || tj.c.skipAnimations)
        return function ({ keyframes: J, delay: et, onUpdate: eo, onComplete: el }) {
          let setValue = () => (eo && eo(J[J.length - 1]),
            el && el(),
          {
            time: 0,
            speed: 1,
            duration: 0,
            play: to.Z,
            pause: to.Z,
            stop: to.Z,
            then: J => (J(),
              Promise.resolve()),
            cancel: to.Z,
            complete: to.Z
          });
          return et ? animateValue({
            keyframes: [0, 1],
            duration: 0,
            delay: et,
            onComplete: setValue
          }) : setValue()
        }(th.current ? {
          ...ew,
          delay: 0
        } : ew);
      if (!el.isHandoff && et.owner && et.owner.current instanceof HTMLElement && !et.owner.getProps().onUpdate) {
        let eo = function (J, et, { onUpdate: eo, onComplete: el, ...ec }) {
          let ed, eh;
          let ep = tB() && tF.has(et) && !ec.repeatDelay && "mirror" !== ec.repeatType && 0 !== ec.damping && "inertia" !== ec.type;
          if (!ep)
            return !1;
          let ef = !1
            , em = !1
            , updateFinishedPromise = () => {
              eh = new Promise(J => {
                ed = J
              }
              )
            }
            ;
          updateFinishedPromise();
          let { keyframes: eg, duration: ey = 300, ease: eb, times: ew } = ec;
          if (requiresPregeneratedKeyframes(et, ec)) {
            let J = animateValue({
              ...ec,
              repeat: 0,
              delay: 0
            })
              , et = {
                done: !1,
                value: eg[0]
              }
              , eo = []
              , el = 0;
            for (; !et.done && el < 2e4;)
              et = J.sample(el),
                eo.push(et.value),
                el += 10;
            ew = void 0,
              eg = eo,
              ey = el - 10,
              eb = "linear"
          }
          let e_ = function (J, et, eo, { delay: el = 0, duration: ec, repeat: ed = 0, repeatType: eh = "loop", ease: ep, times: ef } = {}) {
            let em = {
              [et]: eo
            };
            ef && (em.offset = ef);
            let eg = function mapEasingToNativeEasing(J) {
              if (J)
                return isBezierDefinition(J) ? cubicBezierAsString(J) : Array.isArray(J) ? J.map(mapEasingToNativeEasing) : tp[J]
            }(ep);
            return Array.isArray(eg) && (em.easing = eg),
              J.animate(em, {
                delay: el,
                duration: ec,
                easing: Array.isArray(eg) ? "linear" : eg,
                fill: "both",
                iterations: ed + 1,
                direction: "reverse" === eh ? "alternate" : "normal"
              })
          }(J.owner.current, et, eg, {
            ...ec,
            duration: ey,
            ease: eb,
            times: ew
          })
            , cancelAnimation = () => {
              em = !1,
                e_.cancel()
            }
            , safeCancel = () => {
              em = !0,
                e4.Wi.update(cancelAnimation),
                ed(),
                updateFinishedPromise()
            }
            ;
          return e_.onfinish = () => {
            em || (J.set(function (J, { repeat: et, repeatType: eo = "loop" }) {
              let el = et && "loop" !== eo && et % 2 == 1 ? 0 : J.length - 1;
              return J[el]
            }(eg, ec)),
              el && el(),
              safeCancel())
          }
            ,
          {
            then: (J, et) => eh.then(J, et),
            attachTimeline: J => (e_.timeline = J,
              e_.onfinish = null,
              to.Z),
            get time() {
              return millisecondsToSeconds(e_.currentTime || 0)
            },
            set time(newTime) {
              e_.currentTime = secondsToMilliseconds(newTime)
            },
            get speed() {
              return e_.playbackRate
            },
            set speed(newSpeed) {
              e_.playbackRate = newSpeed
            },
            get duration() {
              return millisecondsToSeconds(ey)
            },
            play: () => {
              ef || (e_.play(),
                (0,
                  e4.Pn)(cancelAnimation))
            }
            ,
            pause: () => e_.pause(),
            stop: () => {
              if (ef = !0,
                "idle" === e_.playState)
                return;
              let { currentTime: et } = e_;
              if (et) {
                let eo = animateValue({
                  ...ec,
                  autoplay: !1
                });
                J.setWithVelocity(eo.sample(et - 10).value, eo.sample(et).value, 10)
              }
              safeCancel()
            }
            ,
            complete: () => {
              em || e_.finish()
            }
            ,
            cancel: safeCancel
          }
        }(et, J, ew);
        if (eo)
          return eo
      }
      return animateValue(ew)
    }
      ;
    function isWillChangeMotionValue(J) {
      return !!(isMotionValue(J) && J.add)
    }
    let isNumericalString = J => /^\-?\d*\.?\d+$/.test(J);
    function addUniqueItem(J, et) {
      -1 === J.indexOf(et) && J.push(et)
    }
    function removeItem(J, et) {
      let eo = J.indexOf(et);
      eo > -1 && J.splice(eo, 1)
    }
    let SubscriptionManager = class SubscriptionManager {
      constructor() {
        this.subscriptions = []
      }
      add(J) {
        return addUniqueItem(this.subscriptions, J),
          () => removeItem(this.subscriptions, J)
      }
      notify(J, et, eo) {
        let el = this.subscriptions.length;
        if (el) {
          if (1 === el)
            this.subscriptions[0](J, et, eo);
          else
            for (let ec = 0; ec < el; ec++) {
              let el = this.subscriptions[ec];
              el && el(J, et, eo)
            }
        }
      }
      getSize() {
        return this.subscriptions.length
      }
      clear() {
        this.subscriptions.length = 0
      }
    }
      ;
    let isFloat = J => !isNaN(parseFloat(J))
      , tG = {
        current: void 0
      };
    let MotionValue = class MotionValue {
      constructor(J, et = {}) {
        this.version = "11.0.3",
          this.canTrackVelocity = !1,
          this.events = {},
          this.updateAndNotify = (J, et = !0) => {
            let eo = tL.now();
            this.updatedAt !== eo && this.setPrevFrameValue(),
              this.prev = this.current,
              this.setCurrent(J),
              this.current !== this.prev && this.events.change && this.events.change.notify(this.current),
              et && this.events.renderRequest && this.events.renderRequest.notify(this.current)
          }
          ,
          this.hasAnimated = !1,
          this.setCurrent(J),
          this.canTrackVelocity = isFloat(this.current),
          this.owner = et.owner
      }
      setCurrent(J) {
        this.current = J,
          this.updatedAt = tL.now()
      }
      setPrevFrameValue(J = this.current) {
        this.prevFrameValue = J,
          this.prevUpdatedAt = this.updatedAt
      }
      onChange(J) {
        return this.on("change", J)
      }
      on(J, et) {
        this.events[J] || (this.events[J] = new SubscriptionManager);
        let eo = this.events[J].add(et);
        return "change" === J ? () => {
          eo(),
            e4.Wi.read(() => {
              this.events.change.getSize() || this.stop()
            }
            )
        }
          : eo
      }
      clearListeners() {
        for (let J in this.events)
          this.events[J].clear()
      }
      attach(J, et) {
        this.passiveEffect = J,
          this.stopPassiveEffect = et
      }
      set(J, et = !0) {
        et && this.passiveEffect ? this.passiveEffect(J, this.updateAndNotify) : this.updateAndNotify(J, et)
      }
      setWithVelocity(J, et, eo) {
        this.set(et),
          this.prev = void 0,
          this.prevFrameValue = J,
          this.prevUpdatedAt = this.updatedAt - eo
      }
      jump(J) {
        this.updateAndNotify(J),
          this.prev = J,
          this.prevUpdatedAt = this.prevFrameValue = void 0,
          this.stop(),
          this.stopPassiveEffect && this.stopPassiveEffect()
      }
      get() {
        return tG.current && tG.current.push(this),
          this.current
      }
      getPrevious() {
        return this.prev
      }
      getVelocity() {
        var J;
        let et = tL.now();
        if (!this.canTrackVelocity || void 0 === this.prevFrameValue || et - this.updatedAt > 30)
          return 0;
        let eo = Math.min(this.updatedAt - this.prevUpdatedAt, 30);
        return J = parseFloat(this.current) - parseFloat(this.prevFrameValue),
          eo ? J * (1e3 / eo) : 0
      }
      start(J) {
        return this.stop(),
          new Promise(et => {
            this.hasAnimated = !0,
              this.animation = J(et),
              this.events.animationStart && this.events.animationStart.notify()
          }
          ).then(() => {
            this.events.animationComplete && this.events.animationComplete.notify(),
              this.clearAnimation()
          }
          )
      }
      stop() {
        this.animation && (this.animation.stop(),
          this.events.animationCancel && this.events.animationCancel.notify()),
          this.clearAnimation()
      }
      isAnimating() {
        return !!this.animation
      }
      clearAnimation() {
        delete this.animation
      }
      destroy() {
        this.clearListeners(),
          this.stop(),
          this.stopPassiveEffect && this.stopPassiveEffect()
      }
    }
      ;
    function motionValue(J, et) {
      return new MotionValue(J, et)
    }
    let testValueType = J => et => et.test(J)
      , tY = [eF, eY, eG, eZ, eJ, eK, {
        test: J => "auto" === J,
        parse: J => J
      }]
      , findDimensionValueType = J => tY.find(testValueType(J))
      , tK = [...tY, tA, tN]
      , findValueType = J => tK.find(testValueType(J));
    function animateTarget(J, et, { delay: eo = 0, transitionOverride: el, type: ec } = {}) {
      let { transition: ed = J.getDefaultTransition(), transitionEnd: eh, ...ep } = J.makeTargetAnimatable(et)
        , ef = J.getValue("willChange");
      el && (ed = el);
      let em = []
        , eg = ec && J.animationState && J.animationState.getState()[ec];
      for (let et in ep) {
        let el = J.getValue(et)
          , ec = ep[et];
        if (!el || void 0 === ec || eg && function ({ protectedKeys: J, needsAnimating: et }, eo) {
          let el = J.hasOwnProperty(eo) && !0 !== et[eo];
          return et[eo] = !1,
            el
        }(eg, et))
          continue;
        let eh = {
          delay: eo,
          elapsed: 0,
          ...getValueTransition(ed || {}, et)
        };
        if (window.HandoffAppearAnimations) {
          let eo = J.getProps()[ew];
          if (eo) {
            let J = window.HandoffAppearAnimations(eo, et, el, e4.Wi);
            null !== J && (eh.elapsed = J,
              eh.isHandoff = !0)
          }
        }
        let ey = !eh.isHandoff && !function (J, et) {
          let eo = J.get();
          if (!Array.isArray(et))
            return eo !== et;
          for (let J = 0; J < et.length; J++)
            if (et[J] !== eo)
              return !0
        }(el, ec);
        if ("spring" === eh.type && (el.getVelocity() || eh.velocity) && (ey = !1),
          el.animation && (ey = !1),
          ey)
          continue;
        el.start(animateMotionValue(et, el, ec, J.shouldReduceMotion && eD.has(et) ? {
          type: !1
        } : eh));
        let eb = el.animation;
        isWillChangeMotionValue(ef) && (ef.add(et),
          eb.then(() => ef.remove(et))),
          em.push(eb)
      }
      return eh && Promise.all(em).then(() => {
        eh && function (J, et) {
          let eo = resolveVariant(J, et)
            , { transitionEnd: el = {}, transition: ec = {}, ...ed } = eo ? J.makeTargetAnimatable(eo, !1) : {};
          for (let et in ed = {
            ...ed,
            ...el
          }) {
            let eo = resolveFinalValueInKeyframes(ed[et]);
            J.hasValue(et) ? J.getValue(et).set(eo) : J.addValue(et, motionValue(eo))
          }
        }(J, eh)
      }
      ),
        em
    }
    function animateVariant(J, et, eo = {}) {
      let el = resolveVariant(J, et, eo.custom)
        , { transition: ec = J.getDefaultTransition() || {} } = el || {};
      eo.transitionOverride && (ec = eo.transitionOverride);
      let ed = el ? () => Promise.all(animateTarget(J, el, eo)) : () => Promise.resolve()
        , eh = J.variantChildren && J.variantChildren.size ? (el = 0) => {
          let { delayChildren: ed = 0, staggerChildren: eh, staggerDirection: ep } = ec;
          return function (J, et, eo = 0, el = 0, ec = 1, ed) {
            let eh = []
              , ep = (J.variantChildren.size - 1) * el
              , ef = 1 === ec ? (J = 0) => J * el : (J = 0) => ep - J * el;
            return Array.from(J.variantChildren).sort(sortByTreeOrder).forEach((J, el) => {
              J.notify("AnimationStart", et),
                eh.push(animateVariant(J, et, {
                  ...ed,
                  delay: eo + ef(el)
                }).then(() => J.notify("AnimationComplete", et)))
            }
            ),
              Promise.all(eh)
          }(J, et, ed + el, eh, ep, eo)
        }
          : () => Promise.resolve()
        , { when: ep } = ec;
      if (!ep)
        return Promise.all([ed(), eh(eo.delay)]);
      {
        let [J, et] = "beforeChildren" === ep ? [ed, eh] : [eh, ed];
        return J().then(() => et())
      }
    }
    function sortByTreeOrder(J, et) {
      return J.sortNodePosition(et)
    }
    let tJ = [...eC].reverse()
      , tQ = eC.length;
    function createTypeState(J = !1) {
      return {
        isActive: J,
        protectedKeys: {},
        needsAnimating: {},
        prevResolvedValues: {}
      }
    }
    let tX = 0
      , distance = (J, et) => Math.abs(J - et);
    let PanSession = class PanSession {
      constructor(J, et, { transformPagePoint: eo, contextWindow: el, dragSnapToOrigin: ec = !1 } = {}) {
        if (this.startEvent = null,
          this.lastMoveEvent = null,
          this.lastMoveEventInfo = null,
          this.handlers = {},
          this.contextWindow = window,
          this.updatePoint = () => {
            if (!(this.lastMoveEvent && this.lastMoveEventInfo))
              return;
            let J = getPanInfo(this.lastMoveEventInfo, this.history)
              , et = null !== this.startEvent
              , eo = function (J, et) {
                let eo = distance(J.x, et.x)
                  , el = distance(J.y, et.y);
                return Math.sqrt(eo ** 2 + el ** 2)
              }(J.offset, {
                x: 0,
                y: 0
              }) >= 3;
            if (!et && !eo)
              return;
            let { point: el } = J
              , { timestamp: ec } = e4.frameData;
            this.history.push({
              ...el,
              timestamp: ec
            });
            let { onStart: ed, onMove: eh } = this.handlers;
            et || (ed && ed(this.lastMoveEvent, J),
              this.startEvent = this.lastMoveEvent),
              eh && eh(this.lastMoveEvent, J)
          }
          ,
          this.handlePointerMove = (J, et) => {
            this.lastMoveEvent = J,
              this.lastMoveEventInfo = transformPoint(et, this.transformPagePoint),
              e4.Wi.update(this.updatePoint, !0)
          }
          ,
          this.handlePointerUp = (J, et) => {
            this.end();
            let { onEnd: eo, onSessionEnd: el, resumeAnimation: ec } = this.handlers;
            if (this.dragSnapToOrigin && ec && ec(),
              !(this.lastMoveEvent && this.lastMoveEventInfo))
              return;
            let ed = getPanInfo("pointercancel" === J.type ? this.lastMoveEventInfo : transformPoint(et, this.transformPagePoint), this.history);
            this.startEvent && eo && eo(J, ed),
              el && el(J, ed)
          }
          ,
          !isPrimaryPointer(J))
          return;
        this.dragSnapToOrigin = ec,
          this.handlers = et,
          this.transformPagePoint = eo,
          this.contextWindow = el || window;
        let ed = extractEventInfo(J)
          , eh = transformPoint(ed, this.transformPagePoint)
          , { point: ep } = eh
          , { timestamp: ef } = e4.frameData;
        this.history = [{
          ...ep,
          timestamp: ef
        }];
        let { onSessionStart: em } = et;
        em && em(J, getPanInfo(eh, this.history)),
          this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp))
      }
      updateHandlers(J) {
        this.handlers = J
      }
      end() {
        this.removeListeners && this.removeListeners(),
          (0,
            e4.Pn)(this.updatePoint)
      }
    }
      ;
    function transformPoint(J, et) {
      return et ? {
        point: et(J.point)
      } : J
    }
    function subtractPoint(J, et) {
      return {
        x: J.x - et.x,
        y: J.y - et.y
      }
    }
    function getPanInfo({ point: J }, et) {
      return {
        point: J,
        delta: subtractPoint(J, lastDevicePoint(et)),
        offset: subtractPoint(J, et[0]),
        velocity: function (J, et) {
          if (J.length < 2)
            return {
              x: 0,
              y: 0
            };
          let eo = J.length - 1
            , el = null
            , ec = lastDevicePoint(J);
          for (; eo >= 0 && (el = J[eo],
            !(ec.timestamp - el.timestamp > secondsToMilliseconds(.1)));)
            eo--;
          if (!el)
            return {
              x: 0,
              y: 0
            };
          let ed = millisecondsToSeconds(ec.timestamp - el.timestamp);
          if (0 === ed)
            return {
              x: 0,
              y: 0
            };
          let eh = {
            x: (ec.x - el.x) / ed,
            y: (ec.y - el.y) / ed
          };
          return eh.x === 1 / 0 && (eh.x = 0),
            eh.y === 1 / 0 && (eh.y = 0),
            eh
        }(et, 0)
      }
    }
    function lastDevicePoint(J) {
      return J[J.length - 1]
    }
    function calcLength(J) {
      return J.max - J.min
    }
    function isNear(J, et = 0, eo = .01) {
      return Math.abs(J - et) <= eo
    }
    function calcAxisDelta(J, et, eo, el = .5) {
      J.origin = el,
        J.originPoint = mix(et.min, et.max, J.origin),
        J.scale = calcLength(eo) / calcLength(et),
        (isNear(J.scale, 1, 1e-4) || isNaN(J.scale)) && (J.scale = 1),
        J.translate = mix(eo.min, eo.max, J.origin) - J.originPoint,
        (isNear(J.translate) || isNaN(J.translate)) && (J.translate = 0)
    }
    function calcBoxDelta(J, et, eo, el) {
      calcAxisDelta(J.x, et.x, eo.x, el ? el.originX : void 0),
        calcAxisDelta(J.y, et.y, eo.y, el ? el.originY : void 0)
    }
    function calcRelativeAxis(J, et, eo) {
      J.min = eo.min + et.min,
        J.max = J.min + calcLength(et)
    }
    function calcRelativeAxisPosition(J, et, eo) {
      J.min = et.min - eo.min,
        J.max = J.min + calcLength(et)
    }
    function calcRelativePosition(J, et, eo) {
      calcRelativeAxisPosition(J.x, et.x, eo.x),
        calcRelativeAxisPosition(J.y, et.y, eo.y)
    }
    function calcRelativeAxisConstraints(J, et, eo) {
      return {
        min: void 0 !== et ? J.min + et : void 0,
        max: void 0 !== eo ? J.max + eo - (J.max - J.min) : void 0
      }
    }
    function calcViewportAxisConstraints(J, et) {
      let eo = et.min - J.min
        , el = et.max - J.max;
      return et.max - et.min < J.max - J.min && ([eo, el] = [el, eo]),
      {
        min: eo,
        max: el
      }
    }
    function resolveAxisElastic(J, et, eo) {
      return {
        min: resolvePointElastic(J, et),
        max: resolvePointElastic(J, eo)
      }
    }
    function resolvePointElastic(J, et) {
      return "number" == typeof J ? J : J[et] || 0
    }
    let createAxisDelta = () => ({
      translate: 0,
      scale: 1,
      origin: 0,
      originPoint: 0
    })
      , createDelta = () => ({
        x: createAxisDelta(),
        y: createAxisDelta()
      })
      , createAxis = () => ({
        min: 0,
        max: 0
      })
      , createBox = () => ({
        x: createAxis(),
        y: createAxis()
      });
    function eachAxis(J) {
      return [J("x"), J("y")]
    }
    function convertBoundingBoxToBox({ top: J, left: et, right: eo, bottom: el }) {
      return {
        x: {
          min: et,
          max: eo
        },
        y: {
          min: J,
          max: el
        }
      }
    }
    function isIdentityScale(J) {
      return void 0 === J || 1 === J
    }
    function hasScale({ scale: J, scaleX: et, scaleY: eo }) {
      return !isIdentityScale(J) || !isIdentityScale(et) || !isIdentityScale(eo)
    }
    function hasTransform(J) {
      return hasScale(J) || has2DTranslate(J) || J.z || J.rotate || J.rotateX || J.rotateY
    }
    function has2DTranslate(J) {
      var et, eo;
      return (et = J.x) && "0%" !== et || (eo = J.y) && "0%" !== eo
    }
    function applyPointDelta(J, et, eo, el, ec) {
      return void 0 !== ec && (J = el + ec * (J - el)),
        el + eo * (J - el) + et
    }
    function applyAxisDelta(J, et = 0, eo = 1, el, ec) {
      J.min = applyPointDelta(J.min, et, eo, el, ec),
        J.max = applyPointDelta(J.max, et, eo, el, ec)
    }
    function applyBoxDelta(J, { x: et, y: eo }) {
      applyAxisDelta(J.x, et.translate, et.scale, et.originPoint),
        applyAxisDelta(J.y, eo.translate, eo.scale, eo.originPoint)
    }
    function snapToDefault(J) {
      return Number.isInteger(J) ? J : J > 1.0000000000001 || J < .999999999999 ? J : 1
    }
    function translateAxis(J, et) {
      J.min = J.min + et,
        J.max = J.max + et
    }
    function transformAxis(J, et, [eo, el, ec]) {
      let ed = void 0 !== et[ec] ? et[ec] : .5
        , eh = mix(J.min, J.max, ed);
      applyAxisDelta(J, et[eo], et[el], eh, et.scale)
    }
    let t0 = ["x", "scaleX", "originX"]
      , t1 = ["y", "scaleY", "originY"];
    function transformBox(J, et) {
      transformAxis(J.x, et, t0),
        transformAxis(J.y, et, t1)
    }
    function measureViewportBox(J, et) {
      return convertBoundingBoxToBox(function (J, et) {
        if (!et)
          return J;
        let eo = et({
          x: J.left,
          y: J.top
        })
          , el = et({
            x: J.right,
            y: J.bottom
          });
        return {
          top: eo.y,
          left: eo.x,
          bottom: el.y,
          right: el.x
        }
      }(J.getBoundingClientRect(), et))
    }
    let getContextWindow = ({ current: J }) => J ? J.ownerDocument.defaultView : null
      , t2 = new WeakMap;
    let VisualElementDragControls = class VisualElementDragControls {
      constructor(J) {
        this.openGlobalLock = null,
          this.isDragging = !1,
          this.currentDirection = null,
          this.originPoint = {
            x: 0,
            y: 0
          },
          this.constraints = !1,
          this.hasMutatedConstraints = !1,
          this.elastic = createBox(),
          this.visualElement = J
      }
      start(J, { snapToCursor: et = !1 } = {}) {
        let { presenceContext: eo } = this.visualElement;
        if (eo && !1 === eo.isPresent)
          return;
        let { dragSnapToOrigin: el } = this.getProps();
        this.panSession = new PanSession(J, {
          onSessionStart: J => {
            let { dragSnapToOrigin: eo } = this.getProps();
            eo ? this.pauseAnimation() : this.stopAnimation(),
              et && this.snapToCursor(extractEventInfo(J, "page").point)
          }
          ,
          onStart: (J, et) => {
            let { drag: eo, dragPropagation: el, onDragStart: ec } = this.getProps();
            if (eo && !el && (this.openGlobalLock && this.openGlobalLock(),
              this.openGlobalLock = getGlobalLock(eo),
              !this.openGlobalLock))
              return;
            this.isDragging = !0,
              this.currentDirection = null,
              this.resolveConstraints(),
              this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0,
                this.visualElement.projection.target = void 0),
              eachAxis(J => {
                let et = this.getAxisMotionValue(J).get() || 0;
                if (eG.test(et)) {
                  let { projection: eo } = this.visualElement;
                  if (eo && eo.layout) {
                    let el = eo.layout.layoutBox[J];
                    if (el) {
                      let J = calcLength(el);
                      et = J * (parseFloat(et) / 100)
                    }
                  }
                }
                this.originPoint[J] = et
              }
              ),
              ec && e4.Wi.update(() => ec(J, et), !1, !0);
            let { animationState: ed } = this.visualElement;
            ed && ed.setActive("whileDrag", !0)
          }
          ,
          onMove: (J, et) => {
            let { dragPropagation: eo, dragDirectionLock: el, onDirectionLock: ec, onDrag: ed } = this.getProps();
            if (!eo && !this.openGlobalLock)
              return;
            let { offset: eh } = et;
            if (el && null === this.currentDirection) {
              this.currentDirection = function (J, et = 10) {
                let eo = null;
                return Math.abs(J.y) > et ? eo = "y" : Math.abs(J.x) > et && (eo = "x"),
                  eo
              }(eh),
                null !== this.currentDirection && ec && ec(this.currentDirection);
              return
            }
            this.updateAxis("x", et.point, eh),
              this.updateAxis("y", et.point, eh),
              this.visualElement.render(),
              ed && ed(J, et)
          }
          ,
          onSessionEnd: (J, et) => this.stop(J, et),
          resumeAnimation: () => eachAxis(J => {
            var et;
            return "paused" === this.getAnimationState(J) && (null === (et = this.getAxisMotionValue(J).animation) || void 0 === et ? void 0 : et.play())
          }
          )
        }, {
          transformPagePoint: this.visualElement.getTransformPagePoint(),
          dragSnapToOrigin: el,
          contextWindow: getContextWindow(this.visualElement)
        })
      }
      stop(J, et) {
        let eo = this.isDragging;
        if (this.cancel(),
          !eo)
          return;
        let { velocity: el } = et;
        this.startAnimation(el);
        let { onDragEnd: ec } = this.getProps();
        ec && e4.Wi.update(() => ec(J, et))
      }
      cancel() {
        this.isDragging = !1;
        let { projection: J, animationState: et } = this.visualElement;
        J && (J.isAnimationBlocked = !1),
          this.panSession && this.panSession.end(),
          this.panSession = void 0;
        let { dragPropagation: eo } = this.getProps();
        !eo && this.openGlobalLock && (this.openGlobalLock(),
          this.openGlobalLock = null),
          et && et.setActive("whileDrag", !1)
      }
      updateAxis(J, et, eo) {
        let { drag: el } = this.getProps();
        if (!eo || !shouldDrag(J, el, this.currentDirection))
          return;
        let ec = this.getAxisMotionValue(J)
          , ed = this.originPoint[J] + eo[J];
        this.constraints && this.constraints[J] && (ed = function (J, { min: et, max: eo }, el) {
          return void 0 !== et && J < et ? J = el ? mix(et, J, el.min) : Math.max(J, et) : void 0 !== eo && J > eo && (J = el ? mix(eo, J, el.max) : Math.min(J, eo)),
            J
        }(ed, this.constraints[J], this.elastic[J])),
          ec.set(ed)
      }
      resolveConstraints() {
        var J;
        let { dragConstraints: et, dragElastic: eo } = this.getProps()
          , el = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : null === (J = this.visualElement.projection) || void 0 === J ? void 0 : J.layout
          , ec = this.constraints;
        et && isRefObject(et) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : et && el ? this.constraints = function (J, { top: et, left: eo, bottom: el, right: ec }) {
          return {
            x: calcRelativeAxisConstraints(J.x, eo, ec),
            y: calcRelativeAxisConstraints(J.y, et, el)
          }
        }(el.layoutBox, et) : this.constraints = !1,
          this.elastic = function (J = .35) {
            return !1 === J ? J = 0 : !0 === J && (J = .35),
            {
              x: resolveAxisElastic(J, "left", "right"),
              y: resolveAxisElastic(J, "top", "bottom")
            }
          }(eo),
          ec !== this.constraints && el && this.constraints && !this.hasMutatedConstraints && eachAxis(J => {
            this.getAxisMotionValue(J) && (this.constraints[J] = function (J, et) {
              let eo = {};
              return void 0 !== et.min && (eo.min = et.min - J.min),
                void 0 !== et.max && (eo.max = et.max - J.min),
                eo
            }(el.layoutBox[J], this.constraints[J]))
          }
          )
      }
      resolveRefConstraints() {
        var J;
        let { dragConstraints: et, onMeasureDragConstraints: eo } = this.getProps();
        if (!et || !isRefObject(et))
          return !1;
        let el = et.current;
        (0,
          td.k)(null !== el, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
        let { projection: ec } = this.visualElement;
        if (!ec || !ec.layout)
          return !1;
        let ed = function (J, et, eo) {
          let el = measureViewportBox(J, eo)
            , { scroll: ec } = et;
          return ec && (translateAxis(el.x, ec.offset.x),
            translateAxis(el.y, ec.offset.y)),
            el
        }(el, ec.root, this.visualElement.getTransformPagePoint())
          , eh = {
            x: calcViewportAxisConstraints((J = ec.layout.layoutBox).x, ed.x),
            y: calcViewportAxisConstraints(J.y, ed.y)
          };
        if (eo) {
          let J = eo(function ({ x: J, y: et }) {
            return {
              top: et.min,
              right: J.max,
              bottom: et.max,
              left: J.min
            }
          }(eh));
          this.hasMutatedConstraints = !!J,
            J && (eh = convertBoundingBoxToBox(J))
        }
        return eh
      }
      startAnimation(J) {
        let { drag: et, dragMomentum: eo, dragElastic: el, dragTransition: ec, dragSnapToOrigin: ed, onDragTransitionEnd: eh } = this.getProps()
          , ep = this.constraints || {}
          , ef = eachAxis(eh => {
            if (!shouldDrag(eh, et, this.currentDirection))
              return;
            let ef = ep && ep[eh] || {};
            ed && (ef = {
              min: 0,
              max: 0
            });
            let em = {
              type: "inertia",
              velocity: eo ? J[eh] : 0,
              bounceStiffness: el ? 200 : 1e6,
              bounceDamping: el ? 40 : 1e7,
              timeConstant: 750,
              restDelta: 1,
              restSpeed: 10,
              ...ec,
              ...ef
            };
            return this.startAxisValueAnimation(eh, em)
          }
          );
        return Promise.all(ef).then(eh)
      }
      startAxisValueAnimation(J, et) {
        let eo = this.getAxisMotionValue(J);
        return eo.start(animateMotionValue(J, eo, 0, et))
      }
      stopAnimation() {
        eachAxis(J => this.getAxisMotionValue(J).stop())
      }
      pauseAnimation() {
        eachAxis(J => {
          var et;
          return null === (et = this.getAxisMotionValue(J).animation) || void 0 === et ? void 0 : et.pause()
        }
        )
      }
      getAnimationState(J) {
        var et;
        return null === (et = this.getAxisMotionValue(J).animation) || void 0 === et ? void 0 : et.state
      }
      getAxisMotionValue(J) {
        let et = "_drag" + J.toUpperCase()
          , eo = this.visualElement.getProps()
          , el = eo[et];
        return el || this.visualElement.getValue(J, (eo.initial ? eo.initial[J] : void 0) || 0)
      }
      snapToCursor(J) {
        eachAxis(et => {
          let { drag: eo } = this.getProps();
          if (!shouldDrag(et, eo, this.currentDirection))
            return;
          let { projection: el } = this.visualElement
            , ec = this.getAxisMotionValue(et);
          if (el && el.layout) {
            let { min: eo, max: ed } = el.layout.layoutBox[et];
            ec.set(J[et] - mix(eo, ed, .5))
          }
        }
        )
      }
      scalePositionWithinConstraints() {
        if (!this.visualElement.current)
          return;
        let { drag: J, dragConstraints: et } = this.getProps()
          , { projection: eo } = this.visualElement;
        if (!isRefObject(et) || !eo || !this.constraints)
          return;
        this.stopAnimation();
        let el = {
          x: 0,
          y: 0
        };
        eachAxis(J => {
          let et = this.getAxisMotionValue(J);
          if (et) {
            let eo = et.get();
            el[J] = function (J, et) {
              let eo = .5
                , el = calcLength(J)
                , ec = calcLength(et);
              return ec > el ? eo = progress(et.min, et.max - el, J.min) : el > ec && (eo = progress(J.min, J.max - ec, et.min)),
                clamp(0, 1, eo)
            }({
              min: eo,
              max: eo
            }, this.constraints[J])
          }
        }
        );
        let { transformTemplate: ec } = this.visualElement.getProps();
        this.visualElement.current.style.transform = ec ? ec({}, "") : "none",
          eo.root && eo.root.updateScroll(),
          eo.updateLayout(),
          this.resolveConstraints(),
          eachAxis(et => {
            if (!shouldDrag(et, J, null))
              return;
            let eo = this.getAxisMotionValue(et)
              , { min: ec, max: ed } = this.constraints[et];
            eo.set(mix(ec, ed, el[et]))
          }
          )
      }
      addListeners() {
        if (!this.visualElement.current)
          return;
        t2.set(this.visualElement, this);
        let J = this.visualElement.current
          , et = addPointerEvent(J, "pointerdown", J => {
            let { drag: et, dragListener: eo = !0 } = this.getProps();
            et && eo && this.start(J)
          }
          )
          , measureDragConstraints = () => {
            let { dragConstraints: J } = this.getProps();
            isRefObject(J) && (this.constraints = this.resolveRefConstraints())
          }
          , { projection: eo } = this.visualElement
          , el = eo.addEventListener("measure", measureDragConstraints);
        eo && !eo.layout && (eo.root && eo.root.updateScroll(),
          eo.updateLayout()),
          measureDragConstraints();
        let ec = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints())
          , ed = eo.addEventListener("didUpdate", ({ delta: J, hasLayoutChanged: et }) => {
            this.isDragging && et && (eachAxis(et => {
              let eo = this.getAxisMotionValue(et);
              eo && (this.originPoint[et] += J[et].translate,
                eo.set(eo.get() + J[et].translate))
            }
            ),
              this.visualElement.render())
          }
          );
        return () => {
          ec(),
            et(),
            el(),
            ed && ed()
        }
      }
      getProps() {
        let J = this.visualElement.getProps()
          , { drag: et = !1, dragDirectionLock: eo = !1, dragPropagation: el = !1, dragConstraints: ec = !1, dragElastic: ed = .35, dragMomentum: eh = !0 } = J;
        return {
          ...J,
          drag: et,
          dragDirectionLock: eo,
          dragPropagation: el,
          dragConstraints: ec,
          dragElastic: ed,
          dragMomentum: eh
        }
      }
    }
      ;
    function shouldDrag(J, et, eo) {
      return (!0 === et || et === J) && (null === eo || eo === J)
    }
    let asyncHandler = J => (et, eo) => {
      J && e4.Wi.update(() => J(et, eo))
    }
      , t3 = {
        hasAnimatedSinceResize: !0,
        hasEverUpdated: !1
      };
    function pixelsToPercent(J, et) {
      return et.max === et.min ? 0 : J / (et.max - et.min) * 100
    }
    let t5 = {
      correct: (J, et) => {
        if (!et.target)
          return J;
        if ("string" == typeof J) {
          if (!eY.test(J))
            return J;
          J = parseFloat(J)
        }
        let eo = pixelsToPercent(J, et.target.x)
          , el = pixelsToPercent(J, et.target.y);
        return `${eo}% ${el}%`
      }
    };
    let MeasureLayoutWithContext = class MeasureLayoutWithContext extends ep.Component {
      componentDidMount() {
        let { visualElement: J, layoutGroup: et, switchLayoutGroup: eo, layoutId: el } = this.props
          , { projection: ec } = J;
        Object.assign(eN, t6),
          ec && (et.group && et.group.add(ec),
            eo && eo.register && el && eo.register(ec),
            ec.root.didUpdate(),
            ec.addEventListener("animationComplete", () => {
              this.safeToRemove()
            }
            ),
            ec.setOptions({
              ...ec.options,
              onExitComplete: () => this.safeToRemove()
            })),
          t3.hasEverUpdated = !0
      }
      getSnapshotBeforeUpdate(J) {
        let { layoutDependency: et, visualElement: eo, drag: el, isPresent: ec } = this.props
          , ed = eo.projection;
        return ed && (ed.isPresent = ec,
          el || J.layoutDependency !== et || void 0 === et ? ed.willUpdate() : this.safeToRemove(),
          J.isPresent === ec || (ec ? ed.promote() : ed.relegate() || e4.Wi.postRender(() => {
            let J = ed.getStack();
            J && J.members.length || this.safeToRemove()
          }
          ))),
          null
      }
      componentDidUpdate() {
        let { projection: J } = this.props.visualElement;
        J && (J.root.didUpdate(),
          ex.postRender(() => {
            !J.currentAnimation && J.isLead() && this.safeToRemove()
          }
          ))
      }
      componentWillUnmount() {
        let { visualElement: J, layoutGroup: et, switchLayoutGroup: eo } = this.props
          , { projection: el } = J;
        el && (el.scheduleCheckAfterUnmount(),
          et && et.group && et.group.remove(el),
          eo && eo.deregister && eo.deregister(el))
      }
      safeToRemove() {
        let { safeToRemove: J } = this.props;
        J && J()
      }
      render() {
        return null
      }
    }
      ;
    function MeasureLayout(J) {
      let [et, eo] = function () {
        let J = (0,
          ep.useContext)(eg.O);
        if (null === J)
          return [!0, null];
        let { isPresent: et, onExitComplete: eo, register: el } = J
          , ec = (0,
            ep.useId)();
        return (0,
          ep.useEffect)(() => el(ec), []),
          !et && eo ? [!1, () => eo && eo(ec)] : [!0]
      }()
        , el = (0,
          ep.useContext)(eP.p);
      return ep.createElement(MeasureLayoutWithContext, {
        ...J,
        layoutGroup: el,
        switchLayoutGroup: (0,
          ep.useContext)(eR),
        isPresent: et,
        safeToRemove: eo
      })
    }
    let t6 = {
      borderRadius: {
        ...t5,
        applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
      },
      borderTopLeftRadius: t5,
      borderTopRightRadius: t5,
      borderBottomLeftRadius: t5,
      borderBottomRightRadius: t5,
      boxShadow: {
        correct: (J, { treeScale: et, projectionDelta: eo }) => {
          let el = tN.parse(J);
          if (el.length > 5)
            return J;
          let ec = tN.createTransformer(J)
            , ed = "number" != typeof el[0] ? 1 : 0
            , eh = eo.x.scale * et.x
            , ep = eo.y.scale * et.y;
          el[0 + ed] /= eh,
            el[1 + ed] /= ep;
          let ef = mix(eh, ep, .5);
          return "number" == typeof el[2 + ed] && (el[2 + ed] /= ef),
            "number" == typeof el[3 + ed] && (el[3 + ed] /= ef),
            ec(el)
        }
      }
    }
      , t4 = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"]
      , t8 = t4.length
      , asNumber = J => "string" == typeof J ? parseFloat(J) : J
      , isPx = J => "number" == typeof J || eY.test(J);
    function getRadius(J, et) {
      return void 0 !== J[et] ? J[et] : J.borderRadius
    }
    let t7 = compress(0, .5, ty)
      , t9 = compress(.5, .95, to.Z);
    function compress(J, et, eo) {
      return el => el < J ? 0 : el > et ? 1 : eo(progress(J, et, el))
    }
    function copyAxisInto(J, et) {
      J.min = et.min,
        J.max = et.max
    }
    function copyBoxInto(J, et) {
      copyAxisInto(J.x, et.x),
        copyAxisInto(J.y, et.y)
    }
    function removePointDelta(J, et, eo, el, ec) {
      return J -= et,
        J = el + 1 / eo * (J - el),
        void 0 !== ec && (J = el + 1 / ec * (J - el)),
        J
    }
    function removeAxisTransforms(J, et, [eo, el, ec], ed, eh) {
      !function (J, et = 0, eo = 1, el = .5, ec, ed = J, eh = J) {
        if (eG.test(et)) {
          et = parseFloat(et);
          let J = mix(eh.min, eh.max, et / 100);
          et = J - eh.min
        }
        if ("number" != typeof et)
          return;
        let ep = mix(ed.min, ed.max, el);
        J === ed && (ep -= et),
          J.min = removePointDelta(J.min, et, eo, ep, ec),
          J.max = removePointDelta(J.max, et, eo, ep, ec)
      }(J, et[eo], et[el], et[ec], et.scale, ed, eh)
    }
    let ro = ["x", "scaleX", "originX"]
      , ra = ["y", "scaleY", "originY"];
    function removeBoxTransforms(J, et, eo, el) {
      removeAxisTransforms(J.x, et, ro, eo ? eo.x : void 0, el ? el.x : void 0),
        removeAxisTransforms(J.y, et, ra, eo ? eo.y : void 0, el ? el.y : void 0)
    }
    function isAxisDeltaZero(J) {
      return 0 === J.translate && 1 === J.scale
    }
    function isDeltaZero(J) {
      return isAxisDeltaZero(J.x) && isAxisDeltaZero(J.y)
    }
    function boxEqualsRounded(J, et) {
      return Math.round(J.x.min) === Math.round(et.x.min) && Math.round(J.x.max) === Math.round(et.x.max) && Math.round(J.y.min) === Math.round(et.y.min) && Math.round(J.y.max) === Math.round(et.y.max)
    }
    function aspectRatio(J) {
      return calcLength(J.x) / calcLength(J.y)
    }
    let NodeStack = class NodeStack {
      constructor() {
        this.members = []
      }
      add(J) {
        addUniqueItem(this.members, J),
          J.scheduleRender()
      }
      remove(J) {
        if (removeItem(this.members, J),
          J === this.prevLead && (this.prevLead = void 0),
          J === this.lead) {
          let J = this.members[this.members.length - 1];
          J && this.promote(J)
        }
      }
      relegate(J) {
        let et;
        let eo = this.members.findIndex(et => J === et);
        if (0 === eo)
          return !1;
        for (let J = eo; J >= 0; J--) {
          let eo = this.members[J];
          if (!1 !== eo.isPresent) {
            et = eo;
            break
          }
        }
        return !!et && (this.promote(et),
          !0)
      }
      promote(J, et) {
        let eo = this.lead;
        if (J !== eo && (this.prevLead = eo,
          this.lead = J,
          J.show(),
          eo)) {
          eo.instance && eo.scheduleRender(),
            J.scheduleRender(),
            J.resumeFrom = eo,
            et && (J.resumeFrom.preserveOpacity = !0),
            eo.snapshot && (J.snapshot = eo.snapshot,
              J.snapshot.latestValues = eo.animationValues || eo.latestValues),
            J.root && J.root.isUpdating && (J.isLayoutDirty = !0);
          let { crossfade: el } = J.options;
          !1 === el && eo.hide()
        }
      }
      exitAnimationComplete() {
        this.members.forEach(J => {
          let { options: et, resumingFrom: eo } = J;
          et.onExitComplete && et.onExitComplete(),
            eo && eo.options.onExitComplete && eo.options.onExitComplete()
        }
        )
      }
      scheduleRender() {
        this.members.forEach(J => {
          J.instance && J.scheduleRender(!1)
        }
        )
      }
      removeLeadSnapshot() {
        this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
      }
    }
      ;
    function buildProjectionTransform(J, et, eo) {
      let el = ""
        , ec = J.x.translate / et.x
        , ed = J.y.translate / et.y;
      if ((ec || ed) && (el = `translate3d(${ec}px, ${ed}px, 0) `),
        (1 !== et.x || 1 !== et.y) && (el += `scale(${1 / et.x}, ${1 / et.y}) `),
        eo) {
        let { rotate: J, rotateX: et, rotateY: ec } = eo;
        J && (el += `rotate(${J}deg) `),
          et && (el += `rotateX(${et}deg) `),
          ec && (el += `rotateY(${ec}deg) `)
      }
      let eh = J.x.scale * et.x
        , ep = J.y.scale * et.y;
      return (1 !== eh || 1 !== ep) && (el += `scale(${eh}, ${ep})`),
        el || "none"
    }
    let compareByDepth = (J, et) => J.depth - et.depth;
    let FlatTree = class FlatTree {
      constructor() {
        this.children = [],
          this.isDirty = !1
      }
      add(J) {
        addUniqueItem(this.children, J),
          this.isDirty = !0
      }
      remove(J) {
        removeItem(this.children, J),
          this.isDirty = !0
      }
      forEach(J) {
        this.isDirty && this.children.sort(compareByDepth),
          this.isDirty = !1,
          this.children.forEach(J)
      }
    }
      ;
    let rl = ["", "X", "Y", "Z"]
      , rc = {
        visibility: "hidden"
      }
      , rd = 0
      , rh = {
        type: "projectionFrame",
        totalNodes: 0,
        resolvedTargetDeltas: 0,
        recalculatedProjection: 0
      };
    function createProjectionNode({ attachResizeListener: J, defaultParent: et, measureScroll: eo, checkIsScrollRoot: el, resetTransform: ec }) {
      return class {
        constructor(J = {}, eo = null == et ? void 0 : et()) {
          this.id = rd++,
            this.animationId = 0,
            this.children = new Set,
            this.options = {},
            this.isTreeAnimating = !1,
            this.isAnimationBlocked = !1,
            this.isLayoutDirty = !1,
            this.isProjectionDirty = !1,
            this.isSharedProjectionDirty = !1,
            this.isTransformDirty = !1,
            this.updateManuallyBlocked = !1,
            this.updateBlockedByResize = !1,
            this.isUpdating = !1,
            this.isSVG = !1,
            this.needsReset = !1,
            this.shouldResetTransform = !1,
            this.treeScale = {
              x: 1,
              y: 1
            },
            this.eventHandlers = new Map,
            this.hasTreeAnimated = !1,
            this.updateScheduled = !1,
            this.projectionUpdateScheduled = !1,
            this.checkUpdateFailed = () => {
              this.isUpdating && (this.isUpdating = !1,
                this.clearAllSnapshots())
            }
            ,
            this.updateProjection = () => {
              this.projectionUpdateScheduled = !1,
                rh.totalNodes = rh.resolvedTargetDeltas = rh.recalculatedProjection = 0,
                this.nodes.forEach(propagateDirtyNodes),
                this.nodes.forEach(resolveTargetDelta),
                this.nodes.forEach(calcProjection),
                this.nodes.forEach(cleanDirtyNodes),
                window.MotionDebug && window.MotionDebug.record(rh)
            }
            ,
            this.hasProjected = !1,
            this.isVisible = !0,
            this.animationProgress = 0,
            this.sharedNodes = new Map,
            this.latestValues = J,
            this.root = eo ? eo.root || eo : this,
            this.path = eo ? [...eo.path, eo] : [],
            this.parent = eo,
            this.depth = eo ? eo.depth + 1 : 0;
          for (let J = 0; J < this.path.length; J++)
            this.path[J].shouldResetTransform = !0;
          this.root === this && (this.nodes = new FlatTree)
        }
        addEventListener(J, et) {
          return this.eventHandlers.has(J) || this.eventHandlers.set(J, new SubscriptionManager),
            this.eventHandlers.get(J).add(et)
        }
        notifyListeners(J, ...et) {
          let eo = this.eventHandlers.get(J);
          eo && eo.notify(...et)
        }
        hasListeners(J) {
          return this.eventHandlers.has(J)
        }
        mount(et, eo = this.root.hasTreeAnimated) {
          if (this.instance)
            return;
          this.isSVG = et instanceof SVGElement && "svg" !== et.tagName,
            this.instance = et;
          let { layoutId: el, layout: ec, visualElement: ed } = this.options;
          if (ed && !ed.current && ed.mount(et),
            this.root.nodes.add(this),
            this.parent && this.parent.children.add(this),
            eo && (ec || el) && (this.isLayoutDirty = !0),
            J) {
            let eo;
            let resizeUnblockUpdate = () => this.root.updateBlockedByResize = !1;
            J(et, () => {
              this.root.updateBlockedByResize = !0,
                eo && eo(),
                eo = function (J, et) {
                  let eo = tL.now()
                    , checkElapsed = ({ timestamp: el }) => {
                      let ec = el - eo;
                      ec >= et && ((0,
                        e4.Pn)(checkElapsed),
                        J(ec - et))
                    }
                    ;
                  return e4.Wi.read(checkElapsed, !0),
                    () => (0,
                      e4.Pn)(checkElapsed)
                }(resizeUnblockUpdate, 250),
                t3.hasAnimatedSinceResize && (t3.hasAnimatedSinceResize = !1,
                  this.nodes.forEach(finishAnimation))
            }
            )
          }
          el && this.root.registerSharedNode(el, this),
            !1 !== this.options.animate && ed && (el || ec) && this.addEventListener("didUpdate", ({ delta: J, hasLayoutChanged: et, hasRelativeTargetChanged: eo, layout: el }) => {
              if (this.isTreeAnimationBlocked()) {
                this.target = void 0,
                  this.relativeTarget = void 0;
                return
              }
              let ec = this.options.transition || ed.getDefaultTransition() || rp
                , { onLayoutAnimationStart: eh, onLayoutAnimationComplete: ep } = ed.getProps()
                , ef = !this.targetLayout || !boxEqualsRounded(this.targetLayout, el) || eo
                , em = !et && eo;
              if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || em || et && (ef || !this.currentAnimation)) {
                this.resumeFrom && (this.resumingFrom = this.resumeFrom,
                  this.resumingFrom.resumingFrom = void 0),
                  this.setAnimationOrigin(J, em);
                let et = {
                  ...getValueTransition(ec, "layout"),
                  onPlay: eh,
                  onComplete: ep
                };
                (ed.shouldReduceMotion || this.options.layoutRoot) && (et.delay = 0,
                  et.type = !1),
                  this.startAnimation(et)
              } else
                et || finishAnimation(this),
                  this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
              this.targetLayout = el
            }
            )
        }
        unmount() {
          this.options.layoutId && this.willUpdate(),
            this.root.nodes.remove(this);
          let J = this.getStack();
          J && J.remove(this),
            this.parent && this.parent.children.delete(this),
            this.instance = void 0,
            (0,
              e4.Pn)(this.updateProjection)
        }
        blockUpdate() {
          this.updateManuallyBlocked = !0
        }
        unblockUpdate() {
          this.updateManuallyBlocked = !1
        }
        isUpdateBlocked() {
          return this.updateManuallyBlocked || this.updateBlockedByResize
        }
        isTreeAnimationBlocked() {
          return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1
        }
        startUpdate() {
          !this.isUpdateBlocked() && (this.isUpdating = !0,
            this.nodes && this.nodes.forEach(resetRotation),
            this.animationId++)
        }
        getTransformTemplate() {
          let { visualElement: J } = this.options;
          return J && J.getProps().transformTemplate
        }
        willUpdate(J = !0) {
          if (this.root.hasTreeAnimated = !0,
            this.root.isUpdateBlocked()) {
            this.options.onExitComplete && this.options.onExitComplete();
            return
          }
          if (this.root.isUpdating || this.root.startUpdate(),
            this.isLayoutDirty)
            return;
          this.isLayoutDirty = !0;
          for (let J = 0; J < this.path.length; J++) {
            let et = this.path[J];
            et.shouldResetTransform = !0,
              et.updateScroll("snapshot"),
              et.options.layoutRoot && et.willUpdate(!1)
          }
          let { layoutId: et, layout: eo } = this.options;
          if (void 0 === et && !eo)
            return;
          let el = this.getTransformTemplate();
          this.prevTransformTemplateValue = el ? el(this.latestValues, "") : void 0,
            this.updateSnapshot(),
            J && this.notifyListeners("willUpdate")
        }
        update() {
          this.updateScheduled = !1;
          let J = this.isUpdateBlocked();
          if (J) {
            this.unblockUpdate(),
              this.clearAllSnapshots(),
              this.nodes.forEach(clearMeasurements);
            return
          }
          this.isUpdating || this.nodes.forEach(clearIsLayoutDirty),
            this.isUpdating = !1,
            this.nodes.forEach(resetTransformStyle),
            this.nodes.forEach(updateLayout),
            this.nodes.forEach(notifyLayoutUpdate),
            this.clearAllSnapshots();
          let et = tL.now();
          e4.frameData.delta = clamp(0, 1e3 / 60, et - e4.frameData.timestamp),
            e4.frameData.timestamp = et,
            e4.frameData.isProcessing = !0,
            e4.S6.update.process(e4.frameData),
            e4.S6.preRender.process(e4.frameData),
            e4.S6.render.process(e4.frameData),
            e4.frameData.isProcessing = !1
        }
        didUpdate() {
          this.updateScheduled || (this.updateScheduled = !0,
            ex.read(() => this.update()))
        }
        clearAllSnapshots() {
          this.nodes.forEach(clearSnapshot),
            this.sharedNodes.forEach(removeLeadSnapshots)
        }
        scheduleUpdateProjection() {
          this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0,
            e4.Wi.preRender(this.updateProjection, !1, !0))
        }
        scheduleCheckAfterUnmount() {
          e4.Wi.postRender(() => {
            this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
          }
          )
        }
        updateSnapshot() {
          !this.snapshot && this.instance && (this.snapshot = this.measure())
        }
        updateLayout() {
          if (!this.instance || (this.updateScroll(),
            !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
            return;
          if (this.resumeFrom && !this.resumeFrom.instance)
            for (let J = 0; J < this.path.length; J++) {
              let et = this.path[J];
              et.updateScroll()
            }
          let J = this.layout;
          this.layout = this.measure(!1),
            this.layoutCorrected = createBox(),
            this.isLayoutDirty = !1,
            this.projectionDelta = void 0,
            this.notifyListeners("measure", this.layout.layoutBox);
          let { visualElement: et } = this.options;
          et && et.notify("LayoutMeasure", this.layout.layoutBox, J ? J.layoutBox : void 0)
        }
        updateScroll(J = "measure") {
          let et = !!(this.options.layoutScroll && this.instance);
          this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === J && (et = !1),
            et && (this.scroll = {
              animationId: this.root.animationId,
              phase: J,
              isRoot: el(this.instance),
              offset: eo(this.instance)
            })
        }
        resetTransform() {
          if (!ec)
            return;
          let J = this.isLayoutDirty || this.shouldResetTransform
            , et = this.projectionDelta && !isDeltaZero(this.projectionDelta)
            , eo = this.getTransformTemplate()
            , el = eo ? eo(this.latestValues, "") : void 0
            , ed = el !== this.prevTransformTemplateValue;
          J && (et || hasTransform(this.latestValues) || ed) && (ec(this.instance, el),
            this.shouldResetTransform = !1,
            this.scheduleRender())
        }
        measure(J = !0) {
          var et;
          let eo = this.measurePageBox()
            , el = this.removeElementScroll(eo);
          return J && (el = this.removeTransform(el)),
            roundAxis((et = el).x),
            roundAxis(et.y),
          {
            animationId: this.root.animationId,
            measuredBox: eo,
            layoutBox: el,
            latestValues: {},
            source: this.id
          }
        }
        measurePageBox() {
          let { visualElement: J } = this.options;
          if (!J)
            return createBox();
          let et = J.measureViewportBox()
            , { scroll: eo } = this.root;
          return eo && (translateAxis(et.x, eo.offset.x),
            translateAxis(et.y, eo.offset.y)),
            et
        }
        removeElementScroll(J) {
          let et = createBox();
          copyBoxInto(et, J);
          for (let eo = 0; eo < this.path.length; eo++) {
            let el = this.path[eo]
              , { scroll: ec, options: ed } = el;
            if (el !== this.root && ec && ed.layoutScroll) {
              if (ec.isRoot) {
                copyBoxInto(et, J);
                let { scroll: eo } = this.root;
                eo && (translateAxis(et.x, -eo.offset.x),
                  translateAxis(et.y, -eo.offset.y))
              }
              translateAxis(et.x, ec.offset.x),
                translateAxis(et.y, ec.offset.y)
            }
          }
          return et
        }
        applyTransform(J, et = !1) {
          let eo = createBox();
          copyBoxInto(eo, J);
          for (let J = 0; J < this.path.length; J++) {
            let el = this.path[J];
            !et && el.options.layoutScroll && el.scroll && el !== el.root && transformBox(eo, {
              x: -el.scroll.offset.x,
              y: -el.scroll.offset.y
            }),
              hasTransform(el.latestValues) && transformBox(eo, el.latestValues)
          }
          return hasTransform(this.latestValues) && transformBox(eo, this.latestValues),
            eo
        }
        removeTransform(J) {
          let et = createBox();
          copyBoxInto(et, J);
          for (let J = 0; J < this.path.length; J++) {
            let eo = this.path[J];
            if (!eo.instance || !hasTransform(eo.latestValues))
              continue;
            hasScale(eo.latestValues) && eo.updateSnapshot();
            let el = createBox()
              , ec = eo.measurePageBox();
            copyBoxInto(el, ec),
              removeBoxTransforms(et, eo.latestValues, eo.snapshot ? eo.snapshot.layoutBox : void 0, el)
          }
          return hasTransform(this.latestValues) && removeBoxTransforms(et, this.latestValues),
            et
        }
        setTargetDelta(J) {
          this.targetDelta = J,
            this.root.scheduleUpdateProjection(),
            this.isProjectionDirty = !0
        }
        setOptions(J) {
          this.options = {
            ...this.options,
            ...J,
            crossfade: void 0 === J.crossfade || J.crossfade
          }
        }
        clearMeasurements() {
          this.scroll = void 0,
            this.layout = void 0,
            this.snapshot = void 0,
            this.prevTransformTemplateValue = void 0,
            this.targetDelta = void 0,
            this.target = void 0,
            this.isLayoutDirty = !1
        }
        forceRelativeParentToResolveTarget() {
          this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== e4.frameData.timestamp && this.relativeParent.resolveTargetDelta(!0)
        }
        resolveTargetDelta(J = !1) {
          var et, eo, el, ec;
          let ed = this.getLead();
          this.isProjectionDirty || (this.isProjectionDirty = ed.isProjectionDirty),
            this.isTransformDirty || (this.isTransformDirty = ed.isTransformDirty),
            this.isSharedProjectionDirty || (this.isSharedProjectionDirty = ed.isSharedProjectionDirty);
          let eh = !!this.resumingFrom || this !== ed
            , ep = !(J || eh && this.isSharedProjectionDirty || this.isProjectionDirty || (null === (et = this.parent) || void 0 === et ? void 0 : et.isProjectionDirty) || this.attemptToResolveRelativeTarget);
          if (ep)
            return;
          let { layout: ef, layoutId: em } = this.options;
          if (this.layout && (ef || em)) {
            if (this.resolvedRelativeTargetAt = e4.frameData.timestamp,
              !this.targetDelta && !this.relativeTarget) {
              let J = this.getClosestProjectingParent();
              J && J.layout && 1 !== this.animationProgress ? (this.relativeParent = J,
                this.forceRelativeParentToResolveTarget(),
                this.relativeTarget = createBox(),
                this.relativeTargetOrigin = createBox(),
                calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, J.layout.layoutBox),
                copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
            }
            if (this.relativeTarget || this.targetDelta) {
              if ((this.target || (this.target = createBox(),
                this.targetWithTransforms = createBox()),
                this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) ? (this.forceRelativeParentToResolveTarget(),
                  eo = this.target,
                  el = this.relativeTarget,
                  ec = this.relativeParent.target,
                  calcRelativeAxis(eo.x, el.x, ec.x),
                  calcRelativeAxis(eo.y, el.y, ec.y)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : copyBoxInto(this.target, this.layout.layoutBox),
                    applyBoxDelta(this.target, this.targetDelta)) : copyBoxInto(this.target, this.layout.layoutBox),
                this.attemptToResolveRelativeTarget) {
                this.attemptToResolveRelativeTarget = !1;
                let J = this.getClosestProjectingParent();
                J && !!J.resumingFrom == !!this.resumingFrom && !J.options.layoutScroll && J.target && 1 !== this.animationProgress ? (this.relativeParent = J,
                  this.forceRelativeParentToResolveTarget(),
                  this.relativeTarget = createBox(),
                  this.relativeTargetOrigin = createBox(),
                  calcRelativePosition(this.relativeTargetOrigin, this.target, J.target),
                  copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
              }
              rh.resolvedTargetDeltas++
            }
          }
        }
        getClosestProjectingParent() {
          return !this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues) ? void 0 : this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
        }
        isProjecting() {
          return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
        }
        calcProjection() {
          var J;
          let et = this.getLead()
            , eo = !!this.resumingFrom || this !== et
            , el = !0;
          if ((this.isProjectionDirty || (null === (J = this.parent) || void 0 === J ? void 0 : J.isProjectionDirty)) && (el = !1),
            eo && (this.isSharedProjectionDirty || this.isTransformDirty) && (el = !1),
            this.resolvedRelativeTargetAt === e4.frameData.timestamp && (el = !1),
            el)
            return;
          let { layout: ec, layoutId: ed } = this.options;
          if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation),
            this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0),
            !this.layout || !(ec || ed))
            return;
          copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
          let eh = this.treeScale.x
            , ep = this.treeScale.y;
          !function (J, et, eo, el = !1) {
            let ec, ed;
            let eh = eo.length;
            if (eh) {
              et.x = et.y = 1;
              for (let ep = 0; ep < eh; ep++) {
                ed = (ec = eo[ep]).projectionDelta;
                let eh = ec.instance;
                (!eh || !eh.style || "contents" !== eh.style.display) && (el && ec.options.layoutScroll && ec.scroll && ec !== ec.root && transformBox(J, {
                  x: -ec.scroll.offset.x,
                  y: -ec.scroll.offset.y
                }),
                  ed && (et.x *= ed.x.scale,
                    et.y *= ed.y.scale,
                    applyBoxDelta(J, ed)),
                  el && hasTransform(ec.latestValues) && transformBox(J, ec.latestValues))
              }
              et.x = snapToDefault(et.x),
                et.y = snapToDefault(et.y)
            }
          }(this.layoutCorrected, this.treeScale, this.path, eo),
            et.layout && !et.target && (1 !== this.treeScale.x || 1 !== this.treeScale.y) && (et.target = et.layout.layoutBox,
              et.targetWithTransforms = createBox());
          let { target: ef } = et;
          if (!ef) {
            this.projectionTransform && (this.projectionDelta = createDelta(),
              this.projectionTransform = "none",
              this.scheduleRender());
            return
          }
          this.projectionDelta || (this.projectionDelta = createDelta(),
            this.projectionDeltaWithTransform = createDelta());
          let em = this.projectionTransform;
          calcBoxDelta(this.projectionDelta, this.layoutCorrected, ef, this.latestValues),
            this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale),
            (this.projectionTransform !== em || this.treeScale.x !== eh || this.treeScale.y !== ep) && (this.hasProjected = !0,
              this.scheduleRender(),
              this.notifyListeners("projectionUpdate", ef)),
            rh.recalculatedProjection++
        }
        hide() {
          this.isVisible = !1
        }
        show() {
          this.isVisible = !0
        }
        scheduleRender(J = !0) {
          if (this.options.scheduleRender && this.options.scheduleRender(),
            J) {
            let J = this.getStack();
            J && J.scheduleRender()
          }
          this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
        }
        setAnimationOrigin(J, et = !1) {
          let eo;
          let el = this.snapshot
            , ec = el ? el.latestValues : {}
            , ed = {
              ...this.latestValues
            }
            , eh = createDelta();
          this.relativeParent && this.relativeParent.options.layoutRoot || (this.relativeTarget = this.relativeTargetOrigin = void 0),
            this.attemptToResolveRelativeTarget = !et;
          let ep = createBox()
            , ef = el ? el.source : void 0
            , em = this.layout ? this.layout.source : void 0
            , eg = ef !== em
            , ey = this.getStack()
            , eb = !ey || ey.members.length <= 1
            , ew = !!(eg && !eb && !0 === this.options.crossfade && !this.path.some(hasOpacityCrossfade));
          this.animationProgress = 0,
            this.mixTargetDelta = et => {
              let el = et / 1e3;
              if (mixAxisDelta(eh.x, J.x, el),
                mixAxisDelta(eh.y, J.y, el),
                this.setTargetDelta(eh),
                this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
                var ef, em, ey, e_;
                calcRelativePosition(ep, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
                  ey = this.relativeTarget,
                  e_ = this.relativeTargetOrigin,
                  mixAxis(ey.x, e_.x, ep.x, el),
                  mixAxis(ey.y, e_.y, ep.y, el),
                  eo && (ef = this.relativeTarget,
                    em = eo,
                    ef.x.min === em.x.min && ef.x.max === em.x.max && ef.y.min === em.y.min && ef.y.max === em.y.max) && (this.isProjectionDirty = !1),
                  eo || (eo = createBox()),
                  copyBoxInto(eo, this.relativeTarget)
              }
              eg && (this.animationValues = ed,
                function (J, et, eo, el, ec, ed) {
                  ec ? (J.opacity = mix(0, void 0 !== eo.opacity ? eo.opacity : 1, t7(el)),
                    J.opacityExit = mix(void 0 !== et.opacity ? et.opacity : 1, 0, t9(el))) : ed && (J.opacity = mix(void 0 !== et.opacity ? et.opacity : 1, void 0 !== eo.opacity ? eo.opacity : 1, el));
                  for (let ec = 0; ec < t8; ec++) {
                    let ed = `border${t4[ec]}Radius`
                      , eh = getRadius(et, ed)
                      , ep = getRadius(eo, ed);
                    if (void 0 === eh && void 0 === ep)
                      continue;
                    eh || (eh = 0),
                      ep || (ep = 0);
                    let ef = 0 === eh || 0 === ep || isPx(eh) === isPx(ep);
                    ef ? (J[ed] = Math.max(mix(asNumber(eh), asNumber(ep), el), 0),
                      (eG.test(ep) || eG.test(eh)) && (J[ed] += "%")) : J[ed] = ep
                  }
                  (et.rotate || eo.rotate) && (J.rotate = mix(et.rotate || 0, eo.rotate || 0, el))
                }(ed, ec, this.latestValues, el, ew, eb)),
                this.root.scheduleUpdateProjection(),
                this.scheduleRender(),
                this.animationProgress = el
            }
            ,
            this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
        }
        startAnimation(J) {
          this.notifyListeners("animationStart"),
            this.currentAnimation && this.currentAnimation.stop(),
            this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(),
            this.pendingAnimation && ((0,
              e4.Pn)(this.pendingAnimation),
              this.pendingAnimation = void 0),
            this.pendingAnimation = e4.Wi.update(() => {
              t3.hasAnimatedSinceResize = !0,
                this.currentAnimation = function (J, et, eo) {
                  let el = isMotionValue(J) ? J : motionValue(J);
                  return el.start(animateMotionValue("", el, 1e3, eo)),
                    el.animation
                }(0, 0, {
                  ...J,
                  onUpdate: et => {
                    this.mixTargetDelta(et),
                      J.onUpdate && J.onUpdate(et)
                  }
                  ,
                  onComplete: () => {
                    J.onComplete && J.onComplete(),
                      this.completeAnimation()
                  }
                }),
                this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation),
                this.pendingAnimation = void 0
            }
            )
        }
        completeAnimation() {
          this.resumingFrom && (this.resumingFrom.currentAnimation = void 0,
            this.resumingFrom.preserveOpacity = void 0);
          let J = this.getStack();
          J && J.exitAnimationComplete(),
            this.resumingFrom = this.currentAnimation = this.animationValues = void 0,
            this.notifyListeners("animationComplete")
        }
        finishAnimation() {
          this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(1e3),
            this.currentAnimation.stop()),
            this.completeAnimation()
        }
        applyTransformsToTarget() {
          let J = this.getLead()
            , { targetWithTransforms: et, target: eo, layout: el, latestValues: ec } = J;
          if (et && eo && el) {
            if (this !== J && this.layout && el && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, el.layoutBox)) {
              eo = this.target || createBox();
              let et = calcLength(this.layout.layoutBox.x);
              eo.x.min = J.target.x.min,
                eo.x.max = eo.x.min + et;
              let el = calcLength(this.layout.layoutBox.y);
              eo.y.min = J.target.y.min,
                eo.y.max = eo.y.min + el
            }
            copyBoxInto(et, eo),
              transformBox(et, ec),
              calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, et, ec)
          }
        }
        registerSharedNode(J, et) {
          this.sharedNodes.has(J) || this.sharedNodes.set(J, new NodeStack);
          let eo = this.sharedNodes.get(J);
          eo.add(et);
          let el = et.options.initialPromotionConfig;
          et.promote({
            transition: el ? el.transition : void 0,
            preserveFollowOpacity: el && el.shouldPreserveFollowOpacity ? el.shouldPreserveFollowOpacity(et) : void 0
          })
        }
        isLead() {
          let J = this.getStack();
          return !J || J.lead === this
        }
        getLead() {
          var J;
          let { layoutId: et } = this.options;
          return et && (null === (J = this.getStack()) || void 0 === J ? void 0 : J.lead) || this
        }
        getPrevLead() {
          var J;
          let { layoutId: et } = this.options;
          return et ? null === (J = this.getStack()) || void 0 === J ? void 0 : J.prevLead : void 0
        }
        getStack() {
          let { layoutId: J } = this.options;
          if (J)
            return this.root.sharedNodes.get(J)
        }
        promote({ needsReset: J, transition: et, preserveFollowOpacity: eo } = {}) {
          let el = this.getStack();
          el && el.promote(this, eo),
            J && (this.projectionDelta = void 0,
              this.needsReset = !0),
            et && this.setOptions({
              transition: et
            })
        }
        relegate() {
          let J = this.getStack();
          return !!J && J.relegate(this)
        }
        resetRotation() {
          let { visualElement: J } = this.options;
          if (!J)
            return;
          let et = !1
            , { latestValues: eo } = J;
          if ((eo.rotate || eo.rotateX || eo.rotateY || eo.rotateZ) && (et = !0),
            !et)
            return;
          let el = {};
          for (let et = 0; et < rl.length; et++) {
            let ec = "rotate" + rl[et];
            eo[ec] && (el[ec] = eo[ec],
              J.setStaticValue(ec, 0))
          }
          for (let et in J.render(),
            el)
            J.setStaticValue(et, el[et]);
          J.scheduleRender()
        }
        getProjectionStyles(J) {
          var et, eo;
          if (!this.instance || this.isSVG)
            return;
          if (!this.isVisible)
            return rc;
          let el = {
            visibility: ""
          }
            , ec = this.getTransformTemplate();
          if (this.needsReset)
            return this.needsReset = !1,
              el.opacity = "",
              el.pointerEvents = resolveMotionValue(null == J ? void 0 : J.pointerEvents) || "",
              el.transform = ec ? ec(this.latestValues, "") : "none",
              el;
          let ed = this.getLead();
          if (!this.projectionDelta || !this.layout || !ed.target) {
            let et = {};
            return this.options.layoutId && (et.opacity = void 0 !== this.latestValues.opacity ? this.latestValues.opacity : 1,
              et.pointerEvents = resolveMotionValue(null == J ? void 0 : J.pointerEvents) || ""),
              this.hasProjected && !hasTransform(this.latestValues) && (et.transform = ec ? ec({}, "") : "none",
                this.hasProjected = !1),
              et
          }
          let eh = ed.animationValues || ed.latestValues;
          this.applyTransformsToTarget(),
            el.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, eh),
            ec && (el.transform = ec(eh, el.transform));
          let { x: ep, y: ef } = this.projectionDelta;
          for (let J in el.transformOrigin = `${100 * ep.origin}% ${100 * ef.origin}% 0`,
            ed.animationValues ? el.opacity = ed === this ? null !== (eo = null !== (et = eh.opacity) && void 0 !== et ? et : this.latestValues.opacity) && void 0 !== eo ? eo : 1 : this.preserveOpacity ? this.latestValues.opacity : eh.opacityExit : el.opacity = ed === this ? void 0 !== eh.opacity ? eh.opacity : "" : void 0 !== eh.opacityExit ? eh.opacityExit : 0,
            eN) {
            if (void 0 === eh[J])
              continue;
            let { correct: et, applyTo: eo } = eN[J]
              , ec = "none" === el.transform ? eh[J] : et(eh[J], ed);
            if (eo) {
              let J = eo.length;
              for (let et = 0; et < J; et++)
                el[eo[et]] = ec
            } else
              el[J] = ec
          }
          return this.options.layoutId && (el.pointerEvents = ed === this ? resolveMotionValue(null == J ? void 0 : J.pointerEvents) || "" : "none"),
            el
        }
        clearSnapshot() {
          this.resumeFrom = this.snapshot = void 0
        }
        resetTree() {
          this.root.nodes.forEach(J => {
            var et;
            return null === (et = J.currentAnimation) || void 0 === et ? void 0 : et.stop()
          }
          ),
            this.root.nodes.forEach(clearMeasurements),
            this.root.sharedNodes.clear()
        }
      }
    }
    function updateLayout(J) {
      J.updateLayout()
    }
    function notifyLayoutUpdate(J) {
      var et;
      let eo = (null === (et = J.resumeFrom) || void 0 === et ? void 0 : et.snapshot) || J.snapshot;
      if (J.isLead() && J.layout && eo && J.hasListeners("didUpdate")) {
        let { layoutBox: et, measuredBox: el } = J.layout
          , { animationType: ec } = J.options
          , ed = eo.source !== J.layout.source;
        "size" === ec ? eachAxis(J => {
          let el = ed ? eo.measuredBox[J] : eo.layoutBox[J]
            , ec = calcLength(el);
          el.min = et[J].min,
            el.max = el.min + ec
        }
        ) : shouldAnimatePositionOnly(ec, eo.layoutBox, et) && eachAxis(el => {
          let ec = ed ? eo.measuredBox[el] : eo.layoutBox[el]
            , eh = calcLength(et[el]);
          ec.max = ec.min + eh,
            J.relativeTarget && !J.currentAnimation && (J.isProjectionDirty = !0,
              J.relativeTarget[el].max = J.relativeTarget[el].min + eh)
        }
        );
        let eh = createDelta();
        calcBoxDelta(eh, et, eo.layoutBox);
        let ep = createDelta();
        ed ? calcBoxDelta(ep, J.applyTransform(el, !0), eo.measuredBox) : calcBoxDelta(ep, et, eo.layoutBox);
        let ef = !isDeltaZero(eh)
          , em = !1;
        if (!J.resumeFrom) {
          let el = J.getClosestProjectingParent();
          if (el && !el.resumeFrom) {
            let { snapshot: ec, layout: ed } = el;
            if (ec && ed) {
              let eh = createBox();
              calcRelativePosition(eh, eo.layoutBox, ec.layoutBox);
              let ep = createBox();
              calcRelativePosition(ep, et, ed.layoutBox),
                boxEqualsRounded(eh, ep) || (em = !0),
                el.options.layoutRoot && (J.relativeTarget = ep,
                  J.relativeTargetOrigin = eh,
                  J.relativeParent = el)
            }
          }
        }
        J.notifyListeners("didUpdate", {
          layout: et,
          snapshot: eo,
          delta: ep,
          layoutDelta: eh,
          hasLayoutChanged: ef,
          hasRelativeTargetChanged: em
        })
      } else if (J.isLead()) {
        let { onExitComplete: et } = J.options;
        et && et()
      }
      J.options.transition = void 0
    }
    function propagateDirtyNodes(J) {
      rh.totalNodes++,
        J.parent && (J.isProjecting() || (J.isProjectionDirty = J.parent.isProjectionDirty),
          J.isSharedProjectionDirty || (J.isSharedProjectionDirty = !!(J.isProjectionDirty || J.parent.isProjectionDirty || J.parent.isSharedProjectionDirty)),
          J.isTransformDirty || (J.isTransformDirty = J.parent.isTransformDirty))
    }
    function cleanDirtyNodes(J) {
      J.isProjectionDirty = J.isSharedProjectionDirty = J.isTransformDirty = !1
    }
    function clearSnapshot(J) {
      J.clearSnapshot()
    }
    function clearMeasurements(J) {
      J.clearMeasurements()
    }
    function clearIsLayoutDirty(J) {
      J.isLayoutDirty = !1
    }
    function resetTransformStyle(J) {
      let { visualElement: et } = J.options;
      et && et.getProps().onBeforeLayoutMeasure && et.notify("BeforeLayoutMeasure"),
        J.resetTransform()
    }
    function finishAnimation(J) {
      J.finishAnimation(),
        J.targetDelta = J.relativeTarget = J.target = void 0,
        J.isProjectionDirty = !0
    }
    function resolveTargetDelta(J) {
      J.resolveTargetDelta()
    }
    function calcProjection(J) {
      J.calcProjection()
    }
    function resetRotation(J) {
      J.resetRotation()
    }
    function removeLeadSnapshots(J) {
      J.removeLeadSnapshot()
    }
    function mixAxisDelta(J, et, eo) {
      J.translate = mix(et.translate, 0, eo),
        J.scale = mix(et.scale, 1, eo),
        J.origin = et.origin,
        J.originPoint = et.originPoint
    }
    function mixAxis(J, et, eo, el) {
      J.min = mix(et.min, eo.min, el),
        J.max = mix(et.max, eo.max, el)
    }
    function hasOpacityCrossfade(J) {
      return J.animationValues && void 0 !== J.animationValues.opacityExit
    }
    let rp = {
      duration: .45,
      ease: [.4, 0, .1, 1]
    }
      , userAgentContains = J => "undefined" != typeof navigator && navigator.userAgent.toLowerCase().includes(J)
      , rm = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : to.Z;
    function roundAxis(J) {
      J.min = rm(J.min),
        J.max = rm(J.max)
    }
    function shouldAnimatePositionOnly(J, et, eo) {
      return "position" === J || "preserve-aspect" === J && !isNear(aspectRatio(et), aspectRatio(eo), .2)
    }
    let rg = createProjectionNode({
      attachResizeListener: (J, et) => addDomEvent(J, "resize", et),
      measureScroll: () => ({
        x: document.documentElement.scrollLeft || document.body.scrollLeft,
        y: document.documentElement.scrollTop || document.body.scrollTop
      }),
      checkIsScrollRoot: () => !0
    })
      , ry = {
        current: void 0
      }
      , rb = createProjectionNode({
        measureScroll: J => ({
          x: J.scrollLeft,
          y: J.scrollTop
        }),
        defaultParent: () => {
          if (!ry.current) {
            let J = new rg({});
            J.mount(window),
              J.setOptions({
                layoutScroll: !0
              }),
              ry.current = J
          }
          return ry.current
        }
        ,
        resetTransform: (J, et) => {
          J.style.transform = void 0 !== et ? et : "none"
        }
        ,
        checkIsScrollRoot: J => "fixed" === window.getComputedStyle(J).position
      })
      , rw = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
    function getVariableValue(J, et, eo = 1) {
      (0,
        td.k)(eo <= 4, `Max CSS variable fallback depth detected in property "${J}". This may indicate a circular fallback dependency.`);
      let [el, ec] = function (J) {
        let et = rw.exec(J);
        if (!et)
          return [,];
        let [, eo, el] = et;
        return [eo, el]
      }(J);
      if (!el)
        return;
      let ed = window.getComputedStyle(et).getPropertyValue(el);
      if (ed) {
        let J = ed.trim();
        return isNumericalString(J) ? parseFloat(J) : J
      }
      return eB(ec) ? getVariableValue(ec, et, eo + 1) : ec
    }
    let r_ = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"])
      , isPositionalKey = J => r_.has(J)
      , hasPositionalKey = J => Object.keys(J).some(isPositionalKey)
      , isNumOrPxType = J => J === eF || J === eY
      , getPosFromMatrix = (J, et) => parseFloat(J.split(", ")[et])
      , getTranslateFromMatrix = (J, et) => (eo, { transform: el }) => {
        if ("none" === el || !el)
          return 0;
        let ec = el.match(/^matrix3d\((.+)\)$/);
        if (ec)
          return getPosFromMatrix(ec[1], et);
        {
          let et = el.match(/^matrix\((.+)\)$/);
          return et ? getPosFromMatrix(et[1], J) : 0
        }
      }
      , rx = new Set(["x", "y", "z"])
      , rE = eM.filter(J => !rx.has(J))
      , rC = {
        width: ({ x: J }, { paddingLeft: et = "0", paddingRight: eo = "0" }) => J.max - J.min - parseFloat(et) - parseFloat(eo),
        height: ({ y: J }, { paddingTop: et = "0", paddingBottom: eo = "0" }) => J.max - J.min - parseFloat(et) - parseFloat(eo),
        top: (J, { top: et }) => parseFloat(et),
        left: (J, { left: et }) => parseFloat(et),
        bottom: ({ y: J }, { top: et }) => parseFloat(et) + (J.max - J.min),
        right: ({ x: J }, { left: et }) => parseFloat(et) + (J.max - J.min),
        x: getTranslateFromMatrix(4, 13),
        y: getTranslateFromMatrix(5, 14)
      };
    rC.translateX = rC.x,
      rC.translateY = rC.y;
    let convertChangedValueTypes = (J, et, eo) => {
      let el = et.measureViewportBox()
        , ec = et.current
        , ed = getComputedStyle(ec)
        , { display: eh } = ed
        , ep = {};
      "none" === eh && et.setStaticValue("display", J.display || "block"),
        eo.forEach(J => {
          ep[J] = rC[J](el, ed)
        }
        ),
        et.render();
      let ef = et.measureViewportBox();
      return eo.forEach(eo => {
        let el = et.getValue(eo);
        el && el.jump(ep[eo]),
          J[eo] = rC[eo](ef, ed)
      }
      ),
        J
    }
      , checkAndConvertChangedValueTypes = (J, et, eo = {}, el = {}) => {
        et = {
          ...et
        },
          el = {
            ...el
          };
        let ec = Object.keys(et).filter(isPositionalKey)
          , ed = []
          , eh = !1
          , ep = [];
        if (ec.forEach(ec => {
          let ef;
          let em = J.getValue(ec);
          if (!J.hasValue(ec))
            return;
          let eg = eo[ec]
            , ey = findDimensionValueType(eg)
            , eb = et[ec];
          if (isKeyframesTarget(eb)) {
            let J = eb.length
              , et = null === eb[0] ? 1 : 0;
            ey = findDimensionValueType(eg = eb[et]);
            for (let eo = et; eo < J && null !== eb[eo]; eo++)
              ef ? (0,
                td.k)(findDimensionValueType(eb[eo]) === ef, "All keyframes must be of the same type") : (ef = findDimensionValueType(eb[eo]),
                  (0,
                    td.k)(ef === ey || isNumOrPxType(ey) && isNumOrPxType(ef), "Keyframes must be of the same dimension as the current value"))
          } else
            ef = findDimensionValueType(eb);
          if (ey !== ef) {
            if (isNumOrPxType(ey) && isNumOrPxType(ef)) {
              let J = em.get();
              "string" == typeof J && em.set(parseFloat(J)),
                "string" == typeof eb ? et[ec] = parseFloat(eb) : Array.isArray(eb) && ef === eY && (et[ec] = eb.map(parseFloat))
            } else
              (null == ey ? void 0 : ey.transform) && (null == ef ? void 0 : ef.transform) && (0 === eg || 0 === eb) ? 0 === eg ? em.set(ef.transform(eg)) : et[ec] = ey.transform(eb) : (eh || (ed = function (J) {
                let et = [];
                return rE.forEach(eo => {
                  let el = J.getValue(eo);
                  void 0 !== el && (et.push([eo, el.get()]),
                    el.set(eo.startsWith("scale") ? 1 : 0))
                }
                ),
                  et.length && J.render(),
                  et
              }(J),
                eh = !0),
                ep.push(ec),
                el[ec] = void 0 !== el[ec] ? el[ec] : et[ec],
                em.jump(eb))
          }
        }
        ),
          !ep.length)
          return {
            target: et,
            transitionEnd: el
          };
        {
          let eo = ep.indexOf("height") >= 0 ? window.pageYOffset : null
            , ec = convertChangedValueTypes(et, J, ep);
          return ed.length && ed.forEach(([et, eo]) => {
            J.getValue(et).set(eo)
          }
          ),
            J.render(),
            eA.j && null !== eo && window.scrollTo({
              top: eo
            }),
          {
            target: ec,
            transitionEnd: el
          }
        }
      }
      , parseDomVariant = (J, et, eo, el) => {
        var ec, ed;
        let eh = function (J, { ...et }, eo) {
          let el = J.current;
          if (!(el instanceof Element))
            return {
              target: et,
              transitionEnd: eo
            };
          for (let ec in eo && (eo = {
            ...eo
          }),
            J.values.forEach(J => {
              let et = J.get();
              if (!eB(et))
                return;
              let eo = getVariableValue(et, el);
              eo && J.set(eo)
            }
            ),
            et) {
            let J = et[ec];
            if (!eB(J))
              continue;
            let ed = getVariableValue(J, el);
            ed && (et[ec] = ed,
              eo || (eo = {}),
              void 0 === eo[ec] && (eo[ec] = J))
          }
          return {
            target: et,
            transitionEnd: eo
          }
        }(J, et, el);
        return et = eh.target,
          el = eh.transitionEnd,
          ec = et,
          ed = el,
          hasPositionalKey(ec) ? checkAndConvertChangedValueTypes(J, ec, eo, ed) : {
            target: ec,
            transitionEnd: ed
          }
      }
      , rS = {
        current: null
      }
      , rk = {
        current: !1
      }
      , rT = new WeakMap
      , rA = Object.keys(eT)
      , rP = rA.length
      , rR = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"]
      , rI = eS.length;
    let VisualElement = class VisualElement {
      constructor({ parent: J, props: et, presenceContext: eo, reducedMotionConfig: el, visualState: ec }, ed = {}) {
        this.current = null,
          this.children = new Set,
          this.isVariantNode = !1,
          this.isControllingVariants = !1,
          this.shouldReduceMotion = null,
          this.values = new Map,
          this.features = {},
          this.valueSubscriptions = new Map,
          this.prevMotionValues = {},
          this.events = {},
          this.propEventSubscriptions = {},
          this.notifyUpdate = () => this.notify("Update", this.latestValues),
          this.render = () => {
            this.current && (this.triggerBuild(),
              this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
          }
          ,
          this.scheduleRender = () => e4.Wi.render(this.render, !1, !0);
        let { latestValues: eh, renderState: ep } = ec;
        this.latestValues = eh,
          this.baseTarget = {
            ...eh
          },
          this.initialValues = et.initial ? {
            ...eh
          } : {},
          this.renderState = ep,
          this.parent = J,
          this.props = et,
          this.presenceContext = eo,
          this.depth = J ? J.depth + 1 : 0,
          this.reducedMotionConfig = el,
          this.options = ed,
          this.isControllingVariants = isControllingVariants(et),
          this.isVariantNode = isVariantNode(et),
          this.isVariantNode && (this.variantChildren = new Set),
          this.manuallyAnimateOnMount = !!(J && J.current);
        let { willChange: ef, ...em } = this.scrapeMotionValuesFromProps(et, {});
        for (let J in em) {
          let et = em[J];
          void 0 !== eh[J] && isMotionValue(et) && (et.set(eh[J], !1),
            isWillChangeMotionValue(ef) && ef.add(J))
        }
      }
      scrapeMotionValuesFromProps(J, et) {
        return {}
      }
      mount(J) {
        this.current = J,
          rT.set(J, this),
          this.projection && !this.projection.instance && this.projection.mount(J),
          this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)),
          this.values.forEach((J, et) => this.bindToMotionValue(et, J)),
          rk.current || function () {
            if (rk.current = !0,
              eA.j) {
              if (window.matchMedia) {
                let J = window.matchMedia("(prefers-reduced-motion)")
                  , setReducedMotionPreferences = () => rS.current = J.matches;
                J.addListener(setReducedMotionPreferences),
                  setReducedMotionPreferences()
              } else
                rS.current = !1
            }
          }(),
          this.shouldReduceMotion = "never" !== this.reducedMotionConfig && ("always" === this.reducedMotionConfig || rS.current),
          this.parent && this.parent.children.add(this),
          this.update(this.props, this.presenceContext)
      }
      unmount() {
        for (let J in rT.delete(this.current),
          this.projection && this.projection.unmount(),
          (0,
            e4.Pn)(this.notifyUpdate),
          (0,
            e4.Pn)(this.render),
          this.valueSubscriptions.forEach(J => J()),
          this.removeFromVariantTree && this.removeFromVariantTree(),
          this.parent && this.parent.children.delete(this),
          this.events)
          this.events[J].clear();
        for (let J in this.features)
          this.features[J].unmount();
        this.current = null
      }
      bindToMotionValue(J, et) {
        let eo = eD.has(J)
          , el = et.on("change", et => {
            this.latestValues[J] = et,
              this.props.onUpdate && e4.Wi.update(this.notifyUpdate, !1, !0),
              eo && this.projection && (this.projection.isTransformDirty = !0)
          }
          )
          , ec = et.on("renderRequest", this.scheduleRender);
        this.valueSubscriptions.set(J, () => {
          el(),
            ec()
        }
        )
      }
      sortNodePosition(J) {
        return this.current && this.sortInstanceNodePosition && this.type === J.type ? this.sortInstanceNodePosition(this.current, J.current) : 0
      }
      loadFeatures({ children: J, ...et }, eo, el, ec) {
        let ed, eh;
        for (let J = 0; J < rP; J++) {
          let eo = rA[J]
            , { isEnabled: el, Feature: ec, ProjectionNode: ep, MeasureLayout: ef } = eT[eo];
          ep && (ed = ep),
            el(et) && (!this.features[eo] && ec && (this.features[eo] = new ec(this)),
              ef && (eh = ef))
        }
        if (("html" === this.type || "svg" === this.type) && !this.projection && ed) {
          this.projection = new ed(this.latestValues, this.parent && this.parent.projection);
          let { layoutId: J, layout: eo, drag: el, dragConstraints: eh, layoutScroll: ep, layoutRoot: ef } = et;
          this.projection.setOptions({
            layoutId: J,
            layout: eo,
            alwaysMeasureLayout: !!el || eh && isRefObject(eh),
            visualElement: this,
            scheduleRender: () => this.scheduleRender(),
            animationType: "string" == typeof eo ? eo : "both",
            initialPromotionConfig: ec,
            layoutScroll: ep,
            layoutRoot: ef
          })
        }
        return eh
      }
      updateFeatures() {
        for (let J in this.features) {
          let et = this.features[J];
          et.isMounted ? et.update() : (et.mount(),
            et.isMounted = !0)
        }
      }
      triggerBuild() {
        this.build(this.renderState, this.latestValues, this.options, this.props)
      }
      measureViewportBox() {
        return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox()
      }
      getStaticValue(J) {
        return this.latestValues[J]
      }
      setStaticValue(J, et) {
        this.latestValues[J] = et
      }
      makeTargetAnimatable(J, et = !0) {
        return this.makeTargetAnimatableFromInstance(J, et)
      }
      update(J, et) {
        (J.transformTemplate || this.props.transformTemplate) && this.scheduleRender(),
          this.prevProps = this.props,
          this.props = J,
          this.prevPresenceContext = this.presenceContext,
          this.presenceContext = et;
        for (let et = 0; et < rR.length; et++) {
          let eo = rR[et];
          this.propEventSubscriptions[eo] && (this.propEventSubscriptions[eo](),
            delete this.propEventSubscriptions[eo]);
          let el = J["on" + eo];
          el && (this.propEventSubscriptions[eo] = this.on(eo, el))
        }
        this.prevMotionValues = function (J, et, eo) {
          let { willChange: el } = et;
          for (let ec in et) {
            let ed = et[ec]
              , eh = eo[ec];
            if (isMotionValue(ed))
              J.addValue(ec, ed),
                isWillChangeMotionValue(el) && el.add(ec);
            else if (isMotionValue(eh))
              J.addValue(ec, motionValue(ed, {
                owner: J
              })),
                isWillChangeMotionValue(el) && el.remove(ec);
            else if (eh !== ed) {
              if (J.hasValue(ec)) {
                let et = J.getValue(ec);
                et.hasAnimated || et.set(ed)
              } else {
                let et = J.getStaticValue(ec);
                J.addValue(ec, motionValue(void 0 !== et ? et : ed, {
                  owner: J
                }))
              }
            }
          }
          for (let el in eo)
            void 0 === et[el] && J.removeValue(el);
          return et
        }(this, this.scrapeMotionValuesFromProps(J, this.prevProps), this.prevMotionValues),
          this.handleChildMotionValue && this.handleChildMotionValue()
      }
      getProps() {
        return this.props
      }
      getVariant(J) {
        return this.props.variants ? this.props.variants[J] : void 0
      }
      getDefaultTransition() {
        return this.props.transition
      }
      getTransformPagePoint() {
        return this.props.transformPagePoint
      }
      getClosestVariantNode() {
        return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
      }
      getVariantContext(J = !1) {
        if (J)
          return this.parent ? this.parent.getVariantContext() : void 0;
        if (!this.isControllingVariants) {
          let J = this.parent && this.parent.getVariantContext() || {};
          return void 0 !== this.props.initial && (J.initial = this.props.initial),
            J
        }
        let et = {};
        for (let J = 0; J < rI; J++) {
          let eo = eS[J]
            , el = this.props[eo];
          (isVariantLabel(el) || !1 === el) && (et[eo] = el)
        }
        return et
      }
      addVariantChild(J) {
        let et = this.getClosestVariantNode();
        if (et)
          return et.variantChildren && et.variantChildren.add(J),
            () => et.variantChildren.delete(J)
      }
      addValue(J, et) {
        et !== this.values.get(J) && (this.removeValue(J),
          this.bindToMotionValue(J, et)),
          this.values.set(J, et),
          this.latestValues[J] = et.get()
      }
      removeValue(J) {
        this.values.delete(J);
        let et = this.valueSubscriptions.get(J);
        et && (et(),
          this.valueSubscriptions.delete(J)),
          delete this.latestValues[J],
          this.removeValueFromRenderState(J, this.renderState)
      }
      hasValue(J) {
        return this.values.has(J)
      }
      getValue(J, et) {
        if (this.props.values && this.props.values[J])
          return this.props.values[J];
        let eo = this.values.get(J);
        return void 0 === eo && void 0 !== et && (eo = motionValue(et, {
          owner: this
        }),
          this.addValue(J, eo)),
          eo
      }
      readValue(J) {
        var et;
        return void 0 === this.latestValues[J] && this.current ? null !== (et = this.getBaseTargetFromProps(this.props, J)) && void 0 !== et ? et : this.readValueFromInstance(this.current, J, this.options) : this.latestValues[J]
      }
      setBaseTarget(J, et) {
        this.baseTarget[J] = et
      }
      getBaseTarget(J) {
        var et;
        let { initial: eo } = this.props
          , el = "string" == typeof eo || "object" == typeof eo ? null === (et = resolveVariantFromProps(this.props, eo)) || void 0 === et ? void 0 : et[J] : void 0;
        if (eo && void 0 !== el)
          return el;
        let ec = this.getBaseTargetFromProps(this.props, J);
        return void 0 === ec || isMotionValue(ec) ? void 0 !== this.initialValues[J] && void 0 === el ? void 0 : this.baseTarget[J] : ec
      }
      on(J, et) {
        return this.events[J] || (this.events[J] = new SubscriptionManager),
          this.events[J].add(et)
      }
      notify(J, ...et) {
        this.events[J] && this.events[J].notify(...et)
      }
    }
      ;
    let DOMVisualElement = class DOMVisualElement extends VisualElement {
      sortInstanceNodePosition(J, et) {
        return 2 & J.compareDocumentPosition(et) ? 1 : -1
      }
      getBaseTargetFromProps(J, et) {
        return J.style ? J.style[et] : void 0
      }
      removeValueFromRenderState(J, { vars: et, style: eo }) {
        delete et[J],
          delete eo[J]
      }
      makeTargetAnimatableFromInstance({ transition: J, transitionEnd: et, ...eo }, el) {
        let ec = function (J, et, eo) {
          let el = {};
          for (let ec in J) {
            let J = function (J, et) {
              if (!et)
                return;
              let eo = et[J] || et.default || et;
              return eo.from
            }(ec, et);
            if (void 0 !== J)
              el[ec] = J;
            else {
              let J = eo.getValue(ec);
              J && (el[ec] = J.get())
            }
          }
          return el
        }(eo, J || {}, this);
        if (el) {
          !function (J, et, eo) {
            var el, ec;
            let ed = Object.keys(et).filter(et => !J.hasValue(et))
              , eh = ed.length;
            if (eh)
              for (let ep = 0; ep < eh; ep++) {
                let eh = ed[ep]
                  , ef = et[eh]
                  , em = null;
                Array.isArray(ef) && (em = ef[0]),
                  null === em && (em = null !== (ec = null !== (el = eo[eh]) && void 0 !== el ? el : J.readValue(eh)) && void 0 !== ec ? ec : et[eh]),
                  null != em && ("string" == typeof em && (isNumericalString(em) || isZeroValueString(em)) ? em = parseFloat(em) : !findValueType(em) && tN.test(ef) && (em = animatable_none_getAnimatableNone(eh, ef)),
                    J.addValue(eh, motionValue(em, {
                      owner: J
                    })),
                    void 0 === eo[eh] && (eo[eh] = em),
                    null !== em && J.setBaseTarget(eh, em))
              }
          }(this, eo, ec);
          let J = parseDomVariant(this, eo, ec, et);
          et = J.transitionEnd,
            eo = J.target
        }
        return {
          transition: J,
          transitionEnd: et,
          ...eo
        }
      }
    }
      ;
    let HTMLVisualElement = class HTMLVisualElement extends DOMVisualElement {
      constructor() {
        super(...arguments),
          this.type = "html"
      }
      readValueFromInstance(J, et) {
        if (eD.has(et)) {
          let J = getDefaultValueType(et);
          return J && J.default || 0
        }
        {
          let eo = window.getComputedStyle(J)
            , el = (e$(et) ? eo.getPropertyValue(et) : eo[et]) || 0;
          return "string" == typeof el ? el.trim() : el
        }
      }
      measureInstanceViewportBox(J, { transformPagePoint: et }) {
        return measureViewportBox(J, et)
      }
      build(J, et, eo, el) {
        buildHTMLStyles(J, et, eo, el.transformTemplate)
      }
      scrapeMotionValuesFromProps(J, et) {
        return scrapeMotionValuesFromProps(J, et)
      }
      handleChildMotionValue() {
        this.childSubscription && (this.childSubscription(),
          delete this.childSubscription);
        let { children: J } = this.props;
        isMotionValue(J) && (this.childSubscription = J.on("change", J => {
          this.current && (this.current.textContent = `${J}`)
        }
        ))
      }
      renderInstance(J, et, eo, el) {
        renderHTML(J, et, eo, el)
      }
    }
      ;
    let SVGVisualElement = class SVGVisualElement extends DOMVisualElement {
      constructor() {
        super(...arguments),
          this.type = "svg",
          this.isSVGTag = !1
      }
      getBaseTargetFromProps(J, et) {
        return J[et]
      }
      readValueFromInstance(J, et) {
        if (eD.has(et)) {
          let J = getDefaultValueType(et);
          return J && J.default || 0
        }
        return et = e5.has(et) ? et : camelToDash(et),
          J.getAttribute(et)
      }
      measureInstanceViewportBox() {
        return createBox()
      }
      scrapeMotionValuesFromProps(J, et) {
        return scrape_motion_values_scrapeMotionValuesFromProps(J, et)
      }
      build(J, et, eo, el) {
        buildSVGAttrs(J, et, eo, this.isSVGTag, el.transformTemplate)
      }
      renderInstance(J, et, eo, el) {
        renderSVG(J, et, eo, el)
      }
      mount(J) {
        this.isSVGTag = isSVGTag(J.tagName),
          super.mount(J)
      }
    }
      ;
    let create_visual_element_createDomVisualElement = (J, et) => isSVGComponent(J) ? new SVGVisualElement(et, {
      enableHardwareAcceleration: !1
    }) : new HTMLVisualElement(et, {
      enableHardwareAcceleration: !0
    })
      , rO = {
        animation: {
          Feature: class extends Feature {
            constructor(J) {
              super(J),
                J.animationState || (J.animationState = function (J) {
                  let animate = et => Promise.all(et.map(({ animation: et, options: eo }) => (function (J, et, eo = {}) {
                    let el;
                    if (J.notify("AnimationStart", et),
                      Array.isArray(et)) {
                      let ec = et.map(et => animateVariant(J, et, eo));
                      el = Promise.all(ec)
                    } else if ("string" == typeof et)
                      el = animateVariant(J, et, eo);
                    else {
                      let ec = "function" == typeof et ? resolveVariant(J, et, eo.custom) : et;
                      el = Promise.all(animateTarget(J, ec, eo))
                    }
                    return el.then(() => J.notify("AnimationComplete", et))
                  }
                  )(J, et, eo)))
                    , et = {
                      animate: createTypeState(!0),
                      whileInView: createTypeState(),
                      whileHover: createTypeState(),
                      whileTap: createTypeState(),
                      whileDrag: createTypeState(),
                      whileFocus: createTypeState(),
                      exit: createTypeState()
                    }
                    , eo = !0
                    , buildResolvedTypeValues = (et, eo) => {
                      let el = resolveVariant(J, eo);
                      if (el) {
                        let { transition: J, transitionEnd: eo, ...ec } = el;
                        et = {
                          ...et,
                          ...ec,
                          ...eo
                        }
                      }
                      return et
                    }
                    ;
                  function animateChanges(el, ec) {
                    let ed = J.getProps()
                      , eh = J.getVariantContext(!0) || {}
                      , ep = []
                      , ef = new Set
                      , em = {}
                      , eg = 1 / 0;
                    for (let eb = 0; eb < tQ; eb++) {
                      var ey;
                      let ew = tJ[eb]
                        , e_ = et[ew]
                        , ex = void 0 !== ed[ew] ? ed[ew] : eh[ew]
                        , eE = isVariantLabel(ex)
                        , eC = ew === ec ? e_.isActive : null;
                      !1 === eC && (eg = eb);
                      let eS = ex === eh[ew] && ex !== ed[ew] && eE;
                      if (eS && eo && J.manuallyAnimateOnMount && (eS = !1),
                        e_.protectedKeys = {
                          ...em
                        },
                        !e_.isActive && null === eC || !ex && !e_.prevProp || isAnimationControls(ex) || "boolean" == typeof ex)
                        continue;
                      let ek = (ey = e_.prevProp,
                        "string" == typeof ex ? ex !== ey : !!Array.isArray(ex) && !shallowCompare(ex, ey))
                        , eT = ek || ew === ec && e_.isActive && !eS && eE || eb > eg && eE
                        , eA = !1
                        , eP = Array.isArray(ex) ? ex : [ex]
                        , eR = eP.reduce(buildResolvedTypeValues, {});
                      !1 === eC && (eR = {});
                      let { prevResolvedValues: eI = {} } = e_
                        , eO = {
                          ...eI,
                          ...eR
                        }
                        , markToAnimate = J => {
                          eT = !0,
                            ef.has(J) && (eA = !0,
                              ef.delete(J)),
                            e_.needsAnimating[J] = !0
                        }
                        ;
                      for (let J in eO) {
                        let et = eR[J]
                          , eo = eI[J];
                        if (!em.hasOwnProperty(J))
                          (isKeyframesTarget(et) && isKeyframesTarget(eo) ? shallowCompare(et, eo) : et === eo) ? void 0 !== et && ef.has(J) ? markToAnimate(J) : e_.protectedKeys[J] = !0 : void 0 !== et ? markToAnimate(J) : ef.add(J)
                      }
                      e_.prevProp = ex,
                        e_.prevResolvedValues = eR,
                        e_.isActive && (em = {
                          ...em,
                          ...eR
                        }),
                        eo && J.blockInitialAnimation && (eT = !1),
                        eT && (!eS || eA) && ep.push(...eP.map(J => ({
                          animation: J,
                          options: {
                            type: ew,
                            ...el
                          }
                        })))
                    }
                    if (ef.size) {
                      let et = {};
                      ef.forEach(eo => {
                        let el = J.getBaseTarget(eo);
                        void 0 !== el && (et[eo] = el)
                      }
                      ),
                        ep.push({
                          animation: et
                        })
                    }
                    let eb = !!ep.length;
                    return eo && (!1 === ed.initial || ed.initial === ed.animate) && !J.manuallyAnimateOnMount && (eb = !1),
                      eo = !1,
                      eb ? animate(ep) : Promise.resolve()
                  }
                  return {
                    animateChanges,
                    setActive: function (eo, el, ec) {
                      var ed;
                      if (et[eo].isActive === el)
                        return Promise.resolve();
                      null === (ed = J.variantChildren) || void 0 === ed || ed.forEach(J => {
                        var et;
                        return null === (et = J.animationState) || void 0 === et ? void 0 : et.setActive(eo, el)
                      }
                      ),
                        et[eo].isActive = el;
                      let eh = animateChanges(ec, eo);
                      for (let J in et)
                        et[J].protectedKeys = {};
                      return eh
                    },
                    setAnimateFunction: function (et) {
                      animate = et(J)
                    },
                    getState: () => et
                  }
                }(J))
            }
            updateAnimationControlsSubscription() {
              let { animate: J } = this.node.getProps();
              this.unmount(),
                isAnimationControls(J) && (this.unmount = J.subscribe(this.node))
            }
            mount() {
              this.updateAnimationControlsSubscription()
            }
            update() {
              let { animate: J } = this.node.getProps()
                , { animate: et } = this.node.prevProps || {};
              J !== et && this.updateAnimationControlsSubscription()
            }
            unmount() { }
          }
        },
        exit: {
          Feature: class extends Feature {
            constructor() {
              super(...arguments),
                this.id = tX++
            }
            update() {
              if (!this.node.presenceContext)
                return;
              let { isPresent: J, onExitComplete: et, custom: eo } = this.node.presenceContext
                , { isPresent: el } = this.node.prevPresenceContext || {};
              if (!this.node.animationState || J === el)
                return;
              let ec = this.node.animationState.setActive("exit", !J, {
                custom: null != eo ? eo : this.node.getProps().custom
              });
              et && !J && ec.then(() => et(this.id))
            }
            mount() {
              let { register: J } = this.node.presenceContext || {};
              J && (this.unmount = J(this.id))
            }
            unmount() { }
          }
        },
        inView: {
          Feature: class extends Feature {
            constructor() {
              super(...arguments),
                this.hasEnteredView = !1,
                this.isInView = !1
            }
            startObserver() {
              this.unmount();
              let { viewport: J = {} } = this.node.getProps()
                , { root: et, margin: eo, amount: el = "some", once: ec } = J
                , ed = {
                  root: et ? et.current : void 0,
                  rootMargin: eo,
                  threshold: "number" == typeof el ? el : tc[el]
                };
              return function (J, et, eo) {
                let el = function ({ root: J, ...et }) {
                  let eo = J || document;
                  tl.has(eo) || tl.set(eo, {});
                  let el = tl.get(eo)
                    , ec = JSON.stringify(et);
                  return el[ec] || (el[ec] = new IntersectionObserver(fireAllObserverCallbacks, {
                    root: J,
                    ...et
                  })),
                    el[ec]
                }(et);
                return ta.set(J, eo),
                  el.observe(J),
                  () => {
                    ta.delete(J),
                      el.unobserve(J)
                  }
              }(this.node.current, ed, J => {
                let { isIntersecting: et } = J;
                if (this.isInView === et || (this.isInView = et,
                  ec && !et && this.hasEnteredView))
                  return;
                et && (this.hasEnteredView = !0),
                  this.node.animationState && this.node.animationState.setActive("whileInView", et);
                let { onViewportEnter: eo, onViewportLeave: el } = this.node.getProps()
                  , ed = et ? eo : el;
                ed && ed(J)
              }
              )
            }
            mount() {
              this.startObserver()
            }
            update() {
              if ("undefined" == typeof IntersectionObserver)
                return;
              let { props: J, prevProps: et } = this.node
                , eo = ["amount", "margin", "root"].some(function ({ viewport: J = {} }, { viewport: et = {} } = {}) {
                  return eo => J[eo] !== et[eo]
                }(J, et));
              eo && this.startObserver()
            }
            unmount() { }
          }
        },
        tap: {
          Feature: class extends Feature {
            constructor() {
              super(...arguments),
                this.removeStartListeners = to.Z,
                this.removeEndListeners = to.Z,
                this.removeAccessibleListeners = to.Z,
                this.startPointerPress = (J, et) => {
                  if (this.isPressing)
                    return;
                  this.removeEndListeners();
                  let eo = this.node.getProps()
                    , el = addPointerEvent(window, "pointerup", (J, et) => {
                      if (!this.checkPressEnd())
                        return;
                      let { onTap: eo, onTapCancel: el, globalTapTarget: ec } = this.node.getProps();
                      e4.Wi.update(() => {
                        ec || isNodeOrChild(this.node.current, J.target) ? eo && eo(J, et) : el && el(J, et)
                      }
                      )
                    }
                      , {
                        passive: !(eo.onTap || eo.onPointerUp)
                      })
                    , ec = addPointerEvent(window, "pointercancel", (J, et) => this.cancelPress(J, et), {
                      passive: !(eo.onTapCancel || eo.onPointerCancel)
                    });
                  this.removeEndListeners = pipe(el, ec),
                    this.startPress(J, et)
                }
                ,
                this.startAccessiblePress = () => {
                  let J = addDomEvent(this.node.current, "keydown", J => {
                    "Enter" !== J.key || this.isPressing || (this.removeEndListeners(),
                      this.removeEndListeners = addDomEvent(this.node.current, "keyup", J => {
                        "Enter" === J.key && this.checkPressEnd() && fireSyntheticPointerEvent("up", (J, et) => {
                          let { onTap: eo } = this.node.getProps();
                          eo && e4.Wi.update(() => eo(J, et))
                        }
                        )
                      }
                      ),
                      fireSyntheticPointerEvent("down", (J, et) => {
                        this.startPress(J, et)
                      }
                      ))
                  }
                  )
                    , et = addDomEvent(this.node.current, "blur", () => {
                      this.isPressing && fireSyntheticPointerEvent("cancel", (J, et) => this.cancelPress(J, et))
                    }
                    );
                  this.removeAccessibleListeners = pipe(J, et)
                }
            }
            startPress(J, et) {
              this.isPressing = !0;
              let { onTapStart: eo, whileTap: el } = this.node.getProps();
              el && this.node.animationState && this.node.animationState.setActive("whileTap", !0),
                eo && e4.Wi.update(() => eo(J, et))
            }
            checkPressEnd() {
              this.removeEndListeners(),
                this.isPressing = !1;
              let J = this.node.getProps();
              return J.whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1),
                !isDragActive()
            }
            cancelPress(J, et) {
              if (!this.checkPressEnd())
                return;
              let { onTapCancel: eo } = this.node.getProps();
              eo && e4.Wi.update(() => eo(J, et))
            }
            mount() {
              let J = this.node.getProps()
                , et = addPointerEvent(J.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, {
                  passive: !(J.onTapStart || J.onPointerStart)
                })
                , eo = addDomEvent(this.node.current, "focus", this.startAccessiblePress);
              this.removeStartListeners = pipe(et, eo)
            }
            unmount() {
              this.removeStartListeners(),
                this.removeEndListeners(),
                this.removeAccessibleListeners()
            }
          }
        },
        focus: {
          Feature: class extends Feature {
            constructor() {
              super(...arguments),
                this.isActive = !1
            }
            onFocus() {
              let J = !1;
              try {
                J = this.node.current.matches(":focus-visible")
              } catch (et) {
                J = !0
              }
              J && this.node.animationState && (this.node.animationState.setActive("whileFocus", !0),
                this.isActive = !0)
            }
            onBlur() {
              this.isActive && this.node.animationState && (this.node.animationState.setActive("whileFocus", !1),
                this.isActive = !1)
            }
            mount() {
              this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()))
            }
            unmount() { }
          }
        },
        hover: {
          Feature: class extends Feature {
            mount() {
              this.unmount = pipe(addHoverEvent(this.node, !0), addHoverEvent(this.node, !1))
            }
            unmount() { }
          }
        },
        pan: {
          Feature: class extends Feature {
            constructor() {
              super(...arguments),
                this.removePointerDownListener = to.Z
            }
            onPointerDown(J) {
              this.session = new PanSession(J, this.createPanHandlers(), {
                transformPagePoint: this.node.getTransformPagePoint(),
                contextWindow: getContextWindow(this.node)
              })
            }
            createPanHandlers() {
              let { onPanSessionStart: J, onPanStart: et, onPan: eo, onPanEnd: el } = this.node.getProps();
              return {
                onSessionStart: asyncHandler(J),
                onStart: asyncHandler(et),
                onMove: eo,
                onEnd: (J, et) => {
                  delete this.session,
                    el && e4.Wi.update(() => el(J, et))
                }
              }
            }
            mount() {
              this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", J => this.onPointerDown(J))
            }
            update() {
              this.session && this.session.updateHandlers(this.createPanHandlers())
            }
            unmount() {
              this.removePointerDownListener(),
                this.session && this.session.end()
            }
          }
        },
        drag: {
          Feature: class extends Feature {
            constructor(J) {
              super(J),
                this.removeGroupControls = to.Z,
                this.removeListeners = to.Z,
                this.controls = new VisualElementDragControls(J)
            }
            mount() {
              let { dragControls: J } = this.node.getProps();
              J && (this.removeGroupControls = J.subscribe(this.controls)),
                this.removeListeners = this.controls.addListeners() || to.Z
            }
            unmount() {
              this.removeGroupControls(),
                this.removeListeners()
            }
          }
          ,
          ProjectionNode: rb,
          MeasureLayout: MeasureLayout
        },
        layout: {
          ProjectionNode: rb,
          MeasureLayout: MeasureLayout
        }
      }
      , rN = function (J) {
        function custom(et, eo = {}) {
          return function ({ preloadedFeatures: J, createVisualElement: et, useRender: eo, useVisualState: el, Component: ec }) {
            J && function (J) {
              for (let et in J)
                eT[et] = {
                  ...eT[et],
                  ...J[et]
                }
            }(J);
            let ed = (0,
              ep.forwardRef)(function (ed, eh) {
                var e_;
                let eE;
                let eC = {
                  ...(0,
                    ep.useContext)(ef),
                  ...ed,
                  layoutId: function ({ layoutId: J }) {
                    let et = (0,
                      ep.useContext)(eP.p).id;
                    return et && void 0 !== J ? et + "-" + J : J
                  }(ed)
                }
                  , { isStatic: eS } = eC
                  , ek = function (J) {
                    let { initial: et, animate: eo } = function (J, et) {
                      if (isControllingVariants(J)) {
                        let { initial: et, animate: eo } = J;
                        return {
                          initial: !1 === et || isVariantLabel(et) ? et : void 0,
                          animate: isVariantLabel(eo) ? eo : void 0
                        }
                      }
                      return !1 !== J.inherit ? et : {}
                    }(J, (0,
                      ep.useContext)(em));
                    return (0,
                      ep.useMemo)(() => ({
                        initial: et,
                        animate: eo
                      }), [variantLabelsAsDependency(et), variantLabelsAsDependency(eo)])
                  }(ed)
                  , eT = el(ed, eS);
                if (!eS && eA.j) {
                  ek.visualElement = function (J, et, eo, el) {
                    let { visualElement: ec } = (0,
                      ep.useContext)(em)
                      , ed = (0,
                        ep.useContext)(eb)
                      , eh = (0,
                        ep.useContext)(eg.O)
                      , e_ = (0,
                        ep.useContext)(ef).reducedMotion
                      , eE = (0,
                        ep.useRef)();
                    el = el || ed.renderer,
                      !eE.current && el && (eE.current = el(J, {
                        visualState: et,
                        parent: ec,
                        props: eo,
                        presenceContext: eh,
                        blockInitialAnimation: !!eh && !1 === eh.initial,
                        reducedMotionConfig: e_
                      }));
                    let eC = eE.current;
                    (0,
                      ep.useInsertionEffect)(() => {
                        eC && eC.update(eo, eh)
                      }
                      );
                    let eS = (0,
                      ep.useRef)(!!(eo[ew] && !window.HandoffComplete));
                    return (0,
                      ey.L)(() => {
                        eC && (ex.postRender(eC.render),
                          eS.current && eC.animationState && eC.animationState.animateChanges())
                      }
                      ),
                      (0,
                        ep.useEffect)(() => {
                          eC && (eC.updateFeatures(),
                            !eS.current && eC.animationState && eC.animationState.animateChanges(),
                            eS.current && (eS.current = !1,
                              window.HandoffComplete = !0))
                        }
                        ),
                      eC
                  }(ec, eT, eC, et);
                  let eo = (0,
                    ep.useContext)(eR)
                    , el = (0,
                      ep.useContext)(eb).strict;
                  ek.visualElement && (eE = ek.visualElement.loadFeatures(eC, el, J, eo))
                }
                return ep.createElement(em.Provider, {
                  value: ek
                }, eE && ek.visualElement ? ep.createElement(eE, {
                  visualElement: ek.visualElement,
                  ...eC
                }) : null, eo(ec, ed, (e_ = ek.visualElement,
                  (0,
                    ep.useCallback)(J => {
                      J && eT.mount && eT.mount(J),
                        e_ && (J ? e_.mount(J) : e_.unmount()),
                        eh && ("function" == typeof eh ? eh(J) : isRefObject(eh) && (eh.current = J))
                    }
                      , [e_])), eT, eS, ek.visualElement))
              });
            return ed[eI] = ec,
              ed
          }(J(et, eo))
        }
        if ("undefined" == typeof Proxy)
          return custom;
        let et = new Map;
        return new Proxy(custom, {
          get: (J, eo) => (et.has(eo) || et.set(eo, custom(eo)),
            et.get(eo))
        })
      }((J, et) => (function (J, { forwardMotionProps: et = !1 }, eo, el) {
        let ec = isSVGComponent(J) ? e8 : e7;
        return {
          ...ec,
          preloadedFeatures: eo,
          useRender: function (J = !1) {
            return (et, eo, el, { latestValues: ec }, ed) => {
              let eh = isSVGComponent(et) ? useSVGProps : useHTMLProps
                , ef = eh(eo, ec, ed, et)
                , em = function (J, et, eo) {
                  let el = {};
                  for (let ec in J)
                    ("values" !== ec || "object" != typeof J.values) && (shouldForward(ec) || !0 === eo && isValidMotionProp(ec) || !et && !isValidMotionProp(ec) || J.draggable && ec.startsWith("onDrag")) && (el[ec] = J[ec]);
                  return el
                }(eo, "string" == typeof et, J)
                , eg = {
                  ...em,
                  ...ef,
                  ref: el
                }
                , { children: ey } = eo
                , eb = (0,
                  ep.useMemo)(() => isMotionValue(ey) ? ey.get() : ey, [ey]);
              return (0,
                ep.createElement)(et, {
                  ...eg,
                  children: eb
                })
            }
          }(et),
          createVisualElement: el,
          Component: J
        }
      }
      )(J, et, rO, create_visual_element_createDomVisualElement))
  },
  22081: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      c: function () {
        return el
      }
    });
    let el = {
      skipAnimations: !1,
      useManualTiming: !1
    }
  },
  45487: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      K: function () {
        return ec
      },
      k: function () {
        return ed
      }
    });
    var el = eo(81662);
    let ec = el.Z
      , ed = el.Z
  },
  11741: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      j: function () {
        return el
      }
    });
    let el = "undefined" != typeof document
  },
  81662: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      Z: function () {
        return noop
      }
    });
    let noop = J => J
  },
  96681: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      h: function () {
        return useConstant
      }
    });
    var el = eo(67294);
    function useConstant(J) {
      let et = (0,
        el.useRef)(null);
      return null === et.current && (et.current = J()),
        et.current
    }
  },
  58868: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      L: function () {
        return ed
      }
    });
    var el = eo(67294)
      , ec = eo(11741);
    let ed = ec.j ? el.useLayoutEffect : el.useEffect
  },
  37380: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      Cb: function () {
        return n
      },
      SB: function () {
        return state_r
      }
    });
    var el = eo(97286);
    /**
* @license
* Copyright 2017 Google LLC
* SPDX-License-Identifier: BSD-3-Clause
*/
    let ec = {
      attribute: !0,
      type: String,
      converter: el.Ts,
      reflect: !1,
      hasChanged: el.Qu
    }
      , r = (J = ec, et, eo) => {
        let { kind: el, metadata: ed } = eo
          , eh = globalThis.litPropertyMetadata.get(ed);
        if (void 0 === eh && globalThis.litPropertyMetadata.set(ed, eh = new Map),
          eh.set(eo.name, J),
          "accessor" === el) {
          let { name: el } = eo;
          return {
            set(eo) {
              let ec = et.get.call(this);
              et.set.call(this, eo),
                this.requestUpdate(el, ec, J)
            },
            init(et) {
              return void 0 !== et && this.C(el, void 0, J),
                et
            }
          }
        }
        if ("setter" === el) {
          let { name: el } = eo;
          return function (eo) {
            let ec = this[el];
            et.call(this, eo),
              this.requestUpdate(el, ec, J)
          }
        }
        throw Error("Unsupported decorator location: " + el)
      }
      ;
    function n(J) {
      return (et, eo) => "object" == typeof eo ? r(J, et, eo) : ((J, et, eo) => {
        let el = et.hasOwnProperty(eo);
        return et.constructor.createProperty(eo, el ? {
          ...J,
          wrapped: !0
        } : J),
          el ? Object.getOwnPropertyDescriptor(et, eo) : void 0
      }
      )(J, et, eo)
    }
    /**
* @license
* Copyright 2017 Google LLC
* SPDX-License-Identifier: BSD-3-Clause
*/
    function state_r(J) {
      return n({
        ...J,
        state: !0,
        attribute: !1
      })
    }
  },
  35592: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      o: function () {
        return o
      }
    });
    var el = eo(69699);
    /**
* @license
* Copyright 2018 Google LLC
* SPDX-License-Identifier: BSD-3-Clause
*/
    let o = J => J ?? el.Ld
  },
  69178: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      V: function () {
        return ref_e
      },
      i: function () {
        return ep
      }
    });
    var el = eo(69699);
    /**
* @license
* Copyright 2020 Google LLC
* SPDX-License-Identifier: BSD-3-Clause
*/
    let { D: ec } = el._$LH
      , directive_helpers_f = J => void 0 === J.strings;
    var ed = eo(48476);
    /**
* @license
* Copyright 2017 Google LLC
* SPDX-License-Identifier: BSD-3-Clause
*/
    let async_directive_s = (J, et) => {
      let eo = J._$AN;
      if (void 0 === eo)
        return !1;
      for (let J of eo)
        J._$AO?.(et, !1),
          async_directive_s(J, et);
      return !0
    }
      , o = J => {
        let et, eo;
        do {
          if (void 0 === (et = J._$AM))
            break;
          (eo = et._$AN).delete(J),
            J = et
        } while (0 === eo?.size)
      }
      , async_directive_r = J => {
        for (let et; et = J._$AM; J = et) {
          let eo = et._$AN;
          if (void 0 === eo)
            et._$AN = eo = new Set;
          else if (eo.has(J))
            break;
          eo.add(J),
            async_directive_c(et)
        }
      }
      ;
    function async_directive_h(J) {
      void 0 !== this._$AN ? (o(this),
        this._$AM = J,
        async_directive_r(this)) : this._$AM = J
    }
    function async_directive_n(J, et = !1, eo = 0) {
      let el = this._$AH
        , ec = this._$AN;
      if (void 0 !== ec && 0 !== ec.size) {
        if (et) {
          if (Array.isArray(el))
            for (let J = eo; J < el.length; J++)
              async_directive_s(el[J], !1),
                o(el[J]);
          else
            null != el && (async_directive_s(el, !1),
              o(el))
        } else
          async_directive_s(this, J)
      }
    }
    let async_directive_c = J => {
      J.type == ed.pX.CHILD && (J._$AP ??= async_directive_n,
        J._$AQ ??= async_directive_h)
    }
      ;
    let f = class f extends ed.Xe {
      constructor() {
        super(...arguments),
          this._$AN = void 0
      }
      _$AT(J, et, eo) {
        super._$AT(J, et, eo),
          async_directive_r(this),
          this.isConnected = J._$AU
      }
      _$AO(J, et = !0) {
        J !== this.isConnected && (this.isConnected = J,
          J ? this.reconnected?.() : this.disconnected?.()),
          et && (async_directive_s(this, J),
            o(this))
      }
      setValue(J) {
        if (directive_helpers_f(this._$Ct))
          this._$Ct._$AI(J, this);
        else {
          let et = [...this._$Ct._$AH];
          et[this._$Ci] = J,
            this._$Ct._$AI(et, this, 0)
        }
      }
      disconnected() { }
      reconnected() { }
    }
      ;
    /**
* @license
* Copyright 2020 Google LLC
* SPDX-License-Identifier: BSD-3-Clause
*/
    let ref_e = () => new ref_h;
    let ref_h = class ref_h {
    }
      ;
    let eh = new WeakMap
      , ep = (0,
        ed.XM)(class extends f {
          render(J) {
            return el.Ld
          }
          update(J, [et]) {
            let eo = et !== this.G;
            return eo && void 0 !== this.G && this.ot(void 0),
              (eo || this.rt !== this.lt) && (this.G = et,
                this.ct = J.options?.host,
                this.ot(this.lt = J.element)),
              el.Ld
          }
          ot(J) {
            if ("function" == typeof this.G) {
              let et = this.ct ?? globalThis
                , eo = eh.get(et);
              void 0 === eo && (eo = new WeakMap,
                eh.set(et, eo)),
                void 0 !== eo.get(this.G) && this.G.call(this.ct, void 0),
                eo.set(this.G, J),
                void 0 !== J && this.G.call(this.ct, J)
            } else
              this.G.value = J
          }
          get rt() {
            return "function" == typeof this.G ? eh.get(this.ct ?? globalThis)?.get(this.G) : this.G?.value
          }
          disconnected() {
            this.rt === this.lt && this.ot(void 0)
          }
          reconnected() {
            this.ot(this.lt)
          }
        }
        )
  },
  77996: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      oi: function () {
        return lit_element_s
      },
      iv: function () {
        return i
      },
      dy: function () {
        return eV
      },
      YP: function () {
        return eW
      },
      $m: function () {
        return r
      }
    }),
      eo(97286),
      eo(69699);
    /**
* @license
* Copyright 2019 Google LLC
* SPDX-License-Identifier: BSD-3-Clause
*/
    let el = globalThis
      , ec = el.ShadowRoot && (void 0 === el.ShadyCSS || el.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype
      , ed = Symbol()
      , eh = new WeakMap;
    let n = class n {
      constructor(J, et, eo) {
        if (this._$cssResult$ = !0,
          eo !== ed)
          throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
        this.cssText = J,
          this.t = et
      }
      get styleSheet() {
        let J = this.o
          , et = this.t;
        if (ec && void 0 === J) {
          let eo = void 0 !== et && 1 === et.length;
          eo && (J = eh.get(et)),
            void 0 === J && ((this.o = J = new CSSStyleSheet).replaceSync(this.cssText),
              eo && eh.set(et, J))
        }
        return J
      }
      toString() {
        return this.cssText
      }
    }
      ;
    let r = J => new n("string" == typeof J ? J : J + "", void 0, ed)
      , i = (J, ...et) => {
        let eo = 1 === J.length ? J[0] : et.reduce((et, eo, el) => et + (J => {
          if (!0 === J._$cssResult$)
            return J.cssText;
          if ("number" == typeof J)
            return J;
          throw Error("Value passed to 'css' function must be a 'css' function result: " + J + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")
        }
        )(eo) + J[el + 1], J[0]);
        return new n(eo, J, ed)
      }
      , S = (J, et) => {
        if (ec)
          J.adoptedStyleSheets = et.map(J => J instanceof CSSStyleSheet ? J : J.styleSheet);
        else
          for (let eo of et) {
            let et = document.createElement("style")
              , ec = el.litNonce;
            void 0 !== ec && et.setAttribute("nonce", ec),
              et.textContent = eo.cssText,
              J.appendChild(et)
          }
      }
      , ep = ec ? J => J : J => J instanceof CSSStyleSheet ? (J => {
        let et = "";
        for (let eo of J.cssRules)
          et += eo.cssText;
        return r(et)
      }
      )(J) : J
      , { is: ef, defineProperty: em, getOwnPropertyDescriptor: eg, getOwnPropertyNames: ey, getOwnPropertySymbols: eb, getPrototypeOf: ew } = Object
      , e_ = globalThis
      , ex = e_.trustedTypes
      , eE = ex ? ex.emptyScript : ""
      , eC = e_.reactiveElementPolyfillSupport
      , d = (J, et) => J
      , eS = {
        toAttribute(J, et) {
          switch (et) {
            case Boolean:
              J = J ? eE : null;
              break;
            case Object:
            case Array:
              J = null == J ? J : JSON.stringify(J)
          }
          return J
        },
        fromAttribute(J, et) {
          let eo = J;
          switch (et) {
            case Boolean:
              eo = null !== J;
              break;
            case Number:
              eo = null === J ? null : Number(J);
              break;
            case Object:
            case Array:
              try {
                eo = JSON.parse(J)
              } catch (J) {
                eo = null
              }
          }
          return eo
        }
      }
      , f = (J, et) => !ef(J, et)
      , ek = {
        attribute: !0,
        type: String,
        converter: eS,
        reflect: !1,
        hasChanged: f
      };
    Symbol.metadata ??= Symbol("metadata"),
      e_.litPropertyMetadata ??= new WeakMap;
    let b = class b extends HTMLElement {
      static addInitializer(J) {
        this._$Ei(),
          (this.l ??= []).push(J)
      }
      static get observedAttributes() {
        return this.finalize(),
          this._$Eh && [...this._$Eh.keys()]
      }
      static createProperty(J, et = ek) {
        if (et.state && (et.attribute = !1),
          this._$Ei(),
          this.elementProperties.set(J, et),
          !et.noAccessor) {
          let eo = Symbol()
            , el = this.getPropertyDescriptor(J, eo, et);
          void 0 !== el && em(this.prototype, J, el)
        }
      }
      static getPropertyDescriptor(J, et, eo) {
        let { get: el, set: ec } = eg(this.prototype, J) ?? {
          get() {
            return this[et]
          },
          set(J) {
            this[et] = J
          }
        };
        return {
          get() {
            return el?.call(this)
          },
          set(et) {
            let ed = el?.call(this);
            ec.call(this, et),
              this.requestUpdate(J, ed, eo)
          },
          configurable: !0,
          enumerable: !0
        }
      }
      static getPropertyOptions(J) {
        return this.elementProperties.get(J) ?? ek
      }
      static _$Ei() {
        if (this.hasOwnProperty(d("elementProperties")))
          return;
        let J = ew(this);
        J.finalize(),
          void 0 !== J.l && (this.l = [...J.l]),
          this.elementProperties = new Map(J.elementProperties)
      }
      static finalize() {
        if (this.hasOwnProperty(d("finalized")))
          return;
        if (this.finalized = !0,
          this._$Ei(),
          this.hasOwnProperty(d("properties"))) {
          let J = this.properties
            , et = [...ey(J), ...eb(J)];
          for (let eo of et)
            this.createProperty(eo, J[eo])
        }
        let J = this[Symbol.metadata];
        if (null !== J) {
          let et = litPropertyMetadata.get(J);
          if (void 0 !== et)
            for (let [J, eo] of et)
              this.elementProperties.set(J, eo)
        }
        for (let [J, et] of (this._$Eh = new Map,
          this.elementProperties)) {
          let eo = this._$Eu(J, et);
          void 0 !== eo && this._$Eh.set(eo, J)
        }
        this.elementStyles = this.finalizeStyles(this.styles)
      }
      static finalizeStyles(J) {
        let et = [];
        if (Array.isArray(J)) {
          let eo = new Set(J.flat(1 / 0).reverse());
          for (let J of eo)
            et.unshift(ep(J))
        } else
          void 0 !== J && et.push(ep(J));
        return et
      }
      static _$Eu(J, et) {
        let eo = et.attribute;
        return !1 === eo ? void 0 : "string" == typeof eo ? eo : "string" == typeof J ? J.toLowerCase() : void 0
      }
      constructor() {
        super(),
          this._$Ep = void 0,
          this.isUpdatePending = !1,
          this.hasUpdated = !1,
          this._$Em = null,
          this._$Ev()
      }
      _$Ev() {
        this._$Eg = new Promise(J => this.enableUpdating = J),
          this._$AL = new Map,
          this._$ES(),
          this.requestUpdate(),
          this.constructor.l?.forEach(J => J(this))
      }
      addController(J) {
        (this._$E_ ??= new Set).add(J),
          void 0 !== this.renderRoot && this.isConnected && J.hostConnected?.()
      }
      removeController(J) {
        this._$E_?.delete(J)
      }
      _$ES() {
        let J = new Map
          , et = this.constructor.elementProperties;
        for (let eo of et.keys())
          this.hasOwnProperty(eo) && (J.set(eo, this[eo]),
            delete this[eo]);
        J.size > 0 && (this._$Ep = J)
      }
      createRenderRoot() {
        let J = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
        return S(J, this.constructor.elementStyles),
          J
      }
      connectedCallback() {
        this.renderRoot ??= this.createRenderRoot(),
          this.enableUpdating(!0),
          this._$E_?.forEach(J => J.hostConnected?.())
      }
      enableUpdating(J) { }
      disconnectedCallback() {
        this._$E_?.forEach(J => J.hostDisconnected?.())
      }
      attributeChangedCallback(J, et, eo) {
        this._$AK(J, eo)
      }
      _$EO(J, et) {
        let eo = this.constructor.elementProperties.get(J)
          , el = this.constructor._$Eu(J, eo);
        if (void 0 !== el && !0 === eo.reflect) {
          let ec = (void 0 !== eo.converter?.toAttribute ? eo.converter : eS).toAttribute(et, eo.type);
          this._$Em = J,
            null == ec ? this.removeAttribute(el) : this.setAttribute(el, ec),
            this._$Em = null
        }
      }
      _$AK(J, et) {
        let eo = this.constructor
          , el = eo._$Eh.get(J);
        if (void 0 !== el && this._$Em !== el) {
          let J = eo.getPropertyOptions(el)
            , ec = "function" == typeof J.converter ? {
              fromAttribute: J.converter
            } : void 0 !== J.converter?.fromAttribute ? J.converter : eS;
          this._$Em = el,
            this[el] = ec.fromAttribute(et, J.type),
            this._$Em = null
        }
      }
      requestUpdate(J, et, eo) {
        if (void 0 !== J) {
          if (!((eo ??= this.constructor.getPropertyOptions(J)).hasChanged ?? f)(this[J], et))
            return;
          this.C(J, et, eo)
        }
        !1 === this.isUpdatePending && (this._$Eg = this._$EP())
      }
      C(J, et, eo) {
        this._$AL.has(J) || this._$AL.set(J, et),
          !0 === eo.reflect && this._$Em !== J && (this._$ET ??= new Set).add(J)
      }
      async _$EP() {
        this.isUpdatePending = !0;
        try {
          await this._$Eg
        } catch (J) {
          Promise.reject(J)
        }
        let J = this.scheduleUpdate();
        return null != J && await J,
          !this.isUpdatePending
      }
      scheduleUpdate() {
        return this.performUpdate()
      }
      performUpdate() {
        if (!this.isUpdatePending)
          return;
        if (!this.hasUpdated) {
          if (this.renderRoot ??= this.createRenderRoot(),
            this._$Ep) {
            for (let [J, et] of this._$Ep)
              this[J] = et;
            this._$Ep = void 0
          }
          let J = this.constructor.elementProperties;
          if (J.size > 0)
            for (let [et, eo] of J)
              !0 !== eo.wrapped || this._$AL.has(et) || void 0 === this[et] || this.C(et, this[et], eo)
        }
        let J = !1
          , et = this._$AL;
        try {
          (J = this.shouldUpdate(et)) ? (this.willUpdate(et),
            this._$E_?.forEach(J => J.hostUpdate?.()),
            this.update(et)) : this._$Ej()
        } catch (et) {
          throw J = !1,
          this._$Ej(),
          et
        }
        J && this._$AE(et)
      }
      willUpdate(J) { }
      _$AE(J) {
        this._$E_?.forEach(J => J.hostUpdated?.()),
          this.hasUpdated || (this.hasUpdated = !0,
            this.firstUpdated(J)),
          this.updated(J)
      }
      _$Ej() {
        this._$AL = new Map,
          this.isUpdatePending = !1
      }
      get updateComplete() {
        return this.getUpdateComplete()
      }
      getUpdateComplete() {
        return this._$Eg
      }
      shouldUpdate(J) {
        return !0
      }
      update(J) {
        this._$ET &&= this._$ET.forEach(J => this._$EO(J, this[J])),
          this._$Ej()
      }
      updated(J) { }
      firstUpdated(J) { }
    }
      ;
    b.elementStyles = [],
      b.shadowRootOptions = {
        mode: "open"
      },
      b[d("elementProperties")] = new Map,
      b[d("finalized")] = new Map,
      eC?.({
        ReactiveElement: b
      }),
      (e_.reactiveElementVersions ??= []).push("2.0.3");
    /**
* @license
* Copyright 2017 Google LLC
* SPDX-License-Identifier: BSD-3-Clause
*/
    let eT = globalThis
      , eA = eT.trustedTypes
      , eP = eA ? eA.createPolicy("lit-html", {
        createHTML: J => J
      }) : void 0
      , eR = "$lit$"
      , eI = `lit$${(Math.random() + "").slice(9)}$`
      , eO = "?" + eI
      , eN = `<${eO}>`
      , eM = document
      , lit_html_l = () => eM.createComment("")
      , lit_html_c = J => null === J || "object" != typeof J && "function" != typeof J
      , eD = Array.isArray
      , lit_html_u = J => eD(J) || "function" == typeof J?.[Symbol.iterator]
      , ej = "[ 	\n\f\r]"
      , eL = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g
      , e$ = /-->/g
      , eB = />/g
      , eF = RegExp(`>|${ej}(?:([^\\s"'>=/]+)(${ej}*=${ej}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g")
      , eU = /'/g
      , ez = /"/g
      , eH = /^(?:script|style|textarea|title)$/i
      , lit_html_y = J => (et, ...eo) => ({
        _$litType$: J,
        strings: et,
        values: eo
      })
      , eV = lit_html_y(1)
      , eW = lit_html_y(2)
      , eZ = Symbol.for("lit-noChange")
      , eG = Symbol.for("lit-nothing")
      , eY = new WeakMap
      , eK = eM.createTreeWalker(eM, 129);
    function C(J, et) {
      if (!Array.isArray(J) || !J.hasOwnProperty("raw"))
        throw Error("invalid template strings array");
      return void 0 !== eP ? eP.createHTML(et) : et
    }
    let P = (J, et) => {
      let eo = J.length - 1, el = [], ec, ed = 2 === et ? "<svg>" : "", eh = eL;
      for (let et = 0; et < eo; et++) {
        let eo = J[et], ep, ef, em = -1, eg = 0;
        for (; eg < eo.length && (eh.lastIndex = eg,
          null !== (ef = eh.exec(eo)));)
          eg = eh.lastIndex,
            eh === eL ? "!--" === ef[1] ? eh = e$ : void 0 !== ef[1] ? eh = eB : void 0 !== ef[2] ? (eH.test(ef[2]) && (ec = RegExp("</" + ef[2], "g")),
              eh = eF) : void 0 !== ef[3] && (eh = eF) : eh === eF ? ">" === ef[0] ? (eh = ec ?? eL,
                em = -1) : void 0 === ef[1] ? em = -2 : (em = eh.lastIndex - ef[2].length,
                  ep = ef[1],
                  eh = void 0 === ef[3] ? eF : '"' === ef[3] ? ez : eU) : eh === ez || eh === eU ? eh = eF : eh === e$ || eh === eB ? eh = eL : (eh = eF,
                    ec = void 0);
        let ey = eh === eF && J[et + 1].startsWith("/>") ? " " : "";
        ed += eh === eL ? eo + eN : em >= 0 ? (el.push(ep),
          eo.slice(0, em) + eR + eo.slice(em) + eI + ey) : eo + eI + (-2 === em ? et : ey)
      }
      return [C(J, ed + (J[eo] || "<?>") + (2 === et ? "</svg>" : "")), el]
    }
      ;
    let V = class V {
      constructor({ strings: J, _$litType$: et }, eo) {
        let el;
        this.parts = [];
        let ec = 0
          , ed = 0
          , eh = J.length - 1
          , ep = this.parts
          , [ef, em] = P(J, et);
        if (this.el = V.createElement(ef, eo),
          eK.currentNode = this.el.content,
          2 === et) {
          let J = this.el.content.firstChild;
          J.replaceWith(...J.childNodes)
        }
        for (; null !== (el = eK.nextNode()) && ep.length < eh;) {
          if (1 === el.nodeType) {
            if (el.hasAttributes())
              for (let J of el.getAttributeNames())
                if (J.endsWith(eR)) {
                  let et = em[ed++]
                    , eo = el.getAttribute(J).split(eI)
                    , eh = /([.?@])?(.*)/.exec(et);
                  ep.push({
                    type: 1,
                    index: ec,
                    name: eh[2],
                    strings: eo,
                    ctor: "." === eh[1] ? k : "?" === eh[1] ? H : "@" === eh[1] ? I : R
                  }),
                    el.removeAttribute(J)
                } else
                  J.startsWith(eI) && (ep.push({
                    type: 6,
                    index: ec
                  }),
                    el.removeAttribute(J));
            if (eH.test(el.tagName)) {
              let J = el.textContent.split(eI)
                , et = J.length - 1;
              if (et > 0) {
                el.textContent = eA ? eA.emptyScript : "";
                for (let eo = 0; eo < et; eo++)
                  el.append(J[eo], lit_html_l()),
                    eK.nextNode(),
                    ep.push({
                      type: 2,
                      index: ++ec
                    });
                el.append(J[et], lit_html_l())
              }
            }
          } else if (8 === el.nodeType) {
            if (el.data === eO)
              ep.push({
                type: 2,
                index: ec
              });
            else {
              let J = -1;
              for (; -1 !== (J = el.data.indexOf(eI, J + 1));)
                ep.push({
                  type: 7,
                  index: ec
                }),
                  J += eI.length - 1
            }
          }
          ec++
        }
      }
      static createElement(J, et) {
        let eo = eM.createElement("template");
        return eo.innerHTML = J,
          eo
      }
    }
      ;
    function N(J, et, eo = J, el) {
      if (et === eZ)
        return et;
      let ec = void 0 !== el ? eo._$Co?.[el] : eo._$Cl
        , ed = lit_html_c(et) ? void 0 : et._$litDirective$;
      return ec?.constructor !== ed && (ec?._$AO?.(!1),
        void 0 === ed ? ec = void 0 : (ec = new ed(J))._$AT(J, eo, el),
        void 0 !== el ? (eo._$Co ??= [])[el] = ec : eo._$Cl = ec),
        void 0 !== ec && (et = N(J, ec._$AS(J, et.values), ec, el)),
        et
    }
    let lit_html_S = class lit_html_S {
      constructor(J, et) {
        this._$AV = [],
          this._$AN = void 0,
          this._$AD = J,
          this._$AM = et
      }
      get parentNode() {
        return this._$AM.parentNode
      }
      get _$AU() {
        return this._$AM._$AU
      }
      u(J) {
        let { el: { content: et }, parts: eo } = this._$AD
          , el = (J?.creationScope ?? eM).importNode(et, !0);
        eK.currentNode = el;
        let ec = eK.nextNode()
          , ed = 0
          , eh = 0
          , ep = eo[0];
        for (; void 0 !== ep;) {
          if (ed === ep.index) {
            let et;
            2 === ep.type ? et = new M(ec, ec.nextSibling, this, J) : 1 === ep.type ? et = new ep.ctor(ec, ep.name, ep.strings, this, J) : 6 === ep.type && (et = new L(ec, this, J)),
              this._$AV.push(et),
              ep = eo[++eh]
          }
          ed !== ep?.index && (ec = eK.nextNode(),
            ed++)
        }
        return eK.currentNode = eM,
          el
      }
      p(J) {
        let et = 0;
        for (let eo of this._$AV)
          void 0 !== eo && (void 0 !== eo.strings ? (eo._$AI(J, eo, et),
            et += eo.strings.length - 2) : eo._$AI(J[et])),
            et++
      }
    }
      ;
    let M = class M {
      get _$AU() {
        return this._$AM?._$AU ?? this._$Cv
      }
      constructor(J, et, eo, el) {
        this.type = 2,
          this._$AH = eG,
          this._$AN = void 0,
          this._$AA = J,
          this._$AB = et,
          this._$AM = eo,
          this.options = el,
          this._$Cv = el?.isConnected ?? !0
      }
      get parentNode() {
        let J = this._$AA.parentNode
          , et = this._$AM;
        return void 0 !== et && 11 === J?.nodeType && (J = et.parentNode),
          J
      }
      get startNode() {
        return this._$AA
      }
      get endNode() {
        return this._$AB
      }
      _$AI(J, et = this) {
        lit_html_c(J = N(this, J, et)) ? J === eG || null == J || "" === J ? (this._$AH !== eG && this._$AR(),
          this._$AH = eG) : J !== this._$AH && J !== eZ && this._(J) : void 0 !== J._$litType$ ? this.g(J) : void 0 !== J.nodeType ? this.$(J) : lit_html_u(J) ? this.T(J) : this._(J)
      }
      k(J) {
        return this._$AA.parentNode.insertBefore(J, this._$AB)
      }
      $(J) {
        this._$AH !== J && (this._$AR(),
          this._$AH = this.k(J))
      }
      _(J) {
        this._$AH !== eG && lit_html_c(this._$AH) ? this._$AA.nextSibling.data = J : this.$(eM.createTextNode(J)),
          this._$AH = J
      }
      g(J) {
        let { values: et, _$litType$: eo } = J
          , el = "number" == typeof eo ? this._$AC(J) : (void 0 === eo.el && (eo.el = V.createElement(C(eo.h, eo.h[0]), this.options)),
            eo);
        if (this._$AH?._$AD === el)
          this._$AH.p(et);
        else {
          let J = new lit_html_S(el, this)
            , eo = J.u(this.options);
          J.p(et),
            this.$(eo),
            this._$AH = J
        }
      }
      _$AC(J) {
        let et = eY.get(J.strings);
        return void 0 === et && eY.set(J.strings, et = new V(J)),
          et
      }
      T(J) {
        eD(this._$AH) || (this._$AH = [],
          this._$AR());
        let et = this._$AH, eo, el = 0;
        for (let ec of J)
          el === et.length ? et.push(eo = new M(this.k(lit_html_l()), this.k(lit_html_l()), this, this.options)) : eo = et[el],
            eo._$AI(ec),
            el++;
        el < et.length && (this._$AR(eo && eo._$AB.nextSibling, el),
          et.length = el)
      }
      _$AR(J = this._$AA.nextSibling, et) {
        for (this._$AP?.(!1, !0, et); J && J !== this._$AB;) {
          let et = J.nextSibling;
          J.remove(),
            J = et
        }
      }
      setConnected(J) {
        void 0 === this._$AM && (this._$Cv = J,
          this._$AP?.(J))
      }
    }
      ;
    let R = class R {
      get tagName() {
        return this.element.tagName
      }
      get _$AU() {
        return this._$AM._$AU
      }
      constructor(J, et, eo, el, ec) {
        this.type = 1,
          this._$AH = eG,
          this._$AN = void 0,
          this.element = J,
          this.name = et,
          this._$AM = el,
          this.options = ec,
          eo.length > 2 || "" !== eo[0] || "" !== eo[1] ? (this._$AH = Array(eo.length - 1).fill(new String),
            this.strings = eo) : this._$AH = eG
      }
      _$AI(J, et = this, eo, el) {
        let ec = this.strings
          , ed = !1;
        if (void 0 === ec)
          (ed = !lit_html_c(J = N(this, J, et, 0)) || J !== this._$AH && J !== eZ) && (this._$AH = J);
        else {
          let el, eh;
          let ep = J;
          for (J = ec[0],
            el = 0; el < ec.length - 1; el++)
            (eh = N(this, ep[eo + el], et, el)) === eZ && (eh = this._$AH[el]),
              ed ||= !lit_html_c(eh) || eh !== this._$AH[el],
              eh === eG ? J = eG : J !== eG && (J += (eh ?? "") + ec[el + 1]),
              this._$AH[el] = eh
        }
        ed && !el && this.O(J)
      }
      O(J) {
        J === eG ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, J ?? "")
      }
    }
      ;
    let k = class k extends R {
      constructor() {
        super(...arguments),
          this.type = 3
      }
      O(J) {
        this.element[this.name] = J === eG ? void 0 : J
      }
    }
      ;
    let H = class H extends R {
      constructor() {
        super(...arguments),
          this.type = 4
      }
      O(J) {
        this.element.toggleAttribute(this.name, !!J && J !== eG)
      }
    }
      ;
    let I = class I extends R {
      constructor(J, et, eo, el, ec) {
        super(J, et, eo, el, ec),
          this.type = 5
      }
      _$AI(J, et = this) {
        if ((J = N(this, J, et, 0) ?? eG) === eZ)
          return;
        let eo = this._$AH
          , el = J === eG && eo !== eG || J.capture !== eo.capture || J.once !== eo.once || J.passive !== eo.passive
          , ec = J !== eG && (eo === eG || el);
        el && this.element.removeEventListener(this.name, this, eo),
          ec && this.element.addEventListener(this.name, this, J),
          this._$AH = J
      }
      handleEvent(J) {
        "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, J) : this._$AH.handleEvent(J)
      }
    }
      ;
    let L = class L {
      constructor(J, et, eo) {
        this.element = J,
          this.type = 6,
          this._$AN = void 0,
          this._$AM = et,
          this.options = eo
      }
      get _$AU() {
        return this._$AM._$AU
      }
      _$AI(J) {
        N(this, J)
      }
    }
      ;
    let eJ = eT.litHtmlPolyfillSupport;
    eJ?.(V, M),
      (eT.litHtmlVersions ??= []).push("3.1.1");
    let j = (J, et, eo) => {
      let el = eo?.renderBefore ?? et
        , ec = el._$litPart$;
      if (void 0 === ec) {
        let J = eo?.renderBefore ?? null;
        el._$litPart$ = ec = new M(et.insertBefore(lit_html_l(), J), J, void 0, eo ?? {})
      }
      return ec._$AI(J),
        ec
    }
      ;
    /**
* @license
* Copyright 2017 Google LLC
* SPDX-License-Identifier: BSD-3-Clause
*/
    let lit_element_s = class lit_element_s extends b {
      constructor() {
        super(...arguments),
          this.renderOptions = {
            host: this
          },
          this._$Do = void 0
      }
      createRenderRoot() {
        let J = super.createRenderRoot();
        return this.renderOptions.renderBefore ??= J.firstChild,
          J
      }
      update(J) {
        let et = this.render();
        this.hasUpdated || (this.renderOptions.isConnected = this.isConnected),
          super.update(J),
          this._$Do = j(et, this.renderRoot, this.renderOptions)
      }
      connectedCallback() {
        super.connectedCallback(),
          this._$Do?.setConnected(!0)
      }
      disconnectedCallback() {
        super.disconnectedCallback(),
          this._$Do?.setConnected(!1)
      }
      render() {
        return eZ
      }
    }
      ;
    lit_element_s._$litElement$ = !0,
      lit_element_s.finalized = !0,
      globalThis.litElementHydrateSupport?.({
        LitElement: lit_element_s
      });
    let eQ = globalThis.litElementPolyfillSupport;
    eQ?.({
      LitElement: lit_element_s
    }),
      (globalThis.litElementVersions ??= []).push("4.0.3")
  },
  97286: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      Ts: function () {
        return eS
      },
      Qu: function () {
        return f
      }
    });
    /**
* @license
* Copyright 2019 Google LLC
* SPDX-License-Identifier: BSD-3-Clause
*/
    let el = globalThis
      , ec = el.ShadowRoot && (void 0 === el.ShadyCSS || el.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype
      , ed = Symbol()
      , eh = new WeakMap;
    let n = class n {
      constructor(J, et, eo) {
        if (this._$cssResult$ = !0,
          eo !== ed)
          throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
        this.cssText = J,
          this.t = et
      }
      get styleSheet() {
        let J = this.o
          , et = this.t;
        if (ec && void 0 === J) {
          let eo = void 0 !== et && 1 === et.length;
          eo && (J = eh.get(et)),
            void 0 === J && ((this.o = J = new CSSStyleSheet).replaceSync(this.cssText),
              eo && eh.set(et, J))
        }
        return J
      }
      toString() {
        return this.cssText
      }
    }
      ;
    let r = J => new n("string" == typeof J ? J : J + "", void 0, ed)
      , S = (J, et) => {
        if (ec)
          J.adoptedStyleSheets = et.map(J => J instanceof CSSStyleSheet ? J : J.styleSheet);
        else
          for (let eo of et) {
            let et = document.createElement("style")
              , ec = el.litNonce;
            void 0 !== ec && et.setAttribute("nonce", ec),
              et.textContent = eo.cssText,
              J.appendChild(et)
          }
      }
      , ep = ec ? J => J : J => J instanceof CSSStyleSheet ? (J => {
        let et = "";
        for (let eo of J.cssRules)
          et += eo.cssText;
        return r(et)
      }
      )(J) : J
      , { is: ef, defineProperty: em, getOwnPropertyDescriptor: eg, getOwnPropertyNames: ey, getOwnPropertySymbols: eb, getPrototypeOf: ew } = Object
      , e_ = globalThis
      , ex = e_.trustedTypes
      , eE = ex ? ex.emptyScript : ""
      , eC = e_.reactiveElementPolyfillSupport
      , d = (J, et) => J
      , eS = {
        toAttribute(J, et) {
          switch (et) {
            case Boolean:
              J = J ? eE : null;
              break;
            case Object:
            case Array:
              J = null == J ? J : JSON.stringify(J)
          }
          return J
        },
        fromAttribute(J, et) {
          let eo = J;
          switch (et) {
            case Boolean:
              eo = null !== J;
              break;
            case Number:
              eo = null === J ? null : Number(J);
              break;
            case Object:
            case Array:
              try {
                eo = JSON.parse(J)
              } catch (J) {
                eo = null
              }
          }
          return eo
        }
      }
      , f = (J, et) => !ef(J, et)
      , ek = {
        attribute: !0,
        type: String,
        converter: eS,
        reflect: !1,
        hasChanged: f
      };
    Symbol.metadata ??= Symbol("metadata"),
      e_.litPropertyMetadata ??= new WeakMap;
    let b = class b extends HTMLElement {
      static addInitializer(J) {
        this._$Ei(),
          (this.l ??= []).push(J)
      }
      static get observedAttributes() {
        return this.finalize(),
          this._$Eh && [...this._$Eh.keys()]
      }
      static createProperty(J, et = ek) {
        if (et.state && (et.attribute = !1),
          this._$Ei(),
          this.elementProperties.set(J, et),
          !et.noAccessor) {
          let eo = Symbol()
            , el = this.getPropertyDescriptor(J, eo, et);
          void 0 !== el && em(this.prototype, J, el)
        }
      }
      static getPropertyDescriptor(J, et, eo) {
        let { get: el, set: ec } = eg(this.prototype, J) ?? {
          get() {
            return this[et]
          },
          set(J) {
            this[et] = J
          }
        };
        return {
          get() {
            return el?.call(this)
          },
          set(et) {
            let ed = el?.call(this);
            ec.call(this, et),
              this.requestUpdate(J, ed, eo)
          },
          configurable: !0,
          enumerable: !0
        }
      }
      static getPropertyOptions(J) {
        return this.elementProperties.get(J) ?? ek
      }
      static _$Ei() {
        if (this.hasOwnProperty(d("elementProperties")))
          return;
        let J = ew(this);
        J.finalize(),
          void 0 !== J.l && (this.l = [...J.l]),
          this.elementProperties = new Map(J.elementProperties)
      }
      static finalize() {
        if (this.hasOwnProperty(d("finalized")))
          return;
        if (this.finalized = !0,
          this._$Ei(),
          this.hasOwnProperty(d("properties"))) {
          let J = this.properties
            , et = [...ey(J), ...eb(J)];
          for (let eo of et)
            this.createProperty(eo, J[eo])
        }
        let J = this[Symbol.metadata];
        if (null !== J) {
          let et = litPropertyMetadata.get(J);
          if (void 0 !== et)
            for (let [J, eo] of et)
              this.elementProperties.set(J, eo)
        }
        for (let [J, et] of (this._$Eh = new Map,
          this.elementProperties)) {
          let eo = this._$Eu(J, et);
          void 0 !== eo && this._$Eh.set(eo, J)
        }
        this.elementStyles = this.finalizeStyles(this.styles)
      }
      static finalizeStyles(J) {
        let et = [];
        if (Array.isArray(J)) {
          let eo = new Set(J.flat(1 / 0).reverse());
          for (let J of eo)
            et.unshift(ep(J))
        } else
          void 0 !== J && et.push(ep(J));
        return et
      }
      static _$Eu(J, et) {
        let eo = et.attribute;
        return !1 === eo ? void 0 : "string" == typeof eo ? eo : "string" == typeof J ? J.toLowerCase() : void 0
      }
      constructor() {
        super(),
          this._$Ep = void 0,
          this.isUpdatePending = !1,
          this.hasUpdated = !1,
          this._$Em = null,
          this._$Ev()
      }
      _$Ev() {
        this._$Eg = new Promise(J => this.enableUpdating = J),
          this._$AL = new Map,
          this._$ES(),
          this.requestUpdate(),
          this.constructor.l?.forEach(J => J(this))
      }
      addController(J) {
        (this._$E_ ??= new Set).add(J),
          void 0 !== this.renderRoot && this.isConnected && J.hostConnected?.()
      }
      removeController(J) {
        this._$E_?.delete(J)
      }
      _$ES() {
        let J = new Map
          , et = this.constructor.elementProperties;
        for (let eo of et.keys())
          this.hasOwnProperty(eo) && (J.set(eo, this[eo]),
            delete this[eo]);
        J.size > 0 && (this._$Ep = J)
      }
      createRenderRoot() {
        let J = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
        return S(J, this.constructor.elementStyles),
          J
      }
      connectedCallback() {
        this.renderRoot ??= this.createRenderRoot(),
          this.enableUpdating(!0),
          this._$E_?.forEach(J => J.hostConnected?.())
      }
      enableUpdating(J) { }
      disconnectedCallback() {
        this._$E_?.forEach(J => J.hostDisconnected?.())
      }
      attributeChangedCallback(J, et, eo) {
        this._$AK(J, eo)
      }
      _$EO(J, et) {
        let eo = this.constructor.elementProperties.get(J)
          , el = this.constructor._$Eu(J, eo);
        if (void 0 !== el && !0 === eo.reflect) {
          let ec = (void 0 !== eo.converter?.toAttribute ? eo.converter : eS).toAttribute(et, eo.type);
          this._$Em = J,
            null == ec ? this.removeAttribute(el) : this.setAttribute(el, ec),
            this._$Em = null
        }
      }
      _$AK(J, et) {
        let eo = this.constructor
          , el = eo._$Eh.get(J);
        if (void 0 !== el && this._$Em !== el) {
          let J = eo.getPropertyOptions(el)
            , ec = "function" == typeof J.converter ? {
              fromAttribute: J.converter
            } : void 0 !== J.converter?.fromAttribute ? J.converter : eS;
          this._$Em = el,
            this[el] = ec.fromAttribute(et, J.type),
            this._$Em = null
        }
      }
      requestUpdate(J, et, eo) {
        if (void 0 !== J) {
          if (!((eo ??= this.constructor.getPropertyOptions(J)).hasChanged ?? f)(this[J], et))
            return;
          this.C(J, et, eo)
        }
        !1 === this.isUpdatePending && (this._$Eg = this._$EP())
      }
      C(J, et, eo) {
        this._$AL.has(J) || this._$AL.set(J, et),
          !0 === eo.reflect && this._$Em !== J && (this._$ET ??= new Set).add(J)
      }
      async _$EP() {
        this.isUpdatePending = !0;
        try {
          await this._$Eg
        } catch (J) {
          Promise.reject(J)
        }
        let J = this.scheduleUpdate();
        return null != J && await J,
          !this.isUpdatePending
      }
      scheduleUpdate() {
        return this.performUpdate()
      }
      performUpdate() {
        if (!this.isUpdatePending)
          return;
        if (!this.hasUpdated) {
          if (this.renderRoot ??= this.createRenderRoot(),
            this._$Ep) {
            for (let [J, et] of this._$Ep)
              this[J] = et;
            this._$Ep = void 0
          }
          let J = this.constructor.elementProperties;
          if (J.size > 0)
            for (let [et, eo] of J)
              !0 !== eo.wrapped || this._$AL.has(et) || void 0 === this[et] || this.C(et, this[et], eo)
        }
        let J = !1
          , et = this._$AL;
        try {
          (J = this.shouldUpdate(et)) ? (this.willUpdate(et),
            this._$E_?.forEach(J => J.hostUpdate?.()),
            this.update(et)) : this._$Ej()
        } catch (et) {
          throw J = !1,
          this._$Ej(),
          et
        }
        J && this._$AE(et)
      }
      willUpdate(J) { }
      _$AE(J) {
        this._$E_?.forEach(J => J.hostUpdated?.()),
          this.hasUpdated || (this.hasUpdated = !0,
            this.firstUpdated(J)),
          this.updated(J)
      }
      _$Ej() {
        this._$AL = new Map,
          this.isUpdatePending = !1
      }
      get updateComplete() {
        return this.getUpdateComplete()
      }
      getUpdateComplete() {
        return this._$Eg
      }
      shouldUpdate(J) {
        return !0
      }
      update(J) {
        this._$ET &&= this._$ET.forEach(J => this._$EO(J, this[J])),
          this._$Ej()
      }
      updated(J) { }
      firstUpdated(J) { }
    }
      ;
    b.elementStyles = [],
      b.shadowRootOptions = {
        mode: "open"
      },
      b[d("elementProperties")] = new Map,
      b[d("finalized")] = new Map,
      eC?.({
        ReactiveElement: b
      }),
      (e_.reactiveElementVersions ??= []).push("2.0.3")
  },
  48476: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      XM: function () {
        return e
      },
      Xe: function () {
        return i
      },
      pX: function () {
        return el
      }
    });
    /**
* @license
* Copyright 2017 Google LLC
* SPDX-License-Identifier: BSD-3-Clause
*/
    let el = {
      ATTRIBUTE: 1,
      CHILD: 2,
      PROPERTY: 3,
      BOOLEAN_ATTRIBUTE: 4,
      EVENT: 5,
      ELEMENT: 6
    }
      , e = J => (...et) => ({
        _$litDirective$: J,
        values: et
      });
    let i = class i {
      constructor(J) { }
      get _$AU() {
        return this._$AM._$AU
      }
      _$AT(J, et, eo) {
        this._$Ct = J,
          this._$AM = et,
          this._$Ci = eo
      }
      _$AS(J, et) {
        return this.update(J, et)
      }
      update(J, et) {
        return this.render(...et)
      }
    }
  },
  69699: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      Jb: function () {
        return eT
      },
      Ld: function () {
        return eA
      },
      _$LH: function () {
        return eI
      }
    });
    /**
* @license
* Copyright 2017 Google LLC
* SPDX-License-Identifier: BSD-3-Clause
*/
    let el = globalThis
      , ec = el.trustedTypes
      , ed = ec ? ec.createPolicy("lit-html", {
        createHTML: J => J
      }) : void 0
      , eh = "$lit$"
      , ep = `lit$${(Math.random() + "").slice(9)}$`
      , ef = "?" + ep
      , em = `<${ef}>`
      , eg = document
      , l = () => eg.createComment("")
      , c = J => null === J || "object" != typeof J && "function" != typeof J
      , ey = Array.isArray
      , u = J => ey(J) || "function" == typeof J?.[Symbol.iterator]
      , eb = "[ 	\n\f\r]"
      , ew = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g
      , e_ = /-->/g
      , ex = />/g
      , eE = RegExp(`>|${eb}(?:([^\\s"'>=/]+)(${eb}*=${eb}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g")
      , eC = /'/g
      , eS = /"/g
      , ek = /^(?:script|style|textarea|title)$/i
      , y = J => (et, ...eo) => ({
        _$litType$: J,
        strings: et,
        values: eo
      })
      , eT = (y(1),
        y(2),
        Symbol.for("lit-noChange"))
      , eA = Symbol.for("lit-nothing")
      , eP = new WeakMap
      , eR = eg.createTreeWalker(eg, 129);
    function C(J, et) {
      if (!Array.isArray(J) || !J.hasOwnProperty("raw"))
        throw Error("invalid template strings array");
      return void 0 !== ed ? ed.createHTML(et) : et
    }
    let P = (J, et) => {
      let eo = J.length - 1, el = [], ec, ed = 2 === et ? "<svg>" : "", ef = ew;
      for (let et = 0; et < eo; et++) {
        let eo = J[et], eg, ey, eb = -1, eT = 0;
        for (; eT < eo.length && (ef.lastIndex = eT,
          null !== (ey = ef.exec(eo)));)
          eT = ef.lastIndex,
            ef === ew ? "!--" === ey[1] ? ef = e_ : void 0 !== ey[1] ? ef = ex : void 0 !== ey[2] ? (ek.test(ey[2]) && (ec = RegExp("</" + ey[2], "g")),
              ef = eE) : void 0 !== ey[3] && (ef = eE) : ef === eE ? ">" === ey[0] ? (ef = ec ?? ew,
                eb = -1) : void 0 === ey[1] ? eb = -2 : (eb = ef.lastIndex - ey[2].length,
                  eg = ey[1],
                  ef = void 0 === ey[3] ? eE : '"' === ey[3] ? eS : eC) : ef === eS || ef === eC ? ef = eE : ef === e_ || ef === ex ? ef = ew : (ef = eE,
                    ec = void 0);
        let eA = ef === eE && J[et + 1].startsWith("/>") ? " " : "";
        ed += ef === ew ? eo + em : eb >= 0 ? (el.push(eg),
          eo.slice(0, eb) + eh + eo.slice(eb) + ep + eA) : eo + ep + (-2 === eb ? et : eA)
      }
      return [C(J, ed + (J[eo] || "<?>") + (2 === et ? "</svg>" : "")), el]
    }
      ;
    let V = class V {
      constructor({ strings: J, _$litType$: et }, eo) {
        let el;
        this.parts = [];
        let ed = 0
          , em = 0
          , eg = J.length - 1
          , ey = this.parts
          , [eb, ew] = P(J, et);
        if (this.el = V.createElement(eb, eo),
          eR.currentNode = this.el.content,
          2 === et) {
          let J = this.el.content.firstChild;
          J.replaceWith(...J.childNodes)
        }
        for (; null !== (el = eR.nextNode()) && ey.length < eg;) {
          if (1 === el.nodeType) {
            if (el.hasAttributes())
              for (let J of el.getAttributeNames())
                if (J.endsWith(eh)) {
                  let et = ew[em++]
                    , eo = el.getAttribute(J).split(ep)
                    , ec = /([.?@])?(.*)/.exec(et);
                  ey.push({
                    type: 1,
                    index: ed,
                    name: ec[2],
                    strings: eo,
                    ctor: "." === ec[1] ? k : "?" === ec[1] ? H : "@" === ec[1] ? I : R
                  }),
                    el.removeAttribute(J)
                } else
                  J.startsWith(ep) && (ey.push({
                    type: 6,
                    index: ed
                  }),
                    el.removeAttribute(J));
            if (ek.test(el.tagName)) {
              let J = el.textContent.split(ep)
                , et = J.length - 1;
              if (et > 0) {
                el.textContent = ec ? ec.emptyScript : "";
                for (let eo = 0; eo < et; eo++)
                  el.append(J[eo], l()),
                    eR.nextNode(),
                    ey.push({
                      type: 2,
                      index: ++ed
                    });
                el.append(J[et], l())
              }
            }
          } else if (8 === el.nodeType) {
            if (el.data === ef)
              ey.push({
                type: 2,
                index: ed
              });
            else {
              let J = -1;
              for (; -1 !== (J = el.data.indexOf(ep, J + 1));)
                ey.push({
                  type: 7,
                  index: ed
                }),
                  J += ep.length - 1
            }
          }
          ed++
        }
      }
      static createElement(J, et) {
        let eo = eg.createElement("template");
        return eo.innerHTML = J,
          eo
      }
    }
      ;
    function N(J, et, eo = J, el) {
      if (et === eT)
        return et;
      let ec = void 0 !== el ? eo._$Co?.[el] : eo._$Cl
        , ed = c(et) ? void 0 : et._$litDirective$;
      return ec?.constructor !== ed && (ec?._$AO?.(!1),
        void 0 === ed ? ec = void 0 : (ec = new ed(J))._$AT(J, eo, el),
        void 0 !== el ? (eo._$Co ??= [])[el] = ec : eo._$Cl = ec),
        void 0 !== ec && (et = N(J, ec._$AS(J, et.values), ec, el)),
        et
    }
    let S = class S {
      constructor(J, et) {
        this._$AV = [],
          this._$AN = void 0,
          this._$AD = J,
          this._$AM = et
      }
      get parentNode() {
        return this._$AM.parentNode
      }
      get _$AU() {
        return this._$AM._$AU
      }
      u(J) {
        let { el: { content: et }, parts: eo } = this._$AD
          , el = (J?.creationScope ?? eg).importNode(et, !0);
        eR.currentNode = el;
        let ec = eR.nextNode()
          , ed = 0
          , eh = 0
          , ep = eo[0];
        for (; void 0 !== ep;) {
          if (ed === ep.index) {
            let et;
            2 === ep.type ? et = new M(ec, ec.nextSibling, this, J) : 1 === ep.type ? et = new ep.ctor(ec, ep.name, ep.strings, this, J) : 6 === ep.type && (et = new L(ec, this, J)),
              this._$AV.push(et),
              ep = eo[++eh]
          }
          ed !== ep?.index && (ec = eR.nextNode(),
            ed++)
        }
        return eR.currentNode = eg,
          el
      }
      p(J) {
        let et = 0;
        for (let eo of this._$AV)
          void 0 !== eo && (void 0 !== eo.strings ? (eo._$AI(J, eo, et),
            et += eo.strings.length - 2) : eo._$AI(J[et])),
            et++
      }
    }
      ;
    let M = class M {
      get _$AU() {
        return this._$AM?._$AU ?? this._$Cv
      }
      constructor(J, et, eo, el) {
        this.type = 2,
          this._$AH = eA,
          this._$AN = void 0,
          this._$AA = J,
          this._$AB = et,
          this._$AM = eo,
          this.options = el,
          this._$Cv = el?.isConnected ?? !0
      }
      get parentNode() {
        let J = this._$AA.parentNode
          , et = this._$AM;
        return void 0 !== et && 11 === J?.nodeType && (J = et.parentNode),
          J
      }
      get startNode() {
        return this._$AA
      }
      get endNode() {
        return this._$AB
      }
      _$AI(J, et = this) {
        c(J = N(this, J, et)) ? J === eA || null == J || "" === J ? (this._$AH !== eA && this._$AR(),
          this._$AH = eA) : J !== this._$AH && J !== eT && this._(J) : void 0 !== J._$litType$ ? this.g(J) : void 0 !== J.nodeType ? this.$(J) : u(J) ? this.T(J) : this._(J)
      }
      k(J) {
        return this._$AA.parentNode.insertBefore(J, this._$AB)
      }
      $(J) {
        this._$AH !== J && (this._$AR(),
          this._$AH = this.k(J))
      }
      _(J) {
        this._$AH !== eA && c(this._$AH) ? this._$AA.nextSibling.data = J : this.$(eg.createTextNode(J)),
          this._$AH = J
      }
      g(J) {
        let { values: et, _$litType$: eo } = J
          , el = "number" == typeof eo ? this._$AC(J) : (void 0 === eo.el && (eo.el = V.createElement(C(eo.h, eo.h[0]), this.options)),
            eo);
        if (this._$AH?._$AD === el)
          this._$AH.p(et);
        else {
          let J = new S(el, this)
            , eo = J.u(this.options);
          J.p(et),
            this.$(eo),
            this._$AH = J
        }
      }
      _$AC(J) {
        let et = eP.get(J.strings);
        return void 0 === et && eP.set(J.strings, et = new V(J)),
          et
      }
      T(J) {
        ey(this._$AH) || (this._$AH = [],
          this._$AR());
        let et = this._$AH, eo, el = 0;
        for (let ec of J)
          el === et.length ? et.push(eo = new M(this.k(l()), this.k(l()), this, this.options)) : eo = et[el],
            eo._$AI(ec),
            el++;
        el < et.length && (this._$AR(eo && eo._$AB.nextSibling, el),
          et.length = el)
      }
      _$AR(J = this._$AA.nextSibling, et) {
        for (this._$AP?.(!1, !0, et); J && J !== this._$AB;) {
          let et = J.nextSibling;
          J.remove(),
            J = et
        }
      }
      setConnected(J) {
        void 0 === this._$AM && (this._$Cv = J,
          this._$AP?.(J))
      }
    }
      ;
    let R = class R {
      get tagName() {
        return this.element.tagName
      }
      get _$AU() {
        return this._$AM._$AU
      }
      constructor(J, et, eo, el, ec) {
        this.type = 1,
          this._$AH = eA,
          this._$AN = void 0,
          this.element = J,
          this.name = et,
          this._$AM = el,
          this.options = ec,
          eo.length > 2 || "" !== eo[0] || "" !== eo[1] ? (this._$AH = Array(eo.length - 1).fill(new String),
            this.strings = eo) : this._$AH = eA
      }
      _$AI(J, et = this, eo, el) {
        let ec = this.strings
          , ed = !1;
        if (void 0 === ec)
          (ed = !c(J = N(this, J, et, 0)) || J !== this._$AH && J !== eT) && (this._$AH = J);
        else {
          let el, eh;
          let ep = J;
          for (J = ec[0],
            el = 0; el < ec.length - 1; el++)
            (eh = N(this, ep[eo + el], et, el)) === eT && (eh = this._$AH[el]),
              ed ||= !c(eh) || eh !== this._$AH[el],
              eh === eA ? J = eA : J !== eA && (J += (eh ?? "") + ec[el + 1]),
              this._$AH[el] = eh
        }
        ed && !el && this.O(J)
      }
      O(J) {
        J === eA ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, J ?? "")
      }
    }
      ;
    let k = class k extends R {
      constructor() {
        super(...arguments),
          this.type = 3
      }
      O(J) {
        this.element[this.name] = J === eA ? void 0 : J
      }
    }
      ;
    let H = class H extends R {
      constructor() {
        super(...arguments),
          this.type = 4
      }
      O(J) {
        this.element.toggleAttribute(this.name, !!J && J !== eA)
      }
    }
      ;
    let I = class I extends R {
      constructor(J, et, eo, el, ec) {
        super(J, et, eo, el, ec),
          this.type = 5
      }
      _$AI(J, et = this) {
        if ((J = N(this, J, et, 0) ?? eA) === eT)
          return;
        let eo = this._$AH
          , el = J === eA && eo !== eA || J.capture !== eo.capture || J.once !== eo.once || J.passive !== eo.passive
          , ec = J !== eA && (eo === eA || el);
        el && this.element.removeEventListener(this.name, this, eo),
          ec && this.element.addEventListener(this.name, this, J),
          this._$AH = J
      }
      handleEvent(J) {
        "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, J) : this._$AH.handleEvent(J)
      }
    }
      ;
    let L = class L {
      constructor(J, et, eo) {
        this.element = J,
          this.type = 6,
          this._$AN = void 0,
          this._$AM = et,
          this.options = eo
      }
      get _$AU() {
        return this._$AM._$AU
      }
      _$AI(J) {
        N(this, J)
      }
    }
      ;
    let eI = {
      j: eh,
      P: ep,
      A: ef,
      C: 1,
      M: P,
      L: S,
      R: u,
      V: N,
      D: M,
      I: R,
      H,
      N: I,
      U: k,
      B: L
    }
      , eO = el.litHtmlPolyfillSupport;
    eO?.(V, M),
      (el.litHtmlVersions ??= []).push("3.1.1")
  },
  88039: function (J, et, eo) {
    "use strict";
    let el;
    eo.d(et, {
      zx: function () {
        return eA
      },
      RQ: function () {
        return tZ
      },
      t3: function () {
        return t0
      },
      Z0: function () {
        return eW
      },
      OK: function () {
        return rq
      },
      Dg: function () {
        return rG
      },
      mQ: function () {
        return rJ
      },
      LQ: function () {
        return no
      },
      Rz: function () {
        return t$
      },
      GH: function () {
        return tN
      },
      ib: function () {
        return tD
      }
    });
    var ec = eo(186)
      , ed = eo(48764).Buffer;
    let eh = "4px 4px 10px 0 rgba(0, 0, 0, 0.35)"
      , ep = "inset 2px 2px 3px rgba(0,0,0,0.2)"
      , createDisabledTextStyles = () => ec.iv`
-webkit-text-fill-color: ${({ theme: J }) => J.materialTextDisabled};
color: ${({ theme: J }) => J.materialTextDisabled};
text-shadow: 1px 1px ${({ theme: J }) => J.materialTextDisabledShadow};
/* filter: grayscale(100%); */
`
      , createBoxStyles = ({ background: J = "material", color: et = "materialText" } = {}) => ec.iv`
box-sizing: border-box;
display: inline-block;
background: ${({ theme: et }) => et[J]};
color: ${({ theme: J }) => J[et]};
`
      , createHatchedBackground = ({ mainColor: J = "black", secondaryColor: et = "transparent", pixelSize: eo = 2 }) => ec.iv`
background-image: ${`linear-gradient(
    45deg,
    ${J} 25%,
    transparent 25%,
    transparent 75%,
    ${J} 75%
  ),linear-gradient(
    45deg,
    ${J} 25%,
    transparent 25%,
    transparent 75%,
    ${J} 75%
  )`};
background-color: ${et};
background-size: ${`${2 * eo}px ${2 * eo}px`};
background-position: 0 0, ${`${eo}px ${eo}px`};
`
      , createFlatBoxStyles = () => ec.iv`
position: relative;
box-sizing: border-box;
display: inline-block;
color: ${({ theme: J }) => J.materialText};
background: ${({ $disabled: J, theme: et }) => J ? et.flatLight : et.canvas};
border: 2px solid ${({ theme: J }) => J.canvas};
outline: 2px solid ${({ theme: J }) => J.flatDark};
outline-offset: -4px;
`
      , ef = {
        button: {
          topLeftOuter: "borderLightest",
          topLeftInner: "borderLight",
          bottomRightInner: "borderDark",
          bottomRightOuter: "borderDarkest"
        },
        buttonPressed: {
          topLeftOuter: "borderDarkest",
          topLeftInner: "borderDark",
          bottomRightInner: "borderLight",
          bottomRightOuter: "borderLightest"
        },
        buttonThin: {
          topLeftOuter: "borderLightest",
          topLeftInner: null,
          bottomRightInner: null,
          bottomRightOuter: "borderDark"
        },
        buttonThinPressed: {
          topLeftOuter: "borderDark",
          topLeftInner: null,
          bottomRightInner: null,
          bottomRightOuter: "borderLightest"
        },
        field: {
          topLeftOuter: "borderDark",
          topLeftInner: "borderDarkest",
          bottomRightInner: "borderLight",
          bottomRightOuter: "borderLightest"
        },
        grouping: {
          topLeftOuter: "borderDark",
          topLeftInner: "borderLightest",
          bottomRightInner: "borderDark",
          bottomRightOuter: "borderLightest"
        },
        status: {
          topLeftOuter: "borderDark",
          topLeftInner: null,
          bottomRightInner: null,
          bottomRightOuter: "borderLightest"
        },
        window: {
          topLeftOuter: "borderLight",
          topLeftInner: "borderLightest",
          bottomRightInner: "borderDark",
          bottomRightOuter: "borderDarkest"
        }
      }
      , createInnerBorderWithShadow = ({ theme: J, topLeftInner: et, bottomRightInner: eo, hasShadow: el = !1, hasInsetShadow: ec = !1 }) => [!!el && eh, !!ec && ep, null !== et && `inset 1px 1px 0px 1px ${J[et]}`, null !== eo && `inset -1px -1px 0 1px ${J[eo]}`].filter(Boolean).join(", ")
      , createBorderStyles = ({ invert: J = !1, style: et = "button" } = {}) => {
        let eo = {
          topLeftOuter: J ? "bottomRightOuter" : "topLeftOuter",
          topLeftInner: J ? "bottomRightInner" : "topLeftInner",
          bottomRightInner: J ? "topLeftInner" : "bottomRightInner",
          bottomRightOuter: J ? "topLeftOuter" : "bottomRightOuter"
        };
        return ec.iv`
  border-style: solid;
  border-width: 2px;
  border-left-color: ${({ theme: J }) => J[ef[et][eo.topLeftOuter]]};
  border-top-color: ${({ theme: J }) => J[ef[et][eo.topLeftOuter]]};
  border-right-color: ${({ theme: J }) => J[ef[et][eo.bottomRightOuter]]};
  border-bottom-color: ${({ theme: J }) => J[ef[et][eo.bottomRightOuter]]};
  box-shadow: ${({ theme: J, shadow: el }) => createInnerBorderWithShadow({
          theme: J,
          topLeftInner: ef[et][eo.topLeftInner],
          bottomRightInner: ef[et][eo.bottomRightInner],
          hasShadow: el
        })};
`
      }
      , focusOutline = () => ec.iv`
outline: 2px dotted ${({ theme: J }) => J.materialText};
`
      , em = "undefined" != typeof btoa ? btoa : J => ed.from(J).toString("base64")
      , createTriangleSVG = (J, et = 0) => {
        let eo = `<svg height="26" width="26" viewBox="0 0 26 26" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <g transform="rotate(${et} 13 13)">
    <polygon fill="${J}" points="6,10 20,10 13,17"/>
  </g>
</svg>`
          , el = em(eo);
        return `url(data:image/svg+xml;base64,${el})`
      }
      , createScrollbars = (J = "default") => ec.iv`
::-webkit-scrollbar {
  width: 26px;
  height: 26px;
}
::-webkit-scrollbar-track {
  ${({ theme: et }) => createHatchedBackground({
        mainColor: "flat" === J ? et.flatLight : et.material,
        secondaryColor: "flat" === J ? et.canvas : et.borderLightest
      })}
}
::-webkit-scrollbar-thumb {
  ${createBoxStyles()}
  ${"flat" === J ? createFlatBoxStyles() : createBorderStyles({
        style: "window"
      })}
    outline-offset: -2px;
}

::-webkit-scrollbar-corner {
  background-color: ${({ theme: J }) => J.material};
}
::-webkit-scrollbar-button {
  ${createBoxStyles()}
  ${"flat" === J ? createFlatBoxStyles() : createBorderStyles({
        style: "window"
      })}
    display: block;
  outline-offset: -2px;
  height: 26px;
  width: 26px;
  background-repeat: no-repeat;
  background-size: 100%;
  background-position: 0 0;
}
::-webkit-scrollbar-button:active,
::-webkit-scrollbar-button:active {
  background-position: 0 1px;
  ${"default" === J ? createBorderStyles({
        style: "window",
        invert: !0
      }) : ""}
}

::-webkit-scrollbar-button:horizontal:increment:start,
::-webkit-scrollbar-button:horizontal:decrement:end,
::-webkit-scrollbar-button:vertical:increment:start,
::-webkit-scrollbar-button:vertical:decrement:end {
  display: none;
}

::-webkit-scrollbar-button:horizontal:decrement {
  background-image: ${({ theme: J }) => createTriangleSVG(J.materialText, 90)};
}

::-webkit-scrollbar-button:horizontal:increment {
  background-image: ${({ theme: J }) => createTriangleSVG(J.materialText, 270)};
}

::-webkit-scrollbar-button:vertical:decrement {
  background-image: ${({ theme: J }) => createTriangleSVG(J.materialText, 180)};
}

::-webkit-scrollbar-button:vertical:increment {
  background-image: ${({ theme: J }) => createTriangleSVG(J.materialText, 0)};
}
`;
    var eg = eo(67294);
    let ey = ec.ZP.a`
color: ${({ theme: J }) => J.anchor};
font-size: inherit;
text-decoration: ${({ underline: J }) => J ? "underline" : "none"};
&:visited {
  color: ${({ theme: J }) => J.anchorVisited};
}
`
      , eb = (0,
        eg.forwardRef)(({ children: J, underline: et = !0, ...eo }, el) => eg.createElement(ey, {
          ref: el,
          underline: et,
          ...eo
        }, J));
    eb.displayName = "Anchor";
    let ew = ec.ZP.header`
${createBorderStyles()};
${createBoxStyles()};

position: ${J => {
        var et;
        return null !== (et = J.position) && void 0 !== et ? et : J.fixed ? "fixed" : "absolute"
      }
      };
top: 0;
right: 0;
left: auto;
display: flex;
flex-direction: column;
width: 100%;
`
      , e_ = (0,
        eg.forwardRef)(({ children: J, fixed: et = !0, position: eo = "fixed", ...el }, ec) => eg.createElement(ew, {
          fixed: et,
          position: !1 !== et ? eo : void 0,
          ref: ec,
          ...el
        }, J));
    e_.displayName = "AppBar";
    let noOp = () => { }
      ;
    function clamp(J, et, eo) {
      return null !== eo && J > eo ? eo : null !== et && J < et ? et : J
    }
    function roundValueToStep(J, et, eo) {
      let el = Math.round((J - eo) / et) * et + eo;
      return Number(el.toFixed(function (J) {
        if (1 > Math.abs(J)) {
          let et = J.toExponential().split("e-")
            , eo = et[0].split(".")[1];
          return (eo ? eo.length : 0) + parseInt(et[1], 10)
        }
        let et = J.toString().split(".")[1];
        return et ? et.length : 0
      }(et)))
    }
    function getSize(J) {
      return "number" == typeof J ? `${J}px` : J
    }
    let ex = ec.ZP.div`
display: inline-block;
box-sizing: border-box;
object-fit: contain;
${({ size: J }) => `
  height: ${J};
  width: ${J};
  `}
border-radius: ${({ square: J }) => J ? 0 : "50%"};
overflow: hidden;
${({ noBorder: J, theme: et }) => !J && `
  border-top: 2px solid ${et.borderDark};
  border-left: 2px solid ${et.borderDark};
  border-bottom: 2px solid ${et.borderLightest};
  border-right: 2px solid ${et.borderLightest};
  background: ${et.material};
`}
${({ src: J }) => !J && `
  display: flex;
  align-items: center;
  justify-content: space-around;
  font-weight: bold;
  font-size: 1rem;
`}
`
      , eE = ec.ZP.img`
display: block;
object-fit: contain;
width: 100%;
height: 100%;
`
      , eC = (0,
        eg.forwardRef)(({ alt: J = "", children: et, noBorder: eo = !1, size: el = 35, square: ec = !1, src: ed, ...eh }, ep) => eg.createElement(ex, {
          noBorder: eo,
          ref: ep,
          size: getSize(el),
          square: ec,
          src: ed,
          ...eh
        }, ed ? eg.createElement(eE, {
          src: ed,
          alt: J
        }) : et));
    eC.displayName = "Avatar";
    let eS = {
      sm: "28px",
      md: "36px",
      lg: "44px"
    }
      , ek = ec.iv`
position: relative;
display: inline-flex;
align-items: center;
justify-content: center;
height: ${({ size: J = "md" }) => eS[J]};
width: ${({ fullWidth: J, size: et = "md", square: eo }) => J ? "100%" : eo ? eS[et] : "auto"};
padding: ${({ square: J }) => J ? 0 : "0 10px"};
font-size: 1rem;
user-select: none;
&:active {
  padding-top: ${({ disabled: J }) => !J && "2px"};
}
padding-top: ${({ active: J, disabled: et }) => J && !et && "2px"};
&:after {
  content: '';
  position: absolute;
  display: block;
  top: 0;
  left: 0;
  height: 100%;
  width: 100%;
}
&:not(:disabled) {
  cursor: pointer;
}
font-family: inherit;
`
      , eT = ec.ZP.button`
${({ active: J, disabled: et, primary: eo, theme: el, variant: ed }) => "flat" === ed ? ec.iv`
        ${createFlatBoxStyles()}
        ${eo ? `
        border: 2px solid ${el.checkmark};
          outline: 2px solid ${el.flatDark};
          outline-offset: -4px;
        ` : `
        border: 2px solid ${el.flatDark};
          outline: 2px solid transparent;
          outline-offset: -4px;
        `}
        &:focus:after, &:active:after {
          ${!J && !et && focusOutline}
          outline-offset: -4px;
        }
      ` : "menu" === ed || "thin" === ed ? ec.iv`
        ${createBoxStyles()};
        border: 2px solid transparent;
        &:hover,
        &:focus {
          ${!et && !J && createBorderStyles({
        style: "buttonThin"
      })}
        }
        &:active {
          ${!et && createBorderStyles({
        style: "buttonThinPressed"
      })}
        }
        ${J && createBorderStyles({
        style: "buttonThinPressed"
      })}
        ${et && createDisabledTextStyles()}
      ` : ec.iv`
        ${createBoxStyles()};
        border: none;
        ${et && createDisabledTextStyles()}
        ${J ? createHatchedBackground({
        mainColor: el.material,
        secondaryColor: el.borderLightest
      }) : ""}
        &:before {
          box-sizing: border-box;
          content: '';
          position: absolute;
          ${eo ? ec.iv`
                left: 2px;
                top: 2px;
                width: calc(100% - 4px);
                height: calc(100% - 4px);
                outline: 2px solid ${el.borderDarkest};
              ` : ec.iv`
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
              `}

          ${J ? createBorderStyles({
        style: "raised" === ed ? "window" : "button",
        invert: !0
      }) : createBorderStyles({
        style: "raised" === ed ? "window" : "button",
        invert: !1
      })}
        }
        &:active:before {
          ${!et && createBorderStyles({
        style: "raised" === ed ? "window" : "button",
        invert: !0
      })}
        }
        &:focus:after,
        &:active:after {
          ${!J && !et && focusOutline}
          outline-offset: -8px;
        }
        &:active:focus:after,
        &:active:after {
          top: ${J ? "0" : "1px"};
        }
      `}
${ek}
`
      , eA = (0,
        eg.forwardRef)(({ onClick: J, disabled: et = !1, children: eo, type: el = "button", fullWidth: ec = !1, size: ed = "md", square: eh = !1, active: ep = !1, onTouchStart: ef = noOp, primary: em = !1, variant: ey = "default", ...eb }, ew) => eg.createElement(eT, {
          active: ep,
          disabled: et,
          $disabled: et,
          fullWidth: ec,
          onClick: et ? void 0 : J,
          onTouchStart: ef,
          primary: em,
          ref: ew,
          size: ed,
          square: eh,
          type: el,
          variant: ey,
          ...eb
        }, eo));
    function useControlledOrUncontrolled({ defaultValue: J, onChange: et, onChangePropName: eo = "onChange", readOnly: el, value: ec, valuePropName: ed = "value" }) {
      let eh = void 0 !== ec
        , [ep, ef] = (0,
          eg.useState)(J)
        , em = (0,
          eg.useCallback)(J => {
            eh || ef(J)
          }
            , [eh]);
      if (eh && "function" != typeof et && !el) {
        let J = `Warning: You provided a \`${ed}\` prop to a component without an \`${eo}\` handler.${"value" === ed ? `This will render a read-only field. If the field should be mutable use \`defaultValue\`. Otherwise, set either \`${eo}\` or \`readOnly\`.` : `This breaks the component state. You must provide an \`${eo}\` function that updates \`${ed}\`.`}`;
        console.warn(J)
      }
      return [eh ? ec : ep, em]
    }
    eA.displayName = "Button";
    let eP = ec.ZP.li`
box-sizing: border-box;

display: flex;
align-items: center;
position: relative;
height: ${J => eS[J.size]};
width: ${J => J.square ? eS[J.size] : "auto"};
padding: 0 8px;
font-size: 1rem;
white-space: nowrap;
justify-content: ${J => J.square ? "space-around" : "space-between"};
text-align: center;
line-height: ${J => eS[J.size]};
color: ${({ theme: J }) => J.materialText};
pointer-events: ${({ $disabled: J }) => J ? "none" : "auto"};
font-weight: ${({ primary: J }) => J ? "bold" : "normal"};
&:hover {
  ${({ theme: J, $disabled: et }) => !et && `
      color: ${J.materialTextInvert};
      background: ${J.hoverBackground};
    `}

  cursor: default;
}
${J => J.$disabled && createDisabledTextStyles()}
`
      , eR = (0,
        eg.forwardRef)(({ size: J = "lg", disabled: et, square: eo, children: el, onClick: ec, primary: ed, ...eh }, ep) => eg.createElement(eP, {
          $disabled: et,
          size: J,
          square: eo,
          onClick: et ? void 0 : ec,
          primary: ed,
          role: "menuitem",
          ref: ep,
          "aria-disabled": et,
          ...eh
        }, el));
    eR.displayName = "MenuListItem";
    let eI = ec.ZP.ul.attrs(() => ({
      role: "menu"
    }))`
box-sizing: border-box;
width: ${J => J.fullWidth ? "100%" : "auto"};
padding: 4px;
${createBorderStyles({
      style: "window"
    })}
${createBoxStyles()}
${J => J.inline && `
  display: inline-flex;
  align-items: center;
`}
list-style: none;
position: relative;
`;
    eI.displayName = "MenuList";
    let eO = ec.ZP.input`
position: absolute;
left: 0;
margin: 0;
width: ${20}px;
height: ${20}px;
opacity: 0;
z-index: -1;
`
      , eN = ec.ZP.label`
display: inline-flex;
align-items: center;
position: relative;
margin: 8px 0;
cursor: ${({ $disabled: J }) => J ? "auto" : "pointer"};
user-select: none;
font-size: 1rem;
color: ${({ theme: J }) => J.materialText};
${J => J.$disabled && createDisabledTextStyles()}

${eP} & {
  margin: 0;
  height: 100%;
}
${eP}:hover & {
  ${({ $disabled: J, theme: et }) => !J && ec.iv`
      color: ${et.materialTextInvert};
    `};
}
`
      , eM = ec.ZP.span`
display: inline-block;
line-height: 1;
padding: 2px;
${eO}:focus ~ & {
  ${focusOutline}
}
${eO}:not(:disabled) ~ &:active {
  ${focusOutline}
}
`
      , eD = ec.ZP.div`
position: relative;
box-sizing: border-box;
padding: 2px;
font-size: 1rem;
border-style: solid;
border-width: 2px;
border-left-color: ${({ theme: J }) => J.borderDark};
border-top-color: ${({ theme: J }) => J.borderDark};
border-right-color: ${({ theme: J }) => J.borderLightest};
border-bottom-color: ${({ theme: J }) => J.borderLightest};
line-height: 1.5;
&:before {
  position: absolute;
  left: 0;
  top: 0;
  content: '';
  width: calc(100% - 4px);
  height: calc(100% - 4px);

  border-style: solid;
  border-width: 2px;
  border-left-color: ${({ theme: J }) => J.borderDarkest};
  border-top-color: ${({ theme: J }) => J.borderDarkest};
  border-right-color: ${({ theme: J }) => J.borderLight};
  border-bottom-color: ${({ theme: J }) => J.borderLight};

  pointer-events: none;
  ${J => J.shadow && `box-shadow:${ep};`}
}
`
      , ej = ec.ZP.div`
box-sizing: border-box;
width: 100%;
height: 100%;
padding: 4px;
overflow: auto;
${createScrollbars()}
`
      , eL = (0,
        eg.forwardRef)(({ children: J, shadow: et = !0, ...eo }, el) => eg.createElement(eD, {
          ref: el,
          shadow: et,
          ...eo
        }, eg.createElement(ej, null, J)));
    eL.displayName = "ScrollView";
    let e$ = ec.iv`
width: ${20}px;
height: ${20}px;
display: flex;
align-items: center;
justify-content: space-around;
margin-right: 0.5rem;
`
      , eB = (0,
        ec.ZP)(eD)`
${e$}
width: ${20}px;
height: ${20}px;
background: ${({ $disabled: J, theme: et }) => J ? et.material : et.canvas};
&:before {
  box-shadow: none;
}
`
      , eF = ec.ZP.div`
position: relative;
box-sizing: border-box;
display: inline-block;
background: ${({ $disabled: J, theme: et }) => J ? et.flatLight : et.canvas};
${e$}
width: ${16}px;
height: ${16}px;
outline: none;
border: 2px solid ${({ theme: J }) => J.flatDark};
background: ${({ $disabled: J, theme: et }) => J ? et.flatLight : et.canvas};
`
      , eU = ec.ZP.span.attrs(() => ({
        "data-testid": "checkmarkIcon"
      }))`
display: inline-block;
position: relative;
width: 100%;
height: 100%;
&:after {
  content: '';
  display: block;
  position: absolute;
  left: 50%;
  top: calc(50% - 1px);
  width: 3px;
  height: 7px;

  border: solid
    ${({ $disabled: J, theme: et }) => J ? et.checkmarkDisabled : et.checkmark};
  border-width: 0 3px 3px 0;
  transform: translate(-50%, -50%) rotate(45deg);

  border-color: ${J => J.$disabled ? J.theme.checkmarkDisabled : J.theme.checkmark};
}
`
      , ez = ec.ZP.span.attrs(() => ({
        "data-testid": "indeterminateIcon"
      }))`
display: inline-block;
position: relative;

width: 100%;
height: 100%;

&:after {
  content: '';
  display: block;

  width: 100%;
  height: 100%;

  ${({ $disabled: J, theme: et }) => createHatchedBackground({
        mainColor: J ? et.checkmarkDisabled : et.checkmark
      })}
  background-position: 0px 0px, 2px 2px;
}
`
      , eH = {
        flat: eF,
        default: eB
      }
      , eV = (0,
        eg.forwardRef)(({ checked: J, className: et = "", defaultChecked: eo = !1, disabled: el = !1, indeterminate: ec = !1, label: ed = "", onChange: eh = noOp, style: ep = {}, value: ef, variant: em = "default", ...ey }, eb) => {
          var ew;
          let [e_, ex] = useControlledOrUncontrolled({
            defaultValue: eo,
            onChange: eh,
            readOnly: null !== (ew = ey.readOnly) && void 0 !== ew ? ew : el,
            value: J
          })
            , eE = (0,
              eg.useCallback)(J => {
                let et = J.target.checked;
                ex(et),
                  eh(J)
              }
                , [eh, ex])
            , eC = eH[em]
            , eS = null;
          return ec ? eS = ez : e_ && (eS = eU),
            eg.createElement(eN, {
              $disabled: el,
              className: et,
              style: ep
            }, eg.createElement(eO, {
              disabled: el,
              onChange: el ? void 0 : eE,
              readOnly: el,
              type: "checkbox",
              value: ef,
              checked: e_,
              "data-indeterminate": ec,
              ref: eb,
              ...ey
            }), eg.createElement(eC, {
              $disabled: el,
              role: "presentation"
            }, eS && eg.createElement(eS, {
              $disabled: el,
              variant: em
            })), ed && eg.createElement(eM, null, ed))
        }
        );
    eV.displayName = "Checkbox";
    let eW = ec.ZP.div`
${({ orientation: J, theme: et, size: eo = "100%" }) => "vertical" === J ? `
  height: ${getSize(eo)};
  border-left: 2px solid ${et.borderDark};
  border-right: 2px solid ${et.borderLightest};
  margin: 0;
  ` : `
  width: ${getSize(eo)};
  border-bottom: 2px solid ${et.borderLightest};
  border-top: 2px solid ${et.borderDark};
  margin: 0;
  `}
`;
    eW.displayName = "Separator";
    let eZ = (0,
      ec.ZP)(eT)`
padding-left: 8px;
`
      , eG = (0,
        ec.ZP)(eW)`
height: 21px;
position: relative;
top: 0;
`
      , eY = ec.ZP.input`
box-sizing: border-box;
width: 100%;
height: 100%;
position: absolute;
left: 0;
top: 0;
opacity: 0;
z-index: 1;
cursor: pointer;
&:disabled {
  cursor: default;
}
`
      , eK = ec.ZP.div`
box-sizing: border-box;
height: 19px;
display: inline-block;
width: 35px;
margin-right: 5px;

background: ${({ color: J }) => J};

${({ $disabled: J }) => J ? ec.iv`
        border: 2px solid ${({ theme: J }) => J.materialTextDisabled};
        filter: drop-shadow(
          1px 1px 0px ${({ theme: J }) => J.materialTextDisabledShadow}
        );
      ` : ec.iv`
        border: 2px solid ${({ theme: J }) => J.materialText};
      `}
${eY}:focus:not(:active) + &:after {
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  ${focusOutline}
  outline-offset: -8px;
}
`
      , eJ = ec.ZP.span`
width: 0px;
height: 0px;
border-left: 6px solid transparent;
border-right: 6px solid transparent;
display: inline-block;
margin-left: 6px;

${({ $disabled: J }) => J ? ec.iv`
        border-top: 6px solid ${({ theme: J }) => J.materialTextDisabled};
        filter: drop-shadow(
          1px 1px 0px ${({ theme: J }) => J.materialTextDisabledShadow}
        );
      ` : ec.iv`
        border-top: 6px solid ${({ theme: J }) => J.materialText};
      `}
&:after {
  content: '';
  box-sizing: border-box;
  position: absolute;
  top: ${({ variant: J }) => "flat" === J ? "6px" : "8px"};
  right: 8px;
  width: 16px;
  height: 19px;
}
`
      , eQ = (0,
        eg.forwardRef)(({ value: J, defaultValue: et, onChange: eo = noOp, disabled: el = !1, variant: ec = "default", ...ed }, eh) => {
          var ep;
          let [ef, em] = useControlledOrUncontrolled({
            defaultValue: et,
            onChange: eo,
            readOnly: null !== (ep = ed.readOnly) && void 0 !== ep ? ep : el,
            value: J
          });
          return eg.createElement(eZ, {
            disabled: el,
            as: "div",
            variant: ec,
            size: "md"
          }, eg.createElement(eY, {
            onChange: J => {
              let et = J.target.value;
              em(et),
                eo(J)
            }
            ,
            readOnly: el,
            disabled: el,
            value: null != ef ? ef : "#008080",
            type: "color",
            ref: eh,
            ...ed
          }), eg.createElement(eK, {
            $disabled: el,
            color: null != ef ? ef : "#008080",
            role: "presentation"
          }), "default" === ec && eg.createElement(eG, {
            orientation: "vertical"
          }), eg.createElement(eJ, {
            $disabled: el,
            variant: ec
          }))
        }
        );
    eQ.displayName = "ColorInput";
    let eX = ec.ZP.div`
position: relative;
--react95-digit-primary-color: #ff0102;
--react95-digit-secondary-color: #740201;
--react95-digit-bg-color: #000000;

${({ pixelSize: J }) => ec.iv`
  width: ${11 * J}px;
  height: ${21 * J}px;
  margin: ${J}px;

  span,
  span:before,
  span:after {
    box-sizing: border-box;
    display: inline-block;
    position: absolute;
  }
  span.active,
  span.active:before,
  span.active:after {
    background: var(--react95-digit-primary-color);
  }
  span:not(.active),
  span:not(.active):before,
  span:not(.active):after {
    ${createHatchedBackground({
      mainColor: "var(--react95-digit-bg-color)",
      secondaryColor: "var(--react95-digit-secondary-color)",
      pixelSize: J
    })}
  }

  span.horizontal,
  span.horizontal:before,
  span.horizontal:after {
    height: ${J}px;
    border-left: ${J}px solid var(--react95-digit-bg-color);
    border-right: ${J}px solid var(--react95-digit-bg-color);
  }
  span.horizontal.active,
  span.horizontal.active:before,
  span.horizontal.active:after {
    height: ${J}px;
    border-left: ${J}px solid var(--react95-digit-primary-color);
    border-right: ${J}px solid var(--react95-digit-primary-color);
  }
  span.horizontal {
    left: ${J}px;
    width: ${9 * J}px;
  }
  span.horizontal:before {
    content: '';
    width: 100%;
    top: ${J}px;
    left: ${0}px;
  }
  span.horizontal:after {
    content: '';
    width: calc(100% - ${2 * J}px);
    top: ${2 * J}px;
    left: ${J}px;
  }
  span.horizontal.top {
    top: 0;
  }
  span.horizontal.bottom {
    bottom: 0;
    transform: rotateX(180deg);
  }

  span.center,
  span.center:before,
  span.center:after {
    height: ${J}px;
    border-left: ${J}px solid var(--react95-digit-bg-color);
    border-right: ${J}px solid var(--react95-digit-bg-color);
  }
  span.center.active,
  span.center.active:before,
  span.center.active:after {
    border-left: ${J}px solid var(--react95-digit-primary-color);
    border-right: ${J}px solid var(--react95-digit-primary-color);
  }
  span.center {
    top: 50%;
    transform: translateY(-50%);
    left: ${J}px;
    width: ${9 * J}px;
  }
  span.center:before,
  span.center:after {
    content: '';
    width: 100%;
  }
  span.center:before {
    top: ${J}px;
  }
  span.center:after {
    bottom: ${J}px;
  }

  span.vertical,
  span.vertical:before,
  span.vertical:after {
    width: ${J}px;
    border-top: ${J}px solid var(--react95-digit-bg-color);
    border-bottom: ${J}px solid var(--react95-digit-bg-color);
  }
  span.vertical {
    height: ${11 * J}px;
  }
  span.vertical.left {
    left: 0;
  }
  span.vertical.right {
    right: 0;
    transform: rotateY(180deg);
  }
  span.vertical.top {
    top: 0px;
  }
  span.vertical.bottom {
    bottom: 0px;
  }
  span.vertical:before {
    content: '';
    height: 100%;
    top: ${0}px;
    left: ${J}px;
  }
  span.vertical:after {
    content: '';
    height: calc(100% - ${2 * J}px);
    top: ${J}px;
    left: ${2 * J}px;
  }
`}
`
      , e0 = ["horizontal top", "center", "horizontal bottom", "vertical top left", "vertical top right", "vertical bottom left", "vertical bottom right"]
      , e1 = [[1, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 1, 0, 1], [1, 1, 1, 0, 1, 1, 0], [1, 1, 1, 0, 1, 0, 1], [0, 1, 0, 1, 1, 0, 1], [1, 1, 1, 1, 0, 0, 1], [1, 1, 1, 1, 0, 1, 1], [1, 0, 0, 0, 1, 0, 1], [1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 0, 1]];
    function Digit({ digit: J = 0, pixelSize: et = 2, ...eo }) {
      let el = e1[Number(J)].map((J, et) => J ? `${e0[et]} active` : e0[et]);
      return eg.createElement(eX, {
        pixelSize: et,
        ...eo
      }, el.map((J, et) => eg.createElement("span", {
        className: J,
        key: et
      })))
    }
    let e2 = ec.ZP.div`
${createBorderStyles({
      style: "status"
    })}
display: inline-flex;
background: #000000;
`
      , e3 = {
        sm: 1,
        md: 2,
        lg: 3,
        xl: 4
      }
      , e5 = (0,
        eg.forwardRef)(({ value: J = 0, minLength: et = 3, size: eo = "md", ...el }, ec) => {
          let ed = (0,
            eg.useMemo)(() => J.toString().padStart(et, "0").split(""), [et, J]);
          return eg.createElement(e2, {
            ref: ec,
            ...el
          }, ed.map((J, et) => eg.createElement(Digit, {
            digit: J,
            pixelSize: e3[eo],
            key: et
          })))
        }
        );
    e5.displayName = "Counter";
    let e6 = ec.iv`
display: flex;
align-items: center;
width: ${({ fullWidth: J }) => J ? "100%" : "auto"};
min-height: ${eS.md};
`
      , e4 = (0,
        ec.ZP)(eD).attrs({
          "data-testid": "variant-default"
        })`
${e6}
background: ${({ $disabled: J, theme: et }) => J ? et.material : et.canvas};
`
      , e8 = ec.ZP.div.attrs({
        "data-testid": "variant-flat"
      })`
${createFlatBoxStyles()}
${e6}
position: relative;
`
      , e7 = ec.iv`
display: block;
box-sizing: border-box;
width: 100%;
height: 100%;
outline: none;
border: none;
background: none;
font-size: 1rem;
min-height: 27px;
font-family: inherit;
color: ${({ theme: J }) => J.canvasText};
${({ disabled: J, variant: et }) => "flat" !== et && J && createDisabledTextStyles()}
`
      , e9 = ec.ZP.input`
${e7}
padding: 0 8px;
`
      , tn = ec.ZP.textarea`
${e7}
padding: 8px;
resize: none;
${({ variant: J }) => createScrollbars(J)}
`
      , to = (0,
        eg.forwardRef)(({ className: J, disabled: et = !1, fullWidth: eo, onChange: el = noOp, shadow: ec = !0, style: ed, variant: eh = "default", ...ep }, ef) => {
          let em = "flat" === eh ? e8 : e4
            , ey = (0,
              eg.useMemo)(() => {
                var J;
                return ep.multiline ? eg.createElement(tn, {
                  disabled: et,
                  onChange: et ? void 0 : el,
                  readOnly: et,
                  ref: ef,
                  variant: eh,
                  ...ep
                }) : eg.createElement(e9, {
                  disabled: et,
                  onChange: et ? void 0 : el,
                  readOnly: et,
                  ref: ef,
                  type: null !== (J = ep.type) && void 0 !== J ? J : "text",
                  variant: eh,
                  ...ep
                })
              }
                , [et, el, ep, ef, eh]);
          return eg.createElement(em, {
            className: J,
            fullWidth: eo,
            $disabled: et,
            shadow: ec,
            style: ed
          }, ey)
        }
        );
    to.displayName = "TextInput";
    let ta = ec.ZP.div`
display: inline-flex;
align-items: center;
`
      , tl = (0,
        ec.ZP)(eA)`
width: 30px;
padding: 0;
flex-shrink: 0;

${({ variant: J }) => "flat" === J ? ec.iv`
        height: calc(50% - 1px);
      ` : ec.iv`
        height: 50%;
      `}
`
      , tc = ec.ZP.div`
display: flex;
flex-direction: column;
flex-wrap: nowrap;
justify-content: space-between;

${({ variant: J }) => "flat" === J ? ec.iv`
        height: calc(${eS.md} - 4px);
      ` : ec.iv`
        height: ${eS.md};
        margin-left: 2px;
      `}
`
      , td = ec.ZP.span`
width: 0px;
height: 0px;
display: inline-block;
${({ invert: J }) => J ? ec.iv`
        border-left: 4px solid transparent;
        border-right: 4px solid transparent;
        border-bottom: 4px solid ${({ theme: J }) => J.materialText};
      ` : ec.iv`
        border-left: 4px solid transparent;
        border-right: 4px solid transparent;
        border-top: 4px solid ${({ theme: J }) => J.materialText};
      `}
${tl}:disabled & {
  filter: drop-shadow(
    1px 1px 0px ${({ theme: J }) => J.materialTextDisabledShadow}
  );
  ${({ invert: J }) => J ? ec.iv`
          border-bottom-color: ${({ theme: J }) => J.materialTextDisabled};
        ` : ec.iv`
          border-top-color: ${({ theme: J }) => J.materialTextDisabled};
        `}
}
`
      , th = (0,
        eg.forwardRef)(({ className: J, defaultValue: et, disabled: eo = !1, max: el, min: ec, onChange: ed, readOnly: eh, step: ep = 1, style: ef, value: em, variant: ey = "default", width: eb, ...ew }, e_) => {
          let [ex, eE] = useControlledOrUncontrolled({
            defaultValue: et,
            onChange: ed,
            readOnly: eh,
            value: em
          })
            , eC = (0,
              eg.useCallback)(J => {
                let et = parseFloat(J.target.value);
                eE(et)
              }
                , [eE])
            , eS = (0,
              eg.useCallback)(J => {
                let et = clamp(parseFloat(((null != ex ? ex : 0) + J).toFixed(2)), null != ec ? ec : null, null != el ? el : null);
                eE(et),
                  null == ed || ed(et)
              }
                , [el, ec, ed, eE, ex])
            , ek = (0,
              eg.useCallback)(() => {
                void 0 !== ex && (null == ed || ed(ex))
              }
                , [ed, ex])
            , eT = (0,
              eg.useCallback)(() => {
                eS(ep)
              }
                , [eS, ep])
            , eA = (0,
              eg.useCallback)(() => {
                eS(-ep)
              }
                , [eS, ep])
            , eP = "flat" === ey ? "flat" : "raised";
          return eg.createElement(ta, {
            className: J,
            style: {
              ...ef,
              width: void 0 !== eb ? getSize(eb) : "auto"
            },
            ...ew
          }, eg.createElement(to, {
            value: ex,
            variant: ey,
            onChange: eC,
            disabled: eo,
            type: "number",
            readOnly: eh,
            ref: e_,
            fullWidth: !0,
            onBlur: ek
          }), eg.createElement(tc, {
            variant: ey
          }, eg.createElement(tl, {
            "data-testid": "increment",
            variant: eP,
            disabled: eo || eh,
            onClick: eT
          }, eg.createElement(td, {
            invert: !0
          })), eg.createElement(tl, {
            "data-testid": "decrement",
            variant: eP,
            disabled: eo || eh,
            onClick: eA
          }, eg.createElement(td, null))))
        }
        );
    th.displayName = "NumberInput";
    let useId = J => (0,
      eg.useMemo)(() => null != J ? J : function () {
        let J = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
          , et = "";
        for (let eo = 0; eo < 10; eo += 1)
          et += J[Math.floor(Math.random() * J.length)];
        return et
      }(), [J])
      , tp = ec.iv`
box-sizing: border-box;
padding-left: 4px;
overflow: hidden;
white-space: nowrap;
user-select: none;
line-height: 100%;
`
      , tf = ec.iv`
background: ${({ theme: J }) => J.hoverBackground};
color: ${({ theme: J }) => J.canvasTextInvert};
`
      , tm = ec.ZP.div`
display: flex;
align-items: center;
justify-content: space-between;
height: 100%;
width: 100%;
&:focus {
  outline: none;
}
`
      , tg = ec.ZP.div`
${tp}
padding-right: 8px;
align-items: center;
display: flex;
height: calc(100% - 4px);
width: calc(100% - 4px);
margin: 0 2px;
border: 2px solid transparent;
${tm}:focus & {
  ${tf}
  border: 2px dotted ${({ theme: J }) => J.focusSecondary};
}
`
      , ty = ec.iv`
height: ${eS.md};
display: inline-block;
color: ${({ $disabled: J = !1, theme: et }) => J ? createDisabledTextStyles() : et.canvasText};
font-size: 1rem;
cursor: ${({ $disabled: J }) => J ? "default" : "pointer"};
`
      , tb = (0,
        ec.ZP)(eD)`
${ty}
background: ${({ $disabled: J = !1, theme: et }) => J ? et.material : et.canvas};
&:focus {
  outline: 0;
}
`
      , tw = ec.ZP.div`
${createFlatBoxStyles()}
${ty}
background: ${({ $disabled: J = !1, theme: et }) => J ? et.flatLight : et.canvas};
`
      , t_ = ec.ZP.select`
-moz-appearance: none;
-webkit-appearance: none;
display: block;
width: 100%;
height: 100%;
color: inherit;
font-size: 1rem;
border: 0;
margin: 0;
background: none;
-webkit-tap-highlight-color: transparent;
border-radius: 0;
padding-right: 30px;
${tp}
cursor: pointer;
&:disabled {
  ${createDisabledTextStyles()};
  background: ${({ theme: J }) => J.material};
  cursor: default;
}
`
      , tx = (0,
        ec.ZP)(eT).attrs(() => ({
          "aria-hidden": "true"
        }))`
width: 30px;
padding: 0;
flex-shrink: 0;
${({ variant: J = "default" }) => "flat" === J ? ec.iv`
        height: 100%;
        margin-right: 0;
      ` : ec.iv`
        height: 100%;
      `}
${({ native: J = !1, variant: et = "default" }) => J && ("flat" === et ? `
    position: absolute;
    right: 0;
    height: 100%;
    ` : `
  position: absolute;
  top: 2px;
  right: 2px;
  height: calc(100% - 4px);
  `)}
  pointer-events: ${({ $disabled: J = !1, native: et = !1 }) => J || et ? "none" : "auto"}
`
      , tE = ec.ZP.span`
position: absolute;
left: 50%;
top: 50%;
transform: translate(-50%, -50%);
width: 0;
height: 0;
border-left: 6px solid transparent;
border-right: 6px solid transparent;
display: inline-block;
border-top: 6px solid
  ${({ $disabled: J = !1, theme: et }) => J ? et.materialTextDisabled : et.materialText};
${({ $disabled: J = !1, theme: et }) => J && `
  filter: drop-shadow(1px 1px 0px ${et.materialTextDisabledShadow});
  border-top-color: ${et.materialTextDisabled};
  `}
${tx}:active & {
  margin-top: 2px;
}
`
      , tC = ec.ZP.ul`
box-sizing: border-box;

font-size: 1rem;
position: absolute;
transform: translateY(100%);
left: 0;
background: ${({ theme: J }) => J.canvas};
padding: 2px;
border-top: none;
cursor: default;
z-index: 1;
cursor: pointer;
box-shadow: ${eh};
${({ variant: J = "default" }) => "flat" === J ? ec.iv`
        bottom: 2px;
        width: 100%;
        border: 2px solid ${({ theme: J }) => J.flatDark};
      ` : ec.iv`
        bottom: -2px;
        width: calc(100% - 2px);
        border: 2px solid ${({ theme: J }) => J.borderDarkest};
      `}
${({ variant: J = "default" }) => createScrollbars(J)}
`
      , tS = ec.ZP.li`
box-sizing: border-box;

width: 100%;
padding-left: 8px;

height: calc(${eS.md} - 4px);
line-height: calc(${eS.md} - 4px);
font-size: 1rem;
white-space: nowrap;
overflow: hidden;
text-overflow: ellipsis;
color: ${({ theme: J }) => J.canvasText};
&:focus {
  outline: 0;
}
${({ active: J }) => J ? tf : ""}
user-select: none;
`
      , tk = []
      , useSelectCommon = ({ className: J, defaultValue: et, disabled: eo, native: el, onChange: ec, options: ed = tk, readOnly: eh, style: ep, value: ef, variant: em, width: ey }) => {
        var eb;
        let ew = (0,
          eg.useMemo)(() => ed.filter(Boolean), [ed])
          , [e_, ex] = useControlledOrUncontrolled({
            defaultValue: null != et ? et : null === (eb = null == ew ? void 0 : ew[0]) || void 0 === eb ? void 0 : eb.value,
            onChange: ec,
            readOnly: eh,
            value: ef
          })
          , eE = !(eo || eh)
          , eC = (0,
            eg.useMemo)(() => ({
              className: J,
              style: {
                ...ep,
                width: ey
              }
            }), [J, ep, ey])
          , eS = (0,
            eg.useMemo)(() => eg.createElement(tx, {
              as: "div",
              "data-testid": "select-button",
              $disabled: eo,
              native: el,
              tabIndex: -1,
              variant: "flat" === em ? "flat" : "raised"
            }, eg.createElement(tE, {
              "data-testid": "select-icon",
              $disabled: eo
            })), [eo, el, em])
          , ek = (0,
            eg.useMemo)(() => "flat" === em ? tw : tb, [em]);
        return (0,
          eg.useMemo)(() => ({
            isEnabled: eE,
            options: ew,
            value: e_,
            setValue: ex,
            wrapperProps: eC,
            DropdownButton: eS,
            Wrapper: ek
          }), [eS, ek, eE, ew, ex, e_, eC])
      }
      , tT = {
        ARROW_DOWN: "ArrowDown",
        ARROW_LEFT: "ArrowLeft",
        ARROW_RIGHT: "ArrowRight",
        ARROW_UP: "ArrowUp",
        END: "End",
        ENTER: "Enter",
        ESC: "Escape",
        HOME: "Home",
        SPACE: "Space",
        TAB: "Tab"
      }
      , useSelectState = ({ onBlur: J, onChange: et, onClose: eo, onFocus: el, onKeyDown: ec, onMouseDown: ed, onOpen: eh, open: ep, options: ef, readOnly: em, value: ey, selectRef: eb, setValue: ew, wrapperRef: e_ }) => {
        let ex = (0,
          eg.useRef)(null)
          , eE = (0,
            eg.useRef)([])
          , eC = (0,
            eg.useRef)(0)
          , eS = (0,
            eg.useRef)(0)
          , ek = (0,
            eg.useRef)()
          , eT = (0,
            eg.useRef)("search")
          , eA = (0,
            eg.useRef)("")
          , eP = (0,
            eg.useRef)()
          , [eR, eI] = useControlledOrUncontrolled({
            defaultValue: !1,
            onChange: eh,
            onChangePropName: "onOpen",
            readOnly: em,
            value: ep,
            valuePropName: "open"
          })
          , eO = (0,
            eg.useMemo)(() => {
              let J = ef.findIndex(J => J.value === ey);
              return eC.current = clamp(J, 0, null),
                ef[J]
            }
              , [ef, ey])
          , [eN, eM] = (0,
            eg.useState)(ef[0])
          , eD = (0,
            eg.useCallback)(J => {
              let et = ex.current
                , eo = eE.current[J];
              if (!eo || !et) {
                ek.current = J;
                return
              }
              ek.current = void 0;
              let el = et.clientHeight
                , ec = et.scrollTop
                , ed = et.scrollTop + el
                , eh = eo.offsetTop
                , ep = eo.offsetHeight
                , ef = eo.offsetTop + eo.offsetHeight;
              eh < ec && et.scrollTo(0, eh),
                ef > ed && et.scrollTo(0, eh - el + ep),
                eo.focus({
                  preventScroll: !0
                })
            }
              , [ex])
          , ej = (0,
            eg.useCallback)((J, { scroll: et } = {}) => {
              var eo;
              let el;
              let ec = ef.length - 1;
              switch (J) {
                case "first":
                  el = 0;
                  break;
                case "last":
                  el = ec;
                  break;
                case "next":
                  el = clamp(eS.current + 1, 0, ec);
                  break;
                case "previous":
                  el = clamp(eS.current - 1, 0, ec);
                  break;
                case "selected":
                  el = clamp(null !== (eo = eC.current) && void 0 !== eo ? eo : 0, 0, ec);
                  break;
                default:
                  el = J
              }
              eS.current = el,
                eM(ef[el]),
                et && eD(el)
            }
              , [eS, ef, eD])
          , eL = (0,
            eg.useCallback)(({ fromEvent: J }) => {
              eI(!0),
                ej("selected", {
                  scroll: !0
                }),
                null == eh || eh({
                  fromEvent: J
                })
            }
              , [ej, eh, eI])
          , e$ = (0,
            eg.useCallback)(() => {
              eT.current = "search",
                eA.current = "",
                clearTimeout(eP.current)
            }
              , [])
          , eB = (0,
            eg.useCallback)(({ focusSelect: J, fromEvent: et }) => {
              var el;
              null == eo || eo({
                fromEvent: et
              }),
                eI(!1),
                eM(ef[0]),
                e$(),
                ek.current = void 0,
                J && (null === (el = eb.current) || void 0 === el || el.focus())
            }
              , [e$, eo, ef, eb, eI])
          , eF = (0,
            eg.useCallback)(({ fromEvent: J }) => {
              eR ? eB({
                focusSelect: !1,
                fromEvent: J
              }) : eL({
                fromEvent: J
              })
            }
              , [eB, eL, eR])
          , eU = (0,
            eg.useCallback)((J, { fromEvent: eo }) => {
              eC.current !== J && (eC.current = J,
                ew(ef[J].value),
                null == et || et(ef[J], {
                  fromEvent: eo
                }))
            }
              , [et, ef, ew])
          , ez = (0,
            eg.useCallback)(({ focusSelect: J, fromEvent: et }) => {
              eU(eS.current, {
                fromEvent: et
              }),
                eB({
                  focusSelect: J,
                  fromEvent: et
                })
            }
              , [eB, eU])
          , eH = (0,
            eg.useCallback)((J, { fromEvent: et, select: eo }) => {
              var el;
              switch ("cycleFirstLetter" === eT.current && J !== eA.current && (eT.current = "search"),
              J === eA.current ? eT.current = "cycleFirstLetter" : eA.current += J,
              eT.current) {
                case "search":
                  {
                    let el = ef.findIndex(J => {
                      var et;
                      return (null === (et = J.label) || void 0 === et ? void 0 : et.toLocaleUpperCase().indexOf(eA.current)) === 0
                    }
                    );
                    el < 0 && (el = ef.findIndex(et => {
                      var eo;
                      return (null === (eo = et.label) || void 0 === eo ? void 0 : eo.toLocaleUpperCase().indexOf(J)) === 0
                    }
                    ),
                      eA.current = J),
                      el >= 0 && (eo ? eU(el, {
                        fromEvent: et
                      }) : ej(el, {
                        scroll: !0
                      }));
                    break
                  }
                case "cycleFirstLetter":
                  {
                    let ec = eo ? null !== (el = eC.current) && void 0 !== el ? el : -1 : eS.current
                      , ed = ef.findIndex((et, eo) => {
                        var el;
                        return eo > ec && (null === (el = et.label) || void 0 === el ? void 0 : el.toLocaleUpperCase().indexOf(J)) === 0
                      }
                      );
                    ed < 0 && (ed = ef.findIndex(et => {
                      var eo;
                      return (null === (eo = et.label) || void 0 === eo ? void 0 : eo.toLocaleUpperCase().indexOf(J)) === 0
                    }
                    )),
                      ed >= 0 && (eo ? eU(ed, {
                        fromEvent: et
                      }) : ej(ed, {
                        scroll: !0
                      }))
                  }
              }
              clearTimeout(eP.current),
                eP.current = setTimeout(() => {
                  "search" === eT.current && (eA.current = "")
                }
                  , 1e3)
            }
              , [ej, ef, eU])
          , eV = (0,
            eg.useCallback)(J => {
              var et;
              0 === J.button && (J.preventDefault(),
                null === (et = eb.current) || void 0 === et || et.focus(),
                eF({
                  fromEvent: J
                }),
                null == ed || ed(J))
            }
              , [ed, eb, eF])
          , eW = (0,
            eg.useCallback)(J => {
              ez({
                focusSelect: !0,
                fromEvent: J
              })
            }
              , [ez])
          , eZ = (0,
            eg.useCallback)(J => {
              let { altKey: et, code: eo, ctrlKey: el, metaKey: ec, shiftKey: ed } = J
                , { ARROW_DOWN: eh, ARROW_UP: ep, END: ef, ENTER: em, ESC: eg, HOME: ey, SPACE: eb, TAB: ew } = tT
                , e_ = et || el || ec || ed;
              if ((eo !== ew || !et && !el && !ec) && (eo === ew || !e_))
                switch (eo) {
                  case eh:
                    if (J.preventDefault(),
                      !eR) {
                      eL({
                        fromEvent: J
                      });
                      return
                    }
                    ej("next", {
                      scroll: !0
                    });
                    break;
                  case ep:
                    if (J.preventDefault(),
                      !eR) {
                      eL({
                        fromEvent: J
                      });
                      return
                    }
                    ej("previous", {
                      scroll: !0
                    });
                    break;
                  case ef:
                    if (J.preventDefault(),
                      !eR) {
                      eL({
                        fromEvent: J
                      });
                      return
                    }
                    ej("last", {
                      scroll: !0
                    });
                    break;
                  case em:
                    if (!eR)
                      return;
                    J.preventDefault(),
                      ez({
                        focusSelect: !0,
                        fromEvent: J
                      });
                    break;
                  case eg:
                    if (!eR)
                      return;
                    J.preventDefault(),
                      eB({
                        focusSelect: !0,
                        fromEvent: J
                      });
                    break;
                  case ey:
                    if (J.preventDefault(),
                      !eR) {
                      eL({
                        fromEvent: J
                      });
                      return
                    }
                    ej("first", {
                      scroll: !0
                    });
                    break;
                  case eb:
                    J.preventDefault(),
                      eR ? ez({
                        focusSelect: !0,
                        fromEvent: J
                      }) : eL({
                        fromEvent: J
                      });
                    break;
                  case ew:
                    if (!eR)
                      return;
                    ed || J.preventDefault(),
                      ez({
                        focusSelect: !ed,
                        fromEvent: J
                      });
                    break;
                  default:
                    !e_ && eo.match(/^Key/) && (J.preventDefault(),
                      J.stopPropagation(),
                      eH(eo.replace(/^Key/, ""), {
                        select: !eR,
                        fromEvent: J
                      }))
                }
            }
              , [ej, eB, eR, eL, eH, ez])
          , eG = (0,
            eg.useCallback)(J => {
              eZ(J),
                null == ec || ec(J)
            }
              , [eZ, ec])
          , eY = (0,
            eg.useCallback)(J => {
              ej(J)
            }
              , [ej])
          , eK = (0,
            eg.useCallback)(et => {
              eR || (e$(),
                null == J || J(et))
            }
              , [e$, J, eR])
          , eJ = (0,
            eg.useCallback)(J => {
              e$(),
                null == el || el(J)
            }
              , [e$, el])
          , eQ = (0,
            eg.useCallback)(J => {
              ex.current = J,
                void 0 !== ek.current && eD(ek.current)
            }
              , [eD])
          , eX = (0,
            eg.useCallback)((J, et) => {
              eE.current[et] = J,
                ek.current === et && eD(ek.current)
            }
              , [eD]);
        return (0,
          eg.useEffect)(() => {
            if (!eR)
              return () => { }
                ;
            let outsideMouseDown = J => {
              var et;
              let eo = J.target;
              (null === (et = e_.current) || void 0 === et ? void 0 : et.contains(eo)) || (J.preventDefault(),
                eB({
                  focusSelect: !1,
                  fromEvent: J
                }))
            }
              ;
            return document.addEventListener("mousedown", outsideMouseDown),
              () => {
                document.removeEventListener("mousedown", outsideMouseDown)
              }
          }
            , [eB, eR, e_]),
          (0,
            eg.useMemo)(() => ({
              activeOption: eN,
              handleActivateOptionIndex: eY,
              handleBlur: eK,
              handleButtonKeyDown: eG,
              handleDropdownKeyDown: eZ,
              handleFocus: eJ,
              handleMouseDown: eV,
              handleOptionClick: eW,
              handleSetDropdownRef: eQ,
              handleSetOptionRef: eX,
              open: eR,
              selectedOption: eO
            }), [eN, eY, eK, eG, eJ, eZ, eV, eW, eQ, eX, eR, eO])
      }
      , tA = (0,
        eg.forwardRef)(({ className: J, defaultValue: et, disabled: eo, onChange: el, options: ec, readOnly: ed, style: eh, value: ep, variant: ef, width: em, ...ey }, eb) => {
          let { isEnabled: ew, options: e_, setValue: ex, value: eE, DropdownButton: eC, Wrapper: eS } = useSelectCommon({
            defaultValue: et,
            disabled: eo,
            native: !0,
            onChange: el,
            options: ec,
            readOnly: ed,
            value: ep,
            variant: ef
          })
            , ek = (0,
              eg.useCallback)(J => {
                let et = e_.find(et => et.value === J.target.value);
                et && (ex(et.value),
                  null == el || el(et, {
                    fromEvent: J
                  }))
              }
                , [el, e_, ex]);
          return eg.createElement(eS, {
            className: J,
            style: {
              ...eh,
              width: em
            }
          }, eg.createElement(tm, null, eg.createElement(t_, {
            ...ey,
            disabled: eo,
            onChange: ew ? ek : noOp,
            ref: eb,
            value: eE
          }, e_.map((J, et) => {
            var eo;
            return eg.createElement("option", {
              key: `${J.value}-${et}`,
              value: J.value
            }, null !== (eo = J.label) && void 0 !== eo ? eo : J.value)
          }
          )), eC))
        }
        );
    function SelectInnerOption({ activateOptionIndex: J, active: et, index: eo, onClick: el, option: ec, selected: ed, setRef: eh }) {
      let ep = (0,
        eg.useCallback)(() => {
          J(eo)
        }
          , [J, eo])
        , ef = (0,
          eg.useCallback)(J => {
            eh(J, eo)
          }
            , [eo, eh])
        , em = useId();
      return eg.createElement(tS, {
        active: et,
        "aria-selected": ed ? "true" : void 0,
        "data-value": ec.value,
        id: em,
        onClick: el,
        onMouseEnter: ep,
        ref: ef,
        role: "option",
        tabIndex: 0
      }, ec.label)
    }
    tA.displayName = "SelectNative";
    let tP = (0,
      eg.forwardRef)(function ({ "aria-label": J, "aria-labelledby": et, className: eo, defaultValue: el, disabled: ec = !1, formatDisplay: ed, inputProps: eh, labelId: ep, menuMaxHeight: ef, name: em, onBlur: ey, onChange: eb, onClose: ew, onFocus: e_, onKeyDown: ex, onMouseDown: eE, onOpen: eC, open: eS, options: ek, readOnly: eT, shadow: eA = !0, style: eP, variant: eR = "default", value: eI, width: eO = "auto", ...eN }, eM) {
        let { isEnabled: eD, options: ej, setValue: eL, value: e$, wrapperProps: eB, DropdownButton: eF, Wrapper: eU } = useSelectCommon({
          className: eo,
          defaultValue: el,
          disabled: ec,
          native: !1,
          onChange: eb,
          options: ek,
          style: eP,
          readOnly: eT,
          value: eI,
          variant: eR,
          width: eO
        })
          , ez = (0,
            eg.useRef)(null)
          , eH = (0,
            eg.useRef)(null)
          , eV = (0,
            eg.useRef)(null)
          , { activeOption: eW, handleActivateOptionIndex: eZ, handleBlur: eG, handleButtonKeyDown: eY, handleDropdownKeyDown: eK, handleFocus: eJ, handleMouseDown: eQ, handleOptionClick: eX, handleSetDropdownRef: e0, handleSetOptionRef: e1, open: e2, selectedOption: e3 } = useSelectState({
            onBlur: ey,
            onChange: eb,
            onClose: ew,
            onFocus: e_,
            onKeyDown: ex,
            onMouseDown: eE,
            onOpen: eC,
            open: eS,
            options: ej,
            value: e$,
            selectRef: eH,
            setValue: eL,
            wrapperRef: eV
          });
        (0,
          eg.useImperativeHandle)(eM, () => ({
            focus: J => {
              var et;
              null === (et = eH.current) || void 0 === et || et.focus(J)
            }
            ,
            node: ez.current,
            value: String(e$)
          }), [e$]);
        let e5 = (0,
          eg.useMemo)(() => e3 ? "function" == typeof ed ? ed(e3) : e3.label : "", [ed, e3])
          , e6 = eD ? 1 : void 0
          , e4 = (0,
            eg.useMemo)(() => ef ? {
              overflow: "auto",
              maxHeight: ef
            } : void 0, [ef])
          , e8 = useId()
          , e7 = (0,
            eg.useMemo)(() => ej.map((J, et) => {
              let eo = `${e$}-${et}`
                , el = J === eW
                , ec = J === e3;
              return eg.createElement(SelectInnerOption, {
                activateOptionIndex: eZ,
                active: el,
                index: et,
                key: eo,
                onClick: eX,
                option: J,
                selected: ec,
                setRef: e1
              })
            }
            ), [eW, eZ, eX, e1, ej, e3, e$]);
        return eg.createElement(eU, {
          ...eB,
          $disabled: ec,
          ref: eV,
          shadow: eA,
          style: {
            ...eP,
            width: eO
          }
        }, eg.createElement("input", {
          name: em,
          ref: ez,
          type: "hidden",
          value: String(e$),
          ...eh
        }), eg.createElement(tm, {
          "aria-disabled": ec,
          "aria-expanded": e2,
          "aria-haspopup": "listbox",
          "aria-label": J,
          "aria-labelledby": null != et ? et : ep,
          "aria-owns": eD && e2 ? e8 : void 0,
          onBlur: eG,
          onFocus: eJ,
          onKeyDown: eY,
          onMouseDown: eD ? eQ : eE,
          ref: eH,
          role: "button",
          tabIndex: e6,
          ...eN
        }, eg.createElement(tg, null, e5), eF), eD && e2 && eg.createElement(tC, {
          id: e8,
          onKeyDown: eK,
          ref: e0,
          role: "listbox",
          style: e4,
          tabIndex: 0,
          variant: eR
        }, e7))
      });
    tP.displayName = "Select";
    let tR = ec.ZP.div`
position: relative;
display: flex;
align-items: center;
padding: ${J => J.noPadding ? "0" : "4px"};
`
      , tI = (0,
        eg.forwardRef)(function ({ children: J, noPadding: et = !1, ...eo }, el) {
          return eg.createElement(tR, {
            noPadding: et,
            ref: el,
            ...eo
          }, J)
        });
    tI.displayName = "Toolbar";
    let tO = ec.ZP.div`
padding: 16px;
`
      , tN = (0,
        eg.forwardRef)(function ({ children: J, ...et }, eo) {
          return eg.createElement(tO, {
            ref: eo,
            ...et
          }, J)
        });
    tN.displayName = "WindowContent";
    let tM = ec.ZP.div`
height: 33px;
line-height: 33px;
padding-left: 0.25rem;
padding-right: 3px;
font-weight: bold;
border: 2px solid ${({ theme: J }) => J.material};
${({ active: J }) => !1 === J ? ec.iv`
        background: ${({ theme: J }) => J.headerNotActiveBackground};
        color: ${({ theme: J }) => J.headerNotActiveText};
      ` : ec.iv`
        background: ${({ theme: J }) => J.headerBackground};
        color: ${({ theme: J }) => J.headerText};
      `}

${eT} {
  padding-left: 0;
  padding-right: 0;
  height: 27px;
  width: 31px;
}
`
      , tD = (0,
        eg.forwardRef)(function ({ active: J = !0, children: et, ...eo }, el) {
          return eg.createElement(tM, {
            active: J,
            ref: el,
            ...eo
          }, et)
        });
    tD.displayName = "WindowHeader";
    let tj = ec.ZP.div`
position: relative;
padding: 4px;
font-size: 1rem;
${createBorderStyles({
      style: "window"
    })}
${createBoxStyles()}
`
      , tL = ec.ZP.span`
${({ theme: J }) => ec.iv`
  display: inline-block;
  position: absolute;
  bottom: 10px;
  right: 10px;
  width: 25px;
  height: 25px;
  background-image: linear-gradient(
    135deg,
    ${J.borderLightest} 16.67%,
    ${J.material} 16.67%,
    ${J.material} 33.33%,
    ${J.borderDark} 33.33%,
    ${J.borderDark} 50%,
    ${J.borderLightest} 50%,
    ${J.borderLightest} 66.67%,
    ${J.material} 66.67%,
    ${J.material} 83.33%,
    ${J.borderDark} 83.33%,
    ${J.borderDark} 100%
  );
  background-size: 8.49px 8.49px;
  clip-path: polygon(100% 0px, 0px 100%, 100% 100%);
  cursor: nwse-resize;
`}
`
      , t$ = (0,
        eg.forwardRef)(({ children: J, resizable: et = !1, resizeRef: eo, shadow: el = !0, ...ec }, ed) => eg.createElement(tj, {
          ref: ed,
          shadow: el,
          ...ec
        }, J, et && eg.createElement(tL, {
          "data-testid": "resizeHandle",
          ref: eo
        })));
    t$.displayName = "Window";
    let tB = (0,
      ec.ZP)(eL)`
width: 234px;
margin: 1rem 0;
background: ${({ theme: J }) => J.canvas};
`
      , tF = ec.ZP.div`
display: flex;
background: ${({ theme: J }) => J.materialDark};
color: #dfe0e3;
`
      , tU = ec.ZP.div`
display: flex;
flex-wrap: wrap;
`
      , tz = ec.ZP.div`
text-align: center;
height: 1.5em;
line-height: 1.5em;
width: 14.28%;
`
      , tH = ec.ZP.span`
cursor: pointer;

background: ${({ active: J, theme: et }) => J ? et.hoverBackground : "transparent"};
color: ${({ active: J, theme: et }) => J ? et.canvasTextInvert : et.canvasText};

&:hover {
  border: 2px dashed
    ${({ theme: J, active: et }) => et ? "none" : J.materialDark};
}
`
      , tV = [{
        value: 0,
        label: "January"
      }, {
        value: 1,
        label: "February"
      }, {
        value: 2,
        label: "March"
      }, {
        value: 3,
        label: "April"
      }, {
        value: 4,
        label: "May"
      }, {
        value: 5,
        label: "June"
      }, {
        value: 6,
        label: "July"
      }, {
        value: 7,
        label: "August"
      }, {
        value: 8,
        label: "September"
      }, {
        value: 9,
        label: "October"
      }, {
        value: 10,
        label: "November"
      }, {
        value: 11,
        label: "December"
      }]
      , tW = (0,
        eg.forwardRef)(({ className: J, date: et = new Date().toISOString(), onAccept: eo, onCancel: el, shadow: ec = !0 }, ed) => {
          let [eh, ep] = (0,
            eg.useState)(() => (function (J) {
              let et = new Date(Date.parse(J))
                , eo = et.getUTCDate()
                , el = et.getUTCMonth()
                , ec = et.getUTCFullYear();
              return {
                day: eo,
                month: el,
                year: ec
              }
            }
            )(et))
            , { year: ef, month: em, day: ey } = eh
            , eb = (0,
              eg.useCallback)(({ value: J }) => {
                ep(et => ({
                  ...et,
                  month: J
                }))
              }
                , [])
            , ew = (0,
              eg.useCallback)(J => {
                ep(et => ({
                  ...et,
                  year: J
                }))
              }
                , [])
            , e_ = (0,
              eg.useCallback)(J => {
                ep(et => ({
                  ...et,
                  day: J
                }))
              }
                , [])
            , ex = (0,
              eg.useCallback)(() => {
                let J = [eh.year, eh.month + 1, eh.day].map(J => String(J).padStart(2, "0")).join("-");
                null == eo || eo(J)
              }
                , [eh.day, eh.month, eh.year, eo])
            , eE = (0,
              eg.useMemo)(() => {
                let J = Array.from({
                  length: 42
                })
                  , et = new Date(ef, em, 1).getDay()
                  , eo = ey
                  , el = new Date(ef, em + 1, 0).getDate();
                return eo = eo < el ? eo : el,
                  J.forEach((ec, ed) => {
                    if (ed >= et && ed < el + et) {
                      let el = ed - et + 1;
                      J[ed] = eg.createElement(tz, {
                        key: ed,
                        onClick: () => {
                          e_(el)
                        }
                      }, eg.createElement(tH, {
                        active: el === eo
                      }, el))
                    } else
                      J[ed] = eg.createElement(tz, {
                        key: ed
                      })
                  }
                  ),
                  J
              }
                , [ey, e_, em, ef]);
          return eg.createElement(t$, {
            className: J,
            ref: ed,
            shadow: ec,
            style: {
              margin: 20
            }
          }, eg.createElement(tD, null, eg.createElement("span", {
            role: "img",
            "aria-label": "\uD83D\uDCC6"
          }, "\uD83D\uDCC6"), "Date"), eg.createElement(tN, null, eg.createElement(tI, {
            noPadding: !0,
            style: {
              justifyContent: "space-between"
            }
          }, eg.createElement(tP, {
            options: tV,
            value: em,
            onChange: eb,
            width: 128,
            menuMaxHeight: 200
          }), eg.createElement(th, {
            value: ef,
            onChange: ew,
            width: 100
          })), eg.createElement(tB, null, eg.createElement(tF, null, eg.createElement(tz, null, "S"), eg.createElement(tz, null, "M"), eg.createElement(tz, null, "T"), eg.createElement(tz, null, "W"), eg.createElement(tz, null, "T"), eg.createElement(tz, null, "F"), eg.createElement(tz, null, "S")), eg.createElement(tU, null, eE)), eg.createElement(tI, {
            noPadding: !0,
            style: {
              justifyContent: "space-between"
            }
          }, eg.createElement(eA, {
            fullWidth: !0,
            onClick: el,
            disabled: !el
          }, "Cancel"), eg.createElement(eA, {
            fullWidth: !0,
            onClick: eo ? ex : void 0,
            disabled: !eo
          }, "OK"))))
        }
        );
    tW.displayName = "DatePicker";
    let createFrameStyles = J => {
      switch (J) {
        case "status":
        case "well":
          return ec.iv`
      ${createBorderStyles({
            style: "status"
          })}
    `;
        case "window":
        case "outside":
          return ec.iv`
      ${createBorderStyles({
            style: "window"
          })}
    `;
        case "field":
          return ec.iv`
      ${createBorderStyles({
            style: "field"
          })}
    `;
        default:
          return ec.iv`
      ${createBorderStyles()}
    `
      }
    }
      , tq = ec.ZP.div`
position: relative;
font-size: 1rem;
${({ variant: J }) => createFrameStyles(J)}
${({ variant: J }) => createBoxStyles("field" === J ? {
        background: "canvas",
        color: "canvasText"
      } : void 0)}
`
      , tZ = (0,
        eg.forwardRef)(({ children: J, shadow: et = !1, variant: eo = "window", ...el }, ec) => eg.createElement(tq, {
          ref: ec,
          shadow: et,
          variant: eo,
          ...el
        }, J));
    tZ.displayName = "Frame";
    let tG = ec.ZP.fieldset`
position: relative;
border: 2px solid
  ${({ theme: J, variant: et }) => "flat" === et ? J.flatDark : J.borderLightest};
padding: 16px;
margin-top: 8px;
font-size: 1rem;
color: ${({ theme: J }) => J.materialText};
${({ variant: J }) => "flat" !== J && ec.iv`
    box-shadow: -1px -1px 0 1px ${({ theme: J }) => J.borderDark},
      inset -1px -1px 0 1px ${({ theme: J }) => J.borderDark};
  `}
${J => J.$disabled && createDisabledTextStyles()}
`
      , tY = ec.ZP.legend`
display: flex;
position: absolute;
top: 0;
left: 8px;
transform: translateY(calc(-50% - 2px));
padding: 0 8px;

font-size: 1rem;
background: ${({ theme: J, variant: et }) => "flat" === et ? J.canvas : J.material};
`
      , tK = (0,
        eg.forwardRef)(({ label: J, disabled: et = !1, variant: eo = "default", children: el, ...ec }, ed) => eg.createElement(tG, {
          "aria-disabled": et,
          $disabled: et,
          variant: eo,
          ref: ed,
          ...ec
        }, J && eg.createElement(tY, {
          variant: eo
        }, J), el));
    tK.displayName = "GroupBox";
    let tJ = ec.ZP.div`
${({ theme: J, size: et = "100%" }) => `
display: inline-block;
box-sizing: border-box;
height: ${getSize(et)};
width: 5px;
border-top: 2px solid ${J.borderLightest};
border-left: 2px solid ${J.borderLightest};
border-bottom: 2px solid ${J.borderDark};
border-right: 2px solid ${J.borderDark};
background: ${J.material};
`}
`;
    tJ.displayName = "Handle";
    let tQ = ec.ZP.div`
display: inline-block;
height: ${({ size: J }) => getSize(J)};
width: ${({ size: J }) => getSize(J)};
`
      , tX = ec.ZP.span`
display: block;
background: ${"url('data:image/gif;base64,R0lGODlhPAA8APQAADc3N6+vr4+Pj05OTvn5+V1dXZ+fn29vby8vLw8PD/X19d/f37S0tJSUlLq6und3d39/f9XV1c/Pz+bm5qamphkZGWZmZsbGxr+/v+rq6tra2u/v7yIiIv///wAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFBAAfACH+I1Jlc2l6ZWQgb24gaHR0cHM6Ly9lemdpZi5jb20vcmVzaXplACwAAAAAPAA8AAAF/+AnjmRpnmiqrmzrvnAsz3Rt37jr7Xzv/8BebhQsGn1D0XFZTH6YUGQySvU4fYKAdsvtdi1Cp3In6ZjP6HTawBMTyWbFYk6v18/snXvsKXciUApmeVZ7PH6ATIIdhHtPcB0TDQ1gQBCTBINthpBnAUEaa5tuh2mfQKFojZx9aRMSEhA7FLAbonqsfmoUOxFqmriknWm8Hr6/q8IeCAAAx2cTERG2aBTNHMGOj8a/v8WF2m/c3cSj4SQ8C92n4Ocm6evm7ui9CosdBPbs8yo8E2YO5PE74Q+gwIElCnYImA3hux3/Fh50yCciw3YUt2GQtiiDtGQO4f3al1GkGpIDeXlg0KDhXpoMLBtMVPaMnJlv/HjUtIkzHA8HEya4tLkhqICGV4bZVAMyaaul3ZpOUQoVz8wbpaoyvWojq1ZVXGt4/QoM49SnZMs6GktW6hC2X93mgKtVbtceWbzo9VIJKdYqUJwCPiJ4cJOzhg+/TWwko+PHkCNLdhgCACH5BAUEAB8ALAAAAAABAAEAAAUD4BcCACH5BAUEAB8ALBYADAAQAA0AAAVFYCeOZPmVaKqimeO+MPxFXv3d+F17Cm3nuJ1ic7lAdroapUjABZCfnQb4ef6k1OHGULtsNk3qjVKLiIFkj/mMIygU4VwIACH5BAUEAB8ALAAAAAABAAEAAAUD4BcCACH5BAUEAB8ALBkAIwAKAAcAAAUp4CdehrGI6Ed5XpSKa4teguBoGlVPAXuJBpam5/l9gh7NZrFQiDJMRQgAIfkEBQQAHwAsAAAAAAEAAQAABQPgFwIAIfkEBQQAHwAsFgAPABAAIQAABVBgJ45kaZ5oakZB67bZ+M10bd94ru987//AoHBILNYYAsGlR/F4IkwnlLeZTBQ9UlaWwzweERHjuzAKFZkMYYZWm4mOw0ETfdanO8Vms7aFAAAh+QQFBAAfACwAAAAAAQABAAAFA+AXAgAh+QQFBAAfACwZABIACgAeAAAFUGAnjmRpnij5rerqtu4Hx3Rt33iu758iZrUZa1TDCASLGsXjiSiZzmFnM5n4TNJSdmREElfL5lO8cgwGACbgrAkwPat3+x1naggKRS+f/4QAACH5BAUEAB8ALAAAAAABAAEAAAUD4BcCACH5BAUEAB8ALBYAIwAQAA0AAAVE4CeOXdmNaGqeabu27SUIC5xSnifZKK7zl8djkCsIaylGziNaakaEzcbH/Cwl0k9kuWxyPYptzrZULA7otFpNIK1eoxAAIfkEBQQAHwAsAAAAAAEAAQAABQPgFwIAIfkEBQQAHwAsAAAAAAEAAQAABQPgFwIAIfkEBQQAHwAsAAAAAAEAAQAABQPgFwIAIfkEBQQAHwAsAAAAAAEAAQAABQPgFwIAIfkEBQQAHwAsAAAAAAEAAQAABQPgFwIAIfkEBQQAHwAsAAAAAAEAAQAABQPgFwIAIfkEBQQAHwAsAAAAAAEAAQAABQPgFwIAIfkEBQQAHwAsAAAAAAEAAQAABQPgFwIAIfkEBQQAHwAsAAAAAAEAAQAABQPgFwIAIfkECQQAHwAsDgAEACAANAAABTHgJ45kaZ5oqq5s675wLM90bd94ru987//AoHBILBqPyKRyyWw6n9CodEqtWq/Y7CoEACH5BAUEAB8ALAAAAAA8ADwAAAX/4CeOZGmeaKqubFt6biy3Xj3fuFjveU/vPJ/wBAQOj6RiEClUGpk9IMAJxQEdmQK1Grt2OhutkvurOb7f8JaM8qLT4iKbuDu/0erxfOS+4+NPex9mfn55coIfCAuFhoBLbDUAjI1vh4FkOxSVd5eQXB4GnI5rXAAbo6R6VTUFqKmWjzasNaKwsaVIHhAEt3cLTjBQA6++XwoHuUM1vMYdyMorwoN8wkC2t9A8s102204Wxana3DNAAQO1FjUCEDXhvuTT5nUdEwOiGxa8BBDwXxKaLTiAKoMFRvJy9CmmoFcHAgrQSEiwKwICDwU0pAMQIdmnboR8TfwWrJyMPrAiz1DkNs2aSRbe6hnr99LEvDJ9IB5DQ8Dhm36glNh5COGBAmQNHrbz+WXBFChOTqFx5+GBxwYCmL1ZcPHmMiWuvkTgECzBBUvrvH4tErbDWCcYDB2IBPbV2yJJ72SZ46TtXSB5v2RIp1ZXXbFkgWxCc68mk752E3tY/OZeIsiIaxi9o+BBokGH3SZ+4FPbZ8yiPQxNeDl0hNUeHWcKjYb1Zx20bd/GzRaV7t28gRSYELvw7pIfgVcLplwF8+bOo0Ffjmm6zerWrxvPzoe79w8hAAAh+QQJBAAfACwBAAEAOgA6AAAFRuAnjmRpnmiqrmzrvnAsz3Rt33iu73zv/8CgcEgsGo/IpHLJbDqf0Kh0Sq1ar9isdsvter/gsHhMLpvP6LR6zW673/D4MgQAIfkEBQQAHwAsAAAAADwAPAAABf/gJ45kaZ5oqq5s675wLM90bd94ru987//AoHBILBqPyJxnyTQym6nn0ilVSa9XGHY7jXKx2m/WK36Gy1CUVCBpu9+OtNqDeNslgip5Gej4/4ATcidLAICHHQF6c0x9iH+CXV6Gj36KZnsejgsREQSACp0Yg0ydEZWWi4RPjgdLG48apEuogJeDJVKtr7GzHrV/t5KrjX6uHhQMF4cKCwujTxHOwKmYjHzGTw+VEVIK1MGqJrrZTNuP3U/f4IniuazlSwMUFMugE/j47NW4JOQdx9bsoybMgxV4ALEIGAis4MFiCZkUaLPgUAYHGDF+Yucw0y5z3Lzt63hNUzwP5xCRpWOyDhxJYtgiStBQEVCGAAEM6MLp0p0/hMdgIZI17AOTntZgmowo9BBRgz9/EfQ54h8BBS39bKDXwBc9CrVejkNYKRLUSWGpivhXtt9PSpXEvmNiwYDdu3jzFB3LAa9fAxbUGkXjtmSZh4TPJM4kRgbhvVEL9xhTEongJJgza97MubPnz6BDix5NurTp0yJCAAAh+QQJBAAfACwEAA4ANAAgAAAFMeAnjmRpnmiqrmzrvnAsz3Rt33iu73zv/8CgcEgsGo/IpHLJbDqf0Kh0Sq1ar9jsKgQAIfkEBQQAHwAsAAAAADwAPAAABf/gJ45kaZ5oqq5s6bVwLHu0bN8uXeM8rP+9YOoHFBpHRN1xmSwue02A82lrFjaOKbVl3XQ6WeWWm7x+v+HdeFj2ntHaNbL9jUAI5/RLTurWOR53eXFbfh0RgB4PCm9hfCKGiDSLb18Bjx+RiR4HjG8TA3trmkSdZxuhalSkRA2VBqpPrD+ulR0Go3SHmz8CeG8bFqJMupJNHr5nCsKxQccTg4oUNA0YCYG/HQQQYsSlnmCUFLUXgm8EAsPeP6Zf2baV2+rEmTrt8PDyzS7O9uD4b5YV2VGjGw52/wB+CaYjlQcpNBAQioHwy4QMCxe4i3BKGIQN3K7AArBATz8anUDADcgQDMGCbQkknDKAh4ABNxQ0gpnoQ8eDVAUO0ADAzUNMhbZMQiG4R4mOo0gb8eTCQgeEqJVM7juCDWvWJnI4ev2aZIwHl2PfZIBIZBXKtAsLgC1kJu0GuWXNaoB7d67ZlWP75jVLw4JXwW35PNSJFPFUrmIb402smFNCW44N5kJ5+dTkx+vuAfus+VHF0X4xzeHsObXq1ZY7ZN76mt0C0rRf1zuWW/du175PHAu+YjhxFcCPm6CsHHnv5kig6w4BACH5BAkEAB8ALAEAAQA6ADoAAAVG4CeOZGmeaKqubOu+cCzPdG3feK7vfO//wKBwSCwaj8ikcslsOp/QqHRKrVqv2Kx2y+16v+CweEwum8/otHrNbrvf8PgyBAAh+QQFBAAfACwAAAAAPAA8AAAF/+AnjmRpnmiqrmzrvnAsz3Rt37jr7Xzv/8BebhQsGn1D0XFZTH6YUGQySvU4fYKAdsvtdi1Cp3In6ZjP6HTawBMTyWbFYk6v18/snXvsKXciUApmeVZ7PH6ATIIdhHtPcB0TDQ1gQBCTBINthpBnAUEaa5tuh2mfQKFojZx9aRMSEhA7FLAbonqsfmoUOxFqmriknWm8Hr6/q8IeCAAAx2cTERG2aBTNHMGOj8a/v8WF2m/c3cSj4SQ8C92n4Ocm6evm7ui9CosdBPbs8yo8E2YO5PE74Q+gwIElCnYImA3hux3/Fh50yCciw3YUt2GQtiiDtGQO4f3al1GkGpIDeXlg0KDhXpoMLBtMVPaMnJlv/HjUtIkzHA8HEya4tLkhqICGV4bZVAMyaaul3ZpOUQoVz8wbpaoyvWojq1ZVXGt4/QoM49SnZMs6GktW6hC2X93mgKtVbtceWbzo9VIJKdYqUJwCPiJ4cJOzhg+/TWwko+PHkCNLdhgCACH5BAUEAB8ALAAAAAABAAEAAAUD4BcCADs=')"};
background-size: cover;
width: 100%;
height: 100%;
`
      , t0 = (0,
        eg.forwardRef)(({ size: J = 30, ...et }, eo) => eg.createElement(tQ, {
          size: J,
          ref: eo,
          ...et
        }, eg.createElement(tX, null)));
    t0.displayName = "Hourglass";
    let t1 = ec.ZP.div`
position: relative;
display: inline-block;
padding-bottom: 26px;
`
      , t2 = ec.ZP.div`
position: relative;
`
      , t3 = ec.ZP.div`
position: relative;
z-index: 1;
box-sizing: border-box;
width: 195px;
height: 155px;
padding: 12px;
background: ${({ theme: J }) => J.material};
border-top: 4px solid ${({ theme: J }) => J.borderLightest};
border-left: 4px solid ${({ theme: J }) => J.borderLightest};
border-bottom: 4px solid ${({ theme: J }) => J.borderDark};
border-right: 4px solid ${({ theme: J }) => J.borderDark};

outline: 1px dotted ${({ theme: J }) => J.material};
outline-offset: -3px;
&:before {
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  outline: 1px dotted ${({ theme: J }) => J.material};
}
box-shadow: 1px 1px 0 1px ${({ theme: J }) => J.borderDarkest};

&:after {
  content: '';
  display: inline-block;
  position: absolute;
  bottom: 4px;
  right: 12px;
  width: 10px;
  border-top: 2px solid #4d9046;
  border-bottom: 2px solid #07ff00;
}
`
      , t5 = (0,
        ec.ZP)(eD).attrs(() => ({
          "data-testid": "background"
        }))`
width: 100%;
height: 100%;
`
      , t6 = ec.ZP.div`
box-sizing: border-box;
position: absolute;
top: calc(100% + 2px);
left: 50%;
transform: translateX(-50%);
height: 10px;
width: 50%;
background: ${({ theme: J }) => J.material};
border-left: 2px solid ${({ theme: J }) => J.borderLightest};
border-bottom: 2px solid ${({ theme: J }) => J.borderDarkest};
border-right: 2px solid ${({ theme: J }) => J.borderDarkest};
box-shadow: inset 0px 0px 0px 2px ${({ theme: J }) => J.borderDark};

&:before {
  content: '';
  position: absolute;
  top: calc(100% + 2px);
  left: 50%;
  transform: translateX(-50%);
  width: 80%;
  height: 8px;
  background: ${({ theme: J }) => J.material};
  border-left: 2px solid ${({ theme: J }) => J.borderLightest};
  border-right: 2px solid ${({ theme: J }) => J.borderDarkest};
  box-shadow: inset 0px 0px 0px 2px ${({ theme: J }) => J.borderDark};
}
&:after {
  content: '';
  position: absolute;
  top: calc(100% + 8px);
  left: 50%;
  transform: translateX(-50%);
  width: 150%;
  height: 4px;
  background: ${({ theme: J }) => J.material};
  border: 2px solid ${({ theme: J }) => J.borderDark};
  border-bottom: none;
  box-shadow: inset 1px 1px 0px 1px ${({ theme: J }) => J.borderLightest},
    1px 1px 0 1px ${({ theme: J }) => J.borderDarkest};
}
`
      , t4 = (0,
        eg.forwardRef)(({ backgroundStyles: J, children: et, ...eo }, el) => eg.createElement(t1, {
          ref: el,
          ...eo
        }, eg.createElement(t2, null, eg.createElement(t3, null, eg.createElement(t5, {
          style: J
        }, et)), eg.createElement(t6, null))));
    t4.displayName = "Monitor";
    let t8 = ec.ZP.div`
display: inline-block;
height: ${eS.md};
width: 100%;
`
      , t7 = (0,
        ec.ZP)(eD)`
width: 100%;
height: 100%;
position: relative;
text-align: center;
padding: 0;
overflow: hidden;
&:before {
  z-index: 1;
}
`
      , t9 = ec.iv`
width: calc(100% - 4px);
height: calc(100% - 4px);

display: flex;
align-items: center;
justify-content: space-around;
`
      , ro = ec.ZP.div`
position: relative;
top: 4px;
${t9}
background: ${({ theme: J }) => J.canvas};
color: #000;
margin-left: 2px;
margin-top: -2px;
color: ${({ theme: J }) => J.materialText};
`
      , ra = ec.ZP.div`
position: absolute;
top: 2px;
left: 2px;
${t9}
color: ${({ theme: J }) => J.materialTextInvert};
background: ${({ theme: J }) => J.progress};
clip-path: polygon(
  0 0,
  ${({ value: J = 0 }) => J}% 0,
  ${({ value: J = 0 }) => J}% 100%,
  0 100%
);
transition: 0.4s linear clip-path;
`
      , rl = ec.ZP.div`
width: calc(100% - 6px);
height: calc(100% - 8px);
position: absolute;
left: 3px;
top: 4px;
box-sizing: border-box;
display: inline-flex;
`
      , rc = ec.ZP.span`
display: inline-block;
width: ${17}px;
box-sizing: border-box;
height: 100%;
background: ${({ theme: J }) => J.progress};
border-color: ${({ theme: J }) => J.material};
border-width: 0px 1px;
border-style: solid;
`
      , rd = (0,
        eg.forwardRef)(({ hideValue: J = !1, shadow: et = !0, value: eo, variant: el = "default", ...ec }, ed) => {
          let eh = J ? null : `${eo}%`
            , ep = (0,
              eg.useRef)(null)
            , [ef, em] = (0,
              eg.useState)([])
            , ey = (0,
              eg.useCallback)(() => {
                if (!ep.current || void 0 === eo)
                  return;
                let J = ep.current.getBoundingClientRect().width
                  , et = Math.round(eo / 100 * J / 17);
                em(Array.from({
                  length: et
                }))
              }
                , [eo]);
          return (0,
            eg.useEffect)(() => (ey(),
              window.addEventListener("resize", ey),
              () => window.removeEventListener("resize", ey)), [ey]),
            eg.createElement(t8, {
              "aria-valuenow": void 0 !== eo ? Math.round(eo) : void 0,
              ref: ed,
              role: "progressbar",
              variant: el,
              ...ec
            }, eg.createElement(t7, {
              variant: el,
              shadow: et
            }, "default" === el ? eg.createElement(eg.Fragment, null, eg.createElement(ro, {
              "data-testid": "defaultProgress1"
            }, eh), eg.createElement(ra, {
              "data-testid": "defaultProgress2",
              value: eo
            }, eh)) : eg.createElement(rl, {
              ref: ep,
              "data-testid": "tileProgress"
            }, ef.map((J, et) => eg.createElement(rc, {
              key: et
            })))))
        }
        );
    rd.displayName = "ProgressBar";
    let rh = ec.iv`
width: ${20}px;
height: ${20}px;
border-radius: 50%;
display: flex;
align-items: center;
justify-content: space-around;
margin-right: 0.5rem;
`
      , rp = (0,
        ec.ZP)(eD)`
${rh}
background: ${({ $disabled: J, theme: et }) => J ? et.material : et.canvas};

&:before {
  content: '';
  position: absolute;
  left: 0px;
  top: 0px;
  width: calc(100% - 4px);
  height: calc(100% - 4px);
  border-radius: 50%;
  box-shadow: none;
}
`
      , rm = ec.ZP.div`
${createFlatBoxStyles()}
${rh}
outline: none;
background: ${({ $disabled: J, theme: et }) => J ? et.flatLight : et.canvas};
&:before {
  content: '';
  display: inline-block;
  position: absolute;
  top: 0;
  left: 0;
  width: calc(100% - 4px);
  height: calc(100% - 4px);
  border: 2px solid ${({ theme: J }) => J.flatDark};
  border-radius: 50%;
}
`
      , rg = ec.ZP.span.attrs(() => ({
        "data-testid": "checkmarkIcon"
      }))`
position: absolute;
content: '';
display: inline-block;
top: 50%;
left: 50%;
width: 6px;
height: 6px;
transform: translate(-50%, -50%);
border-radius: 50%;
background: ${J => J.$disabled ? J.theme.checkmarkDisabled : J.theme.checkmark};
`
      , ry = {
        flat: rm,
        default: rp
      }
      , rb = (0,
        eg.forwardRef)(({ checked: J, className: et = "", disabled: eo = !1, label: el = "", onChange: ec, style: ed = {}, variant: eh = "default", ...ep }, ef) => {
          let em = ry[eh];
          return eg.createElement(eN, {
            $disabled: eo,
            className: et,
            style: ed
          }, eg.createElement(em, {
            $disabled: eo,
            role: "presentation"
          }, J && eg.createElement(rg, {
            $disabled: eo,
            variant: eh
          })), eg.createElement(eO, {
            disabled: eo,
            onChange: eo ? void 0 : ec,
            readOnly: eo,
            type: "radio",
            checked: J,
            ref: ef,
            ...ep
          }), el && eg.createElement(eM, null, el))
        }
        );
    rb.displayName = "Radio";
    let rw = "undefined" != typeof window ? eg.useLayoutEffect : eg.useEffect;
    function useEventCallback(J) {
      let et = eg.useRef(J);
      return rw(() => {
        et.current = J
      }
      ),
        eg.useCallback((...J) => (0,
          et.current)(...J), [])
    }
    function setRef(J, et) {
      "function" == typeof J ? J(et) : J && (J.current = et)
    }
    function useForkRef(J, et) {
      return (0,
        eg.useMemo)(() => null == J && null == et ? null : eo => {
          setRef(J, eo),
            setRef(et, eo)
        }
          , [J, et])
    }
    var r_ = eo(73935);
    let rx = !0
      , rE = !1
      , rC = {
        text: !0,
        search: !0,
        url: !0,
        tel: !0,
        email: !0,
        password: !0,
        number: !0,
        date: !0,
        month: !0,
        week: !0,
        time: !0,
        datetime: !0,
        "datetime-local": !0
      };
    function handleKeyDown(J) {
      J.metaKey || J.altKey || J.ctrlKey || (rx = !0)
    }
    function handlePointerDown() {
      rx = !1
    }
    function handleVisibilityChange() {
      "hidden" === this.visibilityState && rE && (rx = !0)
    }
    function isFocusVisible(J) {
      let { target: et } = J;
      try {
        return et.matches(":focus-visible")
      } catch (J) { }
      return rx || function (J) {
        if ("type" in J) {
          let { type: et, tagName: eo } = J;
          if ("INPUT" === eo && rC[et] && !J.readOnly || "TEXTAREA" === eo && !J.readOnly)
            return !0
        }
        return "isContentEditable" in J && !!J.isContentEditable
      }(et)
    }
    function handleBlurVisible() {
      rE = !0,
        window.clearTimeout(el),
        el = window.setTimeout(() => {
          rE = !1
        }
          , 100)
    }
    function trackFinger(J, et) {
      if (void 0 !== et && "changedTouches" in J) {
        for (let eo = 0; eo < J.changedTouches.length; eo += 1) {
          let el = J.changedTouches[eo];
          if (el.identifier === et)
            return {
              x: el.clientX,
              y: el.clientY
            }
        }
        return !1
      }
      return "clientX" in J && {
        x: J.clientX,
        y: J.clientY
      }
    }
    function ownerDocument(J) {
      return J && J.ownerDocument || document
    }
    let rS = ec.ZP.div`
display: inline-block;
position: relative;
touch-action: none;
&:before {
  content: '';
  display: inline-block;
  position: absolute;
  top: -2px;
  left: -15px;
  width: calc(100% + 30px);
  height: ${({ hasMarks: J }) => J ? "41px" : "39px"};
  ${({ isFocused: J, theme: et }) => J && `
      outline: 2px dotted ${et.materialText};
      `}
}

${({ orientation: J, size: et }) => "vertical" === J ? ec.iv`
        height: ${et};
        margin-right: 1.5rem;
        &:before {
          left: -6px;
          top: -15px;
          height: calc(100% + 30px);
          width: ${({ hasMarks: J }) => J ? "41px" : "39px"};
        }
      ` : ec.iv`
        width: ${et};
        margin-bottom: 1.5rem;
        &:before {
          top: -2px;
          left: -15px;
          width: calc(100% + 30px);
          height: ${({ hasMarks: J }) => J ? "41px" : "39px"};
        }
      `}

pointer-events: ${({ $disabled: J }) => J ? "none" : "auto"};
`
      , sharedGrooveStyles = () => ec.iv`
position: absolute;
${({ orientation: J }) => "vertical" === J ? ec.iv`
        bottom: 0;
        left: 50%;
        transform: translateX(-50%);
        height: 100%;
        width: 8px;
      ` : ec.iv`
        left: 0;
        top: 50%;
        transform: translateY(-50%);
        height: 8px;
        width: 100%;
      `}
`
      , rk = (0,
        ec.ZP)(eD)`
${sharedGrooveStyles()}
`
      , rT = (0,
        ec.ZP)(eD)`
${sharedGrooveStyles()}

border-left-color: ${({ theme: J }) => J.flatLight};
border-top-color: ${({ theme: J }) => J.flatLight};
border-right-color: ${({ theme: J }) => J.canvas};
border-bottom-color: ${({ theme: J }) => J.canvas};
&:before {
  border-left-color: ${({ theme: J }) => J.flatDark};
  border-top-color: ${({ theme: J }) => J.flatDark};
  border-right-color: ${({ theme: J }) => J.flatLight};
  border-bottom-color: ${({ theme: J }) => J.flatLight};
}
`
      , rA = ec.ZP.span`
position: relative;
${({ orientation: J }) => "vertical" === J ? ec.iv`
        width: 32px;
        height: 18px;
        right: 2px;
        transform: translateY(-50%);
      ` : ec.iv`
        height: 32px;
        width: 18px;
        top: 2px;
        transform: translateX(-50%);
      `}
${({ variant: J }) => "flat" === J ? ec.iv`
        ${createFlatBoxStyles()}
        outline: 2px solid ${({ theme: J }) => J.flatDark};
        background: ${({ theme: J }) => J.flatLight};
      ` : ec.iv`
        ${createBoxStyles()}
        ${createBorderStyles()}
        &:focus {
          outline: none;
        }
      `}
  ${({ $disabled: J, theme: et }) => J && createHatchedBackground({
        mainColor: et.material,
        secondaryColor: et.borderLightest
      })}
`
      , rP = ec.ZP.span`
display: inline-block;
position: absolute;

${({ orientation: J }) => "vertical" === J ? ec.iv`
        right: ${-8}px;
        bottom: 0px;
        transform: translateY(1px);
        width: ${6}px;
        border-bottom: 2px solid ${({ theme: J }) => J.materialText};
      ` : ec.iv`
        bottom: ${-6}px;
        height: ${6}px;
        transform: translateX(-1px);
        border-left: 1px solid ${({ theme: J }) => J.materialText};
        border-right: 1px solid ${({ theme: J }) => J.materialText};
      `}

color:  ${({ theme: J }) => J.materialText};
${({ $disabled: J, theme: et }) => J && ec.iv`
    ${createDisabledTextStyles()}
    box-shadow: 1px 1px 0px ${et.materialTextDisabledShadow};
    border-color: ${et.materialTextDisabled};
  `}
`
      , rR = ec.ZP.div`
position: absolute;
bottom: 0;
left: 0;
line-height: 1;
font-size: 0.875rem;

${({ orientation: J }) => "vertical" === J ? ec.iv`
        transform: translate(${8}px, ${7}px);
      ` : ec.iv`
        transform: translate(-0.5ch, calc(100% + 2px));
      `}
`
      , rI = (0,
        eg.forwardRef)(({ defaultValue: J, disabled: et = !1, marks: eo = !1, max: el = 100, min: ec = 0, name: ed, onChange: eh, onChangeCommitted: ep, onMouseDown: ef, orientation: em = "horizontal", size: ey = "100%", step: eb = 1, value: ew, variant: e_ = "default", ...ex }, eE) => {
          let eC = "flat" === e_ ? rT : rk
            , eS = "vertical" === em
            , [ek = ec, eT] = useControlledOrUncontrolled({
              defaultValue: J,
              onChange: null != eh ? eh : ep,
              value: ew
            })
            , { isFocusVisible: eA, onBlurVisible: eP, ref: eR } = function () {
              let J = (0,
                eg.useCallback)(J => {
                  let et = (0,
                    r_.findDOMNode)(J);
                  if (null != et) {
                    var eo;
                    (eo = et.ownerDocument).addEventListener("keydown", handleKeyDown, !0),
                      eo.addEventListener("mousedown", handlePointerDown, !0),
                      eo.addEventListener("pointerdown", handlePointerDown, !0),
                      eo.addEventListener("touchstart", handlePointerDown, !0),
                      eo.addEventListener("visibilitychange", handleVisibilityChange, !0)
                  }
                }
                  , []);
              return {
                isFocusVisible,
                onBlurVisible: handleBlurVisible,
                ref: J
              }
            }()
            , [eI, eO] = (0,
              eg.useState)(!1)
            , eN = (0,
              eg.useRef)()
            , eM = (0,
              eg.useRef)(null)
            , eD = useForkRef(eR, eN)
            , ej = useForkRef(eE, eD)
            , eL = useEventCallback(J => {
              eA(J) && eO(!0)
            }
            )
            , e$ = useEventCallback(() => {
              !1 !== eI && (eO(!1),
                eP())
            }
            )
            , eB = (0,
              eg.useRef)()
            , eF = (0,
              eg.useMemo)(() => !0 === eo && Number.isFinite(eb) ? [...Array(Math.round((el - ec) / eb) + 1)].map((J, et) => ({
                label: void 0,
                value: ec + eb * et
              })) : Array.isArray(eo) ? eo : [], [eo, el, ec, eb])
            , eU = useEventCallback(J => {
              let et = (el - ec) / 10
                , eo = eF.map(J => J.value)
                , ed = eo.indexOf(ek)
                , ef = 0;
              switch (J.key) {
                case "Home":
                  ef = ec;
                  break;
                case "End":
                  ef = el;
                  break;
                case "PageUp":
                  eb && (ef = ek + et);
                  break;
                case "PageDown":
                  eb && (ef = ek - et);
                  break;
                case "ArrowRight":
                case "ArrowUp":
                  ef = eb ? ek + eb : eo[ed + 1] || eo[eo.length - 1];
                  break;
                case "ArrowLeft":
                case "ArrowDown":
                  ef = eb ? ek - eb : eo[ed - 1] || eo[0];
                  break;
                default:
                  return
              }
              J.preventDefault(),
                eb && (ef = roundValueToStep(ef, eb, ec)),
                eT(ef = clamp(ef, ec, el)),
                eO(!0),
                null == eh || eh(ef),
                null == ep || ep(ef)
            }
            )
            , ez = (0,
              eg.useCallback)(J => {
                let et;
                if (!eN.current)
                  return 0;
                let eo = eN.current.getBoundingClientRect();
                if (et = (el - ec) * (eS ? (eo.bottom - J.y) / eo.height : (J.x - eo.left) / eo.width) + ec,
                  eb)
                  et = roundValueToStep(et, eb, ec);
                else {
                  let J = eF.map(J => J.value)
                    , eo = function (J, et) {
                      var eo;
                      let { index: el } = null !== (eo = J.reduce((J, eo, el) => {
                        let ec = Math.abs(et - eo);
                        return null === J || ec < J.distance || ec === J.distance ? {
                          distance: ec,
                          index: el
                        } : J
                      }
                        , null)) && void 0 !== eo ? eo : {};
                      return null != el ? el : -1
                    }(J, et);
                  et = J[eo]
                }
                return clamp(et, ec, el)
              }
                , [eF, el, ec, eb, eS])
            , eH = useEventCallback(J => {
              var et;
              let eo = trackFinger(J, eB.current);
              if (!eo)
                return;
              let el = ez(eo);
              null === (et = eM.current) || void 0 === et || et.focus(),
                eT(el),
                eO(!0),
                null == eh || eh(el)
            }
            )
            , eV = useEventCallback(J => {
              let et = trackFinger(J, eB.current);
              if (!et)
                return;
              let eo = ez(et);
              null == ep || ep(eo),
                eB.current = void 0;
              let el = ownerDocument(eN.current);
              el.removeEventListener("mousemove", eH),
                el.removeEventListener("mouseup", eV),
                el.removeEventListener("touchmove", eH),
                el.removeEventListener("touchend", eV)
            }
            )
            , eW = useEventCallback(J => {
              var et;
              null == ef || ef(J),
                J.preventDefault(),
                null === (et = eM.current) || void 0 === et || et.focus(),
                eO(!0);
              let eo = trackFinger(J, eB.current);
              if (eo) {
                let J = ez(eo);
                eT(J),
                  null == eh || eh(J)
              }
              let el = ownerDocument(eN.current);
              el.addEventListener("mousemove", eH),
                el.addEventListener("mouseup", eV)
            }
            )
            , eZ = useEventCallback(J => {
              var et;
              J.preventDefault();
              let eo = J.changedTouches[0];
              null != eo && (eB.current = eo.identifier),
                null === (et = eM.current) || void 0 === et || et.focus(),
                eO(!0);
              let el = trackFinger(J, eB.current);
              if (el) {
                let J = ez(el);
                eT(J),
                  null == eh || eh(J)
              }
              let ec = ownerDocument(eN.current);
              ec.addEventListener("touchmove", eH),
                ec.addEventListener("touchend", eV)
            }
            );
          return (0,
            eg.useEffect)(() => {
              let { current: J } = eN;
              null == J || J.addEventListener("touchstart", eZ);
              let et = ownerDocument(J);
              return () => {
                null == J || J.removeEventListener("touchstart", eZ),
                  et.removeEventListener("mousemove", eH),
                  et.removeEventListener("mouseup", eV),
                  et.removeEventListener("touchmove", eH),
                  et.removeEventListener("touchend", eV)
              }
            }
              , [eV, eH, eZ]),
            eg.createElement(rS, {
              $disabled: et,
              hasMarks: !!eF.length,
              isFocused: eI,
              onMouseDown: eW,
              orientation: em,
              ref: ej,
              size: getSize(ey),
              ...ex
            }, eg.createElement("input", {
              disabled: et,
              name: ed,
              type: "hidden",
              value: null != ek ? ek : 0
            }), eF && eF.map(J => eg.createElement(rP, {
              $disabled: et,
              "data-testid": "tick",
              key: J.value / (el - ec) * 100,
              orientation: em,
              style: {
                [eS ? "bottom" : "left"]: `${(J.value - ec) / (el - ec) * 100}%`
              }
            }, J.label && eg.createElement(rR, {
              "aria-hidden": !0,
              "data-testid": "mark",
              orientation: em
            }, J.label))), eg.createElement(eC, {
              orientation: em,
              variant: e_
            }), eg.createElement(rA, {
              $disabled: et,
              "aria-disabled": !!et || void 0,
              "aria-orientation": em,
              "aria-valuemax": el,
              "aria-valuemin": ec,
              "aria-valuenow": ek,
              onBlur: e$,
              onFocus: eL,
              onKeyDown: eU,
              orientation: em,
              ref: eM,
              role: "slider",
              style: {
                [eS ? "bottom" : "left"]: `${(eS ? -100 : 0) + 100 * (ek - ec) / (el - ec)}%`
              },
              tabIndex: et ? void 0 : 0,
              variant: e_
            }))
        }
        );
    rI.displayName = "Slider";
    let rO = ec.ZP.tbody`
background: ${({ theme: J }) => J.canvas};
display: table-row-group;
box-shadow: ${ep};
overflow-y: auto;
`
      , rN = (0,
        eg.forwardRef)(function ({ children: J, ...et }, eo) {
          return eg.createElement(rO, {
            ref: eo,
            ...et
          }, J)
        });
    rN.displayName = "TableBody";
    let rM = ec.ZP.td`
padding: 0 8px;
`
      , rD = (0,
        eg.forwardRef)(function ({ children: J, ...et }, eo) {
          return eg.createElement(rM, {
            ref: eo,
            ...et
          }, J)
        });
    rD.displayName = "TableDataCell";
    let rj = ec.ZP.thead`
display: table-header-group;
`
      , rL = (0,
        eg.forwardRef)(function ({ children: J, ...et }, eo) {
          return eg.createElement(rj, {
            ref: eo,
            ...et
          }, J)
        });
    rL.displayName = "TableHead";
    let r$ = ec.ZP.th`
position: relative;
padding: 0 8px;
display: table-cell;
vertical-align: inherit;
background: ${({ theme: J }) => J.material};
cursor: default;
user-select: none;
&:before {
  box-sizing: border-box;
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  ${createBorderStyles()}

  border-left: none;
  border-top: none;
}
${({ $disabled: J }) => !J && ec.iv`
    &:active {
      &:before {
        ${createBorderStyles({
      invert: !0,
      style: "window"
    })}
        border-left: none;
        border-top: none;
        padding-top: 2px;
      }

      & > div {
        position: relative;
        top: 2px;
      }
    }
  `}

color: ${({ theme: J }) => J.materialText};
${({ $disabled: J }) => J && createDisabledTextStyles()}
&:hover {
  color: ${({ theme: J }) => J.materialText};
  ${({ $disabled: J }) => J && createDisabledTextStyles()}
}
`
      , rB = (0,
        eg.forwardRef)(function ({ disabled: J = !1, children: et, onClick: eo, onTouchStart: el = noOp, sort: ec, ...ed }, eh) {
          return eg.createElement(r$, {
            $disabled: J,
            "aria-disabled": J,
            "aria-sort": "asc" === ec ? "ascending" : "desc" === ec ? "descending" : void 0,
            onClick: J ? void 0 : eo,
            onTouchStart: J ? void 0 : el,
            ref: eh,
            ...ed
          }, eg.createElement("div", null, et))
        });
    rB.displayName = "TableHeadCell";
    let rF = ec.ZP.tr`
color: inherit;
display: table-row;
height: calc(${eS.md} - 2px);
line-height: calc(${eS.md} - 2px);
vertical-align: middle;
outline: none;

color: ${({ theme: J }) => J.canvasText};
&:hover {
  background: ${({ theme: J }) => J.hoverBackground};
  color: ${({ theme: J }) => J.canvasTextInvert};
}
`
      , rU = (0,
        eg.forwardRef)(function ({ children: J, ...et }, eo) {
          return eg.createElement(rF, {
            ref: eo,
            ...et
          }, J)
        });
    rU.displayName = "TableRow";
    let rz = ec.ZP.table`
display: table;
width: 100%;
border-collapse: collapse;
border-spacing: 0;
font-size: 1rem;
`
      , rH = (0,
        ec.ZP)(eD)`
&:before {
  box-shadow: none;
}
`
      , rV = (0,
        eg.forwardRef)(({ children: J, ...et }, eo) => eg.createElement(rH, null, eg.createElement(rz, {
          ref: eo,
          ...et
        }, J)));
    rV.displayName = "Table";
    let rW = ec.ZP.button`
${createBoxStyles()}
${createBorderStyles()}
position: relative;
display: inline-flex;
align-items: center;
justify-content: center;
font-size: 1rem;
height: ${eS.md};
line-height: ${eS.md};
padding: 0 8px;
border-bottom: none;
border-top-left-radius: 5px;
border-top-right-radius: 5px;
margin: 0 0 -2px 0;
cursor: default;
color: ${({ theme: J }) => J.materialText};
user-select: none;
font-family: inherit;
&:focus:after,
&:active:after {
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  ${focusOutline}
  outline-offset: -6px;
}
${J => J.selected && `
  z-index: 1;
  height: calc(${eS.md} + 4px);
  top: -4px;
  margin-bottom: -6px;
  padding: 0 16px;
  margin-left: -8px;
  &:not(:last-child) {
    margin-right: -8px;
  }
`}
&:before {
  content: '';
  position: absolute;
  width: calc(100% - 4px);
  height: 6px;
  background: ${({ theme: J }) => J.material};
  bottom: -4px;
  left: 2px;
}
`
      , rq = (0,
        eg.forwardRef)(({ value: J, onClick: et, selected: eo = !1, children: el, ...ec }, ed) => eg.createElement(rW, {
          "aria-selected": eo,
          selected: eo,
          onClick: eo => null == et ? void 0 : et(J, eo),
          ref: ed,
          role: "tab",
          ...ec
        }, el));
    rq.displayName = "Tab";
    let rZ = ec.ZP.div`
${createBoxStyles()}
${createBorderStyles()}
position: relative;
display: block;
height: 100%;
padding: 16px;
font-size: 1rem;
`
      , rG = (0,
        eg.forwardRef)(({ children: J, ...et }, eo) => eg.createElement(rZ, {
          ref: eo,
          ...et
        }, J));
    rG.displayName = "TabBody";
    let rY = ec.ZP.div`
position: relative;
${({ isMultiRow: J, theme: et }) => J && `
button {
  flex-grow: 1;
}
button:last-child:before {
  border-right: 2px solid ${et.borderDark};
}
`}
`
      , rK = ec.ZP.div.attrs(() => ({
        "data-testid": "tab-row"
      }))`
position: relative;
display: flex;
flex-wrap: no-wrap;
text-align: left;
left: 8px;
width: calc(100% - 8px);

&:not(:first-child):before {
  content: '';
  position: absolute;
  right: 0;
  left: 0;
  height: 100%;
  border-right: 2px solid ${({ theme: J }) => J.borderDarkest};
  border-left: 2px solid ${({ theme: J }) => J.borderLightest};
}
`
      , rJ = (0,
        eg.forwardRef)(({ value: J, onChange: et = noOp, children: eo, rows: el = 1, ...ec }, ed) => {
          let eh = (0,
            eg.useMemo)(() => {
              var ec;
              let ed = null !== (ec = eg.Children.map(eo, eo => {
                if (!eg.isValidElement(eo))
                  return null;
                let el = {
                  selected: eo.props.value === J,
                  onClick: et
                };
                return eg.cloneElement(eo, el)
              }
              )) && void 0 !== ec ? ec : []
                , eh = (function (J, et) {
                  let eo = [];
                  for (let el = et; el > 0; el -= 1)
                    eo.push(J.splice(0, Math.ceil(J.length / el)));
                  return eo
                }
                )(ed, el).map((J, et) => ({
                  key: et,
                  tabs: J
                }))
                , ep = eh.findIndex(J => J.tabs.some(J => J.props.selected));
              return eh.push(eh.splice(ep, 1)[0]),
                eh
            }
              , [eo, et, el, J]);
          return eg.createElement(rY, {
            ...ec,
            isMultiRow: el > 1,
            role: "tablist",
            ref: ed
          }, eh.map(J => eg.createElement(rK, {
            key: J.key
          }, J.tabs)))
        }
        );
    rJ.displayName = "Tabs";
    let rQ = ["blur", "focus"]
      , rX = ["click", "contextmenu", "doubleclick", "drag", "dragend", "dragenter", "dragexit", "dragleave", "dragover", "dragstart", "drop", "mousedown", "mouseenter", "mouseleave", "mousemove", "mouseout", "mouseover", "mouseup"];
    function isReactFocusEvent(J) {
      return "nativeEvent" in J && rQ.includes(J.type)
    }
    function isReactMouseEvent(J) {
      return "nativeEvent" in J && rX.includes(J.type)
    }
    let r0 = {
      top: `top: -4px;
      left: 50%;
      transform: translate(-50%, -100%);`,
      bottom: `bottom: -4px;
         left: 50%;
         transform: translate(-50%, 100%);`,
      left: `left: -4px;
       top: 50%;
       transform: translate(-100%, -50%);`,
      right: `right: -4px;
        top: 50%;
        transform: translate(100%, -50%);`
    }
      , r1 = ec.ZP.span`
position: absolute;

z-index: 1;
display: ${J => J.show ? "block" : "none"};
padding: 4px;
border: 2px solid ${({ theme: J }) => J.borderDarkest};
background: ${({ theme: J }) => J.tooltip};
box-shadow: ${eh};
text-align: center;
font-size: 1rem;
${J => r0[J.position]}
`
      , r2 = ec.ZP.div`
position: relative;
display: inline-block;
white-space: nowrap;
`
      , r3 = (0,
        eg.forwardRef)(({ className: J, children: et, disableFocusListener: eo = !1, disableMouseListener: el = !1, enterDelay: ec = 1e3, leaveDelay: ed = 0, onBlur: eh, onClose: ep, onFocus: ef, onMouseEnter: em, onMouseLeave: ey, onOpen: eb, style: ew, text: e_, position: ex = "top", ...eE }, eC) => {
          let [eS, ek] = (0,
            eg.useState)(!1)
            , [eT, eA] = (0,
              eg.useState)()
            , [eP, eR] = (0,
              eg.useState)()
            , eI = !eo
            , eO = !el
            , handleOpen = J => {
              window.clearTimeout(eT),
                window.clearTimeout(eP);
              let et = window.setTimeout(() => {
                ek(!0),
                  null == eb || eb(J)
              }
                , ec);
              eA(et)
            }
            , handleEnter = J => {
              J.persist(),
                isReactFocusEvent(J) ? null == ef || ef(J) : isReactMouseEvent(J) && (null == em || em(J)),
                handleOpen(J)
            }
            , handleClose = J => {
              window.clearTimeout(eT),
                window.clearTimeout(eP);
              let et = window.setTimeout(() => {
                ek(!1),
                  null == ep || ep(J)
              }
                , ed);
              eR(et)
            }
            , handleLeave = J => {
              J.persist(),
                isReactFocusEvent(J) ? null == eh || eh(J) : isReactMouseEvent(J) && (null == ey || ey(J)),
                handleClose(J)
            }
            ;
          return eg.createElement(r2, {
            "data-testid": "tooltip-wrapper",
            onBlur: eI ? handleLeave : void 0,
            onFocus: eI ? handleEnter : void 0,
            onMouseEnter: eO ? handleEnter : void 0,
            onMouseLeave: eO ? handleLeave : void 0,
            tabIndex: eI ? 0 : void 0
          }, eg.createElement(r1, {
            className: J,
            "data-testid": "tooltip",
            position: ex,
            ref: eC,
            show: eS,
            style: ew,
            ...eE
          }, e_), et)
        }
        );
    r3.displayName = "Tooltip";
    let r5 = (0,
      ec.ZP)(eM)`
white-space: nowrap;
`
      , r6 = ec.iv`
:focus {
  outline: none;
}

${({ $disabled: J }) => J ? "cursor: default;" : ec.iv`
        cursor: pointer;

        :focus {
          ${r5} {
            background: ${({ theme: J }) => J.hoverBackground};
            color: ${({ theme: J }) => J.materialTextInvert};
            outline: 2px dotted ${({ theme: J }) => J.focusSecondary};
          }
        }
      `}
`
      , r4 = ec.ZP.ul`
position: relative;
isolation: isolate;

${({ isRootLevel: J }) => J && ec.iv`
    &:before {
      content: '';
      position: absolute;
      top: 20px;
      bottom: 0;
      left: 5.5px;
      width: 1px;
      border-left: 2px dashed ${({ theme: J }) => J.borderDark};
    }
  `}

ul {
  padding-left: 19.5px;
}

li {
  position: relative;

  &:before {
    content: '';
    position: absolute;
    top: 17.5px;
    left: 5.5px;
    width: 22px;
    border-top: 2px dashed ${({ theme: J }) => J.borderDark};
    font-size: 12px;
  }
}
`
      , r8 = ec.ZP.li`
position: relative;
padding-left: ${({ hasItems: J }) => J ? "0" : "13px"};

${({ isRootLevel: J }) => J ? ec.iv`
        &:last-child {
          &:after {
            content: '';
            position: absolute;
            top: 19.5px;
            left: 1px;
            bottom: 0;
            width: 10px;
            background: ${({ theme: J }) => J.material};
          }
        }
      ` : ec.iv`
        &:last-child {
          &:after {
            content: '';
            position: absolute;
            z-index: 1;
            top: 19.5px;
            bottom: 0;
            left: 1.5px;
            width: 10px;
            background: ${({ theme: J }) => J.material};
          }
        }
      `}

& > details > ul {
  &:after {
    content: '';
    position: absolute;
    top: -18px;
    bottom: 0;
    left: 25px;
    border-left: 2px dashed ${({ theme: J }) => J.borderDark};
  }
}
`
      , r7 = ec.ZP.details`
position: relative;
z-index: 2;

&[open] > summary:before {
  content: '-';
}
`
      , r9 = ec.ZP.summary`
position: relative;
z-index: 1;
display: inline-flex;
align-items: center;
color: ${({ theme: J }) => J.materialText};
user-select: none;
padding-left: 18px;
${r6};

&::-webkit-details-marker {
  display: none;
}

&:before {
  content: '+';
  position: absolute;
  left: 0;
  display: block;
  width: 8px;
  height: 9px;
  border: 2px solid #808080;
  padding-left: 1px;
  background-color: #fff;
  line-height: 8px;
  text-align: center;
}
`
      , nn = (0,
        ec.ZP)(eN)`
position: relative;
z-index: 1;
background: none;
border: 0;
font-family: inherit;
padding-top: 8px;
padding-bottom: 8px;
margin: 0;
${r6};
`
      , ns = ec.ZP.span`
display: flex;
align-items: center;
justify-content: center;
width: 16px;
height: 16px;
margin-right: 6px;
`;
    function toggleItem(J, et) {
      return J.includes(et) ? J.filter(J => J !== et) : [...J, et]
    }
    function preventDefault(J) {
      J.preventDefault()
    }
    function TreeBranch({ className: J, disabled: et, expanded: eo, innerRef: el, level: ec, select: ed, selected: eh, style: ep, tree: ef = [] }) {
      let em = 0 === ec
        , ey = (0,
          eg.useCallback)(el => {
            var ef, ey;
            let eb = !!(el.items && el.items.length > 0)
              , ew = eo.includes(el.id)
              , e_ = null !== (ef = et || el.disabled) && void 0 !== ef && ef
              , ex = e_ ? preventDefault : J => ed(J, el)
              , eE = e_ ? preventDefault : J => ed(J, el)
              , eC = eh === el.id
              , eS = eg.createElement(ns, {
                "aria-hidden": !0
              }, el.icon);
            return eg.createElement(r8, {
              key: el.label,
              isRootLevel: em,
              role: "treeitem",
              "aria-expanded": ew,
              "aria-selected": eC,
              hasItems: eb
            }, eb ? eg.createElement(r7, {
              open: ew
            }, eg.createElement(r9, {
              onClick: ex,
              $disabled: e_
            }, eg.createElement(nn, {
              $disabled: e_
            }, eS, eg.createElement(r5, null, el.label))), ew && eg.createElement(TreeBranch, {
              className: J,
              disabled: e_,
              expanded: eo,
              level: ec + 1,
              select: ed,
              selected: eh,
              style: ep,
              tree: null !== (ey = el.items) && void 0 !== ey ? ey : []
            })) : eg.createElement(nn, {
              as: "button",
              $disabled: e_,
              onClick: eE
            }, eS, eg.createElement(r5, null, el.label)))
          }
            , [J, et, eo, em, ec, ed, eh, ep]);
      return eg.createElement(r4, {
        className: em ? J : void 0,
        style: em ? ep : void 0,
        ref: em ? el : void 0,
        role: em ? "tree" : "group",
        isRootLevel: em
      }, ef.map(ey))
    }
    let no = (0,
      eg.forwardRef)(function ({ className: J, defaultExpanded: et = [], defaultSelected: eo, disabled: el = !1, expanded: ec, onNodeSelect: ed, onNodeToggle: eh, selected: ep, style: ef, tree: em = [] }, ey) {
        let [eb, ew] = useControlledOrUncontrolled({
          defaultValue: et,
          onChange: eh,
          onChangePropName: "onNodeToggle",
          value: ec,
          valuePropName: "expanded"
        })
          , [e_, ex] = useControlledOrUncontrolled({
            defaultValue: eo,
            onChange: ed,
            onChangePropName: "onNodeSelect",
            value: ep,
            valuePropName: "selected"
          })
          , eE = (0,
            eg.useCallback)((J, et) => {
              if (eh) {
                let eo = toggleItem(eb, et);
                eh(J, eo)
              }
              ew(J => toggleItem(J, et))
            }
              , [eb, eh, ew])
          , eC = (0,
            eg.useCallback)((J, et) => {
              ex(et),
                ed && ed(J, et)
            }
              , [ed, ex])
          , eS = (0,
            eg.useCallback)((J, et) => {
              J.preventDefault(),
                eC(J, et.id),
                et.items && et.items.length && eE(J, et.id)
            }
              , [eC, eE]);
        return eg.createElement(TreeBranch, {
          className: J,
          disabled: el,
          expanded: eb,
          level: 0,
          innerRef: ey,
          select: eS,
          selected: e_,
          style: ef,
          tree: em
        })
      });
    no.displayName = "TreeView"
  },
  97884: function (J, et, eo) {
    "use strict";
    eo.r(et),
      eo.d(et, {
        Struct: function () {
          return Struct
        },
        StructError: function () {
          return StructError
        },
        any: function () {
          return any
        },
        array: function () {
          return array
        },
        assert: function () {
          return assert
        },
        assign: function () {
          return assign
        },
        bigint: function () {
          return bigint
        },
        boolean: function () {
          return boolean
        },
        coerce: function () {
          return coerce
        },
        create: function () {
          return create
        },
        date: function () {
          return date
        },
        defaulted: function () {
          return defaulted
        },
        define: function () {
          return define
        },
        deprecated: function () {
          return deprecated
        },
        dynamic: function () {
          return dynamic
        },
        empty: function () {
          return empty
        },
        enums: function () {
          return enums
        },
        func: function () {
          return func
        },
        instance: function () {
          return instance
        },
        integer: function () {
          return integer
        },
        intersection: function () {
          return intersection
        },
        is: function () {
          return is
        },
        lazy: function () {
          return lazy
        },
        literal: function () {
          return literal
        },
        map: function () {
          return map
        },
        mask: function () {
          return mask
        },
        max: function () {
          return max
        },
        min: function () {
          return min
        },
        never: function () {
          return never
        },
        nonempty: function () {
          return nonempty
        },
        nullable: function () {
          return nullable
        },
        number: function () {
          return number
        },
        object: function () {
          return object
        },
        omit: function () {
          return omit
        },
        optional: function () {
          return optional
        },
        partial: function () {
          return partial
        },
        pattern: function () {
          return pattern
        },
        pick: function () {
          return pick
        },
        record: function () {
          return record
        },
        refine: function () {
          return refine
        },
        regexp: function () {
          return regexp
        },
        set: function () {
          return set
        },
        size: function () {
          return size
        },
        string: function () {
          return string
        },
        struct: function () {
          return struct
        },
        trimmed: function () {
          return trimmed
        },
        tuple: function () {
          return tuple
        },
        type: function () {
          return type
        },
        union: function () {
          return union
        },
        unknown: function () {
          return unknown
        },
        validate: function () {
          return validate
        }
      });
    let StructError = class StructError extends TypeError {
      constructor(J, et) {
        let eo;
        let { message: el, explanation: ec, ...ed } = J
          , { path: eh } = J
          , ep = 0 === eh.length ? el : `At path: ${eh.join(".")} -- ${el}`;
        super(ec ?? ep),
          null != ec && (this.cause = ep),
          Object.assign(this, ed),
          this.name = this.constructor.name,
          this.failures = () => eo ?? (eo = [J, ...et()])
      }
    }
      ;
    function isObject(J) {
      return "object" == typeof J && null != J
    }
    function isPlainObject(J) {
      if ("[object Object]" !== Object.prototype.toString.call(J))
        return !1;
      let et = Object.getPrototypeOf(J);
      return null === et || et === Object.prototype
    }
    function print(J) {
      return "symbol" == typeof J ? J.toString() : "string" == typeof J ? JSON.stringify(J) : `${J}`
    }
    function* toFailures(J, et, eo, el) {
      var ec;
      for (let ed of (isObject(ec = J) && "function" == typeof ec[Symbol.iterator] || (J = [J]),
        J)) {
        let J = function (J, et, eo, el) {
          if (!0 === J)
            return;
          !1 === J ? J = {} : "string" == typeof J && (J = {
            message: J
          });
          let { path: ec, branch: ed } = et
            , { type: eh } = eo
            , { refinement: ep, message: ef = `Expected a value of type \`${eh}\`${ep ? ` with refinement \`${ep}\`` : ""}, but received: \`${print(el)}\`` } = J;
          return {
            value: el,
            type: eh,
            refinement: ep,
            key: ec[ec.length - 1],
            path: ec,
            branch: ed,
            ...J,
            message: ef
          }
        }(ed, et, eo, el);
        J && (yield J)
      }
    }
    function* run(J, et, eo = {}) {
      let { path: el = [], branch: ec = [J], coerce: ed = !1, mask: eh = !1 } = eo
        , ep = {
          path: el,
          branch: ec
        };
      if (ed && (J = et.coercer(J, ep),
        eh && "type" !== et.type && isObject(et.schema) && isObject(J) && !Array.isArray(J)))
        for (let eo in J)
          void 0 === et.schema[eo] && delete J[eo];
      let ef = "valid";
      for (let el of et.validator(J, ep))
        el.explanation = eo.message,
          ef = "not_valid",
          yield [el, void 0];
      for (let [em, eg, ey] of et.entries(J, ep)) {
        let et = run(eg, ey, {
          path: void 0 === em ? el : [...el, em],
          branch: void 0 === em ? ec : [...ec, eg],
          coerce: ed,
          mask: eh,
          message: eo.message
        });
        for (let eo of et)
          eo[0] ? (ef = null != eo[0].refinement ? "not_refined" : "not_valid",
            yield [eo[0], void 0]) : ed && (eg = eo[1],
              void 0 === em ? J = eg : J instanceof Map ? J.set(em, eg) : J instanceof Set ? J.add(eg) : isObject(J) && (void 0 !== eg || em in J) && (J[em] = eg))
      }
      if ("not_valid" !== ef)
        for (let el of et.refiner(J, ep))
          el.explanation = eo.message,
            ef = "not_refined",
            yield [el, void 0];
      "valid" === ef && (yield [void 0, J])
    }
    let Struct = class Struct {
      constructor(J) {
        let { type: et, schema: eo, validator: el, refiner: ec, coercer: ed = J => J, entries: eh = function* () { }
        } = J;
        this.type = et,
          this.schema = eo,
          this.entries = eh,
          this.coercer = ed,
          el ? this.validator = (J, et) => {
            let eo = el(J, et);
            return toFailures(eo, et, this, J)
          }
            : this.validator = () => [],
          ec ? this.refiner = (J, et) => {
            let eo = ec(J, et);
            return toFailures(eo, et, this, J)
          }
            : this.refiner = () => []
      }
      assert(J, et) {
        return assert(J, this, et)
      }
      create(J, et) {
        return create(J, this, et)
      }
      is(J) {
        return is(J, this)
      }
      mask(J, et) {
        return mask(J, this, et)
      }
      validate(J, et = {}) {
        return validate(J, this, et)
      }
    }
      ;
    function assert(J, et, eo) {
      let el = validate(J, et, {
        message: eo
      });
      if (el[0])
        throw el[0]
    }
    function create(J, et, eo) {
      let el = validate(J, et, {
        coerce: !0,
        message: eo
      });
      if (!el[0])
        return el[1];
      throw el[0]
    }
    function mask(J, et, eo) {
      let el = validate(J, et, {
        coerce: !0,
        mask: !0,
        message: eo
      });
      if (!el[0])
        return el[1];
      throw el[0]
    }
    function is(J, et) {
      let eo = validate(J, et);
      return !eo[0]
    }
    function validate(J, et, eo = {}) {
      let el = run(J, et, eo)
        , ec = function (J) {
          let { done: et, value: eo } = J.next();
          return et ? void 0 : eo
        }(el);
      if (ec[0]) {
        let J = new StructError(ec[0], function* () {
          for (let J of el)
            J[0] && (yield J[0])
        }
        );
        return [J, void 0]
      }
      {
        let J = ec[1];
        return [void 0, J]
      }
    }
    function assign(...J) {
      let et = "type" === J[0].type
        , eo = J.map(J => J.schema)
        , el = Object.assign({}, ...eo);
      return et ? type(el) : object(el)
    }
    function define(J, et) {
      return new Struct({
        type: J,
        schema: null,
        validator: et
      })
    }
    function deprecated(J, et) {
      return new Struct({
        ...J,
        refiner: (et, eo) => void 0 === et || J.refiner(et, eo),
        validator: (eo, el) => void 0 === eo || (et(eo, el),
          J.validator(eo, el))
      })
    }
    function dynamic(J) {
      return new Struct({
        type: "dynamic",
        schema: null,
        *entries(et, eo) {
          let el = J(et, eo);
          yield* el.entries(et, eo)
        },
        validator(et, eo) {
          let el = J(et, eo);
          return el.validator(et, eo)
        },
        coercer(et, eo) {
          let el = J(et, eo);
          return el.coercer(et, eo)
        },
        refiner(et, eo) {
          let el = J(et, eo);
          return el.refiner(et, eo)
        }
      })
    }
    function lazy(J) {
      let et;
      return new Struct({
        type: "lazy",
        schema: null,
        *entries(eo, el) {
          et ?? (et = J()),
            yield* et.entries(eo, el)
        },
        validator: (eo, el) => (et ?? (et = J()),
          et.validator(eo, el)),
        coercer: (eo, el) => (et ?? (et = J()),
          et.coercer(eo, el)),
        refiner: (eo, el) => (et ?? (et = J()),
          et.refiner(eo, el))
      })
    }
    function omit(J, et) {
      let { schema: eo } = J
        , el = {
          ...eo
        };
      for (let J of et)
        delete el[J];
      return "type" === J.type ? type(el) : object(el)
    }
    function partial(J) {
      let et = J instanceof Struct ? {
        ...J.schema
      } : {
        ...J
      };
      for (let J in et)
        et[J] = optional(et[J]);
      return object(et)
    }
    function pick(J, et) {
      let { schema: eo } = J
        , el = {};
      for (let J of et)
        el[J] = eo[J];
      return object(el)
    }
    function struct(J, et) {
      return console.warn("superstruct@0.11 - The `struct` helper has been renamed to `define`."),
        define(J, et)
    }
    function any() {
      return define("any", () => !0)
    }
    function array(J) {
      return new Struct({
        type: "array",
        schema: J,
        *entries(et) {
          if (J && Array.isArray(et))
            for (let [eo, el] of et.entries())
              yield [eo, el, J]
        },
        coercer: J => Array.isArray(J) ? J.slice() : J,
        validator: J => Array.isArray(J) || `Expected an array value, but received: ${print(J)}`
      })
    }
    function bigint() {
      return define("bigint", J => "bigint" == typeof J)
    }
    function boolean() {
      return define("boolean", J => "boolean" == typeof J)
    }
    function date() {
      return define("date", J => J instanceof Date && !isNaN(J.getTime()) || `Expected a valid \`Date\` object, but received: ${print(J)}`)
    }
    function enums(J) {
      let et = {}
        , eo = J.map(J => print(J)).join();
      for (let eo of J)
        et[eo] = eo;
      return new Struct({
        type: "enums",
        schema: et,
        validator: et => J.includes(et) || `Expected one of \`${eo}\`, but received: ${print(et)}`
      })
    }
    function func() {
      return define("func", J => "function" == typeof J || `Expected a function, but received: ${print(J)}`)
    }
    function instance(J) {
      return define("instance", et => et instanceof J || `Expected a \`${J.name}\` instance, but received: ${print(et)}`)
    }
    function integer() {
      return define("integer", J => "number" == typeof J && !isNaN(J) && Number.isInteger(J) || `Expected an integer, but received: ${print(J)}`)
    }
    function intersection(J) {
      return new Struct({
        type: "intersection",
        schema: null,
        *entries(et, eo) {
          for (let el of J)
            yield* el.entries(et, eo)
        },
        *validator(et, eo) {
          for (let el of J)
            yield* el.validator(et, eo)
        },
        *refiner(et, eo) {
          for (let el of J)
            yield* el.refiner(et, eo)
        }
      })
    }
    function literal(J) {
      let et = print(J)
        , eo = typeof J;
      return new Struct({
        type: "literal",
        schema: "string" === eo || "number" === eo || "boolean" === eo ? J : null,
        validator: eo => eo === J || `Expected the literal \`${et}\`, but received: ${print(eo)}`
      })
    }
    function map(J, et) {
      return new Struct({
        type: "map",
        schema: null,
        *entries(eo) {
          if (J && et && eo instanceof Map)
            for (let [el, ec] of eo.entries())
              yield [el, el, J],
                yield [el, ec, et]
        },
        coercer: J => J instanceof Map ? new Map(J) : J,
        validator: J => J instanceof Map || `Expected a \`Map\` object, but received: ${print(J)}`
      })
    }
    function never() {
      return define("never", () => !1)
    }
    function nullable(J) {
      return new Struct({
        ...J,
        validator: (et, eo) => null === et || J.validator(et, eo),
        refiner: (et, eo) => null === et || J.refiner(et, eo)
      })
    }
    function number() {
      return define("number", J => "number" == typeof J && !isNaN(J) || `Expected a number, but received: ${print(J)}`)
    }
    function object(J) {
      let et = J ? Object.keys(J) : []
        , eo = never();
      return new Struct({
        type: "object",
        schema: J || null,
        *entries(el) {
          if (J && isObject(el)) {
            let ec = new Set(Object.keys(el));
            for (let eo of et)
              ec.delete(eo),
                yield [eo, el[eo], J[eo]];
            for (let J of ec)
              yield [J, el[J], eo]
          }
        },
        validator: J => isObject(J) || `Expected an object, but received: ${print(J)}`,
        coercer: J => isObject(J) ? {
          ...J
        } : J
      })
    }
    function optional(J) {
      return new Struct({
        ...J,
        validator: (et, eo) => void 0 === et || J.validator(et, eo),
        refiner: (et, eo) => void 0 === et || J.refiner(et, eo)
      })
    }
    function record(J, et) {
      return new Struct({
        type: "record",
        schema: null,
        *entries(eo) {
          if (isObject(eo))
            for (let el in eo) {
              let ec = eo[el];
              yield [el, el, J],
                yield [el, ec, et]
            }
        },
        validator: J => isObject(J) || `Expected an object, but received: ${print(J)}`
      })
    }
    function regexp() {
      return define("regexp", J => J instanceof RegExp)
    }
    function set(J) {
      return new Struct({
        type: "set",
        schema: null,
        *entries(et) {
          if (J && et instanceof Set)
            for (let eo of et)
              yield [eo, eo, J]
        },
        coercer: J => J instanceof Set ? new Set(J) : J,
        validator: J => J instanceof Set || `Expected a \`Set\` object, but received: ${print(J)}`
      })
    }
    function string() {
      return define("string", J => "string" == typeof J || `Expected a string, but received: ${print(J)}`)
    }
    function tuple(J) {
      let et = never();
      return new Struct({
        type: "tuple",
        schema: null,
        *entries(eo) {
          if (Array.isArray(eo)) {
            let el = Math.max(J.length, eo.length);
            for (let ec = 0; ec < el; ec++)
              yield [ec, eo[ec], J[ec] || et]
          }
        },
        validator: J => Array.isArray(J) || `Expected an array, but received: ${print(J)}`
      })
    }
    function type(J) {
      let et = Object.keys(J);
      return new Struct({
        type: "type",
        schema: J,
        *entries(eo) {
          if (isObject(eo))
            for (let el of et)
              yield [el, eo[el], J[el]]
        },
        validator: J => isObject(J) || `Expected an object, but received: ${print(J)}`,
        coercer: J => isObject(J) ? {
          ...J
        } : J
      })
    }
    function union(J) {
      let et = J.map(J => J.type).join(" | ");
      return new Struct({
        type: "union",
        schema: null,
        coercer(et) {
          for (let eo of J) {
            let [J, el] = eo.validate(et, {
              coerce: !0
            });
            if (!J)
              return el
          }
          return et
        },
        validator(eo, el) {
          let ec = [];
          for (let et of J) {
            let [...J] = run(eo, et, el)
              , [ed] = J;
            if (!ed[0])
              return [];
            for (let [et] of J)
              et && ec.push(et)
          }
          return [`Expected the value to satisfy a union of \`${et}\`, but received: ${print(eo)}`, ...ec]
        }
      })
    }
    function unknown() {
      return define("unknown", () => !0)
    }
    function coerce(J, et, eo) {
      return new Struct({
        ...J,
        coercer: (el, ec) => is(el, et) ? J.coercer(eo(el, ec), ec) : J.coercer(el, ec)
      })
    }
    function defaulted(J, et, eo = {}) {
      return coerce(J, unknown(), J => {
        let el = "function" == typeof et ? et() : et;
        if (void 0 === J)
          return el;
        if (!eo.strict && isPlainObject(J) && isPlainObject(el)) {
          let et = {
            ...J
          }
            , eo = !1;
          for (let J in el)
            void 0 === et[J] && (et[J] = el[J],
              eo = !0);
          if (eo)
            return et
        }
        return J
      }
      )
    }
    function trimmed(J) {
      return coerce(J, string(), J => J.trim())
    }
    function empty(J) {
      return refine(J, "empty", et => {
        let eo = getSize(et);
        return 0 === eo || `Expected an empty ${J.type} but received one with a size of \`${eo}\``
      }
      )
    }
    function getSize(J) {
      return J instanceof Map || J instanceof Set ? J.size : J.length
    }
    function max(J, et, eo = {}) {
      let { exclusive: el } = eo;
      return refine(J, "max", eo => el ? eo < et : eo <= et || `Expected a ${J.type} less than ${el ? "" : "or equal to "}${et} but received \`${eo}\``)
    }
    function min(J, et, eo = {}) {
      let { exclusive: el } = eo;
      return refine(J, "min", eo => el ? eo > et : eo >= et || `Expected a ${J.type} greater than ${el ? "" : "or equal to "}${et} but received \`${eo}\``)
    }
    function nonempty(J) {
      return refine(J, "nonempty", et => {
        let eo = getSize(et);
        return eo > 0 || `Expected a nonempty ${J.type} but received an empty one`
      }
      )
    }
    function pattern(J, et) {
      return refine(J, "pattern", eo => et.test(eo) || `Expected a ${J.type} matching \`/${et.source}/\` but received "${eo}"`)
    }
    function size(J, et, eo = et) {
      let el = `Expected a ${J.type}`
        , ec = et === eo ? `of \`${et}\`` : `between \`${et}\` and \`${eo}\``;
      return refine(J, "size", J => {
        if ("number" == typeof J || J instanceof Date)
          return et <= J && J <= eo || `${el} ${ec} but received \`${J}\``;
        if (J instanceof Map || J instanceof Set) {
          let { size: ed } = J;
          return et <= ed && ed <= eo || `${el} with a size ${ec} but received one with a size of \`${ed}\``
        }
        {
          let { length: ed } = J;
          return et <= ed && ed <= eo || `${el} with a length ${ec} but received one with a length of \`${ed}\``
        }
      }
      )
    }
    function refine(J, et, eo) {
      return new Struct({
        ...J,
        *refiner(el, ec) {
          yield* J.refiner(el, ec);
          let ed = eo(el, ec)
            , eh = toFailures(ed, ec, J, el);
          for (let J of eh)
            yield {
              ...J,
              refinement: et
            }
        }
      })
    }
  },
  17832: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      sj: function () {
        return proxy
      },
      iH: function () {
        return ref
      },
      CO: function () {
        return snapshot
      },
      Ld: function () {
        return subscribe
      }
    }),
      Symbol();
    let el = Symbol()
      , ec = Object.getPrototypeOf
      , ed = new WeakMap
      , l = J => J && (ed.has(J) ? ed.get(J) : ec(J) === Object.prototype || ec(J) === Array.prototype)
      , y = J => l(J) && J[el] || null
      , h = (J, et = !0) => {
        ed.set(J, et)
      }
      , isObject = J => "object" == typeof J && null !== J
      , eh = new WeakMap
      , ep = new WeakSet
      , buildProxyFunction = (J = Object.is, et = (J, et) => new Proxy(J, et), eo = J => isObject(J) && !ep.has(J) && (Array.isArray(J) || !(Symbol.iterator in J)) && !(J instanceof WeakMap) && !(J instanceof WeakSet) && !(J instanceof Error) && !(J instanceof Number) && !(J instanceof Date) && !(J instanceof String) && !(J instanceof RegExp) && !(J instanceof ArrayBuffer), el = J => {
        switch (J.status) {
          case "fulfilled":
            return J.value;
          case "rejected":
            throw J.reason;
          default:
            throw J
        }
      }
        , ec = new WeakMap, ed = (J, et, eo = el) => {
          let ef = ec.get(J);
          if ((null == ef ? void 0 : ef[0]) === et)
            return ef[1];
          let em = Array.isArray(J) ? [] : Object.create(Object.getPrototypeOf(J));
          return h(em, !0),
            ec.set(J, [et, em]),
            Reflect.ownKeys(J).forEach(et => {
              if (Object.getOwnPropertyDescriptor(em, et))
                return;
              let el = Reflect.get(J, et)
                , ec = {
                  value: el,
                  enumerable: !0,
                  configurable: !0
                };
              if (ep.has(el))
                h(el, !1);
              else if (el instanceof Promise)
                delete ec.value,
                  ec.get = () => eo(el);
              else if (eh.has(el)) {
                let [J, et] = eh.get(el);
                ec.value = ed(J, et(), eo)
              }
              Object.defineProperty(em, et, ec)
            }
            ),
            Object.preventExtensions(em)
        }
        , ef = new WeakMap, em = [1, 1], eg = el => {
          if (!isObject(el))
            throw Error("object required");
          let ec = ef.get(el);
          if (ec)
            return ec;
          let ey = em[0]
            , eb = new Set
            , notifyUpdate = (J, et = ++em[0]) => {
              ey !== et && (ey = et,
                eb.forEach(eo => eo(J, et)))
            }
            , ew = em[1]
            , ensureVersion = (J = ++em[1]) => (ew === J || eb.size || (ew = J,
              e_.forEach(([et]) => {
                let eo = et[1](J);
                eo > ey && (ey = eo)
              }
              )),
              ey)
            , createPropListener = J => (et, eo) => {
              let el = [...et];
              el[1] = [J, ...el[1]],
                notifyUpdate(el, eo)
            }
            , e_ = new Map
            , addPropListener = (J, et) => {
              if (e_.has(J))
                throw Error("prop listener already exists");
              if (eb.size) {
                let eo = et[3](createPropListener(J));
                e_.set(J, [et, eo])
              } else
                e_.set(J, [et])
            }
            , removePropListener = J => {
              var et;
              let eo = e_.get(J);
              eo && (e_.delete(J),
                null == (et = eo[1]) || et.call(eo))
            }
            , addListener = J => {
              eb.add(J),
                1 === eb.size && e_.forEach(([J, et], eo) => {
                  if (et)
                    throw Error("remove already exists");
                  let el = J[3](createPropListener(eo));
                  e_.set(eo, [J, el])
                }
                );
              let removeListener = () => {
                eb.delete(J),
                  0 === eb.size && e_.forEach(([J, et], eo) => {
                    et && (et(),
                      e_.set(eo, [J]))
                  }
                  )
              }
                ;
              return removeListener
            }
            , ex = Array.isArray(el) ? [] : Object.create(Object.getPrototypeOf(el))
            , eE = {
              deleteProperty(J, et) {
                let eo = Reflect.get(J, et);
                removePropListener(et);
                let el = Reflect.deleteProperty(J, et);
                return el && notifyUpdate(["delete", [et], eo]),
                  el
              },
              set(et, el, ec, ed) {
                let em = Reflect.has(et, el)
                  , ey = Reflect.get(et, el, ed);
                if (em && (J(ey, ec) || ef.has(ec) && J(ey, ef.get(ec))))
                  return !0;
                removePropListener(el),
                  isObject(ec) && (ec = y(ec) || ec);
                let eb = ec;
                if (ec instanceof Promise)
                  ec.then(J => {
                    ec.status = "fulfilled",
                      ec.value = J,
                      notifyUpdate(["resolve", [el], J])
                  }
                  ).catch(J => {
                    ec.status = "rejected",
                      ec.reason = J,
                      notifyUpdate(["reject", [el], J])
                  }
                  );
                else {
                  !eh.has(ec) && eo(ec) && (eb = eg(ec));
                  let J = !ep.has(eb) && eh.get(eb);
                  J && addPropListener(el, J)
                }
                return Reflect.set(et, el, eb, ed),
                  notifyUpdate(["set", [el], ec, ey]),
                  !0
              }
            }
            , eC = et(ex, eE);
          ef.set(el, eC);
          let eS = [ex, ensureVersion, ed, addListener];
          return eh.set(eC, eS),
            Reflect.ownKeys(el).forEach(J => {
              let et = Object.getOwnPropertyDescriptor(el, J);
              "value" in et && (eC[J] = el[J],
                delete et.value,
                delete et.writable),
                Object.defineProperty(ex, J, et)
            }
            ),
            eC
        }
      ) => [eg, eh, ep, J, et, eo, el, ec, ed, ef, em]
      , [ef] = buildProxyFunction();
    function proxy(J = {}) {
      return ef(J)
    }
    function subscribe(J, et, eo) {
      let el;
      let ec = eh.get(J);
      ec || console.warn("Please use proxy object");
      let ed = []
        , ep = ec[3]
        , ef = !1
        , em = ep(J => {
          if (ed.push(J),
            eo) {
            et(ed.splice(0));
            return
          }
          el || (el = Promise.resolve().then(() => {
            el = void 0,
              ef && et(ed.splice(0))
          }
          ))
        }
        );
      return ef = !0,
        () => {
          ef = !1,
            em()
        }
    }
    function snapshot(J, et) {
      let eo = eh.get(J);
      eo || console.warn("Please use proxy object");
      let [el, ec, ed] = eo;
      return ed(el, ec(), et)
    }
    function ref(J) {
      return ep.add(J),
        J
    }
  },
  14503: function (J, et, eo) {
    "use strict";
    function parseAccount(J) {
      return "string" == typeof J ? {
        address: J,
        type: "json-rpc"
      } : J
    }
    eo.d(et, {
      T: function () {
        return parseAccount
      }
    })
  },
  61376: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      R: function () {
        return call
      }
    });
    var el = eo(14503)
      , ec = eo(16693)
      , ed = eo(62027)
      , eh = eo(80377)
      , ep = eo(97405)
      , ef = eo(7210)
      , em = eo(77799)
      , eg = eo(47864)
      , ey = eo(92106)
      , eb = eo(26445)
      , ew = eo(87469)
      , e_ = eo(61163)
      , ex = eo(74688)
      , eE = eo(32357)
      , eC = eo(47531);
    async function call(J, et) {
      let { account: ec = J.account, batch: ef = !!J.batch?.multicall, blockNumber: em, blockTag: eg = "latest", accessList: eE, data: eS, gas: ek, gasPrice: eT, maxFeePerGas: eA, maxPriorityFeePerGas: eP, nonce: eR, to: eI, value: eO, ...eN } = et
        , eM = ec ? (0,
          el.T)(ec) : void 0;
      try {
        (0,
          eC.F)(et);
        let eo = em ? (0,
          ey.eC)(em) : void 0
          , el = eo || eg
          , ec = J.chain?.formatters?.transactionRequest?.format
          , ed = ec || ex.tG
          , ep = ed({
            ...(0,
              e_.K)(eN, {
                format: ec
              }),
            from: eM?.address,
            accessList: eE,
            data: eS,
            gas: ek,
            gasPrice: eT,
            maxFeePerGas: eA,
            maxPriorityFeePerGas: eP,
            nonce: eR,
            to: eI,
            value: eO
          });
        if (ef && function ({ request: J }) {
          let { data: et, to: eo, ...el } = J;
          return !(!et || et.startsWith("0x82ad56cb")) && !!eo && !(Object.values(el).filter(J => void 0 !== J).length > 0)
        }({
          request: ep
        }))
          try {
            return await scheduleMulticall(J, {
              ...ep,
              blockNumber: em,
              blockTag: eg
            })
          } catch (J) {
            if (!(J instanceof eh.pZ) && !(J instanceof eh.mm))
              throw J
          }
        let eb = await J.request({
          method: "eth_call",
          params: el ? [ep, el] : [ep]
        });
        if ("0x" === eb)
          return {
            data: void 0
          };
        return {
          data: eb
        }
      } catch (ef) {
        let el = function (J) {
          if (!(J instanceof ed.G))
            return;
          let et = J.walk();
          return "object" == typeof et.data ? et.data.data : et.data
        }(ef)
          , { offchainLookup: ec, offchainLookupSignature: eh } = await eo.e(422).then(eo.bind(eo, 10422));
        if (el?.slice(0, 10) === eh && eI)
          return {
            data: await ec(J, {
              data: el,
              to: eI
            })
          };
        throw function (J, { docsPath: et, ...eo }) {
          let el = (() => {
            let et = (0,
              ew.k)(J, eo);
            return et instanceof eb.cj ? J : et
          }
          )();
          return new ep.cg(el, {
            docsPath: et,
            ...eo
          })
        }(ef, {
          ...et,
          account: eM,
          chain: J.chain
        })
      }
    }
    async function scheduleMulticall(J, et) {
      let { batchSize: eo = 1024, wait: el = 0 } = "object" == typeof J.batch?.multicall ? J.batch.multicall : {}
        , { blockNumber: ed, blockTag: eb = "latest", data: ew, multicallAddress: e_, to: ex } = et
        , eC = e_;
      if (!eC) {
        if (!J.chain)
          throw new eh.pZ;
        eC = (0,
          eg.L)({
            blockNumber: ed,
            chain: J.chain,
            contract: "multicall3"
          })
      }
      let eS = ed ? (0,
        ey.eC)(ed) : void 0
        , ek = eS || eb
        , { schedule: eT } = (0,
          eE.S)({
            id: `${J.uid}.${ek}`,
            wait: el,
            shouldSplitBatch(J) {
              let et = J.reduce((J, { data: et }) => J + (et.length - 2), 0);
              return et > 2 * eo
            },
            fn: async et => {
              let eo = et.map(J => ({
                allowFailure: !0,
                callData: J.data,
                target: J.to
              }))
                , el = (0,
                  em.R)({
                    abi: ec.F8,
                    args: [eo],
                    functionName: "aggregate3"
                  })
                , ed = await J.request({
                  method: "eth_call",
                  params: [{
                    data: el,
                    to: eC
                  }, ek]
                });
              return (0,
                ef.k)({
                  abi: ec.F8,
                  args: [eo],
                  functionName: "aggregate3",
                  data: ed || "0x"
                })
            }
          })
        , [{ returnData: eA, success: eP }] = await eT({
          data: ew,
          to: ex
        });
      if (!eP)
        throw new ep.VQ({
          data: eA
        });
      return "0x" === eA ? {
        data: void 0
      } : {
        data: eA
      }
    }
  },
  88930: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      s: function () {
        return getBalance
      }
    });
    var el = eo(92106);
    async function getBalance(J, { address: et, blockNumber: eo, blockTag: ec = "latest" }) {
      let ed = eo ? (0,
        el.eC)(eo) : void 0
        , eh = await J.request({
          method: "eth_getBalance",
          params: [et, ed || ec]
        });
      return BigInt(eh)
    }
  },
  9884: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      A: function () {
        return multicall
      }
    });
    var el = eo(16693)
      , ec = eo(57412)
      , ed = eo(62027)
      , eh = eo(97405)
      , ep = eo(7210)
      , ef = eo(77799)
      , em = eo(47864)
      , eg = eo(72365)
      , ey = eo(93714)
      , eb = eo(88819);
    async function multicall(J, et) {
      let { allowFailure: eo = !0, batchSize: ew, blockNumber: e_, blockTag: ex, multicallAddress: eE } = et
        , eC = et.contracts
        , eS = ew ?? ("object" == typeof J.batch?.multicall && J.batch.multicall.batchSize || 1024)
        , ek = eE;
      if (!ek) {
        if (!J.chain)
          throw Error("client chain not configured. multicallAddress is required.");
        ek = (0,
          em.L)({
            blockNumber: e_,
            chain: J.chain,
            contract: "multicall3"
          })
      }
      let eT = [[]]
        , eA = 0
        , eP = 0;
      for (let J = 0; J < eC.length; J++) {
        let { abi: et, address: el, args: ec, functionName: ed } = eC[J];
        try {
          let J = (0,
            ef.R)({
              abi: et,
              args: ec,
              functionName: ed
            });
          eP += (J.length - 2) / 2,
            eS > 0 && eP > eS && eT[eA].length > 0 && (eA++,
              eP = (J.length - 2) / 2,
              eT[eA] = []),
            eT[eA] = [...eT[eA], {
              allowFailure: !0,
              callData: J,
              target: el
            }]
        } catch (eh) {
          let J = (0,
            eg.S)(eh, {
              abi: et,
              address: el,
              args: ec,
              docsPath: "/docs/contract/multicall",
              functionName: ed
            });
          if (!eo)
            throw J;
          eT[eA] = [...eT[eA], {
            allowFailure: !0,
            callData: "0x",
            target: el
          }]
        }
      }
      let eR = await Promise.allSettled(eT.map(et => (0,
        ey.s)(J, eb.L, "readContract")({
          abi: el.F8,
          address: ek,
          args: [et],
          blockNumber: e_,
          blockTag: ex,
          functionName: "aggregate3"
        })))
        , eI = [];
      for (let J = 0; J < eR.length; J++) {
        let et = eR[J];
        if ("rejected" === et.status) {
          if (!eo)
            throw et.reason;
          for (let eo = 0; eo < eT[J].length; eo++)
            eI.push({
              status: "failure",
              error: et.reason,
              result: void 0
            });
          continue
        }
        let el = et.value;
        for (let et = 0; et < el.length; et++) {
          let { returnData: ed, success: ef } = el[et]
            , { callData: em } = eT[J][et]
            , { abi: ey, address: eb, functionName: ew, args: e_ } = eC[eI.length];
          try {
            if ("0x" === em)
              throw new ec.wb;
            if (!ef)
              throw new eh.VQ({
                data: ed
              });
            let J = (0,
              ep.k)({
                abi: ey,
                args: e_,
                data: ed,
                functionName: ew
              });
            eI.push(eo ? {
              result: J,
              status: "success"
            } : J)
          } catch (et) {
            let J = (0,
              eg.S)(et, {
                abi: ey,
                address: eb,
                args: e_,
                docsPath: "/docs/contract/multicall",
                functionName: ew
              });
            if (!eo)
              throw J;
            eI.push({
              error: J,
              result: void 0,
              status: "failure"
            })
          }
        }
      }
      if (eI.length !== eC.length)
        throw new ed.G("multicall results mismatch");
      return eI
    }
  },
  88819: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      L: function () {
        return readContract
      }
    });
    var el = eo(7210)
      , ec = eo(77799)
      , ed = eo(72365)
      , eh = eo(93714)
      , ep = eo(61376);
    async function readContract(J, et) {
      let { abi: eo, address: ef, args: em, functionName: eg, ...ey } = et
        , eb = (0,
          ec.R)({
            abi: eo,
            args: em,
            functionName: eg
          });
      try {
        let { data: et } = await (0,
          eh.s)(J, ep.R, "call")({
            ...ey,
            data: eb,
            to: ef
          });
        return (0,
          el.k)({
            abi: eo,
            args: em,
            functionName: eg,
            data: et || "0x"
          })
      } catch (J) {
        throw (0,
          ed.S)(J, {
            abi: eo,
            address: ef,
            args: em,
            docsPath: "/docs/contract/readContract",
            functionName: eg
          })
      }
    }
  },
  16189: function (J, et, eo) {
    "use strict";
    let el;
    eo.d(et, {
      e: function () {
        return createClient
      }
    });
    var ec = eo(14503);
    let ed = 256;
    function createClient(J) {
      let { batch: et, cacheTime: eo = J.pollingInterval ?? 4e3, key: eh = "base", name: ep = "Base Client", pollingInterval: ef = 4e3, type: em = "base" } = J
        , eg = J.chain
        , ey = J.account ? (0,
          ec.T)(J.account) : void 0
        , { config: eb, request: ew, value: e_ } = J.transport({
          chain: eg,
          pollingInterval: ef
        })
        , ex = {
          ...eb,
          ...e_
        }
        , eE = {
          account: ey,
          batch: et,
          cacheTime: eo,
          chain: eg,
          key: eh,
          name: ep,
          pollingInterval: ef,
          request: ew,
          transport: ex,
          type: em,
          uid: function (J = 11) {
            if (!el || ed + J > 512) {
              el = "",
                ed = 0;
              for (let J = 0; J < 256; J++)
                el += (256 + 256 * Math.random() | 0).toString(16).substring(1)
            }
            return el.substring(ed, ed++ + J)
          }()
        };
      return Object.assign(eE, {
        extend: function extend(J) {
          return et => {
            let eo = et(J);
            for (let J in eE)
              delete eo[J];
            let el = {
              ...J,
              ...eo
            };
            return Object.assign(el, {
              extend: extend(el)
            })
          }
        }(eE)
      })
    }
  },
  91628: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      q: function () {
        return createTransport
      }
    });
    var el = eo(62027)
      , ec = eo(78863)
      , ed = eo(39028)
      , eh = eo(7760);
    function createTransport({ key: J, name: et, request: eo, retryCount: ep = 3, retryDelay: ef = 150, timeout: em, type: eg }, ey) {
      return {
        config: {
          key: J,
          name: et,
          request: eo,
          retryCount: ep,
          retryDelay: ef,
          timeout: em,
          type: eg
        },
        request: function (J, et = {}) {
          return async (eo, ep = {}) => {
            let { retryDelay: ef = 150, retryCount: em = 3 } = {
              ...et,
              ...ep
            };
            return (0,
              eh.J)(async () => {
                try {
                  return await J(eo)
                } catch (J) {
                  switch (J.code) {
                    case ed.s7.code:
                      throw new ed.s7(J);
                    case ed.B.code:
                      throw new ed.B(J);
                    case ed.LX.code:
                      throw new ed.LX(J);
                    case ed.nY.code:
                      throw new ed.nY(J);
                    case ed.XS.code:
                      throw new ed.XS(J);
                    case ed.yR.code:
                      throw new ed.yR(J);
                    case ed.Og.code:
                      throw new ed.Og(J);
                    case ed.pT.code:
                      throw new ed.pT(J);
                    case ed.KB.code:
                      throw new ed.KB(J);
                    case ed.gS.code:
                      throw new ed.gS(J);
                    case ed.Pv.code:
                      throw new ed.Pv(J);
                    case ed.GD.code:
                      throw new ed.GD(J);
                    case ed.ab.code:
                      throw new ed.ab(J);
                    case ed.PE.code:
                      throw new ed.PE(J);
                    case ed.Ts.code:
                      throw new ed.Ts(J);
                    case ed.u5.code:
                      throw new ed.u5(J);
                    case ed.I0.code:
                      throw new ed.I0(J);
                    case ed.x3.code:
                      throw new ed.x3(J);
                    case 5e3:
                      throw new ed.ab(J);
                    default:
                      if (J instanceof el.G)
                        throw J;
                      throw new ed.ir(J)
                  }
                }
              }
                , {
                  delay: ({ count: J, error: et }) => {
                    if (et && et instanceof ec.Gg) {
                      let J = et?.headers?.get("Retry-After");
                      if (J?.match(/\d/))
                        return 1e3 * parseInt(J)
                    }
                    return ~~(1 << J) * ef
                  }
                  ,
                  retryCount: em,
                  shouldRetry: ({ error: J }) => "code" in J && "number" == typeof J.code ? -1 === J.code || J.code === ed.Pv.code || J.code === ed.XS.code : !(J instanceof ec.Gg) || !J.status || 403 === J.status || 408 === J.status || 413 === J.status || 429 === J.status || 500 === J.status || 502 === J.status || 503 === J.status || 504 === J.status
                })
          }
        }(eo, {
          retryCount: ep,
          retryDelay: ef
        }),
        value: ey
      }
    }
  },
  3980: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      P: function () {
        return custom
      }
    });
    var el = eo(91628);
    function custom(J, et = {}) {
      let { key: eo = "custom", name: ec = "Custom Provider", retryDelay: ed } = et;
      return ({ retryCount: eh }) => (0,
        el.q)({
          key: eo,
          name: ec,
          request: J.request.bind(J),
          retryCount: et.retryCount ?? eh,
          retryDelay: ed,
          type: "custom"
        })
    }
  },
  16693: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      F8: function () {
        return el
      },
      du: function () {
        return eh
      },
      k3: function () {
        return ed
      },
      nZ: function () {
        return ep
      }
    });
    let el = [{
      inputs: [{
        components: [{
          name: "target",
          type: "address"
        }, {
          name: "allowFailure",
          type: "bool"
        }, {
          name: "callData",
          type: "bytes"
        }],
        name: "calls",
        type: "tuple[]"
      }],
      name: "aggregate3",
      outputs: [{
        components: [{
          name: "success",
          type: "bool"
        }, {
          name: "returnData",
          type: "bytes"
        }],
        name: "returnData",
        type: "tuple[]"
      }],
      stateMutability: "view",
      type: "function"
    }]
      , ec = [{
        inputs: [],
        name: "ResolverNotFound",
        type: "error"
      }, {
        inputs: [],
        name: "ResolverWildcardNotSupported",
        type: "error"
      }, {
        inputs: [],
        name: "ResolverNotContract",
        type: "error"
      }, {
        inputs: [{
          name: "returnData",
          type: "bytes"
        }],
        name: "ResolverError",
        type: "error"
      }, {
        inputs: [{
          components: [{
            name: "status",
            type: "uint16"
          }, {
            name: "message",
            type: "string"
          }],
          name: "errors",
          type: "tuple[]"
        }],
        name: "HttpError",
        type: "error"
      }]
      , ed = [...ec, {
        name: "resolve",
        type: "function",
        stateMutability: "view",
        inputs: [{
          name: "name",
          type: "bytes"
        }, {
          name: "data",
          type: "bytes"
        }],
        outputs: [{
          name: "",
          type: "bytes"
        }, {
          name: "address",
          type: "address"
        }]
      }, {
        name: "resolve",
        type: "function",
        stateMutability: "view",
        inputs: [{
          name: "name",
          type: "bytes"
        }, {
          name: "data",
          type: "bytes"
        }, {
          name: "gateways",
          type: "string[]"
        }],
        outputs: [{
          name: "",
          type: "bytes"
        }, {
          name: "address",
          type: "address"
        }]
      }]
      , eh = [...ec, {
        name: "reverse",
        type: "function",
        stateMutability: "view",
        inputs: [{
          type: "bytes",
          name: "reverseName"
        }],
        outputs: [{
          type: "string",
          name: "resolvedName"
        }, {
          type: "address",
          name: "resolvedAddress"
        }, {
          type: "address",
          name: "reverseResolver"
        }, {
          type: "address",
          name: "resolver"
        }]
      }, {
        name: "reverse",
        type: "function",
        stateMutability: "view",
        inputs: [{
          type: "bytes",
          name: "reverseName"
        }, {
          type: "string[]",
          name: "gateways"
        }],
        outputs: [{
          type: "string",
          name: "resolvedName"
        }, {
          type: "address",
          name: "resolvedAddress"
        }, {
          type: "address",
          name: "reverseResolver"
        }, {
          type: "address",
          name: "resolver"
        }]
      }]
      , ep = [{
        name: "text",
        type: "function",
        stateMutability: "view",
        inputs: [{
          name: "name",
          type: "bytes32"
        }, {
          name: "key",
          type: "string"
        }],
        outputs: [{
          name: "",
          type: "string"
        }]
      }]
  },
  21746: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      $: function () {
        return el
      },
      Up: function () {
        return ec
      },
      hZ: function () {
        return ed
      }
    });
    let el = {
      1: "An `assert` condition failed.",
      17: "Arithmic operation resulted in underflow or overflow.",
      18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
      33: "Attempted to convert to an invalid type.",
      34: "Attempted to access a storage byte array that is incorrectly encoded.",
      49: "Performed `.pop()` on an empty array",
      50: "Array index is out of bounds.",
      65: "Allocated too much memory or created an array which is too large.",
      81: "Attempted to call a zero-initialized variable of internal function type."
    }
      , ec = {
        inputs: [{
          name: "message",
          type: "string"
        }],
        name: "Error",
        type: "error"
      }
      , ed = {
        inputs: [{
          name: "reason",
          type: "uint256"
        }],
        name: "Panic",
        type: "error"
      }
  },
  84192: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      Bd: function () {
        return ed
      },
      Zn: function () {
        return ec
      },
      ez: function () {
        return el
      }
    });
    let el = {
      gwei: 9,
      wei: 18
    }
      , ec = {
        ether: -9,
        wei: 9
      }
      , ed = {
        ether: -18,
        gwei: -9
      }
  },
  57412: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      CI: function () {
        return InvalidAbiDecodingTypeError
      },
      M4: function () {
        return AbiEncodingBytesSizeMismatchError
      },
      MX: function () {
        return AbiFunctionOutputsNotFoundError
      },
      S4: function () {
        return AbiItemAmbiguityError
      },
      dh: function () {
        return InvalidAbiEncodingTypeError
      },
      fs: function () {
        return AbiEncodingLengthMismatchError
      },
      gr: function () {
        return AbiEncodingArrayLengthMismatchError
      },
      hn: function () {
        return InvalidArrayError
      },
      wM: function () {
        return InvalidDefinitionTypeError
      },
      wb: function () {
        return AbiDecodingZeroDataError
      },
      xB: function () {
        return AbiDecodingDataSizeTooSmallError
      },
      xL: function () {
        return AbiFunctionNotFoundError
      },
      yP: function () {
        return AbiErrorSignatureNotFoundError
      }
    });
    var el = eo(80522)
      , ec = eo(39135)
      , ed = eo(62027);
    let AbiDecodingDataSizeTooSmallError = class AbiDecodingDataSizeTooSmallError extends ed.G {
      constructor({ data: J, params: et, size: eo }) {
        super(`Data size of ${eo} bytes is too small for given parameters.`, {
          metaMessages: [`Params: (${(0,
            el.h)(et, {
              includeName: !0
            })})`, `Data:   ${J} (${eo} bytes)`]
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiDecodingDataSizeTooSmallError"
          }),
          Object.defineProperty(this, "data", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          Object.defineProperty(this, "params", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          Object.defineProperty(this, "size", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          this.data = J,
          this.params = et,
          this.size = eo
      }
    }
      ;
    let AbiDecodingZeroDataError = class AbiDecodingZeroDataError extends ed.G {
      constructor() {
        super('Cannot decode zero data ("0x") with ABI parameters.'),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiDecodingZeroDataError"
          })
      }
    }
      ;
    let AbiEncodingArrayLengthMismatchError = class AbiEncodingArrayLengthMismatchError extends ed.G {
      constructor({ expectedLength: J, givenLength: et, type: eo }) {
        super(`ABI encoding array length mismatch for type ${eo}.
Expected length: ${J}
Given length: ${et}`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiEncodingArrayLengthMismatchError"
          })
      }
    }
      ;
    let AbiEncodingBytesSizeMismatchError = class AbiEncodingBytesSizeMismatchError extends ed.G {
      constructor({ expectedSize: J, value: et }) {
        super(`Size of bytes "${et}" (bytes${(0,
          ec.d)(et)}) does not match expected size (bytes${J}).`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiEncodingBytesSizeMismatchError"
          })
      }
    }
      ;
    let AbiEncodingLengthMismatchError = class AbiEncodingLengthMismatchError extends ed.G {
      constructor({ expectedLength: J, givenLength: et }) {
        super(`ABI encoding params/values length mismatch.
Expected length (params): ${J}
Given length (values): ${et}`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiEncodingLengthMismatchError"
          })
      }
    }
      ;
    let AbiErrorSignatureNotFoundError = class AbiErrorSignatureNotFoundError extends ed.G {
      constructor(J, { docsPath: et }) {
        super(`Encoded error signature "${J}" not found on ABI.
Make sure you are using the correct ABI and that the error exists on it.
You can look up the decoded signature here: https://openchain.xyz/signatures?query=${J}.`, {
          docsPath: et
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiErrorSignatureNotFoundError"
          }),
          Object.defineProperty(this, "signature", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          this.signature = J
      }
    }
      ;
    let AbiFunctionNotFoundError = class AbiFunctionNotFoundError extends ed.G {
      constructor(J, { docsPath: et } = {}) {
        super(`Function ${J ? `"${J}" ` : ""}not found on ABI.
Make sure you are using the correct ABI and that the function exists on it.`, {
          docsPath: et
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiFunctionNotFoundError"
          })
      }
    }
      ;
    let AbiFunctionOutputsNotFoundError = class AbiFunctionOutputsNotFoundError extends ed.G {
      constructor(J, { docsPath: et }) {
        super(`Function "${J}" does not contain any \`outputs\` on ABI.
Cannot decode function result without knowing what the parameter types are.
Make sure you are using the correct ABI and that the function exists on it.`, {
          docsPath: et
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiFunctionOutputsNotFoundError"
          })
      }
    }
      ;
    let AbiItemAmbiguityError = class AbiItemAmbiguityError extends ed.G {
      constructor(J, et) {
        super("Found ambiguous types in overloaded ABI items.", {
          metaMessages: [`\`${J.type}\` in \`${(0,
            el.t)(J.abiItem)}\`, and`, `\`${et.type}\` in \`${(0,
              el.t)(et.abiItem)}\``, "", "These types encode differently and cannot be distinguished at runtime.", "Remove one of the ambiguous items in the ABI."]
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiItemAmbiguityError"
          })
      }
    }
      ;
    let InvalidAbiEncodingTypeError = class InvalidAbiEncodingTypeError extends ed.G {
      constructor(J, { docsPath: et }) {
        super(`Type "${J}" is not a valid encoding type.
Please provide a valid ABI type.`, {
          docsPath: et
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidAbiEncodingType"
          })
      }
    }
      ;
    let InvalidAbiDecodingTypeError = class InvalidAbiDecodingTypeError extends ed.G {
      constructor(J, { docsPath: et }) {
        super(`Type "${J}" is not a valid decoding type.
Please provide a valid ABI type.`, {
          docsPath: et
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidAbiDecodingType"
          })
      }
    }
      ;
    let InvalidArrayError = class InvalidArrayError extends ed.G {
      constructor(J) {
        super(`Value "${J}" is not a valid array.`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidArrayError"
          })
      }
    }
      ;
    let InvalidDefinitionTypeError = class InvalidDefinitionTypeError extends ed.G {
      constructor(J) {
        super(`"${J}" is not a valid definition type.
Valid types: "function", "event", "error"`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidDefinitionTypeError"
          })
      }
    }
  },
  8998: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      o: function () {
        return AccountNotFoundError
      }
    });
    var el = eo(62027);
    let AccountNotFoundError = class AccountNotFoundError extends el.G {
      constructor({ docsPath: J } = {}) {
        super("Could not find an Account to execute with this Action.\nPlease provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient.", {
          docsPath: J,
          docsSlug: "account"
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AccountNotFoundError"
          })
      }
    }
  },
  26087: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      b: function () {
        return InvalidAddressError
      }
    });
    var el = eo(62027);
    let InvalidAddressError = class InvalidAddressError extends el.G {
      constructor({ address: J }) {
        super(`Address "${J}" is invalid.`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidAddressError"
          })
      }
    }
  },
  62027: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      G: function () {
        return BaseError
      }
    });
    var el = eo(35280);
    let BaseError = class BaseError extends Error {
      constructor(J, et = {}) {
        super(),
          Object.defineProperty(this, "details", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          Object.defineProperty(this, "docsPath", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          Object.defineProperty(this, "metaMessages", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          Object.defineProperty(this, "shortMessage", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ViemError"
          }),
          Object.defineProperty(this, "version", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: (0,
              el.bo)()
          });
        let eo = et.cause instanceof BaseError ? et.cause.details : et.cause?.message ? et.cause.message : et.details
          , ec = et.cause instanceof BaseError && et.cause.docsPath || et.docsPath;
        this.message = [J || "An error occurred.", "", ...et.metaMessages ? [...et.metaMessages, ""] : [], ...ec ? [`Docs: https://viem.sh${ec}${et.docsSlug ? `#${et.docsSlug}` : ""}`] : [], ...eo ? [`Details: ${eo}`] : [], `Version: ${this.version}`].join("\n"),
          et.cause && (this.cause = et.cause),
          this.details = eo,
          this.docsPath = ec,
          this.metaMessages = et.metaMessages,
          this.shortMessage = J
      }
      walk(J) {
        return function walk(J, et) {
          return et?.(J) ? J : J && "object" == typeof J && "cause" in J ? walk(J.cause, et) : et ? null : J
        }(this, J)
      }
    }
  },
  80377: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      Bk: function () {
        return ChainNotFoundError
      },
      Yl: function () {
        return ChainMismatchError
      },
      mm: function () {
        return ChainDoesNotSupportContract
      },
      pZ: function () {
        return ClientChainNotConfiguredError
      }
    });
    var el = eo(62027);
    let ChainDoesNotSupportContract = class ChainDoesNotSupportContract extends el.G {
      constructor({ blockNumber: J, chain: et, contract: eo }) {
        super(`Chain "${et.name}" does not support contract "${eo.name}".`, {
          metaMessages: ["This could be due to any of the following:", ...J && eo.blockCreated && eo.blockCreated > J ? [`- The contract "${eo.name}" was not deployed until block ${eo.blockCreated} (current block ${J}).`] : [`- The chain does not have the contract "${eo.name}" configured.`]]
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ChainDoesNotSupportContract"
          })
      }
    }
      ;
    let ChainMismatchError = class ChainMismatchError extends el.G {
      constructor({ chain: J, currentChainId: et }) {
        super(`The current chain of the wallet (id: ${et}) does not match the target chain for the transaction (id: ${J.id} – ${J.name}).`, {
          metaMessages: [`Current Chain ID:  ${et}`, `Expected Chain ID: ${J.id} – ${J.name}`]
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ChainMismatchError"
          })
      }
    }
      ;
    let ChainNotFoundError = class ChainNotFoundError extends el.G {
      constructor() {
        super("No chain was provided to the request.\nPlease provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ChainNotFoundError"
          })
      }
    }
      ;
    let ClientChainNotConfiguredError = class ClientChainNotConfiguredError extends el.G {
      constructor() {
        super("No chain was provided to the Client."),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ClientChainNotConfiguredError"
          })
      }
    }
  },
  97405: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      cg: function () {
        return CallExecutionError
      },
      uq: function () {
        return ContractFunctionExecutionError
      },
      Lu: function () {
        return ContractFunctionRevertedError
      },
      Dk: function () {
        return ContractFunctionZeroDataError
      },
      VQ: function () {
        return RawContractError
      }
    });
    var el = eo(14503)
      , ec = eo(21746)
      , ed = eo(86899)
      , eh = eo(80522)
      , ep = eo(96070);
    function formatAbiItemWithArgs({ abiItem: J, args: et, includeFunctionName: eo = !0, includeName: el = !1 }) {
      if ("name" in J && "inputs" in J && J.inputs)
        return `${eo ? J.name : ""}(${J.inputs.map((J, eo) => `${el && J.name ? `${J.name}: ` : ""}${"object" == typeof et[eo] ? (0,
          ep.P)(et[eo]) : et[eo]}`).join(", ")})`
    }
    var ef = eo(3640)
      , em = eo(39625)
      , eg = eo(67795)
      , ey = eo(57412)
      , eb = eo(62027)
      , ew = eo(33639)
      , e_ = eo(35280);
    let CallExecutionError = class CallExecutionError extends eb.G {
      constructor(J, { account: et, docsPath: eo, chain: ec, data: ed, gas: eh, gasPrice: ep, maxFeePerGas: ef, maxPriorityFeePerGas: ey, nonce: eb, to: e_, value: ex }) {
        let eE = et ? (0,
          el.T)(et) : void 0
          , eC = (0,
            ew.xr)({
              from: eE?.address,
              to: e_,
              value: void 0 !== ex && `${(0,
                em.d)(ex)} ${ec?.nativeCurrency?.symbol || "ETH"}`,
              data: ed,
              gas: eh,
              gasPrice: void 0 !== ep && `${(0,
                eg.o)(ep)} gwei`,
              maxFeePerGas: void 0 !== ef && `${(0,
                eg.o)(ef)} gwei`,
              maxPriorityFeePerGas: void 0 !== ey && `${(0,
                eg.o)(ey)} gwei`,
              nonce: eb
            });
        super(J.shortMessage, {
          cause: J,
          docsPath: eo,
          metaMessages: [...J.metaMessages ? [...J.metaMessages, " "] : [], "Raw Call Arguments:", eC].filter(Boolean)
        }),
          Object.defineProperty(this, "cause", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "CallExecutionError"
          }),
          this.cause = J
      }
    }
      ;
    let ContractFunctionExecutionError = class ContractFunctionExecutionError extends eb.G {
      constructor(J, { abi: et, args: eo, contractAddress: el, docsPath: ec, functionName: ed, sender: ep }) {
        let em = (0,
          ef.mE)({
            abi: et,
            args: eo,
            name: ed
          })
          , eg = em ? formatAbiItemWithArgs({
            abiItem: em,
            args: eo,
            includeFunctionName: !1,
            includeName: !1
          }) : void 0
          , ey = em ? (0,
            eh.t)(em, {
              includeName: !0
            }) : void 0
          , eb = (0,
            ew.xr)({
              address: el && (0,
                e_.CR)(el),
              function: ey,
              args: eg && "()" !== eg && `${[...Array(ed?.length ?? 0).keys()].map(() => " ").join("")}${eg}`,
              sender: ep
            });
        super(J.shortMessage || `An unknown error occurred while executing the contract function "${ed}".`, {
          cause: J,
          docsPath: ec,
          metaMessages: [...J.metaMessages ? [...J.metaMessages, " "] : [], "Contract Call:", eb].filter(Boolean)
        }),
          Object.defineProperty(this, "abi", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          Object.defineProperty(this, "args", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          Object.defineProperty(this, "cause", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          Object.defineProperty(this, "contractAddress", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          Object.defineProperty(this, "formattedArgs", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          Object.defineProperty(this, "functionName", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          Object.defineProperty(this, "sender", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ContractFunctionExecutionError"
          }),
          this.abi = et,
          this.args = eo,
          this.cause = J,
          this.contractAddress = el,
          this.functionName = ed,
          this.sender = ep
      }
    }
      ;
    let ContractFunctionRevertedError = class ContractFunctionRevertedError extends eb.G {
      constructor({ abi: J, data: et, functionName: eo, message: el }) {
        let ep, ef, em, eg, eb;
        if (et && "0x" !== et)
          try {
            eb = (0,
              ed.p)({
                abi: J,
                data: et
              });
            let { abiItem: eo, errorName: el, args: ep } = eb;
            if ("Error" === el)
              em = ep[0];
            else if ("Panic" === el) {
              let [J] = ep;
              em = ec.$[J]
            } else {
              let J = eo ? (0,
                eh.t)(eo, {
                  includeName: !0
                }) : void 0
                , et = eo && ep ? formatAbiItemWithArgs({
                  abiItem: eo,
                  args: ep,
                  includeFunctionName: !1,
                  includeName: !1
                }) : void 0;
              ef = [J ? `Error: ${J}` : "", et && "()" !== et ? `       ${[...Array(el?.length ?? 0).keys()].map(() => " ").join("")}${et}` : ""]
            }
          } catch (J) {
            ep = J
          }
        else
          el && (em = el);
        ep instanceof ey.yP && (eg = ep.signature,
          ef = [`Unable to decode signature "${eg}" as it was not found on the provided ABI.`, "Make sure you are using the correct ABI and that the error exists on it.", `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${eg}.`]),
          super(em && "execution reverted" !== em || eg ? [`The contract function "${eo}" reverted with the following ${eg ? "signature" : "reason"}:`, em || eg].join("\n") : `The contract function "${eo}" reverted.`, {
            cause: ep,
            metaMessages: ef
          }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ContractFunctionRevertedError"
          }),
          Object.defineProperty(this, "data", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          Object.defineProperty(this, "reason", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          Object.defineProperty(this, "signature", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          this.data = eb,
          this.reason = em,
          this.signature = eg
      }
    }
      ;
    let ContractFunctionZeroDataError = class ContractFunctionZeroDataError extends eb.G {
      constructor({ functionName: J }) {
        super(`The contract function "${J}" returned no data ("0x").`, {
          metaMessages: ["This could be due to any of the following:", `  - The contract does not have the function "${J}",`, "  - The parameters passed to the contract function may be invalid, or", "  - The address is not a contract."]
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ContractFunctionZeroDataError"
          })
      }
    }
      ;
    let RawContractError = class RawContractError extends eb.G {
      constructor({ data: J, message: et }) {
        super(et || ""),
          Object.defineProperty(this, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: 3
          }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "RawContractError"
          }),
          Object.defineProperty(this, "data", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          this.data = J
      }
    }
  },
  69760: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      $: function () {
        return SizeExceedsPaddingSizeError
      },
      m: function () {
        return SliceOffsetOutOfBoundsError
      }
    });
    var el = eo(62027);
    let SliceOffsetOutOfBoundsError = class SliceOffsetOutOfBoundsError extends el.G {
      constructor({ offset: J, position: et, size: eo }) {
        super(`Slice ${"start" === et ? "starting" : "ending"} at offset "${J}" is out-of-bounds (size: ${eo}).`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "SliceOffsetOutOfBoundsError"
          })
      }
    }
      ;
    let SizeExceedsPaddingSizeError = class SizeExceedsPaddingSizeError extends el.G {
      constructor({ size: J, targetSize: et, type: eo }) {
        super(`${eo.charAt(0).toUpperCase()}${eo.slice(1).toLowerCase()} size (${J}) exceeds padding size (${et}).`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "SizeExceedsPaddingSizeError"
          })
      }
    }
  },
  87788: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      J5: function () {
        return IntegerOutOfRangeError
      },
      M6: function () {
        return SizeOverflowError
      },
      yr: function () {
        return InvalidBytesBooleanError
      }
    });
    var el = eo(62027);
    let IntegerOutOfRangeError = class IntegerOutOfRangeError extends el.G {
      constructor({ max: J, min: et, signed: eo, size: el, value: ec }) {
        super(`Number "${ec}" is not in safe ${el ? `${8 * el}-bit ${eo ? "signed" : "unsigned"} ` : ""}integer range ${J ? `(${et} to ${J})` : `(above ${et})`}`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "IntegerOutOfRangeError"
          })
      }
    }
      ;
    let InvalidBytesBooleanError = class InvalidBytesBooleanError extends el.G {
      constructor(J) {
        super(`Bytes value "${J}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidBytesBooleanError"
          })
      }
    }
      ;
    let SizeOverflowError = class SizeOverflowError extends el.G {
      constructor({ givenSize: J, maxSize: et }) {
        super(`Size cannot exceed ${et} bytes. Given size: ${J} bytes.`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "SizeOverflowError"
          })
      }
    }
  },
  26445: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      C_: function () {
        return InsufficientFundsError
      },
      G$: function () {
        return FeeCapTooLowError
      },
      Hh: function () {
        return FeeCapTooHighError
      },
      M_: function () {
        return ExecutionRevertedError
      },
      WF: function () {
        return IntrinsicGasTooHighError
      },
      ZI: function () {
        return NonceTooHighError
      },
      cj: function () {
        return UnknownNodeError
      },
      cs: function () {
        return TipAboveFeeCapError
      },
      dR: function () {
        return IntrinsicGasTooLowError
      },
      pZ: function () {
        return TransactionTypeNotSupportedError
      },
      se: function () {
        return NonceMaxValueError
      },
      vU: function () {
        return NonceTooLowError
      }
    });
    var el = eo(67795)
      , ec = eo(62027);
    let ExecutionRevertedError = class ExecutionRevertedError extends ec.G {
      constructor({ cause: J, message: et } = {}) {
        let eo = et?.replace("execution reverted: ", "")?.replace("execution reverted", "");
        super(`Execution reverted ${eo ? `with reason: ${eo}` : "for an unknown reason"}.`, {
          cause: J
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ExecutionRevertedError"
          })
      }
    }
      ;
    Object.defineProperty(ExecutionRevertedError, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 3
    }),
      Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: /execution reverted/
      });
    let FeeCapTooHighError = class FeeCapTooHighError extends ec.G {
      constructor({ cause: J, maxFeePerGas: et } = {}) {
        super(`The fee cap (\`maxFeePerGas\`${et ? ` = ${(0,
          el.o)(et)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
          cause: J
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "FeeCapTooHigh"
          })
      }
    }
      ;
    Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
    });
    let FeeCapTooLowError = class FeeCapTooLowError extends ec.G {
      constructor({ cause: J, maxFeePerGas: et } = {}) {
        super(`The fee cap (\`maxFeePerGas\`${et ? ` = ${(0,
          el.o)(et)}` : ""} gwei) cannot be lower than the block base fee.`, {
          cause: J
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "FeeCapTooLow"
          })
      }
    }
      ;
    Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
    });
    let NonceTooHighError = class NonceTooHighError extends ec.G {
      constructor({ cause: J, nonce: et } = {}) {
        super(`Nonce provided for the transaction ${et ? `(${et}) ` : ""}is higher than the next one expected.`, {
          cause: J
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "NonceTooHighError"
          })
      }
    }
      ;
    Object.defineProperty(NonceTooHighError, "nodeMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /nonce too high/
    });
    let NonceTooLowError = class NonceTooLowError extends ec.G {
      constructor({ cause: J, nonce: et } = {}) {
        super(`Nonce provided for the transaction ${et ? `(${et}) ` : ""}is lower than the current nonce of the account.
Try increasing the nonce or find the latest nonce with \`getTransactionCount\`.`, {
          cause: J
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "NonceTooLowError"
          })
      }
    }
      ;
    Object.defineProperty(NonceTooLowError, "nodeMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /nonce too low|transaction already imported|already known/
    });
    let NonceMaxValueError = class NonceMaxValueError extends ec.G {
      constructor({ cause: J, nonce: et } = {}) {
        super(`Nonce provided for the transaction ${et ? `(${et}) ` : ""}exceeds the maximum allowed nonce.`, {
          cause: J
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "NonceMaxValueError"
          })
      }
    }
      ;
    Object.defineProperty(NonceMaxValueError, "nodeMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /nonce has max value/
    });
    let InsufficientFundsError = class InsufficientFundsError extends ec.G {
      constructor({ cause: J } = {}) {
        super("The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account.", {
          cause: J,
          metaMessages: ["This error could arise when the account does not have enough funds to:", " - pay for the total gas fee,", " - pay for the value to send.", " ", "The cost of the transaction is calculated as `gas * gas fee + value`, where:", " - `gas` is the amount of gas needed for transaction to execute,", " - `gas fee` is the gas fee,", " - `value` is the amount of ether to send to the recipient."]
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InsufficientFundsError"
          })
      }
    }
      ;
    Object.defineProperty(InsufficientFundsError, "nodeMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /insufficient funds/
    });
    let IntrinsicGasTooHighError = class IntrinsicGasTooHighError extends ec.G {
      constructor({ cause: J, gas: et } = {}) {
        super(`The amount of gas ${et ? `(${et}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
          cause: J
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "IntrinsicGasTooHighError"
          })
      }
    }
      ;
    Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /intrinsic gas too high|gas limit reached/
    });
    let IntrinsicGasTooLowError = class IntrinsicGasTooLowError extends ec.G {
      constructor({ cause: J, gas: et } = {}) {
        super(`The amount of gas ${et ? `(${et}) ` : ""}provided for the transaction is too low.`, {
          cause: J
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "IntrinsicGasTooLowError"
          })
      }
    }
      ;
    Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /intrinsic gas too low/
    });
    let TransactionTypeNotSupportedError = class TransactionTypeNotSupportedError extends ec.G {
      constructor({ cause: J }) {
        super("The transaction type is not supported for this chain.", {
          cause: J
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "TransactionTypeNotSupportedError"
          })
      }
    }
      ;
    Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /transaction type not valid/
    });
    let TipAboveFeeCapError = class TipAboveFeeCapError extends ec.G {
      constructor({ cause: J, maxPriorityFeePerGas: et, maxFeePerGas: eo } = {}) {
        super(`The provided tip (\`maxPriorityFeePerGas\`${et ? ` = ${(0,
          el.o)(et)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${eo ? ` = ${(0,
            el.o)(eo)} gwei` : ""}).`, {
          cause: J
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "TipAboveFeeCapError"
          })
      }
    }
      ;
    Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
    });
    let UnknownNodeError = class UnknownNodeError extends ec.G {
      constructor({ cause: J }) {
        super(`An error occurred while executing: ${J?.shortMessage}`, {
          cause: J
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "UnknownNodeError"
          })
      }
    }
  },
  78863: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      Gg: function () {
        return HttpRequestError
      },
      W5: function () {
        return TimeoutError
      },
      bs: function () {
        return RpcRequestError
      }
    });
    var el = eo(96070)
      , ec = eo(62027)
      , ed = eo(35280);
    let HttpRequestError = class HttpRequestError extends ec.G {
      constructor({ body: J, details: et, headers: eo, status: ec, url: eh }) {
        super("HTTP request failed.", {
          details: et,
          metaMessages: [ec && `Status: ${ec}`, `URL: ${(0,
            ed.Gr)(eh)}`, J && `Request body: ${(0,
              el.P)(J)}`].filter(Boolean)
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "HttpRequestError"
          }),
          Object.defineProperty(this, "body", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          Object.defineProperty(this, "headers", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          Object.defineProperty(this, "status", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          Object.defineProperty(this, "url", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          this.body = J,
          this.headers = eo,
          this.status = ec,
          this.url = eh
      }
    }
      ;
    let RpcRequestError = class RpcRequestError extends ec.G {
      constructor({ body: J, error: et, url: eo }) {
        super("RPC Request failed.", {
          cause: et,
          details: et.message,
          metaMessages: [`URL: ${(0,
            ed.Gr)(eo)}`, `Request body: ${(0,
              el.P)(J)}`]
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "RpcRequestError"
          }),
          Object.defineProperty(this, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          this.code = et.code
      }
    }
      ;
    let TimeoutError = class TimeoutError extends ec.G {
      constructor({ body: J, url: et }) {
        super("The request took too long to respond.", {
          details: "The request timed out.",
          metaMessages: [`URL: ${(0,
            ed.Gr)(et)}`, `Request body: ${(0,
              el.P)(J)}`]
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "TimeoutError"
          })
      }
    }
  },
  39028: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      B: function () {
        return InvalidRequestRpcError
      },
      GD: function () {
        return JsonRpcVersionUnsupportedError
      },
      I0: function () {
        return ChainDisconnectedError
      },
      KB: function () {
        return TransactionRejectedRpcError
      },
      LX: function () {
        return MethodNotFoundRpcError
      },
      Og: function () {
        return ResourceNotFoundRpcError
      },
      PE: function () {
        return UnauthorizedProviderError
      },
      Pv: function () {
        return LimitExceededRpcError
      },
      Ts: function () {
        return UnsupportedProviderMethodError
      },
      XS: function () {
        return InternalRpcError
      },
      ab: function () {
        return UserRejectedRequestError
      },
      gS: function () {
        return MethodNotSupportedRpcError
      },
      ir: function () {
        return UnknownRpcError
      },
      nY: function () {
        return InvalidParamsRpcError
      },
      pT: function () {
        return ResourceUnavailableRpcError
      },
      s7: function () {
        return ParseRpcError
      },
      u5: function () {
        return ProviderDisconnectedError
      },
      x3: function () {
        return SwitchChainError
      },
      yR: function () {
        return InvalidInputRpcError
      }
    });
    var el = eo(62027)
      , ec = eo(78863);
    let RpcError = class RpcError extends el.G {
      constructor(J, { code: et, docsPath: eo, metaMessages: el, shortMessage: ed }) {
        super(ed, {
          cause: J,
          docsPath: eo,
          metaMessages: el || J?.metaMessages
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "RpcError"
          }),
          Object.defineProperty(this, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          this.name = J.name,
          this.code = J instanceof ec.bs ? J.code : et ?? -1
      }
    }
      ;
    let ProviderRpcError = class ProviderRpcError extends RpcError {
      constructor(J, et) {
        super(J, et),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ProviderRpcError"
          }),
          Object.defineProperty(this, "data", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          this.data = et.data
      }
    }
      ;
    let ParseRpcError = class ParseRpcError extends RpcError {
      constructor(J) {
        super(J, {
          code: ParseRpcError.code,
          shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ParseRpcError"
          })
      }
    }
      ;
    Object.defineProperty(ParseRpcError, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: -32700
    });
    let InvalidRequestRpcError = class InvalidRequestRpcError extends RpcError {
      constructor(J) {
        super(J, {
          code: InvalidRequestRpcError.code,
          shortMessage: "JSON is not a valid request object."
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidRequestRpcError"
          })
      }
    }
      ;
    Object.defineProperty(InvalidRequestRpcError, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: -32600
    });
    let MethodNotFoundRpcError = class MethodNotFoundRpcError extends RpcError {
      constructor(J) {
        super(J, {
          code: MethodNotFoundRpcError.code,
          shortMessage: "The method does not exist / is not available."
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "MethodNotFoundRpcError"
          })
      }
    }
      ;
    Object.defineProperty(MethodNotFoundRpcError, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: -32601
    });
    let InvalidParamsRpcError = class InvalidParamsRpcError extends RpcError {
      constructor(J) {
        super(J, {
          code: InvalidParamsRpcError.code,
          shortMessage: "Invalid parameters were provided to the RPC method.\nDouble check you have provided the correct parameters."
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidParamsRpcError"
          })
      }
    }
      ;
    Object.defineProperty(InvalidParamsRpcError, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: -32602
    });
    let InternalRpcError = class InternalRpcError extends RpcError {
      constructor(J) {
        super(J, {
          code: InternalRpcError.code,
          shortMessage: "An internal error was received."
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InternalRpcError"
          })
      }
    }
      ;
    Object.defineProperty(InternalRpcError, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: -32603
    });
    let InvalidInputRpcError = class InvalidInputRpcError extends RpcError {
      constructor(J) {
        super(J, {
          code: InvalidInputRpcError.code,
          shortMessage: "Missing or invalid parameters.\nDouble check you have provided the correct parameters."
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidInputRpcError"
          })
      }
    }
      ;
    Object.defineProperty(InvalidInputRpcError, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: -32e3
    });
    let ResourceNotFoundRpcError = class ResourceNotFoundRpcError extends RpcError {
      constructor(J) {
        super(J, {
          code: ResourceNotFoundRpcError.code,
          shortMessage: "Requested resource not found."
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ResourceNotFoundRpcError"
          })
      }
    }
      ;
    Object.defineProperty(ResourceNotFoundRpcError, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: -32001
    });
    let ResourceUnavailableRpcError = class ResourceUnavailableRpcError extends RpcError {
      constructor(J) {
        super(J, {
          code: ResourceUnavailableRpcError.code,
          shortMessage: "Requested resource not available."
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ResourceUnavailableRpcError"
          })
      }
    }
      ;
    Object.defineProperty(ResourceUnavailableRpcError, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: -32002
    });
    let TransactionRejectedRpcError = class TransactionRejectedRpcError extends RpcError {
      constructor(J) {
        super(J, {
          code: TransactionRejectedRpcError.code,
          shortMessage: "Transaction creation failed."
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "TransactionRejectedRpcError"
          })
      }
    }
      ;
    Object.defineProperty(TransactionRejectedRpcError, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: -32003
    });
    let MethodNotSupportedRpcError = class MethodNotSupportedRpcError extends RpcError {
      constructor(J) {
        super(J, {
          code: MethodNotSupportedRpcError.code,
          shortMessage: "Method is not implemented."
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "MethodNotSupportedRpcError"
          })
      }
    }
      ;
    Object.defineProperty(MethodNotSupportedRpcError, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: -32004
    });
    let LimitExceededRpcError = class LimitExceededRpcError extends RpcError {
      constructor(J) {
        super(J, {
          code: LimitExceededRpcError.code,
          shortMessage: "Request exceeds defined limit."
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "LimitExceededRpcError"
          })
      }
    }
      ;
    Object.defineProperty(LimitExceededRpcError, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: -32005
    });
    let JsonRpcVersionUnsupportedError = class JsonRpcVersionUnsupportedError extends RpcError {
      constructor(J) {
        super(J, {
          code: JsonRpcVersionUnsupportedError.code,
          shortMessage: "Version of JSON-RPC protocol is not supported."
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "JsonRpcVersionUnsupportedError"
          })
      }
    }
      ;
    Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: -32006
    });
    let UserRejectedRequestError = class UserRejectedRequestError extends ProviderRpcError {
      constructor(J) {
        super(J, {
          code: UserRejectedRequestError.code,
          shortMessage: "User rejected the request."
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "UserRejectedRequestError"
          })
      }
    }
      ;
    Object.defineProperty(UserRejectedRequestError, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 4001
    });
    let UnauthorizedProviderError = class UnauthorizedProviderError extends ProviderRpcError {
      constructor(J) {
        super(J, {
          code: UnauthorizedProviderError.code,
          shortMessage: "The requested method and/or account has not been authorized by the user."
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "UnauthorizedProviderError"
          })
      }
    }
      ;
    Object.defineProperty(UnauthorizedProviderError, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 4100
    });
    let UnsupportedProviderMethodError = class UnsupportedProviderMethodError extends ProviderRpcError {
      constructor(J) {
        super(J, {
          code: UnsupportedProviderMethodError.code,
          shortMessage: "The Provider does not support the requested method."
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "UnsupportedProviderMethodError"
          })
      }
    }
      ;
    Object.defineProperty(UnsupportedProviderMethodError, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 4200
    });
    let ProviderDisconnectedError = class ProviderDisconnectedError extends ProviderRpcError {
      constructor(J) {
        super(J, {
          code: ProviderDisconnectedError.code,
          shortMessage: "The Provider is disconnected from all chains."
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ProviderDisconnectedError"
          })
      }
    }
      ;
    Object.defineProperty(ProviderDisconnectedError, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 4900
    });
    let ChainDisconnectedError = class ChainDisconnectedError extends ProviderRpcError {
      constructor(J) {
        super(J, {
          code: ChainDisconnectedError.code,
          shortMessage: "The Provider is not connected to the requested chain."
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ChainDisconnectedError"
          })
      }
    }
      ;
    Object.defineProperty(ChainDisconnectedError, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 4901
    });
    let SwitchChainError = class SwitchChainError extends ProviderRpcError {
      constructor(J) {
        super(J, {
          code: SwitchChainError.code,
          shortMessage: "An error occurred when attempting to switch chain."
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "SwitchChainError"
          })
      }
    }
      ;
    Object.defineProperty(SwitchChainError, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 4902
    });
    let UnknownRpcError = class UnknownRpcError extends RpcError {
      constructor(J) {
        super(J, {
          shortMessage: "An unknown RPC error occurred."
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "UnknownRpcError"
          })
      }
    }
  },
  33639: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      Yb: function () {
        return TransactionReceiptNotFoundError
      },
      j3: function () {
        return InvalidSerializableTransactionError
      },
      mk: function () {
        return TransactionExecutionError
      },
      xY: function () {
        return FeeConflictError
      },
      xr: function () {
        return prettyPrint
      }
    });
    var el = eo(39625)
      , ec = eo(67795)
      , ed = eo(62027);
    function prettyPrint(J) {
      let et = Object.entries(J).map(([J, et]) => void 0 === et || !1 === et ? null : [J, et]).filter(Boolean)
        , eo = et.reduce((J, [et]) => Math.max(J, et.length), 0);
      return et.map(([J, et]) => `  ${`${J}:`.padEnd(eo + 1)}  ${et}`).join("\n")
    }
    let FeeConflictError = class FeeConflictError extends ed.G {
      constructor() {
        super("Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.\nUse `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "FeeConflictError"
          })
      }
    }
      ;
    let InvalidSerializableTransactionError = class InvalidSerializableTransactionError extends ed.G {
      constructor({ transaction: J }) {
        super("Cannot infer a transaction type from provided transaction.", {
          metaMessages: ["Provided Transaction:", "{", prettyPrint(J), "}", "", "To infer the type, either provide:", "- a `type` to the Transaction, or", "- an EIP-1559 Transaction with `maxFeePerGas`, or", "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or", "- a Legacy Transaction with `gasPrice`"]
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidSerializableTransactionError"
          })
      }
    }
      ;
    let TransactionExecutionError = class TransactionExecutionError extends ed.G {
      constructor(J, { account: et, docsPath: eo, chain: ed, data: eh, gas: ep, gasPrice: ef, maxFeePerGas: em, maxPriorityFeePerGas: eg, nonce: ey, to: eb, value: ew }) {
        let e_ = prettyPrint({
          chain: ed && `${ed?.name} (id: ${ed?.id})`,
          from: et?.address,
          to: eb,
          value: void 0 !== ew && `${(0,
            el.d)(ew)} ${ed?.nativeCurrency?.symbol || "ETH"}`,
          data: eh,
          gas: ep,
          gasPrice: void 0 !== ef && `${(0,
            ec.o)(ef)} gwei`,
          maxFeePerGas: void 0 !== em && `${(0,
            ec.o)(em)} gwei`,
          maxPriorityFeePerGas: void 0 !== eg && `${(0,
            ec.o)(eg)} gwei`,
          nonce: ey
        });
        super(J.shortMessage, {
          cause: J,
          docsPath: eo,
          metaMessages: [...J.metaMessages ? [...J.metaMessages, " "] : [], "Request Arguments:", e_].filter(Boolean)
        }),
          Object.defineProperty(this, "cause", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "TransactionExecutionError"
          }),
          this.cause = J
      }
    }
      ;
    let TransactionReceiptNotFoundError = class TransactionReceiptNotFoundError extends ed.G {
      constructor({ hash: J }) {
        super(`Transaction receipt with hash "${J}" could not be found. The Transaction may not be processed on a block yet.`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "TransactionReceiptNotFoundError"
          })
      }
    }
  },
  35280: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      CR: function () {
        return getContractAddress
      },
      Gr: function () {
        return getUrl
      },
      bo: function () {
        return getVersion
      }
    });
    let getContractAddress = J => J
      , getUrl = J => J
      , getVersion = () => "viem@2.5.0"
  },
  37686: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      r: function () {
        return decodeAbiParameters
      }
    });
    var el = eo(57412)
      , ec = eo(45775)
      , ed = eo(62027);
    let NegativeOffsetError = class NegativeOffsetError extends ed.G {
      constructor({ offset: J }) {
        super(`Offset \`${J}\` cannot be negative.`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "NegativeOffsetError"
          })
      }
    }
      ;
    let PositionOutOfBoundsError = class PositionOutOfBoundsError extends ed.G {
      constructor({ length: J, position: et }) {
        super(`Position \`${et}\` is out of bounds (\`0 < position < ${J}\`).`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "PositionOutOfBoundsError"
          })
      }
    }
      ;
    let RecursiveReadLimitExceededError = class RecursiveReadLimitExceededError extends ed.G {
      constructor({ count: J, limit: et }) {
        super(`Recursive read limit of \`${et}\` exceeded (recursive read count: \`${J}\`).`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "RecursiveReadLimitExceededError"
          })
      }
    }
      ;
    let eh = {
      bytes: new Uint8Array,
      dataView: new DataView(new ArrayBuffer(0)),
      position: 0,
      positionReadCount: new Map,
      recursiveReadCount: 0,
      recursiveReadLimit: 1 / 0,
      assertReadLimit() {
        if (this.recursiveReadCount >= this.recursiveReadLimit)
          throw new RecursiveReadLimitExceededError({
            count: this.recursiveReadCount + 1,
            limit: this.recursiveReadLimit
          })
      },
      assertPosition(J) {
        if (J < 0 || J > this.bytes.length - 1)
          throw new PositionOutOfBoundsError({
            length: this.bytes.length,
            position: J
          })
      },
      decrementPosition(J) {
        if (J < 0)
          throw new NegativeOffsetError({
            offset: J
          });
        let et = this.position - J;
        this.assertPosition(et),
          this.position = et
      },
      getReadCount(J) {
        return this.positionReadCount.get(J || this.position) || 0
      },
      incrementPosition(J) {
        if (J < 0)
          throw new NegativeOffsetError({
            offset: J
          });
        let et = this.position + J;
        this.assertPosition(et),
          this.position = et
      },
      inspectByte(J) {
        let et = J ?? this.position;
        return this.assertPosition(et),
          this.bytes[et]
      },
      inspectBytes(J, et) {
        let eo = et ?? this.position;
        return this.assertPosition(eo + J - 1),
          this.bytes.subarray(eo, eo + J)
      },
      inspectUint8(J) {
        let et = J ?? this.position;
        return this.assertPosition(et),
          this.bytes[et]
      },
      inspectUint16(J) {
        let et = J ?? this.position;
        return this.assertPosition(et + 1),
          this.dataView.getUint16(et)
      },
      inspectUint24(J) {
        let et = J ?? this.position;
        return this.assertPosition(et + 2),
          (this.dataView.getUint16(et) << 8) + this.dataView.getUint8(et + 2)
      },
      inspectUint32(J) {
        let et = J ?? this.position;
        return this.assertPosition(et + 3),
          this.dataView.getUint32(et)
      },
      pushByte(J) {
        this.assertPosition(this.position),
          this.bytes[this.position] = J,
          this.position++
      },
      pushBytes(J) {
        this.assertPosition(this.position + J.length - 1),
          this.bytes.set(J, this.position),
          this.position += J.length
      },
      pushUint8(J) {
        this.assertPosition(this.position),
          this.bytes[this.position] = J,
          this.position++
      },
      pushUint16(J) {
        this.assertPosition(this.position + 1),
          this.dataView.setUint16(this.position, J),
          this.position += 2
      },
      pushUint24(J) {
        this.assertPosition(this.position + 2),
          this.dataView.setUint16(this.position, J >> 8),
          this.dataView.setUint8(this.position + 2, 255 & J),
          this.position += 3
      },
      pushUint32(J) {
        this.assertPosition(this.position + 3),
          this.dataView.setUint32(this.position, J),
          this.position += 4
      },
      readByte() {
        this.assertReadLimit(),
          this._touch();
        let J = this.inspectByte();
        return this.position++,
          J
      },
      readBytes(J, et) {
        this.assertReadLimit(),
          this._touch();
        let eo = this.inspectBytes(J);
        return this.position += et ?? J,
          eo
      },
      readUint8() {
        this.assertReadLimit(),
          this._touch();
        let J = this.inspectUint8();
        return this.position += 1,
          J
      },
      readUint16() {
        this.assertReadLimit(),
          this._touch();
        let J = this.inspectUint16();
        return this.position += 2,
          J
      },
      readUint24() {
        this.assertReadLimit(),
          this._touch();
        let J = this.inspectUint24();
        return this.position += 3,
          J
      },
      readUint32() {
        this.assertReadLimit(),
          this._touch();
        let J = this.inspectUint32();
        return this.position += 4,
          J
      },
      setPosition(J) {
        let et = this.position;
        return this.assertPosition(J),
          this.position = J,
          () => this.position = et
      },
      _touch() {
        if (this.recursiveReadLimit === 1 / 0)
          return;
        let J = this.getReadCount();
        this.positionReadCount.set(this.position, J + 1),
          J > 0 && this.recursiveReadCount++
      }
    };
    var ep = eo(39135)
      , ef = eo(3972)
      , em = eo(61836)
      , eg = eo(87788)
      , ey = eo(95946)
      , eb = eo(92106);
    function bytesToNumber(J, et = {}) {
      void 0 !== et.size && (0,
        ey.Yf)(J, {
          size: et.size
        });
      let eo = (0,
        eb.ci)(J, et);
      return (0,
        ey.ly)(eo, et)
    }
    var ew = eo(11187)
      , e_ = eo(45444);
    function decodeAbiParameters(J, et) {
      let eo = "string" == typeof et ? (0,
        ew.nr)(et) : et
        , ed = function (J, { recursiveReadLimit: et = 8192 } = {}) {
          let eo = Object.create(eh);
          return eo.bytes = J,
            eo.dataView = new DataView(J.buffer, J.byteOffset, J.byteLength),
            eo.positionReadCount = new Map,
            eo.recursiveReadLimit = et,
            eo
        }(eo);
      if (0 === (0,
        ep.d)(eo) && J.length > 0)
        throw new el.wb;
      if ((0,
        ep.d)(et) && 32 > (0,
          ep.d)(et))
        throw new el.xB({
          data: "string" == typeof et ? et : (0,
            eb.ci)(et),
          params: J,
          size: (0,
            ep.d)(et)
        });
      let ex = 0
        , eE = [];
      for (let et = 0; et < J.length; ++et) {
        let eo = J[et];
        ed.setPosition(ex);
        let [eh, ep] = function decodeParameter(J, et, { staticPosition: eo }) {
          let ed = (0,
            e_.S)(et.type);
          if (ed) {
            let [el, ec] = ed;
            return function (J, et, { length: eo, staticPosition: el }) {
              if (!eo) {
                let eo = bytesToNumber(J.readBytes(32))
                  , ec = el + eo
                  , ed = ec + 32;
                J.setPosition(ec);
                let eh = bytesToNumber(J.readBytes(32))
                  , ep = hasDynamicChild(et)
                  , ef = 0
                  , em = [];
                for (let eo = 0; eo < eh; ++eo) {
                  J.setPosition(ed + (ep ? 32 * eo : ef));
                  let [el, ec] = decodeParameter(J, et, {
                    staticPosition: ed
                  });
                  ef += ec,
                    em.push(el)
                }
                return J.setPosition(el + 32),
                  [em, 32]
              }
              if (hasDynamicChild(et)) {
                let ec = bytesToNumber(J.readBytes(32))
                  , ed = el + ec
                  , eh = [];
                for (let el = 0; el < eo; ++el) {
                  J.setPosition(ed + 32 * el);
                  let [eo] = decodeParameter(J, et, {
                    staticPosition: ed
                  });
                  eh.push(eo)
                }
                return J.setPosition(el + 32),
                  [eh, 32]
              }
              let ec = 0
                , ed = [];
              for (let eh = 0; eh < eo; ++eh) {
                let [eo, eh] = decodeParameter(J, et, {
                  staticPosition: el + ec
                });
                ec += eh,
                  ed.push(eo)
              }
              return [ed, ec]
            }(J, {
              ...et,
              type: ec
            }, {
              length: el,
              staticPosition: eo
            })
          }
          if ("tuple" === et.type)
            return function (J, et, { staticPosition: eo }) {
              let el = 0 === et.components.length || et.components.some(({ name: J }) => !J)
                , ec = el ? [] : {}
                , ed = 0;
              if (hasDynamicChild(et)) {
                let eh = bytesToNumber(J.readBytes(32))
                  , ep = eo + eh;
                for (let eo = 0; eo < et.components.length; ++eo) {
                  let eh = et.components[eo];
                  J.setPosition(ep + ed);
                  let [ef, em] = decodeParameter(J, eh, {
                    staticPosition: ep
                  });
                  ed += em,
                    ec[el ? eo : eh?.name] = ef
                }
                return J.setPosition(eo + 32),
                  [ec, 32]
              }
              for (let eh = 0; eh < et.components.length; ++eh) {
                let ep = et.components[eh]
                  , [ef, em] = decodeParameter(J, ep, {
                    staticPosition: eo
                  });
                ec[el ? eh : ep?.name] = ef,
                  ed += em
              }
              return [ec, ed]
            }(J, et, {
              staticPosition: eo
            });
          if ("address" === et.type)
            return function (J) {
              let et = J.readBytes(32);
              return [(0,
                ec.x)((0,
                  eb.ci)((0,
                    ef.T4)(et, -20))), 32]
            }(J);
          if ("bool" === et.type)
            return [function (J, et = {}) {
              let eo = J;
              if (void 0 !== et.size && ((0,
                ey.Yf)(eo, {
                  size: et.size
                }),
                eo = (0,
                  em.f)(eo)),
                eo.length > 1 || eo[0] > 1)
                throw new eg.yr(eo);
              return !!eo[0]
            }(J.readBytes(32), {
              size: 32
            }), 32];
          if (et.type.startsWith("bytes"))
            return function (J, et, { staticPosition: eo }) {
              let [el, ec] = et.type.split("bytes");
              if (!ec) {
                let et = bytesToNumber(J.readBytes(32));
                J.setPosition(eo + et);
                let el = bytesToNumber(J.readBytes(32));
                if (0 === el)
                  return J.setPosition(eo + 32),
                    ["0x", 32];
                let ec = J.readBytes(el);
                return J.setPosition(eo + 32),
                  [(0,
                    eb.ci)(ec), 32]
              }
              let ed = (0,
                eb.ci)(J.readBytes(parseInt(ec), 32));
              return [ed, 32]
            }(J, et, {
              staticPosition: eo
            });
          if (et.type.startsWith("uint") || et.type.startsWith("int"))
            return function (J, et) {
              let eo = et.type.startsWith("int")
                , el = parseInt(et.type.split("int")[1] || "256")
                , ec = J.readBytes(32);
              return [el > 48 ? function (J, et = {}) {
                void 0 !== et.size && (0,
                  ey.Yf)(J, {
                    size: et.size
                  });
                let eo = (0,
                  eb.ci)(J, et);
                return (0,
                  ey.y_)(eo, et)
              }(ec, {
                signed: eo
              }) : bytesToNumber(ec, {
                signed: eo
              }), 32]
            }(J, et);
          if ("string" === et.type)
            return function (J, { staticPosition: et }) {
              let eo = bytesToNumber(J.readBytes(32))
                , el = et + eo;
              J.setPosition(el);
              let ec = bytesToNumber(J.readBytes(32));
              if (0 === ec)
                return J.setPosition(et + 32),
                  ["", 32];
              let ed = J.readBytes(ec, 32)
                , eh = function (J, et = {}) {
                  let eo = J;
                  return void 0 !== et.size && ((0,
                    ey.Yf)(eo, {
                      size: et.size
                    }),
                    eo = (0,
                      em.f)(eo, {
                        dir: "right"
                      })),
                    new TextDecoder().decode(eo)
                }((0,
                  em.f)(ed));
              return J.setPosition(et + 32),
                [eh, 32]
            }(J, {
              staticPosition: eo
            });
          throw new el.CI(et.type, {
            docsPath: "/docs/contract/decodeAbiParameters"
          })
        }(ed, eo, {
          staticPosition: 0
        });
        ex += ep,
          eE.push(eh)
      }
      return eE
    }
    function hasDynamicChild(J) {
      let { type: et } = J;
      if ("string" === et || "bytes" === et || et.endsWith("[]"))
        return !0;
      if ("tuple" === et)
        return J.components?.some(hasDynamicChild);
      let eo = (0,
        e_.S)(J.type);
      return !!(eo && hasDynamicChild({
        ...J,
        type: eo[1]
      }))
    }
  },
  86899: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      p: function () {
        return decodeErrorResult
      }
    });
    var el = eo(21746)
      , ec = eo(57412)
      , ed = eo(3972)
      , eh = eo(58034)
      , ep = eo(37686)
      , ef = eo(80522);
    function decodeErrorResult(J) {
      let { abi: et, data: eo } = J
        , em = (0,
          ed.tP)(eo, 0, 4);
      if ("0x" === em)
        throw new ec.wb;
      let eg = [...et || [], el.Up, el.hZ]
        , ey = eg.find(J => "error" === J.type && em === (0,
          eh.C)((0,
            ef.t)(J)));
      if (!ey)
        throw new ec.yP(em, {
          docsPath: "/docs/contract/decodeErrorResult"
        });
      return {
        abiItem: ey,
        args: "inputs" in ey && ey.inputs && ey.inputs.length > 0 ? (0,
          ep.r)(ey.inputs, (0,
            ed.tP)(eo, 4)) : void 0,
        errorName: ey.name
      }
    }
  },
  7210: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      k: function () {
        return decodeFunctionResult
      }
    });
    var el = eo(57412)
      , ec = eo(37686)
      , ed = eo(3640);
    let eh = "/docs/contract/decodeFunctionResult";
    function decodeFunctionResult(J) {
      let { abi: et, args: eo, functionName: ep, data: ef } = J
        , em = et[0];
      if (ep) {
        let J = (0,
          ed.mE)({
            abi: et,
            args: eo,
            name: ep
          });
        if (!J)
          throw new el.xL(ep, {
            docsPath: eh
          });
        em = J
      }
      if ("function" !== em.type)
        throw new el.xL(void 0, {
          docsPath: eh
        });
      if (!em.outputs)
        throw new el.MX(em.name, {
          docsPath: eh
        });
      let eg = (0,
        ec.r)(em.outputs, ef);
      return eg && eg.length > 1 ? eg : eg && 1 === eg.length ? eg[0] : void 0
    }
  },
  45444: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      E: function () {
        return encodeAbiParameters
      },
      S: function () {
        return getArrayComponents
      }
    });
    var el = eo(57412)
      , ec = eo(26087)
      , ed = eo(49321)
      , eh = eo(57040)
      , ep = eo(61769)
      , ef = eo(39135)
      , em = eo(3972)
      , eg = eo(92106);
    function encodeAbiParameters(J, et) {
      if (J.length !== et.length)
        throw new el.fs({
          expectedLength: J.length,
          givenLength: et.length
        });
      let eo = function ({ params: J, values: et }) {
        let eo = [];
        for (let ey = 0; ey < J.length; ey++)
          eo.push(function prepareParam({ param: J, value: et }) {
            let eo = getArrayComponents(J.type);
            if (eo) {
              let [ec, ed] = eo;
              return function (J, { length: et, param: eo }) {
                let ec = null === et;
                if (!Array.isArray(J))
                  throw new el.hn(J);
                if (!ec && J.length !== et)
                  throw new el.gr({
                    expectedLength: et,
                    givenLength: J.length,
                    type: `${eo.type}[${et}]`
                  });
                let ed = !1
                  , ep = [];
                for (let et = 0; et < J.length; et++) {
                  let el = prepareParam({
                    param: eo,
                    value: J[et]
                  });
                  el.dynamic && (ed = !0),
                    ep.push(el)
                }
                if (ec || ed) {
                  let J = encodeParams(ep);
                  if (ec) {
                    let et = (0,
                      eg.eC)(ep.length, {
                        size: 32
                      });
                    return {
                      dynamic: !0,
                      encoded: ep.length > 0 ? (0,
                        eh.zo)([et, J]) : et
                    }
                  }
                  if (ed)
                    return {
                      dynamic: !0,
                      encoded: J
                    }
                }
                return {
                  dynamic: !1,
                  encoded: (0,
                    eh.zo)(ep.map(({ encoded: J }) => J))
                }
              }(et, {
                length: ec,
                param: {
                  ...J,
                  type: ed
                }
              })
            }
            if ("tuple" === J.type)
              return function (J, { param: et }) {
                let eo = !1
                  , el = [];
                for (let ec = 0; ec < et.components.length; ec++) {
                  let ed = et.components[ec]
                    , eh = Array.isArray(J) ? ec : ed.name
                    , ep = prepareParam({
                      param: ed,
                      value: J[eh]
                    });
                  el.push(ep),
                    ep.dynamic && (eo = !0)
                }
                return {
                  dynamic: eo,
                  encoded: eo ? encodeParams(el) : (0,
                    eh.zo)(el.map(({ encoded: J }) => J))
                }
              }(et, {
                param: J
              });
            if ("address" === J.type)
              return function (J) {
                if (!(0,
                  ed.U)(J))
                  throw new ec.b({
                    address: J
                  });
                return {
                  dynamic: !1,
                  encoded: (0,
                    ep.gc)(J.toLowerCase())
                }
              }(et);
            if ("bool" === J.type)
              return {
                dynamic: !1,
                encoded: (0,
                  ep.gc)((0,
                    eg.C4)(et))
              };
            if (J.type.startsWith("uint") || J.type.startsWith("int")) {
              let eo = J.type.startsWith("int");
              return function (J, { signed: et }) {
                return {
                  dynamic: !1,
                  encoded: (0,
                    eg.eC)(J, {
                      size: 32,
                      signed: et
                    })
                }
              }(et, {
                signed: eo
              })
            }
            if (J.type.startsWith("bytes"))
              return function (J, { param: et }) {
                let [, eo] = et.type.split("bytes")
                  , ec = (0,
                    ef.d)(J);
                if (!eo) {
                  let et = J;
                  return ec % 32 != 0 && (et = (0,
                    ep.gc)(et, {
                      dir: "right",
                      size: 32 * Math.ceil((J.length - 2) / 2 / 32)
                    })),
                  {
                    dynamic: !0,
                    encoded: (0,
                      eh.zo)([(0,
                        ep.gc)((0,
                          eg.eC)(ec, {
                            size: 32
                          })), et])
                  }
                }
                if (ec !== parseInt(eo))
                  throw new el.M4({
                    expectedSize: parseInt(eo),
                    value: J
                  });
                return {
                  dynamic: !1,
                  encoded: (0,
                    ep.gc)(J, {
                      dir: "right"
                    })
                }
              }(et, {
                param: J
              });
            if ("string" === J.type)
              return function (J) {
                let et = (0,
                  eg.$G)(J)
                  , eo = Math.ceil((0,
                    ef.d)(et) / 32)
                  , el = [];
                for (let J = 0; J < eo; J++)
                  el.push((0,
                    ep.gc)((0,
                      em.tP)(et, 32 * J, (J + 1) * 32), {
                      dir: "right"
                    }));
                return {
                  dynamic: !0,
                  encoded: (0,
                    eh.zo)([(0,
                      ep.gc)((0,
                        eg.eC)((0,
                          ef.d)(et), {
                          size: 32
                        })), ...el])
                }
              }(et);
            throw new el.dh(J.type, {
              docsPath: "/docs/contract/encodeAbiParameters"
            })
          }({
            param: J[ey],
            value: et[ey]
          }));
        return eo
      }({
        params: J,
        values: et
      })
        , ey = encodeParams(eo);
      return 0 === ey.length ? "0x" : ey
    }
    function encodeParams(J) {
      let et = 0;
      for (let eo = 0; eo < J.length; eo++) {
        let { dynamic: el, encoded: ec } = J[eo];
        el ? et += 32 : et += (0,
          ef.d)(ec)
      }
      let eo = []
        , el = []
        , ec = 0;
      for (let ed = 0; ed < J.length; ed++) {
        let { dynamic: eh, encoded: ep } = J[ed];
        eh ? (eo.push((0,
          eg.eC)(et + ec, {
            size: 32
          })),
          el.push(ep),
          ec += (0,
            ef.d)(ep)) : eo.push(ep)
      }
      return (0,
        eh.zo)([...eo, ...el])
    }
    function getArrayComponents(J) {
      let et = J.match(/^(.*)\[(\d+)?\]$/);
      return et ? [et[2] ? Number(et[2]) : null, et[1]] : void 0
    }
  },
  77799: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      R: function () {
        return encodeFunctionData
      }
    });
    var el = eo(57412)
      , ec = eo(57040)
      , ed = eo(58034)
      , eh = eo(45444)
      , ep = eo(80522)
      , ef = eo(3640);
    let em = "/docs/contract/encodeFunctionData";
    function encodeFunctionData(J) {
      let { abi: et, args: eo, functionName: eg } = J
        , ey = et[0];
      if (eg) {
        let J = (0,
          ef.mE)({
            abi: et,
            args: eo,
            name: eg
          });
        if (!J)
          throw new el.xL(eg, {
            docsPath: em
          });
        ey = J
      }
      if ("function" !== ey.type)
        throw new el.xL(void 0, {
          docsPath: em
        });
      let eb = (0,
        ep.t)(ey)
        , ew = (0,
          ed.C)(eb)
        , e_ = "inputs" in ey && ey.inputs ? (0,
          eh.E)(ey.inputs, eo ?? []) : void 0;
      return (0,
        ec.SM)([ew, e_ ?? "0x"])
    }
  },
  80522: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      h: function () {
        return formatAbiParams
      },
      t: function () {
        return formatAbiItem
      }
    });
    var el = eo(57412);
    function formatAbiItem(J, { includeName: et = !1 } = {}) {
      if ("function" !== J.type && "event" !== J.type && "error" !== J.type)
        throw new el.wM(J.type);
      return `${J.name}(${formatAbiParams(J.inputs, {
        includeName: et
      })})`
    }
    function formatAbiParams(J, { includeName: et = !1 } = {}) {
      return J ? J.map(J => (function (J, { includeName: et }) {
        return J.type.startsWith("tuple") ? `(${formatAbiParams(J.components, {
          includeName: et
        })})${J.type.slice(5)}` : J.type + (et && J.name ? ` ${J.name}` : "")
      }
      )(J, {
        includeName: et
      })).join(et ? ", " : ",") : ""
    }
  },
  3640: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      mE: function () {
        return getAbiItem
      }
    });
    var el = eo(57412)
      , ec = eo(15102)
      , ed = eo(49321)
      , eh = eo(67684);
    let ep = eh.r;
    var ef = eo(58034);
    function getAbiItem(J) {
      let et;
      let { abi: eo, args: eh = [], name: em } = J
        , eg = (0,
          ec.v)(em, {
            strict: !1
          })
        , ey = eo.filter(J => eg ? "function" === J.type ? (0,
          ef.C)(J) === em : "event" === J.type && ep(J) === em : "name" in J && J.name === em);
      if (0 !== ey.length) {
        if (1 === ey.length)
          return ey[0];
        for (let J of ey) {
          if (!("inputs" in J))
            continue;
          if (!eh || 0 === eh.length) {
            if (!J.inputs || 0 === J.inputs.length)
              return J;
            continue
          }
          if (!J.inputs || 0 === J.inputs.length || J.inputs.length !== eh.length)
            continue;
          let eo = eh.every((et, eo) => {
            let el = "inputs" in J && J.inputs[eo];
            return !!el && function isArgOfType(J, et) {
              let eo = typeof J
                , el = et.type;
              switch (el) {
                case "address":
                  return (0,
                    ed.U)(J);
                case "bool":
                  return "boolean" === eo;
                case "function":
                case "string":
                  return "string" === eo;
                default:
                  if ("tuple" === el && "components" in et)
                    return Object.values(et.components).every((et, eo) => isArgOfType(Object.values(J)[eo], et));
                  if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(el))
                    return "number" === eo || "bigint" === eo;
                  if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(el))
                    return "string" === eo || J instanceof Uint8Array;
                  if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(el))
                    return Array.isArray(J) && J.every(J => isArgOfType(J, {
                      ...et,
                      type: el.replace(/(\[[0-9]{0,}\])$/, "")
                    }));
                  return !1
              }
            }(et, el)
          }
          );
          if (eo) {
            if (et && "inputs" in et && et.inputs) {
              let eo = function getAmbiguousTypes(J, et, eo) {
                for (let el in J) {
                  let ec = J[el]
                    , eh = et[el];
                  if ("tuple" === ec.type && "tuple" === eh.type && "components" in ec && "components" in eh)
                    return getAmbiguousTypes(ec.components, eh.components, eo[el]);
                  let ep = [ec.type, eh.type]
                    , ef = !!(ep.includes("address") && ep.includes("bytes20")) || !!(ep.includes("address") && ep.includes("string") || ep.includes("address") && ep.includes("bytes")) && (0,
                      ed.U)(eo[el]);
                  if (ef)
                    return ep
                }
              }(J.inputs, et.inputs, eh);
              if (eo)
                throw new el.S4({
                  abiItem: J,
                  type: eo[0]
                }, {
                  abiItem: et,
                  type: eo[1]
                })
            }
            et = J
          }
        }
        return et || ey[0]
      }
    }
  },
  45775: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      K: function () {
        return getAddress
      },
      x: function () {
        return checksumAddress
      }
    });
    var el = eo(26087)
      , ec = eo(11187)
      , ed = eo(56254)
      , eh = eo(49321);
    function checksumAddress(J, et) {
      let eo = et ? `${et}${J.toLowerCase()}` : J.substring(2).toLowerCase()
        , el = (0,
          ed.w)((0,
            ec.qX)(eo), "bytes")
        , eh = (et ? eo.substring(`${et}0x`.length) : eo).split("");
      for (let J = 0; J < 40; J += 2)
        el[J >> 1] >> 4 >= 8 && eh[J] && (eh[J] = eh[J].toUpperCase()),
          (15 & el[J >> 1]) >= 8 && eh[J + 1] && (eh[J + 1] = eh[J + 1].toUpperCase());
      return `0x${eh.join("")}`
    }
    function getAddress(J, et) {
      if (!(0,
        eh.U)(J))
        throw new el.b({
          address: J
        });
      return checksumAddress(J, et)
    }
  },
  49321: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      U: function () {
        return isAddress
      }
    });
    let el = /^0x[a-fA-F0-9]{40}$/;
    function isAddress(J) {
      return el.test(J)
    }
  },
  86164: function (J, et, eo) {
    "use strict";
    function defineChain(J) {
      return {
        formatters: void 0,
        fees: void 0,
        serializers: void 0,
        ...J
      }
    }
    eo.d(et, {
      a: function () {
        return defineChain
      }
    })
  },
  47864: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      L: function () {
        return getChainContractAddress
      }
    });
    var el = eo(80377);
    function getChainContractAddress({ blockNumber: J, chain: et, contract: eo }) {
      let ec = et?.contracts?.[eo];
      if (!ec)
        throw new el.mm({
          chain: et,
          contract: {
            name: eo
          }
        });
      if (J && ec.blockCreated && ec.blockCreated > J)
        throw new el.mm({
          blockNumber: J,
          chain: et,
          contract: {
            name: eo,
            blockCreated: ec.blockCreated
          }
        });
      return ec.address
    }
  },
  57040: function (J, et, eo) {
    "use strict";
    function concat(J) {
      return "string" == typeof J[0] ? concatHex(J) : function (J) {
        let et = 0;
        for (let eo of J)
          et += eo.length;
        let eo = new Uint8Array(et)
          , el = 0;
        for (let et of J)
          eo.set(et, el),
            el += et.length;
        return eo
      }(J)
    }
    function concatHex(J) {
      return `0x${J.reduce((J, et) => J + et.replace("0x", ""), "")}`
    }
    eo.d(et, {
      SM: function () {
        return concatHex
      },
      zo: function () {
        return concat
      }
    })
  },
  15102: function (J, et, eo) {
    "use strict";
    function isHex(J, { strict: et = !0 } = {}) {
      return !!J && "string" == typeof J && (et ? /^0x[0-9a-fA-F]*$/.test(J) : J.startsWith("0x"))
    }
    eo.d(et, {
      v: function () {
        return isHex
      }
    })
  },
  61769: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      gc: function () {
        return padHex
      },
      vk: function () {
        return pad
      }
    });
    var el = eo(69760);
    function pad(J, { dir: et, size: eo = 32 } = {}) {
      return "string" == typeof J ? padHex(J, {
        dir: et,
        size: eo
      }) : function (J, { dir: et, size: eo = 32 } = {}) {
        if (null === eo)
          return J;
        if (J.length > eo)
          throw new el.$({
            size: J.length,
            targetSize: eo,
            type: "bytes"
          });
        let ec = new Uint8Array(eo);
        for (let el = 0; el < eo; el++) {
          let ed = "right" === et;
          ec[ed ? el : eo - el - 1] = J[ed ? el : J.length - el - 1]
        }
        return ec
      }(J, {
        dir: et,
        size: eo
      })
    }
    function padHex(J, { dir: et, size: eo = 32 } = {}) {
      if (null === eo)
        return J;
      let ec = J.replace("0x", "");
      if (ec.length > 2 * eo)
        throw new el.$({
          size: Math.ceil(ec.length / 2),
          targetSize: eo,
          type: "hex"
        });
      return `0x${ec["right" === et ? "padEnd" : "padStart"](2 * eo, "0")}`
    }
  },
  39135: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      d: function () {
        return size
      }
    });
    var el = eo(15102);
    function size(J) {
      return (0,
        el.v)(J, {
          strict: !1
        }) ? Math.ceil((J.length - 2) / 2) : J.length
    }
  },
  3972: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      T4: function () {
        return sliceBytes
      },
      tP: function () {
        return slice
      }
    });
    var el = eo(69760)
      , ec = eo(15102)
      , ed = eo(39135);
    function slice(J, et, eo, { strict: el } = {}) {
      return (0,
        ec.v)(J, {
          strict: !1
        }) ? function (J, et, eo, { strict: el } = {}) {
          assertStartOffset(J, et);
          let ec = `0x${J.replace("0x", "").slice((et ?? 0) * 2, (eo ?? J.length) * 2)}`;
          return el && assertEndOffset(ec, et, eo),
            ec
        }(J, et, eo, {
          strict: el
        }) : sliceBytes(J, et, eo, {
          strict: el
        })
    }
    function assertStartOffset(J, et) {
      if ("number" == typeof et && et > 0 && et > (0,
        ed.d)(J) - 1)
        throw new el.m({
          offset: et,
          position: "start",
          size: (0,
            ed.d)(J)
        })
    }
    function assertEndOffset(J, et, eo) {
      if ("number" == typeof et && "number" == typeof eo && (0,
        ed.d)(J) !== eo - et)
        throw new el.m({
          offset: eo,
          position: "end",
          size: (0,
            ed.d)(J)
        })
    }
    function sliceBytes(J, et, eo, { strict: el } = {}) {
      assertStartOffset(J, et);
      let ec = J.slice(et, eo);
      return el && assertEndOffset(ec, et, eo),
        ec
    }
  },
  61836: function (J, et, eo) {
    "use strict";
    function trim(J, { dir: et = "left" } = {}) {
      let eo = "string" == typeof J ? J.replace("0x", "") : J
        , el = 0;
      for (let J = 0; J < eo.length - 1 && "0" === eo["left" === et ? J : eo.length - J - 1].toString(); J++)
        el++;
      return (eo = "left" === et ? eo.slice(el) : eo.slice(0, eo.length - el),
        "string" == typeof J) ? (1 === eo.length && "right" === et && (eo = `${eo}0`),
          `0x${eo.length % 2 == 1 ? `0${eo}` : eo}`) : eo
    }
    eo.d(et, {
      f: function () {
        return trim
      }
    })
  },
  95946: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      Yf: function () {
        return assertSize
      },
      ly: function () {
        return hexToNumber
      },
      rR: function () {
        return hexToString
      },
      y_: function () {
        return hexToBigInt
      }
    });
    var el = eo(87788)
      , ec = eo(39135)
      , ed = eo(61836)
      , eh = eo(11187);
    function assertSize(J, { size: et }) {
      if ((0,
        ec.d)(J) > et)
        throw new el.M6({
          givenSize: (0,
            ec.d)(J),
          maxSize: et
        })
    }
    function hexToBigInt(J, et = {}) {
      let { signed: eo } = et;
      et.size && assertSize(J, {
        size: et.size
      });
      let el = BigInt(J);
      if (!eo)
        return el;
      let ec = (J.length - 2) / 2
        , ed = (1n << 8n * BigInt(ec) - 1n) - 1n;
      return el <= ed ? el : el - BigInt(`0x${"f".padStart(2 * ec, "f")}`) - 1n
    }
    function hexToNumber(J, et = {}) {
      return Number(hexToBigInt(J, et))
    }
    function hexToString(J, et = {}) {
      let eo = (0,
        eh.nr)(J);
      return et.size && (assertSize(eo, {
        size: et.size
      }),
        eo = (0,
          ed.f)(eo, {
            dir: "right"
          })),
        new TextDecoder().decode(eo)
    }
  },
  11187: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      O0: function () {
        return toBytes
      },
      nr: function () {
        return hexToBytes
      },
      qX: function () {
        return stringToBytes
      }
    });
    var el = eo(62027)
      , ec = eo(15102)
      , ed = eo(61769)
      , eh = eo(95946)
      , ep = eo(92106);
    let ef = new TextEncoder;
    function toBytes(J, et = {}) {
      return "number" == typeof J || "bigint" == typeof J ? function (J, et) {
        let eo = (0,
          ep.eC)(J, et);
        return hexToBytes(eo)
      }(J, et) : "boolean" == typeof J ? function (J, et = {}) {
        let eo = new Uint8Array(1);
        return (eo[0] = Number(J),
          "number" == typeof et.size) ? ((0,
            eh.Yf)(eo, {
              size: et.size
            }),
            (0,
              ed.vk)(eo, {
                size: et.size
              })) : eo
      }(J, et) : (0,
        ec.v)(J) ? hexToBytes(J, et) : stringToBytes(J, et)
    }
    let em = {
      zero: 48,
      nine: 57,
      A: 65,
      F: 70,
      a: 97,
      f: 102
    };
    function charCodeToBase16(J) {
      return J >= em.zero && J <= em.nine ? J - em.zero : J >= em.A && J <= em.F ? J - (em.A - 10) : J >= em.a && J <= em.f ? J - (em.a - 10) : void 0
    }
    function hexToBytes(J, et = {}) {
      let eo = J;
      et.size && ((0,
        eh.Yf)(eo, {
          size: et.size
        }),
        eo = (0,
          ed.vk)(eo, {
            dir: "right",
            size: et.size
          }));
      let ec = eo.slice(2);
      ec.length % 2 && (ec = `0${ec}`);
      let ep = ec.length / 2
        , ef = new Uint8Array(ep);
      for (let J = 0, et = 0; J < ep; J++) {
        let eo = charCodeToBase16(ec.charCodeAt(et++))
          , ed = charCodeToBase16(ec.charCodeAt(et++));
        if (void 0 === eo || void 0 === ed)
          throw new el.G(`Invalid byte sequence ("${ec[et - 2]}${ec[et - 1]}" in "${ec}").`);
        ef[J] = 16 * eo + ed
      }
      return ef
    }
    function stringToBytes(J, et = {}) {
      let eo = ef.encode(J);
      return "number" == typeof et.size ? ((0,
        eh.Yf)(eo, {
          size: et.size
        }),
        (0,
          ed.vk)(eo, {
            dir: "right",
            size: et.size
          })) : eo
    }
  },
  92106: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      $G: function () {
        return stringToHex
      },
      C4: function () {
        return boolToHex
      },
      NC: function () {
        return toHex
      },
      ci: function () {
        return bytesToHex
      },
      eC: function () {
        return numberToHex
      }
    });
    var el = eo(87788)
      , ec = eo(61769)
      , ed = eo(95946);
    let eh = Array.from({
      length: 256
    }, (J, et) => et.toString(16).padStart(2, "0"));
    function toHex(J, et = {}) {
      return "number" == typeof J || "bigint" == typeof J ? numberToHex(J, et) : "string" == typeof J ? stringToHex(J, et) : "boolean" == typeof J ? boolToHex(J, et) : bytesToHex(J, et)
    }
    function boolToHex(J, et = {}) {
      let eo = `0x${Number(J)}`;
      return "number" == typeof et.size ? ((0,
        ed.Yf)(eo, {
          size: et.size
        }),
        (0,
          ec.vk)(eo, {
            size: et.size
          })) : eo
    }
    function bytesToHex(J, et = {}) {
      let eo = "";
      for (let et = 0; et < J.length; et++)
        eo += eh[J[et]];
      let el = `0x${eo}`;
      return "number" == typeof et.size ? ((0,
        ed.Yf)(el, {
          size: et.size
        }),
        (0,
          ec.vk)(el, {
            dir: "right",
            size: et.size
          })) : el
    }
    function numberToHex(J, et = {}) {
      let eo;
      let { signed: ed, size: eh } = et
        , ep = BigInt(J);
      eh ? eo = ed ? (1n << 8n * BigInt(eh) - 1n) - 1n : 2n ** (8n * BigInt(eh)) - 1n : "number" == typeof J && (eo = BigInt(Number.MAX_SAFE_INTEGER));
      let ef = "bigint" == typeof eo && ed ? -eo - 1n : 0;
      if (eo && ep > eo || ep < ef) {
        let et = "bigint" == typeof J ? "n" : "";
        throw new el.J5({
          max: eo ? `${eo}${et}` : void 0,
          min: `${ef}${et}`,
          signed: ed,
          size: eh,
          value: `${J}${et}`
        })
      }
      let em = `0x${(ed && ep < 0 ? (1n << BigInt(8 * eh)) + BigInt(ep) : ep).toString(16)}`;
      return eh ? (0,
        ec.vk)(em, {
          size: eh
        }) : em
    }
    let ep = new TextEncoder;
    function stringToHex(J, et = {}) {
      let eo = ep.encode(J);
      return bytesToHex(eo, et)
    }
  },
  72365: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      S: function () {
        return getContractError
      }
    });
    var el = eo(57412)
      , ec = eo(62027)
      , ed = eo(97405)
      , eh = eo(39028);
    function getContractError(J, { abi: et, address: eo, args: ep, docsPath: ef, functionName: em, sender: eg }) {
      let { code: ey, data: eb, message: ew, shortMessage: e_ } = J instanceof ed.VQ ? J : J instanceof ec.G ? J.walk(J => "data" in J) || J.walk() : {}
        , ex = J instanceof el.wb ? new ed.Dk({
          functionName: em
        }) : [3, eh.XS.code].includes(ey) && (eb || ew || e_) ? new ed.Lu({
          abi: et,
          data: "object" == typeof eb ? eb.data : eb,
          functionName: em,
          message: e_ ?? ew
        }) : J;
      return new ed.uq(ex, {
        abi: et,
        args: ep,
        contractAddress: eo,
        docsPath: ef,
        functionName: em,
        sender: eg
      })
    }
  },
  87469: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      k: function () {
        return getNodeError
      }
    });
    var el = eo(62027)
      , ec = eo(26445);
    function getNodeError(J, et) {
      let eo = (J.details || "").toLowerCase()
        , ed = J instanceof el.G ? J.walk(J => J.code === ec.M_.code) : J;
      return ed instanceof el.G ? new ec.M_({
        cause: J,
        message: ed.details
      }) : ec.M_.nodeMessage.test(eo) ? new ec.M_({
        cause: J,
        message: J.details
      }) : ec.Hh.nodeMessage.test(eo) ? new ec.Hh({
        cause: J,
        maxFeePerGas: et?.maxFeePerGas
      }) : ec.G$.nodeMessage.test(eo) ? new ec.G$({
        cause: J,
        maxFeePerGas: et?.maxFeePerGas
      }) : ec.ZI.nodeMessage.test(eo) ? new ec.ZI({
        cause: J,
        nonce: et?.nonce
      }) : ec.vU.nodeMessage.test(eo) ? new ec.vU({
        cause: J,
        nonce: et?.nonce
      }) : ec.se.nodeMessage.test(eo) ? new ec.se({
        cause: J,
        nonce: et?.nonce
      }) : ec.C_.nodeMessage.test(eo) ? new ec.C_({
        cause: J
      }) : ec.WF.nodeMessage.test(eo) ? new ec.WF({
        cause: J,
        gas: et?.gas
      }) : ec.dR.nodeMessage.test(eo) ? new ec.dR({
        cause: J,
        gas: et?.gas
      }) : ec.pZ.nodeMessage.test(eo) ? new ec.pZ({
        cause: J
      }) : ec.cs.nodeMessage.test(eo) ? new ec.cs({
        cause: J,
        maxFeePerGas: et?.maxFeePerGas,
        maxPriorityFeePerGas: et?.maxPriorityFeePerGas
      }) : new ec.cj({
        cause: J
      })
    }
  },
  61163: function (J, et, eo) {
    "use strict";
    function extract(J, { format: et }) {
      if (!et)
        return {};
      let eo = {}
        , el = et(J || {});
      return !function extract_(et) {
        let el = Object.keys(et);
        for (let ec of el)
          ec in J && (eo[ec] = J[ec]),
            et[ec] && "object" == typeof et[ec] && !Array.isArray(et[ec]) && extract_(et[ec])
      }(el),
        eo
    }
    eo.d(et, {
      K: function () {
        return extract
      }
    })
  },
  6073: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      Tr: function () {
        return formatTransaction
      },
      c8: function () {
        return ec
      }
    });
    var el = eo(95946);
    let ec = {
      "0x0": "legacy",
      "0x1": "eip2930",
      "0x2": "eip1559"
    };
    function formatTransaction(J) {
      let et = {
        ...J,
        blockHash: J.blockHash ? J.blockHash : null,
        blockNumber: J.blockNumber ? BigInt(J.blockNumber) : null,
        chainId: J.chainId ? (0,
          el.ly)(J.chainId) : void 0,
        gas: J.gas ? BigInt(J.gas) : void 0,
        gasPrice: J.gasPrice ? BigInt(J.gasPrice) : void 0,
        maxFeePerGas: J.maxFeePerGas ? BigInt(J.maxFeePerGas) : void 0,
        maxPriorityFeePerGas: J.maxPriorityFeePerGas ? BigInt(J.maxPriorityFeePerGas) : void 0,
        nonce: J.nonce ? (0,
          el.ly)(J.nonce) : void 0,
        to: J.to ? J.to : null,
        transactionIndex: J.transactionIndex ? Number(J.transactionIndex) : null,
        type: J.type ? ec[J.type] : void 0,
        typeHex: J.type ? J.type : void 0,
        value: J.value ? BigInt(J.value) : void 0,
        v: J.v ? BigInt(J.v) : void 0
      };
      return et.yParity = (() => {
        if (J.yParity)
          return Number(J.yParity);
        if ("bigint" == typeof et.v) {
          if (0n === et.v || 27n === et.v)
            return 0;
          if (1n === et.v || 28n === et.v)
            return 1;
          if (et.v >= 35n)
            return et.v % 2n === 0n ? 1 : 0
        }
      }
      )(),
        "legacy" === et.type && (delete et.accessList,
          delete et.maxFeePerGas,
          delete et.maxPriorityFeePerGas,
          delete et.yParity),
        "eip2930" === et.type && (delete et.maxFeePerGas,
          delete et.maxPriorityFeePerGas),
        et
    }
  },
  74688: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      tG: function () {
        return formatTransactionRequest
      }
    });
    var el = eo(92106);
    let ec = {
      legacy: "0x0",
      eip2930: "0x1",
      eip1559: "0x2"
    };
    function formatTransactionRequest(J) {
      return {
        ...J,
        gas: void 0 !== J.gas ? (0,
          el.eC)(J.gas) : void 0,
        gasPrice: void 0 !== J.gasPrice ? (0,
          el.eC)(J.gasPrice) : void 0,
        maxFeePerGas: void 0 !== J.maxFeePerGas ? (0,
          el.eC)(J.maxFeePerGas) : void 0,
        maxPriorityFeePerGas: void 0 !== J.maxPriorityFeePerGas ? (0,
          el.eC)(J.maxPriorityFeePerGas) : void 0,
        nonce: void 0 !== J.nonce ? (0,
          el.eC)(J.nonce) : void 0,
        type: void 0 !== J.type ? ec[J.type] : void 0,
        value: void 0 !== J.value ? (0,
          el.eC)(J.value) : void 0
      }
    }
  },
  93714: function (J, et, eo) {
    "use strict";
    function getAction(J, et, eo) {
      return el => J[et.name || eo]?.(el) ?? et(J, el)
    }
    eo.d(et, {
      s: function () {
        return getAction
      }
    })
  },
  56254: function (J, et, eo) {
    "use strict";
    function number(J) {
      if (!Number.isSafeInteger(J) || J < 0)
        throw Error(`Wrong positive integer: ${J}`)
    }
    function bytes(J, ...et) {
      if (!(J instanceof Uint8Array))
        throw Error("Expected Uint8Array");
      if (et.length > 0 && !et.includes(J.length))
        throw Error(`Expected Uint8Array of length ${et}, not of length=${J.length}`)
    }
    function exists(J, et = !0) {
      if (J.destroyed)
        throw Error("Hash instance has been destroyed");
      if (et && J.finished)
        throw Error("Hash#digest() has already been called")
    }
    eo.d(et, {
      w: function () {
        return keccak256
      }
    });
    let el = BigInt(4294967296 - 1)
      , ec = BigInt(32)
      , rotlSH = (J, et, eo) => J << eo | et >>> 32 - eo
      , rotlSL = (J, et, eo) => et << eo | J >>> 32 - eo
      , rotlBH = (J, et, eo) => et << eo - 32 | J >>> 64 - eo
      , rotlBL = (J, et, eo) => J << eo - 32 | et >>> 64 - eo
      , u8a = J => J instanceof Uint8Array
      , u32 = J => new Uint32Array(J.buffer, J.byteOffset, Math.floor(J.byteLength / 4))
      , ed = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0];
    if (!ed)
      throw Error("Non little-endian hardware is not supported");
    function toBytes(J) {
      if ("string" == typeof J && (J = function (J) {
        if ("string" != typeof J)
          throw Error(`utf8ToBytes expected string, got ${typeof J}`);
        return new Uint8Array(new TextEncoder().encode(J))
      }(J)),
        !u8a(J))
        throw Error(`expected Uint8Array, got ${typeof J}`);
      return J
    }
    let Hash = class Hash {
      clone() {
        return this._cloneInto()
      }
    }
      ;
    let [eh, ep, ef] = [[], [], []]
      , em = BigInt(0)
      , eg = BigInt(1)
      , ey = BigInt(2)
      , eb = BigInt(7)
      , ew = BigInt(256)
      , e_ = BigInt(113);
    for (let J = 0, et = eg, eo = 1, el = 0; J < 24; J++) {
      [eo, el] = [el, (2 * eo + 3 * el) % 5],
        eh.push(2 * (5 * el + eo)),
        ep.push((J + 1) * (J + 2) / 2 % 64);
      let ec = em;
      for (let J = 0; J < 7; J++)
        (et = (et << eg ^ (et >> eb) * e_) % ew) & ey && (ec ^= eg << (eg << BigInt(J)) - eg);
      ef.push(ec)
    }
    let [ex, eE] = function (J, et = !1) {
      let eo = new Uint32Array(J.length)
        , ed = new Uint32Array(J.length);
      for (let eh = 0; eh < J.length; eh++) {
        let { h: ep, l: ef } = function (J, et = !1) {
          return et ? {
            h: Number(J & el),
            l: Number(J >> ec & el)
          } : {
            h: 0 | Number(J >> ec & el),
            l: 0 | Number(J & el)
          }
        }(J[eh], et);
        [eo[eh], ed[eh]] = [ep, ef]
      }
      return [eo, ed]
    }(ef, !0)
      , rotlH = (J, et, eo) => eo > 32 ? rotlBH(J, et, eo) : rotlSH(J, et, eo)
      , rotlL = (J, et, eo) => eo > 32 ? rotlBL(J, et, eo) : rotlSL(J, et, eo);
    let Keccak = class Keccak extends Hash {
      constructor(J, et, eo, el = !1, ec = 24) {
        if (super(),
          this.blockLen = J,
          this.suffix = et,
          this.outputLen = eo,
          this.enableXOF = el,
          this.rounds = ec,
          this.pos = 0,
          this.posOut = 0,
          this.finished = !1,
          this.destroyed = !1,
          number(eo),
          0 >= this.blockLen || this.blockLen >= 200)
          throw Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200),
          this.state32 = u32(this.state)
      }
      keccak() {
        !function (J, et = 24) {
          let eo = new Uint32Array(10);
          for (let el = 24 - et; el < 24; el++) {
            for (let et = 0; et < 10; et++)
              eo[et] = J[et] ^ J[et + 10] ^ J[et + 20] ^ J[et + 30] ^ J[et + 40];
            for (let et = 0; et < 10; et += 2) {
              let el = (et + 8) % 10
                , ec = (et + 2) % 10
                , ed = eo[ec]
                , eh = eo[ec + 1]
                , ep = rotlH(ed, eh, 1) ^ eo[el]
                , ef = rotlL(ed, eh, 1) ^ eo[el + 1];
              for (let eo = 0; eo < 50; eo += 10)
                J[et + eo] ^= ep,
                  J[et + eo + 1] ^= ef
            }
            let et = J[2]
              , ec = J[3];
            for (let eo = 0; eo < 24; eo++) {
              let el = ep[eo]
                , ed = rotlH(et, ec, el)
                , ef = rotlL(et, ec, el)
                , em = eh[eo];
              et = J[em],
                ec = J[em + 1],
                J[em] = ed,
                J[em + 1] = ef
            }
            for (let et = 0; et < 50; et += 10) {
              for (let el = 0; el < 10; el++)
                eo[el] = J[et + el];
              for (let el = 0; el < 10; el++)
                J[et + el] ^= ~eo[(el + 2) % 10] & eo[(el + 4) % 10]
            }
            J[0] ^= ex[el],
              J[1] ^= eE[el]
          }
          eo.fill(0)
        }(this.state32, this.rounds),
          this.posOut = 0,
          this.pos = 0
      }
      update(J) {
        exists(this);
        let { blockLen: et, state: eo } = this;
        J = toBytes(J);
        let el = J.length;
        for (let ec = 0; ec < el;) {
          let ed = Math.min(et - this.pos, el - ec);
          for (let et = 0; et < ed; et++)
            eo[this.pos++] ^= J[ec++];
          this.pos === et && this.keccak()
        }
        return this
      }
      finish() {
        if (this.finished)
          return;
        this.finished = !0;
        let { state: J, suffix: et, pos: eo, blockLen: el } = this;
        J[eo] ^= et,
          (128 & et) != 0 && eo === el - 1 && this.keccak(),
          J[el - 1] ^= 128,
          this.keccak()
      }
      writeInto(J) {
        exists(this, !1),
          bytes(J),
          this.finish();
        let et = this.state
          , { blockLen: eo } = this;
        for (let el = 0, ec = J.length; el < ec;) {
          this.posOut >= eo && this.keccak();
          let ed = Math.min(eo - this.posOut, ec - el);
          J.set(et.subarray(this.posOut, this.posOut + ed), el),
            this.posOut += ed,
            el += ed
        }
        return J
      }
      xofInto(J) {
        if (!this.enableXOF)
          throw Error("XOF is not possible for this instance");
        return this.writeInto(J)
      }
      xof(J) {
        return number(J),
          this.xofInto(new Uint8Array(J))
      }
      digestInto(J) {
        if (!function (J, et) {
          bytes(J);
          let eo = et.outputLen;
          if (J.length < eo)
            throw Error(`digestInto() expects output buffer of length at least ${eo}`)
        }(J, this),
          this.finished)
          throw Error("digest() was already called");
        return this.writeInto(J),
          this.destroy(),
          J
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen))
      }
      destroy() {
        this.destroyed = !0,
          this.state.fill(0)
      }
      _cloneInto(J) {
        let { blockLen: et, suffix: eo, outputLen: el, rounds: ec, enableXOF: ed } = this;
        return J || (J = new Keccak(et, eo, el, ed, ec)),
          J.state32.set(this.state32),
          J.pos = this.pos,
          J.posOut = this.posOut,
          J.finished = this.finished,
          J.rounds = ec,
          J.suffix = eo,
          J.outputLen = el,
          J.enableXOF = ed,
          J.destroyed = this.destroyed,
          J
      }
    }
      ;
    let eC = function (J) {
      let hashC = et => J().update(toBytes(et)).digest()
        , et = J();
      return hashC.outputLen = et.outputLen,
        hashC.blockLen = et.blockLen,
        hashC.create = () => J(),
        hashC
    }(() => new Keccak(136, 1, 32));
    var eS = eo(15102)
      , ek = eo(11187)
      , eT = eo(92106);
    function keccak256(J, et) {
      let eo = eC((0,
        eS.v)(J, {
          strict: !1
        }) ? (0,
          ek.O0)(J) : J);
      return "bytes" === (et || "hex") ? eo : (0,
        eT.NC)(eo)
    }
  },
  58034: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      C: function () {
        return toFunctionSelector
      }
    });
    var el = eo(3972)
      , ec = eo(67684);
    let toFunctionSelector = J => (0,
      el.tP)((0,
        ec.r)(J), 0, 4)
  },
  67684: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      r: function () {
        return toSignatureHash
      }
    });
    var el = eo(11187)
      , ec = eo(56254);
    let hash = J => (0,
      ec.w)((0,
        el.O0)(J))
      , ed = /^tuple(?<array>(\[(\d*)\])*)$/;
    function formatAbiParameters(J) {
      let et = ""
        , eo = J.length;
      for (let el = 0; el < eo; el++) {
        let ec = J[el];
        et += function formatAbiParameter(J) {
          let et = J.type;
          if (ed.test(J.type) && "components" in J) {
            et = "(";
            let eo = J.components.length;
            for (let el = 0; el < eo; el++) {
              let ec = J.components[el];
              et += formatAbiParameter(ec),
                el < eo - 1 && (et += ", ")
            }
            let el = function (J, et) {
              let eo = J.exec(et);
              return eo?.groups
            }(ed, J.type);
            return et += `)${el?.array ?? ""}`,
              formatAbiParameter({
                ...J,
                type: et
              })
          }
          return ("indexed" in J && J.indexed && (et = `${et} indexed`),
            J.name) ? `${et} ${J.name}` : et
        }(ec),
          el !== eo - 1 && (et += ", ")
      }
      return et
    }
    var eh = eo(62027);
    let toSignature = J => {
      var et;
      let eo = "string" == typeof J ? J : "function" === (et = J).type ? `function ${et.name}(${formatAbiParameters(et.inputs)})${et.stateMutability && "nonpayable" !== et.stateMutability ? ` ${et.stateMutability}` : ""}${et.outputs.length ? ` returns (${formatAbiParameters(et.outputs)})` : ""}` : "event" === et.type ? `event ${et.name}(${formatAbiParameters(et.inputs)})` : "error" === et.type ? `error ${et.name}(${formatAbiParameters(et.inputs)})` : "constructor" === et.type ? `constructor(${formatAbiParameters(et.inputs)})${"payable" === et.stateMutability ? " payable" : ""}` : "fallback" === et.type ? "fallback()" : "receive() external payable";
      return function (J) {
        let et = !0
          , eo = ""
          , el = 0
          , ec = ""
          , ed = !1;
        for (let eh = 0; eh < J.length; eh++) {
          let ep = J[eh];
          if (["(", ")", ","].includes(ep) && (et = !0),
            "(" === ep && el++,
            ")" === ep && el--,
            et) {
            if (0 === el) {
              if (" " === ep && ["event", "function", ""].includes(ec))
                ec = "";
              else if (ec += ep,
                ")" === ep) {
                ed = !0;
                break
              }
              continue
            }
            if (" " === ep) {
              "," !== J[eh - 1] && "," !== eo && ",(" !== eo && (eo = "",
                et = !1);
              continue
            }
            ec += ep,
              eo += ep
          }
        }
        if (!ed)
          throw new eh.G("Unable to normalize signature.");
        return ec
      }(eo)
    }
      ;
    function toSignatureHash(J) {
      return hash(toSignature(J))
    }
  },
  32357: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      S: function () {
        return createBatchScheduler
      }
    });
    let el = new Map;
    function createBatchScheduler({ fn: J, id: et, shouldSplitBatch: eo, wait: ec = 0, sort: ed }) {
      let exec = async () => {
        let et = getScheduler();
        flush();
        let eo = et.map(({ args: J }) => J);
        0 !== eo.length && J(eo).then(J => {
          ed && Array.isArray(J) && J.sort(ed);
          for (let eo = 0; eo < et.length; eo++) {
            let { pendingPromise: el } = et[eo];
            el.resolve?.([J[eo], J])
          }
        }
        ).catch(J => {
          for (let eo = 0; eo < et.length; eo++) {
            let { pendingPromise: el } = et[eo];
            el.reject?.(J)
          }
        }
        )
      }
        , flush = () => el.delete(et)
        , getBatchedArgs = () => getScheduler().map(({ args: J }) => J)
        , getScheduler = () => el.get(et) || []
        , setScheduler = J => el.set(et, [...getScheduler(), J]);
      return {
        flush,
        async schedule(J) {
          let et = {}
            , el = new Promise((J, eo) => {
              et.resolve = J,
                et.reject = eo
            }
            )
            , ed = eo?.([...getBatchedArgs(), J]);
          ed && exec();
          let eh = getScheduler().length > 0;
          return eh ? setScheduler({
            args: J,
            pendingPromise: et
          }) : (setScheduler({
            args: J,
            pendingPromise: et
          }),
            setTimeout(exec, ec)),
            el
        }
      }
    }
  },
  7760: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      J: function () {
        return withRetry
      }
    });
    var el = eo(62914);
    function withRetry(J, { delay: et = 100, retryCount: eo = 2, shouldRetry: ec = () => !0 } = {}) {
      return new Promise((ed, eh) => {
        let attemptRetry = async ({ count: ep = 0 } = {}) => {
          let retry = async ({ error: J }) => {
            let eo = "function" == typeof et ? et({
              count: ep,
              error: J
            }) : et;
            eo && await (0,
              el.D)(eo),
              attemptRetry({
                count: ep + 1
              })
          }
            ;
          try {
            let et = await J();
            ed(et)
          } catch (J) {
            if (ep < eo && await ec({
              count: ep,
              error: J
            }))
              return retry({
                error: J
              });
            eh(J)
          }
        }
          ;
        attemptRetry()
      }
      )
    }
  },
  96070: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      P: function () {
        return stringify
      }
    });
    let stringify = (J, et, eo) => JSON.stringify(J, (J, eo) => {
      let el = "bigint" == typeof eo ? eo.toString() : eo;
      return "function" == typeof et ? et(J, el) : el
    }
      , eo)
  },
  47531: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      F: function () {
        return assertRequest
      }
    });
    var el = eo(14503)
      , ec = eo(26087)
      , ed = eo(26445)
      , eh = eo(33639)
      , ep = eo(49321);
    function assertRequest(J) {
      let { account: et, gasPrice: eo, maxFeePerGas: ef, maxPriorityFeePerGas: em, to: eg } = J
        , ey = et ? (0,
          el.T)(et) : void 0;
      if (ey && !(0,
        ep.U)(ey.address))
        throw new ec.b({
          address: ey.address
        });
      if (eg && !(0,
        ep.U)(eg))
        throw new ec.b({
          address: eg
        });
      if (void 0 !== eo && (void 0 !== ef || void 0 !== em))
        throw new eh.xY;
      if (ef && ef > 2n ** 256n - 1n)
        throw new ed.Hh({
          maxFeePerGas: ef
        });
      if (em && ef && em > ef)
        throw new ed.cs({
          maxFeePerGas: ef,
          maxPriorityFeePerGas: em
        })
    }
  },
  39625: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      d: function () {
        return formatEther
      }
    });
    var el = eo(84192)
      , ec = eo(15229);
    function formatEther(J, et = "wei") {
      return (0,
        ec.b)(J, el.ez[et])
    }
  },
  67795: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      o: function () {
        return formatGwei
      }
    });
    var el = eo(84192)
      , ec = eo(15229);
    function formatGwei(J, et = "wei") {
      return (0,
        ec.b)(J, el.Zn[et])
    }
  },
  15229: function (J, et, eo) {
    "use strict";
    function formatUnits(J, et) {
      let eo = J.toString()
        , el = eo.startsWith("-");
      el && (eo = eo.slice(1));
      let [ec, ed] = [(eo = eo.padStart(et, "0")).slice(0, eo.length - et), eo.slice(eo.length - et)];
      return ed = ed.replace(/(0+)$/, ""),
        `${el ? "-" : ""}${ec || "0"}${ed ? `.${ed}` : ""}`
    }
    eo.d(et, {
      b: function () {
        return formatUnits
      }
    })
  },
  62914: function (J, et, eo) {
    "use strict";
    async function wait(J) {
      return new Promise(et => setTimeout(et, J))
    }
    eo.d(et, {
      D: function () {
        return wait
      }
    })
  },
  92611: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      V: function () {
        return ed
      },
      F: function () {
        return WagmiProvider
      }
    });
    var el = eo(67294);
    let ec = !1;
    async function reconnect(J, et = {}) {
      if (ec)
        return [];
      ec = !0,
        J.setState(J => ({
          ...J,
          status: J.current ? "reconnecting" : "connecting"
        }));
      let eo = [];
      if (et.connectors?.length)
        for (let el of et.connectors) {
          let et;
          et = "function" == typeof el ? J._internal.connectors.setup(el) : el,
            eo.push(et)
        }
      else
        eo.push(...J.connectors);
      let el = await J.storage?.getItem("recentConnectorId")
        , ed = {};
      for (let [, et] of J.state.connections)
        ed[et.connector.id] = 1;
      el && (ed[el] = 0);
      let eh = Object.keys(ed).length > 0 ? [...eo].sort((J, et) => (ed[J.id] ?? 10) - (ed[et.id] ?? 10)) : eo
        , ep = !1
        , ef = []
        , em = [];
      for (let et of eh) {
        let eo = await et.getProvider();
        if (!eo || em.some(J => J === eo))
          continue;
        let el = await et.isAuthorized();
        if (!el)
          continue;
        let ec = await et.connect({
          isReconnecting: !0
        }).catch(() => null);
        ec && (et.emitter.off("connect", J._internal.events.connect),
          et.emitter.on("change", J._internal.events.change),
          et.emitter.on("disconnect", J._internal.events.disconnect),
          J.setState(J => {
            let eo = new Map(ep ? J.connections : new Map).set(et.uid, {
              accounts: ec.accounts,
              chainId: ec.chainId,
              connector: et
            });
            return {
              ...J,
              current: ep ? J.current : et.uid,
              connections: eo
            }
          }
          ),
          ef.push({
            accounts: ec.accounts,
            chainId: ec.chainId,
            connector: et
          }),
          em.push(eo),
          ep = !0)
      }
      return ep ? J.setState(J => ({
        ...J,
        status: "connected"
      })) : J.setState(J => ({
        ...J,
        connections: new Map,
        current: void 0,
        status: "disconnected"
      })),
        ec = !1,
        ef
    }
    function Hydrate(J) {
      let { children: et, config: eo, initialState: ec, reconnectOnMount: ed = !0 } = J
        , { onMount: eh } = function (J, et) {
          let { initialState: eo, reconnectOnMount: el } = et;
          return eo && J.setState({
            ...eo,
            connections: el ? eo.connections : new Map,
            status: el ? "reconnecting" : "disconnected"
          }),
          {
            async onMount() {
              if (J._internal.ssr) {
                await J._internal.store.persist.rehydrate();
                let et = J._internal.mipd?.getProviders().map(J._internal.connectors.providerDetailToConnector).map(J._internal.connectors.setup);
                J._internal.connectors.setState(J => [...J, ...et ?? []])
              }
              el ? reconnect(J) : J.storage && J.setState(J => ({
                ...J,
                connections: new Map
              }))
            }
          }
        }(eo, {
          initialState: ec,
          reconnectOnMount: ed
        });
      eo._internal.ssr || eh();
      let ep = (0,
        el.useRef)(!0);
      return (0,
        el.useEffect)(() => {
          if (ep.current && eo._internal.ssr)
            return eh(),
              () => {
                ep.current = !1
              }
        }
          , []),
        et
    }
    let ed = (0,
      el.createContext)(void 0);
    function WagmiProvider(J) {
      let { children: et, config: eo } = J;
      return (0,
        el.createElement)(Hydrate, J, (0,
          el.createElement)(ed.Provider, {
            value: eo
          }, et))
    }
  },
  99711: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      m: function () {
        return useAccount
      }
    });
    var el = eo(18493);
    function getAccount(J) {
      let et = J.state.current
        , eo = J.state.connections.get(et)
        , el = eo?.accounts
        , ec = el?.[0]
        , ed = J.chains.find(J => J.id === eo?.chainId)
        , eh = J.state.status;
      switch (eh) {
        case "connected":
          return {
            address: ec,
            addresses: el,
            chain: ed,
            chainId: eo?.chainId,
            connector: eo?.connector,
            isConnected: !0,
            isConnecting: !1,
            isDisconnected: !1,
            isReconnecting: !1,
            status: eh
          };
        case "reconnecting":
          return {
            address: ec,
            addresses: el,
            chain: ed,
            chainId: eo?.chainId,
            connector: eo?.connector,
            isConnected: !!ec,
            isConnecting: !1,
            isDisconnected: !1,
            isReconnecting: !0,
            status: eh
          };
        case "connecting":
          return {
            address: ec,
            addresses: el,
            chain: ed,
            chainId: eo?.chainId,
            connector: eo?.connector,
            isConnected: !1,
            isConnecting: !0,
            isDisconnected: !1,
            isReconnecting: !1,
            status: eh
          };
        case "disconnected":
          return {
            address: void 0,
            addresses: void 0,
            chain: void 0,
            chainId: void 0,
            connector: void 0,
            isConnected: !1,
            isConnecting: !1,
            isDisconnected: !0,
            isReconnecting: !1,
            status: eh
          }
      }
    }
    var ec = eo(37122)
      , ed = eo(67294)
      , eh = eo(52798);
    let isPlainObject = J => "object" == typeof J && !Array.isArray(J);
    function useAccount(J = {}) {
      let et = (0,
        ec.Z)(J);
      return function (J, et, eo = et, ec = el.v) {
        let ep = (0,
          ed.useRef)([])
          , ef = (0,
            eh.useSyncExternalStoreWithSelector)(J, et, eo, J => J, (J, et) => {
              if (isPlainObject(J) && isPlainObject(et) && ep.current.length) {
                for (let eo of ep.current) {
                  let el = ec(J[eo], et[eo]);
                  if (!el)
                    return !1
                }
                return !0
              }
              return ec(J, et)
            }
            );
        if (isPlainObject(ef)) {
          let J = {
            ...ef
          };
          return Object.defineProperties(J, Object.entries(J).reduce((J, [et, eo]) => ({
            ...J,
            [et]: {
              configurable: !1,
              enumerable: !0,
              get: () => (ep.current.includes(et) || ep.current.push(et),
                eo)
            }
          }), {})),
            J
        }
        return ef
      }(J => (function (J, et) {
        let { onChange: eo } = et;
        return J.subscribe(() => getAccount(J), eo, {
          equalityFn(J, et) {
            let { connector: eo, ...ec } = J
              , { connector: ed, ...eh } = et;
            return (0,
              el.v)(ec, eh) && eo?.id === ed?.id && eo?.uid === ed?.uid
          }
        })
      }
      )(et, {
        onChange: J
      }), () => getAccount(et))
    }
  },
  4368: function (J, et, eo) {
    "use strict";
    function getChainId(J) {
      return J.state.chainId
    }
    eo.d(et, {
      x: function () {
        return useChainId
      }
    });
    var el = eo(67294)
      , ec = eo(37122);
    function useChainId(J = {}) {
      let et = (0,
        ec.Z)(J);
      return (0,
        el.useSyncExternalStore)(J => (function (J, et) {
          let { onChange: eo } = et;
          return J.subscribe(J => J.chainId, eo)
        }
        )(et, {
          onChange: J
        }), () => getChainId(et), () => getChainId(et))
    }
  },
  37122: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      Z: function () {
        return useConfig
      }
    });
    var el = eo(67294)
      , ec = eo(92611)
      , ed = eo(93981);
    let getVersion = () => "wagmi@2.5.4";
    let BaseError = class BaseError extends ed.G {
      constructor() {
        super(...arguments),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "WagmiError"
          })
      }
      get docsBaseUrl() {
        return "https://wagmi.sh/react"
      }
      get version() {
        return getVersion()
      }
    }
      ;
    let WagmiProviderNotFoundError = class WagmiProviderNotFoundError extends BaseError {
      constructor() {
        super("`useConfig` must be used within `WagmiProvider`.", {
          docsPath: "https://wagmi.sh/react/api/WagmiProvider"
        }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "WagmiProviderNotFoundError"
          })
      }
    }
      ;
    function useConfig(J = {}) {
      let et = J.config ?? (0,
        el.useContext)(ec.V);
      if (!et)
        throw new WagmiProviderNotFoundError;
      return et
    }
  },
  86230: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      S: function () {
        return useWriteContract
      }
    });
    var el = eo(98029)
      , ec = eo(77799)
      , ed = eo(93714)
      , eh = eo(14503)
      , ep = eo(8998)
      , ef = eo(80377)
      , em = eo(26445)
      , eg = eo(33639)
      , ey = eo(87469)
      , eb = eo(61163)
      , ew = eo(74688)
      , e_ = eo(47531)
      , ex = eo(95946);
    async function getChainId(J) {
      let et = await J.request({
        method: "eth_chainId"
      });
      return (0,
        ex.ly)(et)
    }
    var eE = eo(67795)
      , eC = eo(62027);
    let BaseFeeScalarError = class BaseFeeScalarError extends eC.G {
      constructor() {
        super("`baseFeeMultiplier` must be greater than 1."),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "BaseFeeScalarError"
          })
      }
    }
      ;
    let Eip1559FeesNotSupportedError = class Eip1559FeesNotSupportedError extends eC.G {
      constructor() {
        super("Chain does not support EIP-1559 fees."),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Eip1559FeesNotSupportedError"
          })
      }
    }
      ;
    let MaxFeePerGasTooLowError = class MaxFeePerGasTooLowError extends eC.G {
      constructor({ maxPriorityFeePerGas: J }) {
        super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${(0,
          eE.o)(J)} gwei).`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "MaxFeePerGasTooLowError"
          })
      }
    }
      ;
    let BlockNotFoundError = class BlockNotFoundError extends eC.G {
      constructor({ blockHash: J, blockNumber: et }) {
        let eo = "Block";
        J && (eo = `Block at hash "${J}"`),
          et && (eo = `Block at number "${et}"`),
          super(`${eo} could not be found.`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "BlockNotFoundError"
          })
      }
    }
      ;
    var eS = eo(92106)
      , ek = eo(6073);
    function formatBlock(J) {
      let et = J.transactions?.map(J => "string" == typeof J ? J : ek.Tr(J));
      return {
        ...J,
        baseFeePerGas: J.baseFeePerGas ? BigInt(J.baseFeePerGas) : null,
        difficulty: J.difficulty ? BigInt(J.difficulty) : void 0,
        gasLimit: J.gasLimit ? BigInt(J.gasLimit) : void 0,
        gasUsed: J.gasUsed ? BigInt(J.gasUsed) : void 0,
        hash: J.hash ? J.hash : null,
        logsBloom: J.logsBloom ? J.logsBloom : null,
        nonce: J.nonce ? J.nonce : null,
        number: J.number ? BigInt(J.number) : null,
        size: J.size ? BigInt(J.size) : void 0,
        timestamp: J.timestamp ? BigInt(J.timestamp) : void 0,
        transactions: et,
        totalDifficulty: J.totalDifficulty ? BigInt(J.totalDifficulty) : null
      }
    }
    async function getBlock(J, { blockHash: et, blockNumber: eo, blockTag: el, includeTransactions: ec } = {}) {
      let ed = ec ?? !1
        , eh = void 0 !== eo ? (0,
          eS.eC)(eo) : void 0
        , ep = null;
      if (!(ep = et ? await J.request({
        method: "eth_getBlockByHash",
        params: [et, ed]
      }) : await J.request({
        method: "eth_getBlockByNumber",
        params: [eh || (el ?? "latest"), ed]
      })))
        throw new BlockNotFoundError({
          blockHash: et,
          blockNumber: eo
        });
      let ef = J.chain?.formatters?.block?.format || formatBlock;
      return ef(ep)
    }
    async function getGasPrice(J) {
      let et = await J.request({
        method: "eth_gasPrice"
      });
      return BigInt(et)
    }
    async function internal_estimateMaxPriorityFeePerGas(J, et) {
      let { block: eo, chain: el = J.chain, request: ec } = et || {};
      if ("function" == typeof el?.fees?.defaultPriorityFee) {
        let et = eo || await (0,
          ed.s)(J, getBlock, "getBlock")({});
        return el.fees.defaultPriorityFee({
          block: et,
          client: J,
          request: ec
        })
      }
      if (void 0 !== el?.fees?.defaultPriorityFee)
        return el?.fees?.defaultPriorityFee;
      try {
        let et = await J.request({
          method: "eth_maxPriorityFeePerGas"
        });
        return (0,
          ex.y_)(et)
      } catch {
        let [et, el] = await Promise.all([eo ? Promise.resolve(eo) : (0,
          ed.s)(J, getBlock, "getBlock")({}), (0,
            ed.s)(J, getGasPrice, "getGasPrice")({})]);
        if ("bigint" != typeof et.baseFeePerGas)
          throw new Eip1559FeesNotSupportedError;
        let ec = el - et.baseFeePerGas;
        if (ec < 0n)
          return 0n;
        return ec
      }
    }
    async function internal_estimateFeesPerGas(J, et) {
      let { block: eo, chain: el = J.chain, request: ec, type: eh = "eip1559" } = et || {}
        , ep = await (async () => "function" == typeof el?.fees?.baseFeeMultiplier ? el.fees.baseFeeMultiplier({
          block: eo,
          client: J,
          request: ec
        }) : el?.fees?.baseFeeMultiplier ?? 1.2)();
      if (ep < 1)
        throw new BaseFeeScalarError;
      let ef = ep.toString().split(".")[1]?.length ?? 0
        , em = 10 ** ef
        , multiply = J => J * BigInt(Math.ceil(ep * em)) / BigInt(em)
        , eg = eo || await (0,
          ed.s)(J, getBlock, "getBlock")({});
      if ("function" == typeof el?.fees?.estimateFeesPerGas)
        return el.fees.estimateFeesPerGas({
          block: eo,
          client: J,
          multiply,
          request: ec,
          type: eh
        });
      if ("eip1559" === eh) {
        if ("bigint" != typeof eg.baseFeePerGas)
          throw new Eip1559FeesNotSupportedError;
        let et = "bigint" == typeof ec?.maxPriorityFeePerGas ? ec.maxPriorityFeePerGas : await internal_estimateMaxPriorityFeePerGas(J, {
          block: eg,
          chain: el,
          request: ec
        })
          , eo = multiply(eg.baseFeePerGas)
          , ed = ec?.maxFeePerGas ?? eo + et;
        return {
          maxFeePerGas: ed,
          maxPriorityFeePerGas: et
        }
      }
      let ey = ec?.gasPrice ?? multiply(await (0,
        ed.s)(J, getGasPrice, "getGasPrice")({}));
      return {
        gasPrice: ey
      }
    }
    var eT = eo(39625);
    let EstimateGasExecutionError = class EstimateGasExecutionError extends eC.G {
      constructor(J, { account: et, docsPath: eo, chain: el, data: ec, gas: ed, gasPrice: eh, maxFeePerGas: ep, maxPriorityFeePerGas: ef, nonce: em, to: ey, value: eb }) {
        let ew = (0,
          eg.xr)({
            from: et?.address,
            to: ey,
            value: void 0 !== eb && `${(0,
              eT.d)(eb)} ${el?.nativeCurrency?.symbol || "ETH"}`,
            data: ec,
            gas: ed,
            gasPrice: void 0 !== eh && `${(0,
              eE.o)(eh)} gwei`,
            maxFeePerGas: void 0 !== ep && `${(0,
              eE.o)(ep)} gwei`,
            maxPriorityFeePerGas: void 0 !== ef && `${(0,
              eE.o)(ef)} gwei`,
            nonce: em
          });
        super(J.shortMessage, {
          cause: J,
          docsPath: eo,
          metaMessages: [...J.metaMessages ? [...J.metaMessages, " "] : [], "Estimate Gas Arguments:", ew].filter(Boolean)
        }),
          Object.defineProperty(this, "cause", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "EstimateGasExecutionError"
          }),
          this.cause = J
      }
    }
      ;
    async function estimateGas(J, et) {
      let eo = et.account ?? J.account
        , el = eo ? (0,
          eh.T)(eo) : void 0;
      try {
        let { accessList: eo, blockNumber: ec, blockTag: ed, data: eh, gas: ep, gasPrice: ef, maxFeePerGas: em, maxPriorityFeePerGas: eg, nonce: ey, to: ex, value: eE, ...eC } = el?.type === "local" ? await prepareTransactionRequest(J, et) : et
          , ek = ec ? (0,
            eS.eC)(ec) : void 0
          , eT = ek || ed;
        (0,
          e_.F)(et);
        let eA = J.chain?.formatters?.transactionRequest?.format
          , eP = eA || ew.tG
          , eR = eP({
            ...(0,
              eb.K)(eC, {
                format: eA
              }),
            from: el?.address,
            accessList: eo,
            data: eh,
            gas: ep,
            gasPrice: ef,
            maxFeePerGas: em,
            maxPriorityFeePerGas: eg,
            nonce: ey,
            to: ex,
            value: eE
          })
          , eI = await J.request({
            method: "eth_estimateGas",
            params: eT ? [eR, eT] : [eR]
          });
        return BigInt(eI)
      } catch (eo) {
        throw function (J, { docsPath: et, ...eo }) {
          let el = (() => {
            let et = (0,
              ey.k)(J, eo);
            return et instanceof em.cj ? J : et
          }
          )();
          return new EstimateGasExecutionError(el, {
            docsPath: et,
            ...eo
          })
        }(eo, {
          ...et,
          account: el,
          chain: J.chain
        })
      }
    }
    async function getTransactionCount(J, { address: et, blockTag: eo = "latest", blockNumber: el }) {
      let ec = await J.request({
        method: "eth_getTransactionCount",
        params: [et, el ? (0,
          eS.eC)(el) : eo]
      });
      return (0,
        ex.ly)(ec)
    }
    async function prepareTransactionRequest(J, et) {
      let { account: eo = J.account, chain: el, gas: ec, nonce: ep, parameters: ef = ["fees", "gas", "nonce", "type"], type: em } = et
        , ey = eo ? (0,
          eh.T)(eo) : void 0
        , eb = await (0,
          ed.s)(J, getBlock, "getBlock")({
            blockTag: "latest"
          })
        , ew = {
          ...et,
          ...ey ? {
            from: ey?.address
          } : {}
        };
      if (ef.includes("nonce") && void 0 === ep && ey && (ew.nonce = await (0,
        ed.s)(J, getTransactionCount, "getTransactionCount")({
          address: ey.address,
          blockTag: "pending"
        })),
        (ef.includes("fees") || ef.includes("type")) && void 0 === em)
        try {
          ew.type = function (J) {
            if (J.type)
              return J.type;
            if (void 0 !== J.maxFeePerGas || void 0 !== J.maxPriorityFeePerGas)
              return "eip1559";
            if (void 0 !== J.gasPrice)
              return void 0 !== J.accessList ? "eip2930" : "legacy";
            throw new eg.j3({
              transaction: J
            })
          }(ew)
        } catch {
          ew.type = "bigint" == typeof eb.baseFeePerGas ? "eip1559" : "legacy"
        }
      if (ef.includes("fees")) {
        if ("eip1559" === ew.type) {
          let { maxFeePerGas: eo, maxPriorityFeePerGas: ec } = await internal_estimateFeesPerGas(J, {
            block: eb,
            chain: el,
            request: ew
          });
          if (void 0 === et.maxPriorityFeePerGas && et.maxFeePerGas && et.maxFeePerGas < ec)
            throw new MaxFeePerGasTooLowError({
              maxPriorityFeePerGas: ec
            });
          ew.maxPriorityFeePerGas = ec,
            ew.maxFeePerGas = eo
        } else {
          if (void 0 !== et.maxFeePerGas || void 0 !== et.maxPriorityFeePerGas)
            throw new Eip1559FeesNotSupportedError;
          let { gasPrice: eo } = await internal_estimateFeesPerGas(J, {
            block: eb,
            chain: el,
            request: ew,
            type: "legacy"
          });
          ew.gasPrice = eo
        }
      }
      return ef.includes("gas") && void 0 === ec && (ew.gas = await (0,
        ed.s)(J, estimateGas, "estimateGas")({
          ...ew,
          account: ey ? {
            address: ey.address,
            type: "json-rpc"
          } : void 0
        })),
        (0,
          e_.F)(ew),
        delete ew.parameters,
        ew
    }
    async function sendRawTransaction(J, { serializedTransaction: et }) {
      return J.request({
        method: "eth_sendRawTransaction",
        params: [et]
      }, {
        retryCount: 0
      })
    }
    async function sendTransaction(J, et) {
      let { account: eo = J.account, chain: el = J.chain, accessList: ec, data: ex, gas: eE, gasPrice: eC, maxFeePerGas: eS, maxPriorityFeePerGas: ek, nonce: eT, to: eA, value: eP, ...eR } = et;
      if (!eo)
        throw new ep.o({
          docsPath: "/docs/actions/wallet/sendTransaction"
        });
      let eI = (0,
        eh.T)(eo);
      try {
        let eo;
        if ((0,
          e_.F)(et),
          null !== el && (eo = await (0,
            ed.s)(J, getChainId, "getChainId")({}),
            function ({ chain: J, currentChainId: et }) {
              if (!J)
                throw new ef.Bk;
              if (et !== J.id)
                throw new ef.Yl({
                  chain: J,
                  currentChainId: et
                })
            }({
              currentChainId: eo,
              chain: el
            })),
          "local" === eI.type) {
          let et = await (0,
            ed.s)(J, prepareTransactionRequest, "prepareTransactionRequest")({
              account: eI,
              accessList: ec,
              chain: el,
              data: ex,
              gas: eE,
              gasPrice: eC,
              maxFeePerGas: eS,
              maxPriorityFeePerGas: ek,
              nonce: eT,
              to: eA,
              value: eP,
              ...eR
            });
          eo || (eo = await (0,
            ed.s)(J, getChainId, "getChainId")({}));
          let eh = el?.serializers?.transaction
            , ep = await eI.signTransaction({
              ...et,
              chainId: eo
            }, {
              serializer: eh
            });
          return await (0,
            ed.s)(J, sendRawTransaction, "sendRawTransaction")({
              serializedTransaction: ep
            })
        }
        let eh = J.chain?.formatters?.transactionRequest?.format
          , ep = eh || ew.tG
          , em = ep({
            ...(0,
              eb.K)(eR, {
                format: eh
              }),
            accessList: ec,
            data: ex,
            from: eI.address,
            gas: eE,
            gasPrice: eC,
            maxFeePerGas: eS,
            maxPriorityFeePerGas: ek,
            nonce: eT,
            to: eA,
            value: eP
          });
        return await J.request({
          method: "eth_sendTransaction",
          params: [em]
        }, {
          retryCount: 0
        })
      } catch (J) {
        throw function (J, { docsPath: et, ...eo }) {
          let el = (() => {
            let et = (0,
              ey.k)(J, eo);
            return et instanceof em.cj ? J : et
          }
          )();
          return new eg.mk(el, {
            docsPath: et,
            ...eo
          })
        }(J, {
          ...et,
          account: eI,
          chain: et.chain || void 0
        })
      }
    }
    async function writeContract(J, et) {
      let { abi: eo, address: el, args: eh, dataSuffix: ep, functionName: ef, ...em } = et
        , eg = (0,
          ec.R)({
            abi: eo,
            args: eh,
            functionName: ef
          });
      return (0,
        ed.s)(J, sendTransaction, "sendTransaction")({
          data: `${eg}${ep ? ep.replace("0x", "") : ""}`,
          to: el,
          ...em
        })
    }
    var eA = eo(81848)
      , eP = eo(16189)
      , eR = eo(3980)
      , eI = eo(87083);
    async function getConnectorClient(J, et = {}) {
      let eo;
      if (et.connector) {
        let { connector: J } = et
          , [el, ec] = await Promise.all([J.getAccounts(), J.getChainId()]);
        eo = {
          accounts: el,
          chainId: ec,
          connector: J
        }
      } else
        eo = J.state.connections.get(J.state.current);
      if (!eo)
        throw new eI.aH;
      let el = et.chainId ?? eo.chainId
        , ec = eo.connector;
      if (ec.getClient)
        return ec.getClient({
          chainId: el
        });
      let ed = (0,
        eh.T)(et.account ?? eo.accounts[0])
        , ep = J.chains.find(J => J.id === el)
        , ef = await eo.connector.getProvider({
          chainId: el
        });
      if (et.account && !eo.accounts.includes(ed.address))
        throw new eI.JK({
          address: ed.address,
          connector: ec
        });
      return (0,
        eP.e)({
          account: ed,
          chain: ep,
          name: "Connector Client",
          transport: J => (0,
            eR.P)(ef)({
              ...J,
              retryCount: 0
            })
        })
    }
    var eO = eo(7210)
      , eN = eo(72365)
      , eM = eo(61376);
    async function simulateContract(J, et) {
      let { abi: eo, address: el, args: ep, dataSuffix: ef, functionName: em, ...eg } = et
        , ey = eg.account ? (0,
          eh.T)(eg.account) : J.account
        , eb = (0,
          ec.R)({
            abi: eo,
            args: ep,
            functionName: em
          });
      try {
        let { data: ec } = await (0,
          ed.s)(J, eM.R, "call")({
            batch: !1,
            data: `${eb}${ef ? ef.replace("0x", "") : ""}`,
            to: el,
            ...eg,
            account: ey
          })
          , eh = (0,
            eO.k)({
              abi: eo,
              args: ep,
              functionName: em,
              data: ec || "0x"
            })
          , ew = eo.filter(J => "name" in J && J.name === et.functionName);
        return {
          result: eh,
          request: {
            abi: ew,
            address: el,
            args: ep,
            dataSuffix: ef,
            functionName: em,
            ...eg,
            account: ey
          }
        }
      } catch (J) {
        throw (0,
          eN.S)(J, {
            abi: eo,
            address: el,
            args: ep,
            docsPath: "/docs/contract/simulateContract",
            functionName: em,
            sender: ey?.address
          })
      }
    }
    async function simulateContract_simulateContract(J, et) {
      let eo;
      let { abi: el, chainId: ec, connector: ed, ...eh } = et;
      if (et.account)
        eo = et.account;
      else {
        let et = await getConnectorClient(J, {
          chainId: ec,
          connector: ed
        });
        eo = et.account
      }
      let ep = J.getClient({
        chainId: ec
      })
        , ef = (0,
          eA.s)(ep, simulateContract, "simulateContract")
        , { result: em, request: eg } = await ef({
          ...eh,
          abi: el,
          account: eo
        });
      return {
        chainId: ep.chain.id,
        result: em,
        request: {
          __mode: "prepared",
          ...eg,
          chainId: ec
        }
      }
    }
    async function writeContract_writeContract(J, et) {
      let eo;
      let { account: el, chainId: ec, connector: ed, __mode: eh, ...ep } = et
        , ef = await getConnectorClient(J, {
          account: el,
          chainId: ec,
          connector: ed
        });
      if ("prepared" === eh)
        eo = ep;
      else {
        let { request: et } = await simulateContract_simulateContract(J, ep);
        eo = et
      }
      let em = (0,
        eA.s)(ef, writeContract, "writeContract")
        , eg = await em({
          ...eo,
          chain: ec ? {
            id: ec
          } : null
        });
      return eg
    }
    var eD = eo(37122);
    function useWriteContract(J = {}) {
      let { mutation: et } = J
        , eo = (0,
          eD.Z)(J)
        , { mutate: ec, mutateAsync: ed, ...eh } = (0,
          el.D)({
            ...et,
            mutationFn: J => writeContract_writeContract(eo, J),
            mutationKey: ["writeContract"]
          });
      return {
        ...eh,
        writeContract: ec,
        writeContractAsync: ed
      }
    }
  },
  82451: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      aM: function () {
        return useQuery
      },
      if: function () {
        return structuralSharing
      }
    });
    var el = eo(10777)
      , ec = eo(24139)
      , ed = eo(18493)
      , eh = eo(75745);
    function useQuery(J) {
      let et = (0,
        el.a)({
          ...J,
          queryKeyHashFn: eh.k
        });
      return et.queryKey = J.queryKey,
        et
    }
    function structuralSharing(J, et) {
      return (0,
        ed.v)(J, et) ? J : (0,
          ec.Q$)(J, et)
    }
  },
  51810: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      L: function () {
        return readContract
      }
    });
    var el = eo(88819)
      , ec = eo(81848);
    function readContract(J, et) {
      let { chainId: eo, ...ed } = et
        , eh = J.getClient({
          chainId: eo
        })
        , ep = (0,
          ec.s)(eh, el.L, "readContract");
      return ep(ed)
    }
  },
  93981: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      G: function () {
        return BaseError
      }
    });
    var el, ec, ed = eo(14023);
    let getVersion = () => `@wagmi/core@${ed.i}`;
    var __classPrivateFieldGet = function (J, et, eo, el) {
      if ("a" === eo && !el)
        throw TypeError("Private accessor was defined without a getter");
      if ("function" == typeof et ? J !== et || !el : !et.has(J))
        throw TypeError("Cannot read private member from an object whose class did not declare it");
      return "m" === eo ? el : "a" === eo ? el.call(J) : el ? el.value : et.get(J)
    };
    let BaseError = class BaseError extends Error {
      get docsBaseUrl() {
        return "https://wagmi.sh/core"
      }
      get version() {
        return getVersion()
      }
      constructor(J, et = {}) {
        super(),
          el.add(this),
          Object.defineProperty(this, "details", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          Object.defineProperty(this, "docsPath", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          Object.defineProperty(this, "metaMessages", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          Object.defineProperty(this, "shortMessage", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
          }),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "WagmiCoreError"
          });
        let eo = et.cause instanceof BaseError ? et.cause.details : et.cause?.message ? et.cause.message : et.details
          , ec = et.cause instanceof BaseError && et.cause.docsPath || et.docsPath;
        this.message = [J || "An error occurred.", "", ...et.metaMessages ? [...et.metaMessages, ""] : [], ...ec ? [`Docs: ${this.docsBaseUrl}${ec}.html${et.docsSlug ? `#${et.docsSlug}` : ""}`] : [], ...eo ? [`Details: ${eo}`] : [], `Version: ${this.version}`].join("\n"),
          et.cause && (this.cause = et.cause),
          this.details = eo,
          this.docsPath = ec,
          this.metaMessages = et.metaMessages,
          this.shortMessage = J
      }
      walk(J) {
        return __classPrivateFieldGet(this, el, "m", ec).call(this, this, J)
      }
    }
      ;
    el = new WeakSet,
      ec = function _BaseError_walk(J, et) {
        return et?.(J) ? J : J.cause ? __classPrivateFieldGet(this, el, "m", _BaseError_walk).call(this, J.cause, et) : J
      }
  },
  87083: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      JK: function () {
        return ConnectorAccountNotFoundError
      },
      X4: function () {
        return ChainNotConfiguredError
      },
      aH: function () {
        return ConnectorNotConnectedError
      }
    });
    var el = eo(93981);
    let ChainNotConfiguredError = class ChainNotConfiguredError extends el.G {
      constructor() {
        super("Chain not configured."),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ChainNotConfiguredError"
          })
      }
    }
      ;
    let ConnectorNotConnectedError = class ConnectorNotConnectedError extends el.G {
      constructor() {
        super("Connector not connected."),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ConnectorNotConnectedError"
          })
      }
    }
      ;
    let ConnectorAccountNotFoundError = class ConnectorAccountNotFoundError extends el.G {
      constructor({ address: J, connector: et }) {
        super(`Account "${J}" not found for connector "${et.name}".`),
          Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ConnectorAccountNotFoundError"
          })
      }
    }
  },
  75745: function (J, et, eo) {
    "use strict";
    function hashFn(J) {
      return JSON.stringify(J, (J, et) => !function (J) {
        if (!hasObjectPrototype(J))
          return !1;
        let et = J.constructor;
        if (void 0 === et)
          return !0;
        let eo = et.prototype;
        return !!(hasObjectPrototype(eo) && eo.hasOwnProperty("isPrototypeOf"))
      }(et) ? "bigint" == typeof et ? et.toString() : et : Object.keys(et).sort().reduce((J, eo) => (J[eo] = et[eo],
        J), {}))
    }
    function hasObjectPrototype(J) {
      return "[object Object]" === Object.prototype.toString.call(J)
    }
    function filterQueryOptions(J) {
      let { _defaulted: et, behavior: eo, gcTime: el, initialData: ec, initialDataUpdatedAt: ed, maxPages: eh, meta: ep, networkMode: ef, queryFn: em, queryHash: eg, queryKey: ey, queryKeyHashFn: eb, retry: ew, retryDelay: e_, structuralSharing: ex, getPreviousPageParam: eE, getNextPageParam: eC, initialPageParam: eS, _optimisticResults: ek, enabled: eT, notifyOnChangeProps: eA, placeholderData: eP, refetchInterval: eR, refetchIntervalInBackground: eI, refetchOnMount: eO, refetchOnReconnect: eN, refetchOnWindowFocus: eM, retryOnMount: eD, select: ej, staleTime: eL, suspense: e$, throwOnError: eB, config: eF, connector: eU, query: ez, ...eH } = J;
      return eH
    }
    eo.d(et, {
      O: function () {
        return filterQueryOptions
      },
      k: function () {
        return hashFn
      }
    })
  },
  18493: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      v: function () {
        return function deepEqual(J, et) {
          if (J === et)
            return !0;
          if (J && et && "object" == typeof J && "object" == typeof et) {
            let eo, el;
            if (J.constructor !== et.constructor)
              return !1;
            if (Array.isArray(J) && Array.isArray(et)) {
              if ((eo = J.length) !== et.length)
                return !1;
              for (el = eo; 0 != el--;)
                if (!deepEqual(J[el], et[el]))
                  return !1;
              return !0
            }
            if (J.valueOf !== Object.prototype.valueOf)
              return J.valueOf() === et.valueOf();
            if (J.toString !== Object.prototype.toString)
              return J.toString() === et.toString();
            let ec = Object.keys(J);
            if ((eo = ec.length) !== Object.keys(et).length)
              return !1;
            for (el = eo; 0 != el--;)
              if (!Object.prototype.hasOwnProperty.call(et, ec[el]))
                return !1;
            for (el = eo; 0 != el--;) {
              let eo = ec[el];
              if (eo && !deepEqual(J[eo], et[eo]))
                return !1
            }
            return !0
          }
          return J != J && et != et
        }
      }
    })
  },
  81848: function (J, et, eo) {
    "use strict";
    function getAction(J, et, eo) {
      let el = J[et.name ?? eo];
      return "function" == typeof el ? el : eo => et(J, eo)
    }
    eo.d(et, {
      s: function () {
        return getAction
      }
    })
  },
  14023: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      i: function () {
        return el
      }
    });
    let el = "2.6.2"
  },
  64529: function (J, et, eo) {
    "use strict";
    eo.d(et, {
      Ue: function () {
        return create
      }
    });
    let createStoreImpl = J => {
      let et;
      let eo = new Set
        , setState = (J, el) => {
          let ec = "function" == typeof J ? J(et) : J;
          if (!Object.is(ec, et)) {
            let J = et;
            et = (null != el ? el : "object" != typeof ec) ? ec : Object.assign({}, et, ec),
              eo.forEach(eo => eo(et, J))
          }
        }
        , getState = () => et
        , el = {
          setState,
          getState,
          subscribe: J => (eo.add(J),
            () => eo.delete(J)),
          destroy: () => {
            console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),
              eo.clear()
          }
        };
      return et = J(setState, getState, el),
        el
    }
      , createStore = J => J ? createStoreImpl(J) : createStoreImpl;
    var el = eo(67294)
      , ec = eo(52798);
    let { useSyncExternalStoreWithSelector: ed } = ec
      , eh = !1
      , createImpl = J => {
        "function" != typeof J && console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");
        let et = "function" == typeof J ? createStore(J) : J
          , useBoundStore = (J, eo) => (function (J, et = J.getState, eo) {
            eo && !eh && (console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"),
              eh = !0);
            let ec = ed(J.subscribe, J.getState, J.getServerState || J.getState, et, eo);
            return (0,
              el.useDebugValue)(ec),
              ec
          }
          )(et, J, eo);
        return Object.assign(useBoundStore, et),
          useBoundStore
      }
      , create = J => J ? createImpl(J) : createImpl
  }
}, function (J) {
  var __webpack_exec__ = function (et) {
    return J(J.s = et)
  };
  J.O(0, [774, 179], function () {
    return __webpack_exec__(91118),
      __webpack_exec__(59974)
  }),
    _N_E = J.O()
}
]);
